//! A32 data_processing logical tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_EOR_r_A Tests
// ============================================================================

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_0_min_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, Rm=0, imm5=0, type1=0, cond=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_1_poweroftwo_0_10200000() {
    // Encoding: 0x10200000
    // Test aarch32_EOR_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, type1=0, cond=1, S=0, imm5=0, Rm=0
    let encoding: u32 = 0x10200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_2_poweroftwo_0_20200000() {
    // Encoding: 0x20200000
    // Test aarch32_EOR_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=2, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x20200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_3_poweroftwo_0_30200000() {
    // Encoding: 0x30200000
    // Test aarch32_EOR_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rm=0, type1=0, Rn=0, imm5=0, S=0, Rd=0
    let encoding: u32 = 0x30200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_4_poweroftwo_0_40200000() {
    // Encoding: 0x40200000
    // Test aarch32_EOR_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, imm5=0, type1=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x40200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_5_poweroftwo_0_50200000() {
    // Encoding: 0x50200000
    // Test aarch32_EOR_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=5, type1=0, Rn=0, Rd=0, imm5=0, Rm=0
    let encoding: u32 = 0x50200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_6_poweroftwo_0_60200000() {
    // Encoding: 0x60200000
    // Test aarch32_EOR_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, imm5=0, type1=0, cond=6, S=0
    let encoding: u32 = 0x60200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_7_poweroftwo_0_70200000() {
    // Encoding: 0x70200000
    // Test aarch32_EOR_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, imm5=0, Rd=0, Rm=0, cond=7, S=0, Rn=0
    let encoding: u32 = 0x70200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_8_poweroftwo_0_80200000() {
    // Encoding: 0x80200000
    // Test aarch32_EOR_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, imm5=0, Rm=0, S=0, Rd=0, type1=0, Rn=0
    let encoding: u32 = 0x80200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_9_poweroftwo_0_90200000() {
    // Encoding: 0x90200000
    // Test aarch32_EOR_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, imm5=0, cond=9, type1=0, Rn=0
    let encoding: u32 = 0x90200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_10_poweroftwo_0_a0200000() {
    // Encoding: 0xA0200000
    // Test aarch32_EOR_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, S=0, imm5=0, Rd=0, Rn=0, Rm=0, type1=0
    let encoding: u32 = 0xA0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_11_poweroftwo_0_b0200000() {
    // Encoding: 0xB0200000
    // Test aarch32_EOR_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, type1=0, cond=11, imm5=0, Rm=0, Rd=0
    let encoding: u32 = 0xB0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_12_poweroftwo_0_c0200000() {
    // Encoding: 0xC0200000
    // Test aarch32_EOR_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm5=0, S=0, type1=0, Rd=0, Rm=0, cond=12
    let encoding: u32 = 0xC0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_13_poweroftwo_0_d0200000() {
    // Encoding: 0xD0200000
    // Test aarch32_EOR_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rd=0, type1=0, Rm=0, Rn=0, S=0, imm5=0
    let encoding: u32 = 0xD0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_14_poweroftwo_0_e0200000() {
    // Encoding: 0xE0200000
    // Test aarch32_EOR_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=14, imm5=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0xE0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_eor_r_a1_a_field_cond_15_max_0_f0200000() {
    // Encoding: 0xF0200000
    // Test aarch32_EOR_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=15, type1=0, Rm=0, imm5=0, S=0, Rd=0
    let encoding: u32 = 0xF0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_eor_r_a1_a_field_s_0_min_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, imm5=0, type1=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_eor_r_a1_a_field_s_1_max_0_00300000() {
    // Encoding: 0x00300000
    // Test aarch32_EOR_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, Rn=0, type1=0, S=1, imm5=0, cond=0, Rm=0
    let encoding: u32 = 0x00300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_a1_a_field_rn_0_min_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, imm5=0, S=0, type1=0, Rn=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_a1_a_field_rn_1_poweroftwo_0_00210000() {
    // Encoding: 0x00210000
    // Test aarch32_EOR_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=1, cond=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x00210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_a1_a_field_rd_0_min_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rm=0, type1=0, cond=0, Rd=0, Rn=0, imm5=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_a1_a_field_rd_1_poweroftwo_0_00201000() {
    // Encoding: 0x00201000
    // Test aarch32_EOR_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, cond=0, Rd=1, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x00201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_0_zero_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, Rd=0, type1=0, imm5=0, S=0, Rm=0, cond=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_1_poweroftwo_0_00200080() {
    // Encoding: 0x00200080
    // Test aarch32_EOR_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, S=0, Rd=0, imm5=1, Rm=0, Rn=0
    let encoding: u32 = 0x00200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_3_poweroftwominusone_0_00200180() {
    // Encoding: 0x00200180
    // Test aarch32_EOR_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, type1=0, imm5=3, cond=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x00200180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_4_poweroftwo_0_00200200() {
    // Encoding: 0x00200200
    // Test aarch32_EOR_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, imm5=4, S=0, cond=0, Rn=0, type1=0
    let encoding: u32 = 0x00200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_7_poweroftwominusone_0_00200380() {
    // Encoding: 0x00200380
    // Test aarch32_EOR_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=0, imm5=7, type1=0, Rm=0
    let encoding: u32 = 0x00200380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_8_poweroftwo_0_00200400() {
    // Encoding: 0x00200400
    // Test aarch32_EOR_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, imm5=8, cond=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_15_poweroftwominusone_0_00200780() {
    // Encoding: 0x00200780
    // Test aarch32_EOR_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, cond=0, S=0, Rd=0, Rm=0, imm5=15, Rn=0
    let encoding: u32 = 0x00200780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_16_poweroftwo_0_00200800() {
    // Encoding: 0x00200800
    // Test aarch32_EOR_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, type1=0, Rm=0, Rd=0, Rn=0, cond=0, S=0
    let encoding: u32 = 0x00200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_eor_r_a1_a_field_imm5_31_max_0_00200f80() {
    // Encoding: 0x00200F80
    // Test aarch32_EOR_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: cond=0, imm5=31, type1=0, S=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x00200F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_eor_r_a1_a_field_type1_0_min_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: S=0, type1=0, Rm=0, Rd=0, cond=0, imm5=0, Rn=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_eor_r_a1_a_field_type1_1_poweroftwo_0_00200020() {
    // Encoding: 0x00200020
    // Test aarch32_EOR_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, imm5=0, Rd=0, cond=0, type1=1, S=0, Rn=0
    let encoding: u32 = 0x00200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_eor_r_a1_a_field_type1_3_max_0_00200060() {
    // Encoding: 0x00200060
    // Test aarch32_EOR_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: cond=0, Rd=0, type1=3, imm5=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x00200060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_a1_a_field_rm_0_min_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm5=0, type1=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_a1_a_field_rm_1_poweroftwo_0_00200001() {
    // Encoding: 0x00200001
    // Test aarch32_EOR_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rm=1, imm5=0, Rd=0, cond=0, type1=0
    let encoding: u32 = 0x00200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_eor_r_a1_a_combo_0_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, S=0, imm5=0, cond=0, Rd=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_0_condition_eq_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, type1=0, cond=0, imm5=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_1_condition_ne_0_10200000() {
    // Encoding: 0x10200000
    // Test aarch32_EOR_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=1, Rd=0, imm5=0, S=0, type1=0
    let encoding: u32 = 0x10200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_2_condition_cs_hs_0_20200000() {
    // Encoding: 0x20200000
    // Test aarch32_EOR_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, Rm=0, S=0, Rn=0, cond=2
    let encoding: u32 = 0x20200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_3_condition_cc_lo_0_30200000() {
    // Encoding: 0x30200000
    // Test aarch32_EOR_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: S=0, imm5=0, cond=3, Rn=0, type1=0, Rd=0, Rm=0
    let encoding: u32 = 0x30200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_4_condition_mi_0_40200000() {
    // Encoding: 0x40200000
    // Test aarch32_EOR_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, cond=4, Rn=0, Rd=0
    let encoding: u32 = 0x40200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_5_condition_pl_0_50200000() {
    // Encoding: 0x50200000
    // Test aarch32_EOR_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: S=0, cond=5, Rd=0, imm5=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0x50200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_6_condition_vs_0_60200000() {
    // Encoding: 0x60200000
    // Test aarch32_EOR_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, type1=0, Rm=0, cond=6, imm5=0, S=0, Rd=0
    let encoding: u32 = 0x60200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_7_condition_vc_0_70200000() {
    // Encoding: 0x70200000
    // Test aarch32_EOR_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rn=0, type1=0, imm5=0, Rm=0, cond=7, Rd=0
    let encoding: u32 = 0x70200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_8_condition_hi_0_80200000() {
    // Encoding: 0x80200000
    // Test aarch32_EOR_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, imm5=0, type1=0, Rm=0, cond=8, S=0, Rd=0
    let encoding: u32 = 0x80200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_9_condition_ls_0_90200000() {
    // Encoding: 0x90200000
    // Test aarch32_EOR_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: type1=0, cond=9, Rd=0, S=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0x90200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_10_condition_ge_0_a0200000() {
    // Encoding: 0xA0200000
    // Test aarch32_EOR_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: imm5=0, S=0, Rm=0, type1=0, Rn=0, Rd=0, cond=10
    let encoding: u32 = 0xA0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_11_condition_lt_0_b0200000() {
    // Encoding: 0xB0200000
    // Test aarch32_EOR_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=11, imm5=0, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0xB0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_12_condition_gt_0_c0200000() {
    // Encoding: 0xC0200000
    // Test aarch32_EOR_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, Rd=0, Rm=0, Rn=0, imm5=0, cond=12, type1=0
    let encoding: u32 = 0xC0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_13_condition_le_0_d0200000() {
    // Encoding: 0xD0200000
    // Test aarch32_EOR_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, type1=0, imm5=0, cond=13, Rd=0
    let encoding: u32 = 0xD0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_14_condition_al_0_e0200000() {
    // Encoding: 0xE0200000
    // Test aarch32_EOR_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=14, Rd=0, imm5=0, type1=0, S=0
    let encoding: u32 = 0xE0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_eor_r_a1_a_special_cond_15_condition_nv_0_f0200000() {
    // Encoding: 0xF0200000
    // Test aarch32_EOR_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, cond=15, Rn=0, S=0, imm5=0, Rm=0, type1=0
    let encoding: u32 = 0xF0200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_eor_r_a1_a_special_s_0_size_variant_0_0_00200000() {
    // Encoding: 0x00200000
    // Test aarch32_EOR_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=0, Rd=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x00200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_eor_r_a1_a_special_s_1_size_variant_1_0_00300000() {
    // Encoding: 0x00300000
    // Test aarch32_EOR_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, S=1, imm5=0, cond=0, Rd=0
    let encoding: u32 = 0x00300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_t1_a_field_rm_0_min_0_40400000() {
    // Thumb encoding (32): 0x40400000
    // Test aarch32_EOR_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_t1_a_field_rm_1_poweroftwo_0_40480000() {
    // Thumb encoding (32): 0x40480000
    // Test aarch32_EOR_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_eor_r_t1_a_field_rdn_0_min_0_40400000() {
    // Thumb encoding (32): 0x40400000
    // Test aarch32_EOR_r_T1_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_eor_r_t1_a_field_rdn_1_poweroftwo_0_40410000() {
    // Thumb encoding (32): 0x40410000
    // Test aarch32_EOR_r_T1_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rdn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_eor_r_t1_a_field_rdn_7_max_0_40470000() {
    // Thumb encoding (32): 0x40470000
    // Test aarch32_EOR_r_T1_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: Rdn=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40470000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_eor_r_t1_a_combo_0_0_40400000() {
    // Thumb encoding (32): 0x40400000
    // Test aarch32_EOR_r_T1_A field combination: Rm=0, Rdn=0
    // ISET: T32
    // Fields: Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_eor_r_t2_a_field_s_0_min_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rm=0, Rn=0, imm2=0, imm3=0, Rd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_eor_r_t2_a_field_s_1_max_0_ea900000() {
    // Thumb encoding (32): 0xEA900000
    // Test aarch32_EOR_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, S=1, Rn=0, Rd=0, type1=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_t2_a_field_rn_0_min_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, type1=0, S=0, Rn=0, imm3=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_t2_a_field_rn_1_poweroftwo_0_ea810000() {
    // Thumb encoding (32): 0xEA810000
    // Test aarch32_EOR_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, type1=0, Rm=0, S=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_eor_r_t2_a_field_imm3_0_zero_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm2=0, type1=0, imm3=0, S=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_eor_r_t2_a_field_imm3_1_poweroftwo_0_ea801000() {
    // Thumb encoding (32): 0xEA801000
    // Test aarch32_EOR_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, Rm=0, type1=0, imm2=0, imm3=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_eor_r_t2_a_field_imm3_3_poweroftwominusone_0_ea803000() {
    // Thumb encoding (32): 0xEA803000
    // Test aarch32_EOR_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, imm3=3, Rn=0, imm2=0, type1=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA803000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_eor_r_t2_a_field_imm3_7_max_0_ea807000() {
    // Thumb encoding (32): 0xEA807000
    // Test aarch32_EOR_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm3=7, type1=0, Rm=0, Rn=0, imm2=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA807000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_t2_a_field_rd_0_min_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, type1=0, Rm=0, imm2=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_t2_a_field_rd_1_poweroftwo_0_ea800100() {
    // Thumb encoding (32): 0xEA800100
    // Test aarch32_EOR_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm3=0, S=0, imm2=0, type1=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_eor_r_t2_a_field_imm2_0_zero_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, S=0, Rd=0, Rn=0, type1=0, imm3=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_eor_r_t2_a_field_imm2_1_poweroftwo_0_ea800040() {
    // Thumb encoding (32): 0xEA800040
    // Test aarch32_EOR_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm3=0, Rn=0, S=0, Rd=0, imm2=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_eor_r_t2_a_field_imm2_3_max_0_ea8000c0() {
    // Thumb encoding (32): 0xEA8000C0
    // Test aarch32_EOR_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: S=0, Rd=0, type1=0, imm3=0, imm2=3, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA8000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_eor_r_t2_a_field_type1_0_min_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, S=0, imm3=0, type1=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_eor_r_t2_a_field_type1_1_poweroftwo_0_ea800010() {
    // Thumb encoding (32): 0xEA800010
    // Test aarch32_EOR_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=0, type1=1, Rm=0, Rd=0, Rn=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_eor_r_t2_a_field_type1_3_max_0_ea800030() {
    // Thumb encoding (32): 0xEA800030
    // Test aarch32_EOR_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: type1=3, Rm=0, imm3=0, S=0, Rd=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_r_t2_a_field_rm_0_min_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rm=0, S=0, Rd=0, type1=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_r_t2_a_field_rm_1_poweroftwo_0_ea800001() {
    // Thumb encoding (32): 0xEA800001
    // Test aarch32_EOR_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rm=1, Rd=0, S=0, imm2=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_eor_r_t2_a_combo_0_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, Rn=0, S=0, type1=0, imm3=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_eor_r_t2_a_special_s_0_size_variant_0_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: imm2=0, type1=0, Rm=0, Rd=0, S=0, imm3=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_eor_r_t2_a_special_s_1_size_variant_1_0_ea900000() {
    // Thumb encoding (32): 0xEA900000
    // Test aarch32_EOR_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, S=1, Rn=0, imm3=0, Rd=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eor_r_t2_a_invalid_0_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: S=0, Rn=0, imm2=0, imm3=0, Rm=0, type1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eor_r_t2_a_invalid_1_0_ea800000() {
    // Thumb encoding (32): 0xEA800000
    // Test aarch32_EOR_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: type1=0, Rn=0, imm3=0, imm2=0, Rm=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_32_0_00220020() {
    // Test EOR shifted 32-bit: no shift (oracle)
    // Encoding: 0x00220020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00220020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "W0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_64_0_80220020() {
    // Test EOR shifted 64-bit: no shift (oracle)
    // Encoding: 0x80220020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x80220020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFF00,
        "X0 should be 0x00000000FFFFFF00"
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #8 (32)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_32_1_00222020() {
    // Test EOR shifted 32-bit: LSL #8 (oracle)
    // Encoding: 0x00222020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00222020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFEFF, "W0 should be 0xFFFFFEFF");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #8 (64)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_64_1_80222020() {
    // Test EOR shifted 64-bit: LSL #8 (oracle)
    // Encoding: 0x80222020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x80222020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFEFF,
        "X0 should be 0x00000000FFFFFEFF"
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSR #8 (32)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_32_2_00622020() {
    // Test EOR shifted 32-bit: LSR #8 (oracle)
    // Encoding: 0x00622020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x00622020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF00FFFF, "W0 should be 0xFF00FFFF");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSR #8 (64)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_64_2_80622020() {
    // Test EOR shifted 64-bit: LSR #8 (oracle)
    // Encoding: 0x80622020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF000000);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x80622020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF00FFFF,
        "X0 should be 0x00000000FF00FFFF"
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ASR #4 negative (32)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_32_3_00a21020() {
    // Test EOR shifted 32-bit: ASR #4 negative (oracle)
    // Encoding: 0x00A21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x00A21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x78000000, "W0 should be 0x78000000");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ASR #4 negative (64)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_64_3_80a21020() {
    // Test EOR shifted 64-bit: ASR #4 negative (oracle)
    // Encoding: 0x80A21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x80A21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x88000000,
        "X0 should be 0x0000000088000000"
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ROR #4 (32)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_32_4_00e21020() {
    // Test EOR shifted 32-bit: ROR #4 (oracle)
    // Encoding: 0x00E21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x00E21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8888888, "W0 should be 0x08888888");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ROR #4 (64)
#[test]
fn test_aarch32_eor_r_a1_a_eor_shifted_oracle_64_4_80e21020() {
    // Test EOR shifted 64-bit: ROR #4 (oracle)
    // Encoding: 0x80E21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x80E21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x18888888,
        "X0 should be 0x1000000018888888"
    );
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_eor_r_a1_a_a32_logical_reg_0_00210002() {
    // Test A32 EOR: simple values (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x56, "R0 should be 0x00000056");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_eor_r_a1_a_a32_logical_reg_1_00210002() {
    // Test A32 EOR: zero values (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_eor_r_a1_a_a32_logical_reg_2_00210002() {
    // Test A32 EOR: max value (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_eor_r_a1_a_a32_logical_reg_3_00210002() {
    // Test A32 EOR: MSB set (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_eor_r_a1_a_a32_logical_reg_4_00210002() {
    // Test A32 EOR: mixed pattern (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x88888888, "R0 should be 0x88888888");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_zeroresult_0_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_zeroresult_1_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_negativeresult_2_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_unsignedoverflow_3_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_unsignedoverflow_4_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_signedoverflow_5_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_eor_r_a1_a_flags_signedoverflow_6_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_eor_r_a1_a_flags_positiveresult_7_00310002() {
    // Test aarch32_EOR_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00310002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_32_0_40420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_64_0_c0420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_32_1_40420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_64_1_c0420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_32_2_40420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_64_2_c0420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_32_3_40420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_64_3_c0420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_32_4_40420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_64_4_c0420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_32_5_40420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_eor_r_t1_a_lslv_oracle_64_5_c0420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_eor_r_t1_a_t16_oracle_0_40500000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_eor_r_t1_a_t16_oracle_1_40500000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_eor_r_t1_a_t16_oracle_2_40500000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_eor_r_t1_a_t16_oracle_3_40500000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_zeroresult_0_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_zeroresult_1_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_negativeresult_2_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_unsignedoverflow_3_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_unsignedoverflow_4_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_signedoverflow_5_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_eor_r_t1_a_flags_signedoverflow_6_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_eor_r_t1_a_flags_positiveresult_7_40500000() {
    // Test aarch32_EOR_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_zeroresult_0_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_zeroresult_1_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_negativeresult_2_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_unsignedoverflow_3_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_unsignedoverflow_4_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_signedoverflow_5_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_eor_r_t2_a_flags_signedoverflow_6_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_eor_r_t2_a_flags_positiveresult_7_ea910002() {
    // Test aarch32_EOR_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEA910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_AND_i_A Tests
// ============================================================================

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_0_min_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, imm12=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_1_poweroftwo_0_12000000() {
    // Encoding: 0x12000000
    // Test aarch32_AND_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, cond=1, S=0
    let encoding: u32 = 0x12000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_2_poweroftwo_0_22000000() {
    // Encoding: 0x22000000
    // Test aarch32_AND_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=2, Rn=0, imm12=0, S=0
    let encoding: u32 = 0x22000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_3_poweroftwo_0_32000000() {
    // Encoding: 0x32000000
    // Test aarch32_AND_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=3, Rd=0, Rn=0
    let encoding: u32 = 0x32000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_4_poweroftwo_0_42000000() {
    // Encoding: 0x42000000
    // Test aarch32_AND_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=4, Rd=0, S=0
    let encoding: u32 = 0x42000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_5_poweroftwo_0_52000000() {
    // Encoding: 0x52000000
    // Test aarch32_AND_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=5, Rn=0
    let encoding: u32 = 0x52000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_6_poweroftwo_0_62000000() {
    // Encoding: 0x62000000
    // Test aarch32_AND_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, S=0, cond=6
    let encoding: u32 = 0x62000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_7_poweroftwo_0_72000000() {
    // Encoding: 0x72000000
    // Test aarch32_AND_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=7, Rn=0, S=0
    let encoding: u32 = 0x72000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_8_poweroftwo_0_82000000() {
    // Encoding: 0x82000000
    // Test aarch32_AND_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rn=0, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x82000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_9_poweroftwo_0_92000000() {
    // Encoding: 0x92000000
    // Test aarch32_AND_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, S=0, cond=9
    let encoding: u32 = 0x92000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_10_poweroftwo_0_a2000000() {
    // Encoding: 0xA2000000
    // Test aarch32_AND_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=0, cond=10, S=0
    let encoding: u32 = 0xA2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_11_poweroftwo_0_b2000000() {
    // Encoding: 0xB2000000
    // Test aarch32_AND_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=11, Rn=0, imm12=0, S=0
    let encoding: u32 = 0xB2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_12_poweroftwo_0_c2000000() {
    // Encoding: 0xC2000000
    // Test aarch32_AND_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=12, imm12=0, S=0, Rn=0
    let encoding: u32 = 0xC2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_13_poweroftwo_0_d2000000() {
    // Encoding: 0xD2000000
    // Test aarch32_AND_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=13, Rn=0
    let encoding: u32 = 0xD2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_14_poweroftwo_0_e2000000() {
    // Encoding: 0xE2000000
    // Test aarch32_AND_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=14, S=0, Rn=0
    let encoding: u32 = 0xE2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_and_i_a1_a_field_cond_15_max_0_f2000000() {
    // Encoding: 0xF2000000
    // Test aarch32_AND_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm12=0, cond=15
    let encoding: u32 = 0xF2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_and_i_a1_a_field_s_0_min_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_and_i_a1_a_field_s_1_max_0_02100000() {
    // Encoding: 0x02100000
    // Test aarch32_AND_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, S=1, cond=0
    let encoding: u32 = 0x02100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_i_a1_a_field_rn_0_min_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_i_a1_a_field_rn_1_poweroftwo_0_02010000() {
    // Encoding: 0x02010000
    // Test aarch32_AND_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=0, S=0, Rn=1, Rd=0
    let encoding: u32 = 0x02010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_i_a1_a_field_rd_0_min_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm12=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_i_a1_a_field_rd_1_poweroftwo_0_02001000() {
    // Encoding: 0x02001000
    // Test aarch32_AND_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, imm12=0, S=0, cond=0, Rn=0
    let encoding: u32 = 0x02001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_0_zero_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, S=0, cond=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_1_poweroftwo_0_02000001() {
    // Encoding: 0x02000001
    // Test aarch32_AND_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, Rn=0, imm12=1
    let encoding: u32 = 0x02000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_3_poweroftwominusone_0_02000003() {
    // Encoding: 0x02000003
    // Test aarch32_AND_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm12=3, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x02000003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_4_poweroftwo_0_02000004() {
    // Encoding: 0x02000004
    // Test aarch32_AND_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, Rn=0, imm12=4
    let encoding: u32 = 0x02000004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_7_poweroftwominusone_0_02000007() {
    // Encoding: 0x02000007
    // Test aarch32_AND_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, cond=0, imm12=7
    let encoding: u32 = 0x02000007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_8_poweroftwo_0_02000008() {
    // Encoding: 0x02000008
    // Test aarch32_AND_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, imm12=8
    let encoding: u32 = 0x02000008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_15_poweroftwominusone_0_0200000f() {
    // Encoding: 0x0200000F
    // Test aarch32_AND_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=15
    let encoding: u32 = 0x0200000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_16_poweroftwo_0_02000010() {
    // Encoding: 0x02000010
    // Test aarch32_AND_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=16, Rn=0
    let encoding: u32 = 0x02000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_31_poweroftwominusone_0_0200001f() {
    // Encoding: 0x0200001F
    // Test aarch32_AND_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=31, S=0, Rd=0
    let encoding: u32 = 0x0200001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_32_poweroftwo_0_02000020() {
    // Encoding: 0x02000020
    // Test aarch32_AND_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=32, S=0, cond=0
    let encoding: u32 = 0x02000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_63_poweroftwominusone_0_0200003f() {
    // Encoding: 0x0200003F
    // Test aarch32_AND_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, imm12=63, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x0200003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_64_poweroftwo_0_02000040() {
    // Encoding: 0x02000040
    // Test aarch32_AND_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, S=0, imm12=64
    let encoding: u32 = 0x02000040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_127_poweroftwominusone_0_0200007f() {
    // Encoding: 0x0200007F
    // Test aarch32_AND_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, imm12=127, Rd=0
    let encoding: u32 = 0x0200007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_128_poweroftwo_0_02000080() {
    // Encoding: 0x02000080
    // Test aarch32_AND_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=128, Rn=0
    let encoding: u32 = 0x02000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_255_poweroftwominusone_0_020000ff() {
    // Encoding: 0x020000FF
    // Test aarch32_AND_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, S=0, imm12=255
    let encoding: u32 = 0x020000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_256_poweroftwo_0_02000100() {
    // Encoding: 0x02000100
    // Test aarch32_AND_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=256, Rn=0, S=0, cond=0
    let encoding: u32 = 0x02000100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_511_poweroftwominusone_0_020001ff() {
    // Encoding: 0x020001FF
    // Test aarch32_AND_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=511
    let encoding: u32 = 0x020001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_512_poweroftwo_0_02000200() {
    // Encoding: 0x02000200
    // Test aarch32_AND_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=512, Rn=0, Rd=0
    let encoding: u32 = 0x02000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_1023_poweroftwominusone_0_020003ff() {
    // Encoding: 0x020003FF
    // Test aarch32_AND_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=1023, S=0, Rn=0
    let encoding: u32 = 0x020003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_1024_poweroftwo_0_02000400() {
    // Encoding: 0x02000400
    // Test aarch32_AND_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=1024, Rn=0, S=0
    let encoding: u32 = 0x02000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_2047_poweroftwominusone_0_020007ff() {
    // Encoding: 0x020007FF
    // Test aarch32_AND_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=2047, cond=0, Rd=0
    let encoding: u32 = 0x020007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_2048_poweroftwo_0_02000800() {
    // Encoding: 0x02000800
    // Test aarch32_AND_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, imm12=2048, Rd=0, Rn=0
    let encoding: u32 = 0x02000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_and_i_a1_a_field_imm12_4095_max_0_02000fff() {
    // Encoding: 0x02000FFF
    // Test aarch32_AND_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, imm12=4095, Rd=0
    let encoding: u32 = 0x02000FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_and_i_a1_a_combo_0_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_and_i_a1_a_special_cond_0_condition_eq_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_and_i_a1_a_special_cond_1_condition_ne_0_12000000() {
    // Encoding: 0x12000000
    // Test aarch32_AND_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=0, cond=1, Rd=0
    let encoding: u32 = 0x12000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_and_i_a1_a_special_cond_2_condition_cs_hs_0_22000000() {
    // Encoding: 0x22000000
    // Test aarch32_AND_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rn=0, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x22000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_and_i_a1_a_special_cond_3_condition_cc_lo_0_32000000() {
    // Encoding: 0x32000000
    // Test aarch32_AND_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x32000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_and_i_a1_a_special_cond_4_condition_mi_0_42000000() {
    // Encoding: 0x42000000
    // Test aarch32_AND_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x42000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_and_i_a1_a_special_cond_5_condition_pl_0_52000000() {
    // Encoding: 0x52000000
    // Test aarch32_AND_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, cond=5, Rn=0
    let encoding: u32 = 0x52000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_and_i_a1_a_special_cond_6_condition_vs_0_62000000() {
    // Encoding: 0x62000000
    // Test aarch32_AND_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, imm12=0, Rn=0, S=0
    let encoding: u32 = 0x62000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_and_i_a1_a_special_cond_7_condition_vc_0_72000000() {
    // Encoding: 0x72000000
    // Test aarch32_AND_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, S=0, imm12=0, Rn=0
    let encoding: u32 = 0x72000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_and_i_a1_a_special_cond_8_condition_hi_0_82000000() {
    // Encoding: 0x82000000
    // Test aarch32_AND_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: imm12=0, Rn=0, cond=8, Rd=0, S=0
    let encoding: u32 = 0x82000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_and_i_a1_a_special_cond_9_condition_ls_0_92000000() {
    // Encoding: 0x92000000
    // Test aarch32_AND_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x92000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_and_i_a1_a_special_cond_10_condition_ge_0_a2000000() {
    // Encoding: 0xA2000000
    // Test aarch32_AND_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, imm12=0, cond=10, Rd=0, Rn=0
    let encoding: u32 = 0xA2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_and_i_a1_a_special_cond_11_condition_lt_0_b2000000() {
    // Encoding: 0xB2000000
    // Test aarch32_AND_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rd=0, imm12=0, S=0
    let encoding: u32 = 0xB2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_and_i_a1_a_special_cond_12_condition_gt_0_c2000000() {
    // Encoding: 0xC2000000
    // Test aarch32_AND_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, S=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0xC2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_and_i_a1_a_special_cond_13_condition_le_0_d2000000() {
    // Encoding: 0xD2000000
    // Test aarch32_AND_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, imm12=0, Rn=0, S=0
    let encoding: u32 = 0xD2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_and_i_a1_a_special_cond_14_condition_al_0_e2000000() {
    // Encoding: 0xE2000000
    // Test aarch32_AND_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, cond=14, S=0, Rn=0, Rd=0
    let encoding: u32 = 0xE2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_and_i_a1_a_special_cond_15_condition_nv_0_f2000000() {
    // Encoding: 0xF2000000
    // Test aarch32_AND_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=15, S=0, Rn=0
    let encoding: u32 = 0xF2000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_and_i_a1_a_special_s_0_size_variant_0_0_02000000() {
    // Encoding: 0x02000000
    // Test aarch32_AND_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x02000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_and_i_a1_a_special_s_1_size_variant_1_0_02100000() {
    // Encoding: 0x02100000
    // Test aarch32_AND_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, S=1, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0x02100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_and_i_t1_a_field_i_0_min_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field i = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, S=0, imm8=0, i=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_and_i_t1_a_field_i_1_max_0_f4000000() {
    // Thumb encoding (32): 0xF4000000
    // Test aarch32_AND_i_T1_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, S=0, Rn=0, i=1, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF4000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_and_i_t1_a_field_s_0_min_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=0, S=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_and_i_t1_a_field_s_1_max_0_f0100000() {
    // Thumb encoding (32): 0xF0100000
    // Test aarch32_AND_i_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: i=0, imm8=0, S=1, imm3=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_i_t1_a_field_rn_0_min_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, imm3=0, S=0, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_i_t1_a_field_rn_1_poweroftwo_0_f0010000() {
    // Thumb encoding (32): 0xF0010000
    // Test aarch32_AND_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, S=0, imm8=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_and_i_t1_a_field_imm3_0_zero_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, imm8=0, i=0, S=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_and_i_t1_a_field_imm3_1_poweroftwo_0_f0001000() {
    // Thumb encoding (32): 0xF0001000
    // Test aarch32_AND_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, imm8=0, Rn=0, imm3=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_and_i_t1_a_field_imm3_3_poweroftwominusone_0_f0003000() {
    // Thumb encoding (32): 0xF0003000
    // Test aarch32_AND_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=0, imm3=3, S=0, i=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_and_i_t1_a_field_imm3_7_max_0_f0007000() {
    // Thumb encoding (32): 0xF0007000
    // Test aarch32_AND_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm8=0, i=0, S=0, Rn=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_i_t1_a_field_rd_0_min_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm8=0, Rd=0, imm3=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_i_t1_a_field_rd_1_poweroftwo_0_f0000100() {
    // Thumb encoding (32): 0xF0000100
    // Test aarch32_AND_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_0_zero_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rd=0, i=0, imm3=0, S=0, imm8=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_1_poweroftwo_0_f0000001() {
    // Thumb encoding (32): 0xF0000001
    // Test aarch32_AND_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, S=0, i=0, imm3=0, Rd=0, imm8=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_3_poweroftwominusone_0_f0000003() {
    // Thumb encoding (32): 0xF0000003
    // Test aarch32_AND_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, imm8=3, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_4_poweroftwo_0_f0000004() {
    // Thumb encoding (32): 0xF0000004
    // Test aarch32_AND_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, Rd=0, S=0, imm3=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_7_poweroftwominusone_0_f0000007() {
    // Thumb encoding (32): 0xF0000007
    // Test aarch32_AND_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=7, S=0, Rd=0, imm3=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_8_poweroftwo_0_f0000008() {
    // Thumb encoding (32): 0xF0000008
    // Test aarch32_AND_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, imm3=0, Rn=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_15_poweroftwominusone_0_f000000f() {
    // Thumb encoding (32): 0xF000000F
    // Test aarch32_AND_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=15, Rd=0, Rn=0, S=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF000000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_16_poweroftwo_0_f0000010() {
    // Thumb encoding (32): 0xF0000010
    // Test aarch32_AND_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, imm3=0, Rd=0, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_31_poweroftwominusone_0_f000001f() {
    // Thumb encoding (32): 0xF000001F
    // Test aarch32_AND_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, Rd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF000001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_32_poweroftwo_0_f0000020() {
    // Thumb encoding (32): 0xF0000020
    // Test aarch32_AND_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, Rd=0, imm3=0, imm8=32
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_63_poweroftwominusone_0_f000003f() {
    // Thumb encoding (32): 0xF000003F
    // Test aarch32_AND_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=63, imm3=0, S=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF000003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_64_poweroftwo_0_f0000040() {
    // Thumb encoding (32): 0xF0000040
    // Test aarch32_AND_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm8=64, imm3=0, S=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_127_poweroftwominusone_0_f000007f() {
    // Thumb encoding (32): 0xF000007F
    // Test aarch32_AND_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, S=0, imm3=0, Rd=0, i=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF000007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_128_poweroftwo_0_f0000080() {
    // Thumb encoding (32): 0xF0000080
    // Test aarch32_AND_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm3=0, i=0, Rd=0, imm8=128, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_and_i_t1_a_field_imm8_255_max_0_f00000ff() {
    // Thumb encoding (32): 0xF00000FF
    // Test aarch32_AND_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, S=0, Rd=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF00000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_and_i_t1_a_combo_0_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_and_i_t1_a_special_s_0_size_variant_0_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: imm8=0, S=0, imm3=0, Rn=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_and_i_t1_a_special_s_1_size_variant_1_0_f0100000() {
    // Thumb encoding (32): 0xF0100000
    // Test aarch32_AND_i_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, i=0, Rd=0, imm3=0, imm8=0, S=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_and_i_t1_a_invalid_0_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm3=0, S=0, imm8=0, Rd=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_and_i_t1_a_invalid_1_0_f0000000() {
    // Thumb encoding (32): 0xF0000000
    // Test aarch32_AND_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, imm8=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0x92401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0x92403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0x92407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // Encoding: 0x92400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // Encoding: 0x9240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x12001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x12003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_and_i_a1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // Encoding: 0x12000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_0_0_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_0_ff_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_0_aaaaaaaa_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_0_55555555_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_0_ffffffff_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_1_0_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_1_ff_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_1_aaaaaaaa_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAA, "R0 should be 0x000000AA");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_1_55555555_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55, "R0 should be 0x00000055");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_1_ffffffff_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_2_0_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_2_ff_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_2_aaaaaaaa_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_2_55555555_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_2_ffffffff_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_3_0_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_3_ff_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_3_aaaaaaaa_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA000000, "R0 should be 0x0A000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_3_55555555_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5000000, "R0 should be 0x05000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_3_ffffffff_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_4_0_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_4_ff_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_4_aaaaaaaa_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_4_55555555_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_and_i_a1_a_a32_logical_imm_4_ffffffff_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_zeroresult_0_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_zeroresult_1_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_negativeresult_2_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_unsignedoverflow_3_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_unsignedoverflow_4_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_signedoverflow_5_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_and_i_a1_a_flags_signedoverflow_6_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_and_i_a1_a_flags_positiveresult_7_02110000() {
    // Test aarch32_AND_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02110000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x02110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_and_i_t1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_zeroresult_0_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_zeroresult_1_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_negativeresult_2_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_unsignedoverflow_3_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_unsignedoverflow_4_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_signedoverflow_5_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_and_i_t1_a_flags_signedoverflow_6_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_and_i_t1_a_flags_positiveresult_7_f0110000() {
    // Test aarch32_AND_i_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF0110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_BIC_r_A Tests
// ============================================================================

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_0_min_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rn=0, cond=0, imm5=0, Rd=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_1_poweroftwo_0_11c00000() {
    // Encoding: 0x11C00000
    // Test aarch32_BIC_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, imm5=0, cond=1, S=0, type1=0
    let encoding: u32 = 0x11C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_2_poweroftwo_0_21c00000() {
    // Encoding: 0x21C00000
    // Test aarch32_BIC_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, Rm=0, S=0, cond=2, Rn=0
    let encoding: u32 = 0x21C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_3_poweroftwo_0_31c00000() {
    // Encoding: 0x31C00000
    // Test aarch32_BIC_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, S=0, Rn=0, Rm=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x31C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_4_poweroftwo_0_41c00000() {
    // Encoding: 0x41C00000
    // Test aarch32_BIC_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=4, S=0, imm5=0, type1=0
    let encoding: u32 = 0x41C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_5_poweroftwo_0_51c00000() {
    // Encoding: 0x51C00000
    // Test aarch32_BIC_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm5=0, cond=5, Rm=0, type1=0
    let encoding: u32 = 0x51C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_6_poweroftwo_0_61c00000() {
    // Encoding: 0x61C00000
    // Test aarch32_BIC_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rm=0, cond=6, Rn=0, type1=0, S=0
    let encoding: u32 = 0x61C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_7_poweroftwo_0_71c00000() {
    // Encoding: 0x71C00000
    // Test aarch32_BIC_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=0, Rn=0, cond=7, Rd=0, Rm=0
    let encoding: u32 = 0x71C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_8_poweroftwo_0_81c00000() {
    // Encoding: 0x81C00000
    // Test aarch32_BIC_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=8, Rd=0, imm5=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0x81C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_9_poweroftwo_0_91c00000() {
    // Encoding: 0x91C00000
    // Test aarch32_BIC_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, imm5=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x91C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_10_poweroftwo_0_a1c00000() {
    // Encoding: 0xA1C00000
    // Test aarch32_BIC_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, S=0, cond=10, imm5=0, Rd=0
    let encoding: u32 = 0xA1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_11_poweroftwo_0_b1c00000() {
    // Encoding: 0xB1C00000
    // Test aarch32_BIC_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rm=0, S=0, imm5=0, cond=11, Rn=0
    let encoding: u32 = 0xB1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_12_poweroftwo_0_c1c00000() {
    // Encoding: 0xC1C00000
    // Test aarch32_BIC_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rn=0, imm5=0, Rm=0, cond=12, S=0
    let encoding: u32 = 0xC1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_13_poweroftwo_0_d1c00000() {
    // Encoding: 0xD1C00000
    // Test aarch32_BIC_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, cond=13, imm5=0, Rd=0, type1=0
    let encoding: u32 = 0xD1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_14_poweroftwo_0_e1c00000() {
    // Encoding: 0xE1C00000
    // Test aarch32_BIC_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, type1=0, Rm=0, Rn=0, cond=14
    let encoding: u32 = 0xE1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_bic_r_a1_a_field_cond_15_max_0_f1c00000() {
    // Encoding: 0xF1C00000
    // Test aarch32_BIC_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=15, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xF1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_bic_r_a1_a_field_s_0_min_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, imm5=0, S=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_bic_r_a1_a_field_s_1_max_0_01d00000() {
    // Encoding: 0x01D00000
    // Test aarch32_BIC_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, S=1, type1=0, Rd=0, imm5=0
    let encoding: u32 = 0x01D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_a1_a_field_rn_0_min_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm5=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_a1_a_field_rn_1_poweroftwo_0_01c10000() {
    // Encoding: 0x01C10000
    // Test aarch32_BIC_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, type1=0, Rm=0, S=0, cond=0, Rd=0, imm5=0
    let encoding: u32 = 0x01C10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_a1_a_field_rd_0_min_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, imm5=0, type1=0, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_a1_a_field_rd_1_poweroftwo_0_01c01000() {
    // Encoding: 0x01C01000
    // Test aarch32_BIC_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=1, S=0, Rm=0, cond=0, imm5=0, Rn=0
    let encoding: u32 = 0x01C01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_0_zero_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, type1=0, imm5=0, cond=0, Rd=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_1_poweroftwo_0_01c00080() {
    // Encoding: 0x01C00080
    // Test aarch32_BIC_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, type1=0, cond=0, imm5=1, Rm=0, S=0
    let encoding: u32 = 0x01C00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_3_poweroftwominusone_0_01c00180() {
    // Encoding: 0x01C00180
    // Test aarch32_BIC_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rn=0, cond=0, Rd=0, S=0, imm5=3, Rm=0
    let encoding: u32 = 0x01C00180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_4_poweroftwo_0_01c00200() {
    // Encoding: 0x01C00200
    // Test aarch32_BIC_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=4, cond=0, Rm=0, type1=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x01C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_7_poweroftwominusone_0_01c00380() {
    // Encoding: 0x01C00380
    // Test aarch32_BIC_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rn=0, cond=0, imm5=7, Rd=0
    let encoding: u32 = 0x01C00380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_8_poweroftwo_0_01c00400() {
    // Encoding: 0x01C00400
    // Test aarch32_BIC_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, imm5=8, type1=0, Rm=0, S=0
    let encoding: u32 = 0x01C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_15_poweroftwominusone_0_01c00780() {
    // Encoding: 0x01C00780
    // Test aarch32_BIC_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, imm5=15, Rn=0, S=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x01C00780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_16_poweroftwo_0_01c00800() {
    // Encoding: 0x01C00800
    // Test aarch32_BIC_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, imm5=16, cond=0, Rm=0, Rd=0, S=0
    let encoding: u32 = 0x01C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_bic_r_a1_a_field_imm5_31_max_0_01c00f80() {
    // Encoding: 0x01C00F80
    // Test aarch32_BIC_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: cond=0, imm5=31, Rn=0, Rm=0, Rd=0, type1=0, S=0
    let encoding: u32 = 0x01C00F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bic_r_a1_a_field_type1_0_min_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, S=0, type1=0, Rm=0, cond=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bic_r_a1_a_field_type1_1_poweroftwo_0_01c00020() {
    // Encoding: 0x01C00020
    // Test aarch32_BIC_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, type1=1, Rd=0, imm5=0, S=0
    let encoding: u32 = 0x01C00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_bic_r_a1_a_field_type1_3_max_0_01c00060() {
    // Encoding: 0x01C00060
    // Test aarch32_BIC_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: imm5=0, type1=3, Rm=0, cond=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x01C00060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_a1_a_field_rm_0_min_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_a1_a_field_rm_1_poweroftwo_0_01c00001() {
    // Encoding: 0x01C00001
    // Test aarch32_BIC_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=0, type1=0, Rn=0, Rm=1, cond=0, S=0
    let encoding: u32 = 0x01C00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_bic_r_a1_a_combo_0_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=0, imm5=0, Rm=0, type1=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_0_condition_eq_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm5=0, cond=0, type1=0, Rm=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_1_condition_ne_0_11c00000() {
    // Encoding: 0x11C00000
    // Test aarch32_BIC_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, Rd=0, cond=1, imm5=0, type1=0
    let encoding: u32 = 0x11C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_2_condition_cs_hs_0_21c00000() {
    // Encoding: 0x21C00000
    // Test aarch32_BIC_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, imm5=0, Rm=0, S=0, Rd=0, cond=2, type1=0
    let encoding: u32 = 0x21C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_3_condition_cc_lo_0_31c00000() {
    // Encoding: 0x31C00000
    // Test aarch32_BIC_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, Rm=0, type1=0, cond=3, S=0
    let encoding: u32 = 0x31C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_4_condition_mi_0_41c00000() {
    // Encoding: 0x41C00000
    // Test aarch32_BIC_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, S=0, Rm=0, type1=0, imm5=0
    let encoding: u32 = 0x41C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_5_condition_pl_0_51c00000() {
    // Encoding: 0x51C00000
    // Test aarch32_BIC_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm5=0, S=0, type1=0, Rm=0, cond=5
    let encoding: u32 = 0x51C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_6_condition_vs_0_61c00000() {
    // Encoding: 0x61C00000
    // Test aarch32_BIC_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, Rd=0, Rn=0, cond=6, S=0
    let encoding: u32 = 0x61C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_7_condition_vc_0_71c00000() {
    // Encoding: 0x71C00000
    // Test aarch32_BIC_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, type1=0, Rn=0, S=0, Rd=0, Rm=0, imm5=0
    let encoding: u32 = 0x71C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_8_condition_hi_0_81c00000() {
    // Encoding: 0x81C00000
    // Test aarch32_BIC_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: type1=0, S=0, Rn=0, Rm=0, cond=8, imm5=0, Rd=0
    let encoding: u32 = 0x81C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_9_condition_ls_0_91c00000() {
    // Encoding: 0x91C00000
    // Test aarch32_BIC_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, imm5=0, type1=0, cond=9, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x91C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_10_condition_ge_0_a1c00000() {
    // Encoding: 0xA1C00000
    // Test aarch32_BIC_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rm=0, S=0, Rd=0, type1=0, imm5=0, cond=10
    let encoding: u32 = 0xA1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_11_condition_lt_0_b1c00000() {
    // Encoding: 0xB1C00000
    // Test aarch32_BIC_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, type1=0, S=0, Rm=0, Rd=0, imm5=0, cond=11
    let encoding: u32 = 0xB1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_12_condition_gt_0_c1c00000() {
    // Encoding: 0xC1C00000
    // Test aarch32_BIC_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, type1=0, cond=12, Rm=0, Rn=0
    let encoding: u32 = 0xC1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_13_condition_le_0_d1c00000() {
    // Encoding: 0xD1C00000
    // Test aarch32_BIC_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, Rn=0, type1=0, imm5=0, cond=13, Rd=0, Rm=0
    let encoding: u32 = 0xD1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_14_condition_al_0_e1c00000() {
    // Encoding: 0xE1C00000
    // Test aarch32_BIC_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, S=0, imm5=0, type1=0, Rm=0, cond=14, Rn=0
    let encoding: u32 = 0xE1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_bic_r_a1_a_special_cond_15_condition_nv_0_f1c00000() {
    // Encoding: 0xF1C00000
    // Test aarch32_BIC_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=15, type1=0, Rd=0, S=0, imm5=0
    let encoding: u32 = 0xF1C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_bic_r_a1_a_special_s_0_size_variant_0_0_01c00000() {
    // Encoding: 0x01C00000
    // Test aarch32_BIC_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, S=0, type1=0, Rn=0, Rm=0, Rd=0, imm5=0
    let encoding: u32 = 0x01C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_bic_r_a1_a_special_s_1_size_variant_1_0_01d00000() {
    // Encoding: 0x01D00000
    // Test aarch32_BIC_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, imm5=0, type1=0, Rm=0, Rn=0, cond=0, S=1
    let encoding: u32 = 0x01D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_t1_a_field_rm_0_min_0_43800000() {
    // Thumb encoding (32): 0x43800000
    // Test aarch32_BIC_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_t1_a_field_rm_1_poweroftwo_0_43880000() {
    // Thumb encoding (32): 0x43880000
    // Test aarch32_BIC_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43880000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bic_r_t1_a_field_rdn_0_min_0_43800000() {
    // Thumb encoding (32): 0x43800000
    // Test aarch32_BIC_r_T1_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bic_r_t1_a_field_rdn_1_poweroftwo_0_43810000() {
    // Thumb encoding (32): 0x43810000
    // Test aarch32_BIC_r_T1_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_bic_r_t1_a_field_rdn_7_max_0_43870000() {
    // Thumb encoding (32): 0x43870000
    // Test aarch32_BIC_r_T1_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: Rm=0, Rdn=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43870000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_bic_r_t1_a_combo_0_0_43800000() {
    // Thumb encoding (32): 0x43800000
    // Test aarch32_BIC_r_T1_A field combination: Rm=0, Rdn=0
    // ISET: T32
    // Fields: Rdn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_bic_r_t2_a_field_s_0_min_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rm=0, S=0, imm3=0, Rd=0, Rn=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_bic_r_t2_a_field_s_1_max_0_ea300000() {
    // Thumb encoding (32): 0xEA300000
    // Test aarch32_BIC_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: type1=0, Rm=0, Rn=0, imm3=0, Rd=0, S=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_t2_a_field_rn_0_min_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_t2_a_field_rn_1_poweroftwo_0_ea210000() {
    // Thumb encoding (32): 0xEA210000
    // Test aarch32_BIC_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, S=0, imm2=0, Rn=1, imm3=0, Rd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bic_r_t2_a_field_imm3_0_zero_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, type1=0, imm2=0, Rm=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bic_r_t2_a_field_imm3_1_poweroftwo_0_ea201000() {
    // Thumb encoding (32): 0xEA201000
    // Test aarch32_BIC_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, imm3=1, S=0, imm2=0, Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_bic_r_t2_a_field_imm3_3_poweroftwominusone_0_ea203000() {
    // Thumb encoding (32): 0xEA203000
    // Test aarch32_BIC_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rd=0, Rn=0, imm3=3, type1=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA203000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_bic_r_t2_a_field_imm3_7_max_0_ea207000() {
    // Thumb encoding (32): 0xEA207000
    // Test aarch32_BIC_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm2=0, imm3=7, type1=0, Rd=0, Rn=0, Rm=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA207000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_t2_a_field_rd_0_min_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rd=0, type1=0, imm3=0, imm2=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_t2_a_field_rd_1_poweroftwo_0_ea200100() {
    // Thumb encoding (32): 0xEA200100
    // Test aarch32_BIC_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, S=0, Rm=0, Rn=0, imm3=0, Rd=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bic_r_t2_a_field_imm2_0_zero_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, S=0, Rd=0, imm2=0, type1=0, Rm=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bic_r_t2_a_field_imm2_1_poweroftwo_0_ea200040() {
    // Thumb encoding (32): 0xEA200040
    // Test aarch32_BIC_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm2=1, type1=0, Rd=0, Rn=0, Rm=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_bic_r_t2_a_field_imm2_3_max_0_ea2000c0() {
    // Thumb encoding (32): 0xEA2000C0
    // Test aarch32_BIC_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: type1=0, imm3=0, Rm=0, S=0, Rd=0, imm2=3, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA2000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bic_r_t2_a_field_type1_0_min_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, imm3=0, imm2=0, type1=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bic_r_t2_a_field_type1_1_poweroftwo_0_ea200010() {
    // Thumb encoding (32): 0xEA200010
    // Test aarch32_BIC_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, S=0, imm3=0, Rd=0, Rn=0, type1=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_bic_r_t2_a_field_type1_3_max_0_ea200030() {
    // Thumb encoding (32): 0xEA200030
    // Test aarch32_BIC_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: Rd=0, S=0, imm3=0, Rn=0, imm2=0, type1=3, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_r_t2_a_field_rm_0_min_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, S=0, imm3=0, Rn=0, Rd=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_r_t2_a_field_rm_1_poweroftwo_0_ea200001() {
    // Thumb encoding (32): 0xEA200001
    // Test aarch32_BIC_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, imm3=0, S=0, Rm=1, Rn=0, imm2=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_bic_r_t2_a_combo_0_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, type1=0, Rm=0, imm3=0, Rn=0, imm2=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_bic_r_t2_a_special_s_0_size_variant_0_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, imm3=0, Rd=0, Rn=0, S=0, type1=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_bic_r_t2_a_special_s_1_size_variant_1_0_ea300000() {
    // Thumb encoding (32): 0xEA300000
    // Test aarch32_BIC_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, Rd=0, type1=0, imm3=0, imm2=0, S=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bic_r_t2_a_invalid_0_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: type1=0, Rm=0, Rn=0, imm3=0, Rd=0, imm2=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bic_r_t2_a_invalid_1_0_ea200000() {
    // Thumb encoding (32): 0xEA200000
    // Test aarch32_BIC_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, S=0, Rm=0, type1=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_zeroresult_0_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_zeroresult_1_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: ZeroResult
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_negativeresult_2_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: NegativeResult
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_unsignedoverflow_3_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_unsignedoverflow_4_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_signedoverflow_5_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_bic_r_a1_a_flags_signedoverflow_6_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_bic_r_a1_a_flags_positiveresult_7_01d10002() {
    // Test aarch32_BIC_r_A1_A flag computation: PositiveResult
    // Encoding: 0x01D10002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x01D10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_32_0_43820020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_64_0_c3820020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_32_1_43820020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_64_1_c3820020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_32_2_43820020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_64_2_c3820020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_32_3_43820020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_64_3_c3820020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_32_4_43820020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_64_4_c3820020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_32_5_43820020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_bic_r_t1_a_lslv_oracle_64_5_c3820020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_bic_r_t1_a_t16_oracle_0_43900000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_bic_r_t1_a_t16_oracle_1_43900000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_bic_r_t1_a_t16_oracle_2_43900000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_bic_r_t1_a_t16_oracle_3_43900000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_zeroresult_0_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_zeroresult_1_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_negativeresult_2_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_unsignedoverflow_3_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_unsignedoverflow_4_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_signedoverflow_5_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_bic_r_t1_a_flags_signedoverflow_6_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_bic_r_t1_a_flags_positiveresult_7_43900000() {
    // Test aarch32_BIC_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_zeroresult_0_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_zeroresult_1_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_negativeresult_2_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_unsignedoverflow_3_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_unsignedoverflow_4_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_signedoverflow_5_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_bic_r_t2_a_flags_signedoverflow_6_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_bic_r_t2_a_flags_positiveresult_7_ea310002() {
    // Test aarch32_BIC_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xEA310002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_ORR_i_A Tests
// ============================================================================

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_0_min_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, Rn=0, S=0, Rd=0, cond=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_1_poweroftwo_0_13800000() {
    // Encoding: 0x13800000
    // Test aarch32_ORR_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rn=0, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x13800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_2_poweroftwo_0_23800000() {
    // Encoding: 0x23800000
    // Test aarch32_ORR_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, cond=2, S=0, Rd=0
    let encoding: u32 = 0x23800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_3_poweroftwo_0_33800000() {
    // Encoding: 0x33800000
    // Test aarch32_ORR_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=3, imm12=0, Rd=0
    let encoding: u32 = 0x33800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_4_poweroftwo_0_43800000() {
    // Encoding: 0x43800000
    // Test aarch32_ORR_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=4, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x43800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_5_poweroftwo_0_53800000() {
    // Encoding: 0x53800000
    // Test aarch32_ORR_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, cond=5, Rd=0
    let encoding: u32 = 0x53800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_6_poweroftwo_0_63800000() {
    // Encoding: 0x63800000
    // Test aarch32_ORR_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, cond=6, imm12=0
    let encoding: u32 = 0x63800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_7_poweroftwo_0_73800000() {
    // Encoding: 0x73800000
    // Test aarch32_ORR_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rd=0, cond=7, S=0, Rn=0
    let encoding: u32 = 0x73800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_8_poweroftwo_0_83800000() {
    // Encoding: 0x83800000
    // Test aarch32_ORR_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=8, imm12=0
    let encoding: u32 = 0x83800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_9_poweroftwo_0_93800000() {
    // Encoding: 0x93800000
    // Test aarch32_ORR_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, imm12=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x93800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_10_poweroftwo_0_a3800000() {
    // Encoding: 0xA3800000
    // Test aarch32_ORR_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, cond=10, Rn=0
    let encoding: u32 = 0xA3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_11_poweroftwo_0_b3800000() {
    // Encoding: 0xB3800000
    // Test aarch32_ORR_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0xB3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_12_poweroftwo_0_c3800000() {
    // Encoding: 0xC3800000
    // Test aarch32_ORR_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, imm12=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0xC3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_13_poweroftwo_0_d3800000() {
    // Encoding: 0xD3800000
    // Test aarch32_ORR_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=13, Rn=0, Rd=0
    let encoding: u32 = 0xD3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_14_poweroftwo_0_e3800000() {
    // Encoding: 0xE3800000
    // Test aarch32_ORR_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, imm12=0, cond=14
    let encoding: u32 = 0xE3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_orr_i_a1_a_field_cond_15_max_0_f3800000() {
    // Encoding: 0xF3800000
    // Test aarch32_ORR_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, cond=15, imm12=0
    let encoding: u32 = 0xF3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_orr_i_a1_a_field_s_0_min_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, S=0, imm12=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_orr_i_a1_a_field_s_1_max_0_03900000() {
    // Encoding: 0x03900000
    // Test aarch32_ORR_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=0, Rd=0, S=1
    let encoding: u32 = 0x03900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_i_a1_a_field_rn_0_min_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_i_a1_a_field_rn_1_poweroftwo_0_03810000() {
    // Encoding: 0x03810000
    // Test aarch32_ORR_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=0, cond=0, Rn=1, Rd=0
    let encoding: u32 = 0x03810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_i_a1_a_field_rd_0_min_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_i_a1_a_field_rd_1_poweroftwo_0_03801000() {
    // Encoding: 0x03801000
    // Test aarch32_ORR_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=0, Rn=0, Rd=1
    let encoding: u32 = 0x03801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_0_zero_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_1_poweroftwo_0_03800001() {
    // Encoding: 0x03800001
    // Test aarch32_ORR_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, S=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x03800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_3_poweroftwominusone_0_03800003() {
    // Encoding: 0x03800003
    // Test aarch32_ORR_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, imm12=3, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x03800003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_4_poweroftwo_0_03800004() {
    // Encoding: 0x03800004
    // Test aarch32_ORR_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=4
    let encoding: u32 = 0x03800004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_7_poweroftwominusone_0_03800007() {
    // Encoding: 0x03800007
    // Test aarch32_ORR_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, Rn=0, imm12=7
    let encoding: u32 = 0x03800007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_8_poweroftwo_0_03800008() {
    // Encoding: 0x03800008
    // Test aarch32_ORR_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, Rd=0, imm12=8, Rn=0
    let encoding: u32 = 0x03800008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_15_poweroftwominusone_0_0380000f() {
    // Encoding: 0x0380000F
    // Test aarch32_ORR_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, Rn=0, imm12=15
    let encoding: u32 = 0x0380000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_16_poweroftwo_0_03800010() {
    // Encoding: 0x03800010
    // Test aarch32_ORR_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm12=16, cond=0
    let encoding: u32 = 0x03800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_31_poweroftwominusone_0_0380001f() {
    // Encoding: 0x0380001F
    // Test aarch32_ORR_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm12=31
    let encoding: u32 = 0x0380001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_32_poweroftwo_0_03800020() {
    // Encoding: 0x03800020
    // Test aarch32_ORR_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=32, cond=0, Rn=0, S=0
    let encoding: u32 = 0x03800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_63_poweroftwominusone_0_0380003f() {
    // Encoding: 0x0380003F
    // Test aarch32_ORR_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=63, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x0380003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_64_poweroftwo_0_03800040() {
    // Encoding: 0x03800040
    // Test aarch32_ORR_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rn=0, Rd=0, imm12=64
    let encoding: u32 = 0x03800040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_127_poweroftwominusone_0_0380007f() {
    // Encoding: 0x0380007F
    // Test aarch32_ORR_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=127, S=0, cond=0
    let encoding: u32 = 0x0380007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_128_poweroftwo_0_03800080() {
    // Encoding: 0x03800080
    // Test aarch32_ORR_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=128, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x03800080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_255_poweroftwominusone_0_038000ff() {
    // Encoding: 0x038000FF
    // Test aarch32_ORR_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=255, S=0, Rn=0, cond=0
    let encoding: u32 = 0x038000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_256_poweroftwo_0_03800100() {
    // Encoding: 0x03800100
    // Test aarch32_ORR_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rn=0, Rd=0, imm12=256
    let encoding: u32 = 0x03800100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_511_poweroftwominusone_0_038001ff() {
    // Encoding: 0x038001FF
    // Test aarch32_ORR_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=511, S=0, Rn=0
    let encoding: u32 = 0x038001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_512_poweroftwo_0_03800200() {
    // Encoding: 0x03800200
    // Test aarch32_ORR_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=512, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x03800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_1023_poweroftwominusone_0_038003ff() {
    // Encoding: 0x038003FF
    // Test aarch32_ORR_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=1023, S=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x038003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_1024_poweroftwo_0_03800400() {
    // Encoding: 0x03800400
    // Test aarch32_ORR_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm12=1024, cond=0, S=0
    let encoding: u32 = 0x03800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_2047_poweroftwominusone_0_038007ff() {
    // Encoding: 0x038007FF
    // Test aarch32_ORR_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, imm12=2047
    let encoding: u32 = 0x038007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_2048_poweroftwo_0_03800800() {
    // Encoding: 0x03800800
    // Test aarch32_ORR_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=2048
    let encoding: u32 = 0x03800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_orr_i_a1_a_field_imm12_4095_max_0_03800fff() {
    // Encoding: 0x03800FFF
    // Test aarch32_ORR_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=4095, Rn=0, S=0
    let encoding: u32 = 0x03800FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_orr_i_a1_a_combo_0_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: S=0, imm12=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_0_condition_eq_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_1_condition_ne_0_13800000() {
    // Encoding: 0x13800000
    // Test aarch32_ORR_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, imm12=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x13800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_2_condition_cs_hs_0_23800000() {
    // Encoding: 0x23800000
    // Test aarch32_ORR_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm12=0, cond=2, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x23800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_3_condition_cc_lo_0_33800000() {
    // Encoding: 0x33800000
    // Test aarch32_ORR_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=3, S=0, Rn=0
    let encoding: u32 = 0x33800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_4_condition_mi_0_43800000() {
    // Encoding: 0x43800000
    // Test aarch32_ORR_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=4, imm12=0, Rd=0
    let encoding: u32 = 0x43800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_5_condition_pl_0_53800000() {
    // Encoding: 0x53800000
    // Test aarch32_ORR_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, cond=5, Rn=0, S=0, imm12=0
    let encoding: u32 = 0x53800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_6_condition_vs_0_63800000() {
    // Encoding: 0x63800000
    // Test aarch32_ORR_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, S=0, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0x63800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_7_condition_vc_0_73800000() {
    // Encoding: 0x73800000
    // Test aarch32_ORR_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, imm12=0, Rn=0, cond=7, S=0
    let encoding: u32 = 0x73800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_8_condition_hi_0_83800000() {
    // Encoding: 0x83800000
    // Test aarch32_ORR_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=8, imm12=0, Rn=0
    let encoding: u32 = 0x83800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_9_condition_ls_0_93800000() {
    // Encoding: 0x93800000
    // Test aarch32_ORR_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, imm12=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x93800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_10_condition_ge_0_a3800000() {
    // Encoding: 0xA3800000
    // Test aarch32_ORR_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rd=0, S=0, imm12=0
    let encoding: u32 = 0xA3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_11_condition_lt_0_b3800000() {
    // Encoding: 0xB3800000
    // Test aarch32_ORR_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, imm12=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0xB3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_12_condition_gt_0_c3800000() {
    // Encoding: 0xC3800000
    // Test aarch32_ORR_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, imm12=0, S=0, Rn=0
    let encoding: u32 = 0xC3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_13_condition_le_0_d3800000() {
    // Encoding: 0xD3800000
    // Test aarch32_ORR_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0xD3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_14_condition_al_0_e3800000() {
    // Encoding: 0xE3800000
    // Test aarch32_ORR_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, S=0, imm12=0, Rn=0, Rd=0
    let encoding: u32 = 0xE3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_orr_i_a1_a_special_cond_15_condition_nv_0_f3800000() {
    // Encoding: 0xF3800000
    // Test aarch32_ORR_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: imm12=0, cond=15, S=0, Rd=0, Rn=0
    let encoding: u32 = 0xF3800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_orr_i_a1_a_special_s_0_size_variant_0_0_03800000() {
    // Encoding: 0x03800000
    // Test aarch32_ORR_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x03800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_orr_i_a1_a_special_s_1_size_variant_1_0_03900000() {
    // Encoding: 0x03900000
    // Test aarch32_ORR_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: imm12=0, Rn=0, S=1, cond=0, Rd=0
    let encoding: u32 = 0x03900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_orr_i_t1_a_field_i_0_min_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field i = 0 (Min)
    // ISET: T32
    // Fields: i=0, Rn=0, Rd=0, imm8=0, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_orr_i_t1_a_field_i_1_max_0_f4400000() {
    // Thumb encoding (32): 0xF4400000
    // Test aarch32_ORR_i_T1_A field i = 1 (Max)
    // ISET: T32
    // Fields: S=0, imm3=0, Rn=0, i=1, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF4400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_orr_i_t1_a_field_s_0_min_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, S=0, Rn=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_orr_i_t1_a_field_s_1_max_0_f0500000() {
    // Thumb encoding (32): 0xF0500000
    // Test aarch32_ORR_i_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: i=0, S=1, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_i_t1_a_field_rn_0_min_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, imm8=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_i_t1_a_field_rn_1_poweroftwo_0_f0410000() {
    // Thumb encoding (32): 0xF0410000
    // Test aarch32_ORR_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=0, S=0, imm3=0, i=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_orr_i_t1_a_field_imm3_0_zero_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, imm3=0, imm8=0, i=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_orr_i_t1_a_field_imm3_1_poweroftwo_0_f0401000() {
    // Thumb encoding (32): 0xF0401000
    // Test aarch32_ORR_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, i=0, imm3=1, Rd=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm3_3_poweroftwominusone_0_f0403000() {
    // Thumb encoding (32): 0xF0403000
    // Test aarch32_ORR_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rd=0, imm8=0, Rn=0, i=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0403000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm3_7_max_0_f0407000() {
    // Thumb encoding (32): 0xF0407000
    // Test aarch32_ORR_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rn=0, Rd=0, i=0, imm3=7, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0407000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_i_t1_a_field_rd_0_min_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, S=0, i=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_i_t1_a_field_rd_1_poweroftwo_0_f0400100() {
    // Thumb encoding (32): 0xF0400100
    // Test aarch32_ORR_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rd=1, Rn=0, S=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_0_zero_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, i=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_1_poweroftwo_0_f0400001() {
    // Thumb encoding (32): 0xF0400001
    // Test aarch32_ORR_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, imm8=1, Rn=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_3_poweroftwominusone_0_f0400003() {
    // Thumb encoding (32): 0xF0400003
    // Test aarch32_ORR_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0, imm8=3, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_4_poweroftwo_0_f0400004() {
    // Thumb encoding (32): 0xF0400004
    // Test aarch32_ORR_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, imm8=4, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_7_poweroftwominusone_0_f0400007() {
    // Thumb encoding (32): 0xF0400007
    // Test aarch32_ORR_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, imm3=0, S=0, Rd=0, imm8=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_8_poweroftwo_0_f0400008() {
    // Thumb encoding (32): 0xF0400008
    // Test aarch32_ORR_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, i=0, imm3=0, S=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_15_poweroftwominusone_0_f040000f() {
    // Thumb encoding (32): 0xF040000F
    // Test aarch32_ORR_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rd=0, imm8=15, imm3=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF040000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_16_poweroftwo_0_f0400010() {
    // Thumb encoding (32): 0xF0400010
    // Test aarch32_ORR_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=16, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_31_poweroftwominusone_0_f040001f() {
    // Thumb encoding (32): 0xF040001F
    // Test aarch32_ORR_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, imm8=31, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF040001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_32_poweroftwo_0_f0400020() {
    // Thumb encoding (32): 0xF0400020
    // Test aarch32_ORR_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm8=32, i=0, Rn=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_63_poweroftwominusone_0_f040003f() {
    // Thumb encoding (32): 0xF040003F
    // Test aarch32_ORR_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, Rd=0, imm8=63, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF040003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_64_poweroftwo_0_f0400040() {
    // Thumb encoding (32): 0xF0400040
    // Test aarch32_ORR_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, Rd=0, S=0, imm3=0, imm8=64
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_127_poweroftwominusone_0_f040007f() {
    // Thumb encoding (32): 0xF040007F
    // Test aarch32_ORR_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, i=0, Rn=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF040007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_128_poweroftwo_0_f0400080() {
    // Thumb encoding (32): 0xF0400080
    // Test aarch32_ORR_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, imm8=128, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_orr_i_t1_a_field_imm8_255_max_0_f04000ff() {
    // Thumb encoding (32): 0xF04000FF
    // Test aarch32_ORR_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: Rd=0, i=0, imm3=0, Rn=0, imm8=255, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF04000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_orr_i_t1_a_combo_0_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_orr_i_t1_a_special_s_0_size_variant_0_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: i=0, Rd=0, Rn=0, S=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_orr_i_t1_a_special_s_1_size_variant_1_0_f0500000() {
    // Thumb encoding (32): 0xF0500000
    // Test aarch32_ORR_i_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, Rd=0, S=1, imm8=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_orr_i_t1_a_invalid_0_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, imm3=0, Rn=0, imm8=0, S=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_orr_i_t1_a_invalid_1_0_f0400000() {
    // Thumb encoding (32): 0xF0400000
    // Test aarch32_ORR_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: S=0, imm3=0, imm8=0, Rd=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_64_0_b2401c20() {
    // Test ORR 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0xB2401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xB2401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_64_1_b2403c20() {
    // Test ORR 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0xB2403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xB2403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_64_2_b2407c20() {
    // Test ORR 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0xB2407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xB2407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_64_3_b2400020() {
    // Test ORR 64-bit: single bit mask (oracle)
    // Encoding: 0xB2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0xB2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xCAFEBABF,
        "X0 should be 0xDEADBEEFCAFEBABF"
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_64_4_b240f820() {
    // Test ORR 64-bit: all but MSB (oracle)
    // Encoding: 0xB240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xB240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_32_0_32001c20() {
    // Test ORR 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x32001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x32001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_32_1_32003c20() {
    // Test ORR 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x32003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x32003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_orr_i_a1_a_orr_oracle_32_2_32000020() {
    // Test ORR 32-bit: single bit mask (oracle)
    // Encoding: 0x32000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x32000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDEADBEEF, "W0 should be 0xDEADBEEF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_0_0_0381000a() {
    // Test A32 ORR: small immediate (oracle)
    // Encoding: 0x0381000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0381000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_0_ff_0381000a() {
    // Test A32 ORR: small immediate (oracle)
    // Encoding: 0x0381000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0381000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_0_aaaaaaaa_0381000a() {
    // Test A32 ORR: small immediate (oracle)
    // Encoding: 0x0381000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0381000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAAA, "R0 should be 0xAAAAAAAA");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_0_55555555_0381000a() {
    // Test A32 ORR: small immediate (oracle)
    // Encoding: 0x0381000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0381000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5555555F, "R0 should be 0x5555555F");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_0_ffffffff_0381000a() {
    // Test A32 ORR: small immediate (oracle)
    // Encoding: 0x0381000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0381000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_1_0_038100ff() {
    // Test A32 ORR: max imm8 (oracle)
    // Encoding: 0x038100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x038100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_1_ff_038100ff() {
    // Test A32 ORR: max imm8 (oracle)
    // Encoding: 0x038100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x038100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_1_aaaaaaaa_038100ff() {
    // Test A32 ORR: max imm8 (oracle)
    // Encoding: 0x038100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x038100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAFF, "R0 should be 0xAAAAAAFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_1_55555555_038100ff() {
    // Test A32 ORR: max imm8 (oracle)
    // Encoding: 0x038100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x038100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x555555FF, "R0 should be 0x555555FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_1_ffffffff_038100ff() {
    // Test A32 ORR: max imm8 (oracle)
    // Encoding: 0x038100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x038100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_2_0_03810180() {
    // Test A32 ORR: rotated by 2 (oracle)
    // Encoding: 0x03810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_2_ff_03810180() {
    // Test A32 ORR: rotated by 2 (oracle)
    // Encoding: 0x03810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x03810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_2_aaaaaaaa_03810180() {
    // Test A32 ORR: rotated by 2 (oracle)
    // Encoding: 0x03810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x03810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAAA, "R0 should be 0xAAAAAAAA");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_2_55555555_03810180() {
    // Test A32 ORR: rotated by 2 (oracle)
    // Encoding: 0x03810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x03810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555575, "R0 should be 0x55555575");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_2_ffffffff_03810180() {
    // Test A32 ORR: rotated by 2 (oracle)
    // Encoding: 0x03810180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x03810180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_3_0_0381040f() {
    // Test A32 ORR: rotated by 8 (oracle)
    // Encoding: 0x0381040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0381040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_3_ff_0381040f() {
    // Test A32 ORR: rotated by 8 (oracle)
    // Encoding: 0x0381040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0381040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0000FF, "R0 should be 0x0F0000FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_3_aaaaaaaa_0381040f() {
    // Test A32 ORR: rotated by 8 (oracle)
    // Encoding: 0x0381040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0381040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAFAAAAAA, "R0 should be 0xAFAAAAAA");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_3_55555555_0381040f() {
    // Test A32 ORR: rotated by 8 (oracle)
    // Encoding: 0x0381040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0381040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5F555555, "R0 should be 0x5F555555");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_3_ffffffff_0381040f() {
    // Test A32 ORR: rotated by 8 (oracle)
    // Encoding: 0x0381040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0381040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_4_0_03810000() {
    // Test A32 ORR: zero immediate (oracle)
    // Encoding: 0x03810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_4_ff_03810000() {
    // Test A32 ORR: zero immediate (oracle)
    // Encoding: 0x03810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x03810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_4_aaaaaaaa_03810000() {
    // Test A32 ORR: zero immediate (oracle)
    // Encoding: 0x03810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x03810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAAA, "R0 should be 0xAAAAAAAA");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_4_55555555_03810000() {
    // Test A32 ORR: zero immediate (oracle)
    // Encoding: 0x03810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x03810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555555, "R0 should be 0x55555555");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `ORR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_orr_i_a1_a_a32_logical_imm_4_ffffffff_03810000() {
    // Test A32 ORR: zero immediate (oracle)
    // Encoding: 0x03810000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x03810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_zeroresult_0_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: ZeroResult
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_zeroresult_1_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: ZeroResult
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_negativeresult_2_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: NegativeResult
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_unsignedoverflow_3_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_unsignedoverflow_4_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_signedoverflow_5_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_orr_i_a1_a_flags_signedoverflow_6_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_orr_i_a1_a_flags_positiveresult_7_03910000() {
    // Test aarch32_ORR_i_A1_A flag computation: PositiveResult
    // Encoding: 0x03910000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x03910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_64_0_b2401c20() {
    // Test ORR 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xB2401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_64_1_b2403c20() {
    // Test ORR 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xB2403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_64_2_b2407c20() {
    // Test ORR 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xB2407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_64_3_b2400020() {
    // Test ORR 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0xB2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xCAFEBABF,
        "X0 should be 0xDEADBEEFCAFEBABF"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_64_4_b240f820() {
    // Test ORR 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xB240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0xFFFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_32_0_32001c20() {
    // Test ORR 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x32001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_32_1_32003c20() {
    // Test ORR 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x32003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `ORR W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_orr_i_t1_a_orr_oracle_32_2_32000020() {
    // Test ORR 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x32000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDEADBEEF, "W0 should be 0xDEADBEEF");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_zeroresult_0_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_zeroresult_1_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_negativeresult_2_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_unsignedoverflow_3_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_unsignedoverflow_4_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_signedoverflow_5_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_orr_i_t1_a_flags_signedoverflow_6_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_orr_i_t1_a_flags_positiveresult_7_f0510000() {
    // Test aarch32_ORR_i_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF0510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_AND_rr_A Tests
// ============================================================================

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, S=0, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_1_poweroftwo_10_10000010() {
    // Encoding: 0x10000010
    // Test aarch32_AND_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rn=0, cond=1, Rd=0, Rs=0
    let encoding: u32 = 0x10000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_2_poweroftwo_10_20000010() {
    // Encoding: 0x20000010
    // Test aarch32_AND_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rm=0, cond=2, Rd=0, type1=0, S=0, Rn=0
    let encoding: u32 = 0x20000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_3_poweroftwo_10_30000010() {
    // Encoding: 0x30000010
    // Test aarch32_AND_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rs=0, S=0, cond=3, type1=0, Rm=0
    let encoding: u32 = 0x30000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_4_poweroftwo_10_40000010() {
    // Encoding: 0x40000010
    // Test aarch32_AND_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, S=0, cond=4, Rn=0, Rd=0
    let encoding: u32 = 0x40000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_5_poweroftwo_10_50000010() {
    // Encoding: 0x50000010
    // Test aarch32_AND_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=5, type1=0, Rs=0, S=0
    let encoding: u32 = 0x50000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_6_poweroftwo_10_60000010() {
    // Encoding: 0x60000010
    // Test aarch32_AND_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=6, Rd=0, Rn=0, S=0, Rs=0, Rm=0
    let encoding: u32 = 0x60000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_7_poweroftwo_10_70000010() {
    // Encoding: 0x70000010
    // Test aarch32_AND_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, Rs=0, type1=0, S=0, cond=7
    let encoding: u32 = 0x70000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_8_poweroftwo_10_80000010() {
    // Encoding: 0x80000010
    // Test aarch32_AND_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rn=0, Rs=0, Rm=0, cond=8, S=0
    let encoding: u32 = 0x80000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_9_poweroftwo_10_90000010() {
    // Encoding: 0x90000010
    // Test aarch32_AND_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rs=0, Rd=0, Rm=0, type1=0, Rn=0, S=0
    let encoding: u32 = 0x90000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_10_poweroftwo_10_a0000010() {
    // Encoding: 0xA0000010
    // Test aarch32_AND_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=0, Rn=0, cond=10, type1=0, Rm=0, S=0
    let encoding: u32 = 0xA0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_11_poweroftwo_10_b0000010() {
    // Encoding: 0xB0000010
    // Test aarch32_AND_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, cond=11, Rm=0, Rn=0, Rs=0, S=0
    let encoding: u32 = 0xB0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_12_poweroftwo_10_c0000010() {
    // Encoding: 0xC0000010
    // Test aarch32_AND_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rd=0, cond=12, type1=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0xC0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_13_poweroftwo_10_d0000010() {
    // Encoding: 0xD0000010
    // Test aarch32_AND_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=13, Rn=0, type1=0, S=0, Rd=0, Rs=0
    let encoding: u32 = 0xD0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_14_poweroftwo_10_e0000010() {
    // Encoding: 0xE0000010
    // Test aarch32_AND_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=14, type1=0, Rm=0, Rs=0
    let encoding: u32 = 0xE0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_and_rr_a1_a_field_cond_15_max_10_f0000010() {
    // Encoding: 0xF0000010
    // Test aarch32_AND_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, S=0, type1=0, Rd=0, Rn=0, Rm=0, Rs=0
    let encoding: u32 = 0xF0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_and_rr_a1_a_field_s_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rs=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_and_rr_a1_a_field_s_1_max_10_00100010() {
    // Encoding: 0x00100010
    // Test aarch32_AND_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, Rn=0, type1=0, Rm=0, cond=0, Rd=0, Rs=0
    let encoding: u32 = 0x00100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rn_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: type1=0, cond=0, Rn=0, Rm=0, Rs=0, S=0, Rd=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rn_1_poweroftwo_10_00010010() {
    // Encoding: 0x00010010
    // Test aarch32_AND_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rn=1, cond=0, S=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00010010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rd_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, S=0, Rn=0, type1=0, Rs=0, Rd=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rd_1_poweroftwo_10_00001010() {
    // Encoding: 0x00001010
    // Test aarch32_AND_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, Rm=0, S=0, Rn=0, cond=0, Rs=0, type1=0
    let encoding: u32 = 0x00001010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rs_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: S=0, type1=0, Rd=0, cond=0, Rm=0, Rn=0, Rs=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rs_1_poweroftwo_10_00000110() {
    // Encoding: 0x00000110
    // Test aarch32_AND_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=1, cond=0, type1=0, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x00000110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_and_rr_a1_a_field_type1_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=0, Rn=0, type1=0, Rd=0, Rs=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_and_rr_a1_a_field_type1_1_poweroftwo_10_00000030() {
    // Encoding: 0x00000030
    // Test aarch32_AND_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=1, S=0, Rm=0, Rd=0, cond=0, Rs=0, Rn=0
    let encoding: u32 = 0x00000030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_and_rr_a1_a_field_type1_3_max_10_00000070() {
    // Encoding: 0x00000070
    // Test aarch32_AND_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rs=0, Rm=0, cond=0, S=0, Rn=0, Rd=0, type1=3
    let encoding: u32 = 0x00000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rm_0_min_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, type1=0, S=0, Rn=0, Rm=0, Rs=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_rr_a1_a_field_rm_1_poweroftwo_10_00000011() {
    // Encoding: 0x00000011
    // Test aarch32_AND_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rd=0, Rn=0, cond=0, S=0, Rs=0, type1=0
    let encoding: u32 = 0x00000011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_and_rr_a1_a_combo_0_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: type1=0, S=0, Rd=0, Rm=0, cond=0, Rn=0, Rs=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_0_condition_eq_16_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, type1=0, Rs=0, Rm=0, Rd=0, S=0, Rn=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_1_condition_ne_16_10000010() {
    // Encoding: 0x10000010
    // Test aarch32_AND_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, S=0, cond=1, Rd=0, Rs=0
    let encoding: u32 = 0x10000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_2_condition_cs_hs_16_20000010() {
    // Encoding: 0x20000010
    // Test aarch32_AND_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, Rm=0, cond=2, Rs=0, type1=0
    let encoding: u32 = 0x20000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_3_condition_cc_lo_16_30000010() {
    // Encoding: 0x30000010
    // Test aarch32_AND_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: S=0, Rd=0, Rs=0, cond=3, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0x30000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_4_condition_mi_16_40000010() {
    // Encoding: 0x40000010
    // Test aarch32_AND_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rd=0, type1=0, Rn=0, Rm=0, Rs=0, S=0
    let encoding: u32 = 0x40000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_5_condition_pl_16_50000010() {
    // Encoding: 0x50000010
    // Test aarch32_AND_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, Rs=0, cond=5, type1=0, Rm=0
    let encoding: u32 = 0x50000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_6_condition_vs_16_60000010() {
    // Encoding: 0x60000010
    // Test aarch32_AND_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: type1=0, S=0, Rd=0, Rm=0, Rn=0, cond=6, Rs=0
    let encoding: u32 = 0x60000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_7_condition_vc_16_70000010() {
    // Encoding: 0x70000010
    // Test aarch32_AND_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rd=0, S=0, type1=0, Rn=0, Rs=0, Rm=0
    let encoding: u32 = 0x70000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_8_condition_hi_16_80000010() {
    // Encoding: 0x80000010
    // Test aarch32_AND_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, Rn=0, cond=8, Rd=0, S=0
    let encoding: u32 = 0x80000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_9_condition_ls_16_90000010() {
    // Encoding: 0x90000010
    // Test aarch32_AND_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rm=0, Rd=0, Rs=0, type1=0, S=0, Rn=0
    let encoding: u32 = 0x90000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_10_condition_ge_16_a0000010() {
    // Encoding: 0xA0000010
    // Test aarch32_AND_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, Rs=0, type1=0, Rm=0, Rd=0, Rn=0, cond=10
    let encoding: u32 = 0xA0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_11_condition_lt_16_b0000010() {
    // Encoding: 0xB0000010
    // Test aarch32_AND_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=11, S=0, Rs=0, Rd=0, type1=0
    let encoding: u32 = 0xB0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_12_condition_gt_16_c0000010() {
    // Encoding: 0xC0000010
    // Test aarch32_AND_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, S=0, Rd=0, Rs=0, Rm=0, type1=0
    let encoding: u32 = 0xC0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_13_condition_le_16_d0000010() {
    // Encoding: 0xD0000010
    // Test aarch32_AND_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rn=0, Rs=0, cond=13, S=0, Rm=0
    let encoding: u32 = 0xD0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_14_condition_al_16_e0000010() {
    // Encoding: 0xE0000010
    // Test aarch32_AND_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rs=0, S=0, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0xE0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_and_rr_a1_a_special_cond_15_condition_nv_16_f0000010() {
    // Encoding: 0xF0000010
    // Test aarch32_AND_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rs=0, cond=15, S=0, Rn=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0xF0000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_and_rr_a1_a_special_s_0_size_variant_0_16_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rd=0, Rs=0, type1=0, S=0, Rn=0, cond=0, Rm=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_and_rr_a1_a_special_s_1_size_variant_1_16_00100010() {
    // Encoding: 0x00100010
    // Test aarch32_AND_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, Rs=0, type1=0, Rn=0, cond=0, Rm=0, Rd=0
    let encoding: u32 = 0x00100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_and_rr_a1_a_invalid_0_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: S=0, cond=0, Rn=0, type1=0, Rm=0, Rd=0, Rs=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_and_rr_a1_a_invalid_1_10_00000010() {
    // Encoding: 0x00000010
    // Test aarch32_AND_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, cond=0, Rn=0, Rs=0, S=0
    let encoding: u32 = 0x00000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_32_0_00020030() {
    // Test AND shifted 32-bit: no shift (oracle)
    // Encoding: 0x00020030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00020030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_64_0_80020030() {
    // Test AND shifted 64-bit: no shift (oracle)
    // Encoding: 0x80020030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF);
    let encoding: u32 = 0x80020030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #8 (32)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_32_1_00022030() {
    // Test AND shifted 32-bit: LSL #8 (oracle)
    // Encoding: 0x00022030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00022030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x100, "W0 should be 0x00000100");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #8 (64)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_64_1_80022030() {
    // Test AND shifted 64-bit: LSL #8 (oracle)
    // Encoding: 0x80022030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x80022030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x100, "X0 should be 0x0000000000000100");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSR #8 (32)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_32_2_00422030() {
    // Test AND shifted 32-bit: LSR #8 (oracle)
    // Encoding: 0x00422030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x00422030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0000, "W0 should be 0x00FF0000");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSR #8 (64)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_64_2_80422030() {
    // Test AND shifted 64-bit: LSR #8 (oracle)
    // Encoding: 0x80422030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x80422030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0000, "X0 should be 0x0000000000FF0000");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ASR #4 negative (32)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_32_3_00821030() {
    // Test AND shifted 32-bit: ASR #4 negative (oracle)
    // Encoding: 0x00821030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x00821030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ASR #4 negative (64)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_64_3_80821030() {
    // Test AND shifted 64-bit: ASR #4 negative (oracle)
    // Encoding: 0x80821030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x80821030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ROR #4 (32)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_32_4_00c21030() {
    // Test AND shifted 32-bit: ROR #4 (oracle)
    // Encoding: 0x00C21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00C21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345670, "W0 should be 0x12345670");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ROR #4 (64)
#[test]
fn test_aarch32_and_rr_a1_a_and_shifted_oracle_64_4_80c21030() {
    // Test AND shifted 64-bit: ROR #4 (oracle)
    // Encoding: 0x80C21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x80C21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2345670, "X0 should be 0x0000000002345670");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_and_rr_a1_a_a32_logical_reg_0_00010002() {
    // Test A32 AND: simple values (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_and_rr_a1_a_a32_logical_reg_1_00010002() {
    // Test A32 AND: zero values (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_and_rr_a1_a_a32_logical_reg_2_00010002() {
    // Test A32 AND: max value (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "R0 should be 0x00000001");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_and_rr_a1_a_a32_logical_reg_3_00010002() {
    // Test A32 AND: MSB set (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_and_rr_a1_a_a32_logical_reg_4_00010002() {
    // Test A32 AND: mixed pattern (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345670, "R0 should be 0x12345670");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_zeroresult_0_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_zeroresult_1_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_negativeresult_2_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_unsignedoverflow_3_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_unsignedoverflow_4_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_signedoverflow_5_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_and_rr_a1_a_flags_signedoverflow_6_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_and_rr_a1_a_flags_positiveresult_7_00110012() {
    // Test aarch32_AND_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00110012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00110012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_BIC_rr_A Tests
// ============================================================================

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rs=0, Rm=0, S=0, Rd=0, type1=0, Rn=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_1_poweroftwo_10_11c00010() {
    // Encoding: 0x11C00010
    // Test aarch32_BIC_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=0, Rn=0, cond=1, Rm=0, type1=0, S=0
    let encoding: u32 = 0x11C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_2_poweroftwo_10_21c00010() {
    // Encoding: 0x21C00010
    // Test aarch32_BIC_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, S=0, cond=2, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0x21C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_3_poweroftwo_10_31c00010() {
    // Encoding: 0x31C00010
    // Test aarch32_BIC_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=3, Rs=0, type1=0, Rn=0, S=0
    let encoding: u32 = 0x31C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_4_poweroftwo_10_41c00010() {
    // Encoding: 0x41C00010
    // Test aarch32_BIC_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rs=0, S=0, type1=0, Rm=0, Rn=0, cond=4
    let encoding: u32 = 0x41C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_5_poweroftwo_10_51c00010() {
    // Encoding: 0x51C00010
    // Test aarch32_BIC_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, Rs=0, S=0, cond=5, Rd=0
    let encoding: u32 = 0x51C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_6_poweroftwo_10_61c00010() {
    // Encoding: 0x61C00010
    // Test aarch32_BIC_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, type1=0, Rs=0, Rd=0, cond=6
    let encoding: u32 = 0x61C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_7_poweroftwo_10_71c00010() {
    // Encoding: 0x71C00010
    // Test aarch32_BIC_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x71C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_8_poweroftwo_10_81c00010() {
    // Encoding: 0x81C00010
    // Test aarch32_BIC_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rs=0, Rn=0, Rm=0, Rd=0, S=0, type1=0
    let encoding: u32 = 0x81C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_9_poweroftwo_10_91c00010() {
    // Encoding: 0x91C00010
    // Test aarch32_BIC_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, cond=9, Rm=0, Rs=0, Rn=0, S=0
    let encoding: u32 = 0x91C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_10_poweroftwo_10_a1c00010() {
    // Encoding: 0xA1C00010
    // Test aarch32_BIC_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rs=0, type1=0, Rn=0, Rm=0, cond=10
    let encoding: u32 = 0xA1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_11_poweroftwo_10_b1c00010() {
    // Encoding: 0xB1C00010
    // Test aarch32_BIC_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, cond=11, Rn=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0xB1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_12_poweroftwo_10_c1c00010() {
    // Encoding: 0xC1C00010
    // Test aarch32_BIC_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, cond=12, Rn=0, Rd=0, Rs=0, S=0
    let encoding: u32 = 0xC1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_13_poweroftwo_10_d1c00010() {
    // Encoding: 0xD1C00010
    // Test aarch32_BIC_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, Rm=0, S=0, cond=13, Rn=0, Rd=0, type1=0
    let encoding: u32 = 0xD1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_14_poweroftwo_10_e1c00010() {
    // Encoding: 0xE1C00010
    // Test aarch32_BIC_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, type1=0, cond=14, Rm=0, Rd=0, S=0, Rs=0
    let encoding: u32 = 0xE1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_bic_rr_a1_a_field_cond_15_max_10_f1c00010() {
    // Encoding: 0xF1C00010
    // Test aarch32_BIC_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, type1=0, S=0, Rd=0, Rs=0, Rm=0, Rn=0
    let encoding: u32 = 0xF1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_bic_rr_a1_a_field_s_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, S=0, type1=0, Rn=0, Rs=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_bic_rr_a1_a_field_s_1_max_10_01d00010() {
    // Encoding: 0x01D00010
    // Test aarch32_BIC_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, cond=0, Rd=0, type1=0, Rs=0, Rn=0, Rm=0
    let encoding: u32 = 0x01D00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rn_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, Rm=0, Rs=0, Rn=0, type1=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rn_1_poweroftwo_10_01c10010() {
    // Encoding: 0x01C10010
    // Test aarch32_BIC_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=1, Rd=0, Rs=0, S=0, type1=0
    let encoding: u32 = 0x01C10010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rd_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, Rn=0, S=0, Rs=0, type1=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rd_1_poweroftwo_10_01c01010() {
    // Encoding: 0x01C01010
    // Test aarch32_BIC_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=0, S=0, Rm=0, Rn=0, cond=0, Rd=1
    let encoding: u32 = 0x01C01010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rs_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rs=0, Rm=0, type1=0, S=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rs_1_poweroftwo_10_01c00110() {
    // Encoding: 0x01C00110
    // Test aarch32_BIC_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, type1=0, S=0, Rn=0, cond=0, Rd=0, Rs=1
    let encoding: u32 = 0x01C00110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bic_rr_a1_a_field_type1_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, S=0, type1=0, cond=0, Rs=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_bic_rr_a1_a_field_type1_1_poweroftwo_10_01c00030() {
    // Encoding: 0x01C00030
    // Test aarch32_BIC_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=1, S=0, Rn=0, Rm=0, cond=0, Rd=0, Rs=0
    let encoding: u32 = 0x01C00030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_bic_rr_a1_a_field_type1_3_max_10_01c00070() {
    // Encoding: 0x01C00070
    // Test aarch32_BIC_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rs=0, type1=3, Rm=0, Rn=0, Rd=0, S=0, cond=0
    let encoding: u32 = 0x01C00070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rm_0_min_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, S=0, cond=0, Rs=0, type1=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_rr_a1_a_field_rm_1_poweroftwo_10_01c00011() {
    // Encoding: 0x01C00011
    // Test aarch32_BIC_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, type1=0, Rm=1, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x01C00011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_bic_rr_a1_a_combo_0_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, cond=0, Rs=0, Rd=0, type1=0, S=0, Rm=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_0_condition_eq_16_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_1_condition_ne_16_11c00010() {
    // Encoding: 0x11C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rs=0, cond=1, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x11C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_2_condition_cs_hs_16_21c00010() {
    // Encoding: 0x21C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, S=0, Rn=0, type1=0, Rd=0, Rs=0, Rm=0
    let encoding: u32 = 0x21C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_3_condition_cc_lo_16_31c00010() {
    // Encoding: 0x31C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, cond=3, Rn=0, Rd=0, Rs=0, Rm=0, S=0
    let encoding: u32 = 0x31C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_4_condition_mi_16_41c00010() {
    // Encoding: 0x41C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: type1=0, S=0, Rd=0, Rn=0, Rm=0, Rs=0, cond=4
    let encoding: u32 = 0x41C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_5_condition_pl_16_51c00010() {
    // Encoding: 0x51C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, type1=0, Rm=0, Rs=0, cond=5
    let encoding: u32 = 0x51C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_6_condition_vs_16_61c00010() {
    // Encoding: 0x61C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, Rs=0, cond=6, Rn=0, type1=0
    let encoding: u32 = 0x61C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_7_condition_vc_16_71c00010() {
    // Encoding: 0x71C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rs=0, S=0, cond=7, type1=0, Rn=0
    let encoding: u32 = 0x71C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_8_condition_hi_16_81c00010() {
    // Encoding: 0x81C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, Rs=0, type1=0, S=0, Rn=0, cond=8, Rd=0
    let encoding: u32 = 0x81C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_9_condition_ls_16_91c00010() {
    // Encoding: 0x91C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, cond=9, Rd=0, Rs=0, type1=0
    let encoding: u32 = 0x91C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_10_condition_ge_16_a1c00010() {
    // Encoding: 0xA1C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rs=0, S=0, type1=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xA1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_11_condition_lt_16_b1c00010() {
    // Encoding: 0xB1C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rs=0, Rn=0, cond=11, Rd=0
    let encoding: u32 = 0xB1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_12_condition_gt_16_c1c00010() {
    // Encoding: 0xC1C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, Rs=0, type1=0, cond=12, Rm=0
    let encoding: u32 = 0xC1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_13_condition_le_16_d1c00010() {
    // Encoding: 0xD1C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rn=0, Rm=0, Rd=0, cond=13, S=0
    let encoding: u32 = 0xD1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_14_condition_al_16_e1c00010() {
    // Encoding: 0xE1C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rs=0, Rd=0, type1=0, S=0, Rm=0, Rn=0, cond=14
    let encoding: u32 = 0xE1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_bic_rr_a1_a_special_cond_15_condition_nv_16_f1c00010() {
    // Encoding: 0xF1C00010
    // Test aarch32_BIC_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, Rs=0, type1=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0xF1C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_bic_rr_a1_a_special_s_0_size_variant_0_16_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_bic_rr_a1_a_special_s_1_size_variant_1_16_01d00010() {
    // Encoding: 0x01D00010
    // Test aarch32_BIC_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rs=0, type1=0, cond=0, Rd=0, Rm=0, S=1, Rn=0
    let encoding: u32 = 0x01D00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bic_rr_a1_a_invalid_0_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rs=0, Rn=0, S=0, Rd=0, Rm=0, cond=0, type1=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bic_rr_a1_a_invalid_1_10_01c00010() {
    // Encoding: 0x01C00010
    // Test aarch32_BIC_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: type1=0, Rn=0, Rs=0, Rm=0, Rd=0, S=0, cond=0
    let encoding: u32 = 0x01C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_zeroresult_0_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_zeroresult_1_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_negativeresult_2_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_unsignedoverflow_3_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_unsignedoverflow_4_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_signedoverflow_5_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_signedoverflow_6_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_bic_rr_a1_a_flags_positiveresult_7_01d10012() {
    // Test aarch32_BIC_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x01D10012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x01D10012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_ORR_rr_A Tests
// ============================================================================

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=0, type1=0, Rn=0, Rd=0, Rs=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_1_poweroftwo_10_11800010() {
    // Encoding: 0x11800010
    // Test aarch32_ORR_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=1, S=0, Rs=0, type1=0, Rd=0
    let encoding: u32 = 0x11800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_2_poweroftwo_10_21800010() {
    // Encoding: 0x21800010
    // Test aarch32_ORR_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rd=0, S=0, Rm=0, type1=0, Rs=0, Rn=0
    let encoding: u32 = 0x21800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_3_poweroftwo_10_31800010() {
    // Encoding: 0x31800010
    // Test aarch32_ORR_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, Rs=0, Rd=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x31800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_4_poweroftwo_10_41800010() {
    // Encoding: 0x41800010
    // Test aarch32_ORR_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rm=0, S=0, Rd=0, Rn=0, Rs=0, type1=0
    let encoding: u32 = 0x41800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_5_poweroftwo_10_51800010() {
    // Encoding: 0x51800010
    // Test aarch32_ORR_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rd=0, Rs=0, S=0, type1=0, Rn=0, Rm=0
    let encoding: u32 = 0x51800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_6_poweroftwo_10_61800010() {
    // Encoding: 0x61800010
    // Test aarch32_ORR_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, type1=0, Rm=0, S=0, Rd=0, Rs=0
    let encoding: u32 = 0x61800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_7_poweroftwo_10_71800010() {
    // Encoding: 0x71800010
    // Test aarch32_ORR_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rn=0, Rd=0, S=0, Rs=0, cond=7
    let encoding: u32 = 0x71800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_8_poweroftwo_10_81800010() {
    // Encoding: 0x81800010
    // Test aarch32_ORR_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, cond=8, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x81800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_9_poweroftwo_10_91800010() {
    // Encoding: 0x91800010
    // Test aarch32_ORR_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rs=0, S=0, type1=0, cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x91800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_10_poweroftwo_10_a1800010() {
    // Encoding: 0xA1800010
    // Test aarch32_ORR_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, S=0, Rn=0, cond=10, Rd=0
    let encoding: u32 = 0xA1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_11_poweroftwo_10_b1800010() {
    // Encoding: 0xB1800010
    // Test aarch32_ORR_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rn=0, Rs=0, Rm=0, type1=0, S=0
    let encoding: u32 = 0xB1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_12_poweroftwo_10_c1800010() {
    // Encoding: 0xC1800010
    // Test aarch32_ORR_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, S=0, cond=12, Rd=0, Rn=0
    let encoding: u32 = 0xC1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_13_poweroftwo_10_d1800010() {
    // Encoding: 0xD1800010
    // Test aarch32_ORR_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=13, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0xD1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_14_poweroftwo_10_e1800010() {
    // Encoding: 0xE1800010
    // Test aarch32_ORR_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, Rs=0, type1=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0xE1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_orr_rr_a1_a_field_cond_15_max_10_f1800010() {
    // Encoding: 0xF1800010
    // Test aarch32_ORR_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, Rs=0, cond=15, Rn=0, S=0, Rd=0, type1=0
    let encoding: u32 = 0xF1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_orr_rr_a1_a_field_s_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, type1=0, Rd=0, S=0, Rn=0, Rs=0, cond=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_orr_rr_a1_a_field_s_1_max_10_01900010() {
    // Encoding: 0x01900010
    // Test aarch32_ORR_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, S=1, Rn=0, Rs=0, Rd=0, Rm=0, type1=0
    let encoding: u32 = 0x01900010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rn_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rs=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rn_1_poweroftwo_10_01810010() {
    // Encoding: 0x01810010
    // Test aarch32_ORR_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, type1=0, Rs=0, Rm=0, S=0, Rn=1
    let encoding: u32 = 0x01810010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rd_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, S=0, Rs=0, Rm=0, Rd=0, cond=0, type1=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rd_1_poweroftwo_10_01801010() {
    // Encoding: 0x01801010
    // Test aarch32_ORR_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=1, Rs=0, Rm=0, type1=0, cond=0, Rn=0
    let encoding: u32 = 0x01801010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rs_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: Rs=0, cond=0, S=0, type1=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rs_1_poweroftwo_10_01800110() {
    // Encoding: 0x01800110
    // Test aarch32_ORR_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rs=1, Rm=0, type1=0, S=0
    let encoding: u32 = 0x01800110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_orr_rr_a1_a_field_type1_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rs=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_orr_rr_a1_a_field_type1_1_poweroftwo_10_01800030() {
    // Encoding: 0x01800030
    // Test aarch32_ORR_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rs=0, Rn=0, Rd=0, type1=1, Rm=0, S=0
    let encoding: u32 = 0x01800030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_orr_rr_a1_a_field_type1_3_max_10_01800070() {
    // Encoding: 0x01800070
    // Test aarch32_ORR_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, S=0, Rd=0, type1=3, Rs=0
    let encoding: u32 = 0x01800070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rm_0_min_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rs=0, Rm=0, S=0, Rn=0, type1=0, Rd=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_rr_a1_a_field_rm_1_poweroftwo_10_01800011() {
    // Encoding: 0x01800011
    // Test aarch32_ORR_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=1, type1=0, S=0, Rd=0, cond=0, Rs=0
    let encoding: u32 = 0x01800011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_orr_rr_a1_a_combo_0_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, type1=0, Rs=0, Rm=0, cond=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_0_condition_eq_16_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, Rn=0, Rm=0, Rs=0, type1=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_1_condition_ne_16_11800010() {
    // Encoding: 0x11800010
    // Test aarch32_ORR_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, type1=0, Rn=0, Rm=0, S=0, cond=1, Rs=0
    let encoding: u32 = 0x11800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_2_condition_cs_hs_16_21800010() {
    // Encoding: 0x21800010
    // Test aarch32_ORR_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, cond=2, S=0, Rd=0, Rs=0, Rn=0, type1=0
    let encoding: u32 = 0x21800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_3_condition_cc_lo_16_31800010() {
    // Encoding: 0x31800010
    // Test aarch32_ORR_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, type1=0, Rs=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x31800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_4_condition_mi_16_41800010() {
    // Encoding: 0x41800010
    // Test aarch32_ORR_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: type1=0, Rm=0, S=0, Rs=0, Rn=0, cond=4, Rd=0
    let encoding: u32 = 0x41800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_5_condition_pl_16_51800010() {
    // Encoding: 0x51800010
    // Test aarch32_ORR_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rs=0, type1=0, cond=5, S=0, Rn=0
    let encoding: u32 = 0x51800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_6_condition_vs_16_61800010() {
    // Encoding: 0x61800010
    // Test aarch32_ORR_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rs=0, Rn=0, type1=0, cond=6, S=0
    let encoding: u32 = 0x61800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_7_condition_vc_16_71800010() {
    // Encoding: 0x71800010
    // Test aarch32_ORR_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rd=0, type1=0, Rs=0, Rm=0, S=0
    let encoding: u32 = 0x71800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_8_condition_hi_16_81800010() {
    // Encoding: 0x81800010
    // Test aarch32_ORR_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rn=0, Rm=0, Rd=0, cond=8, Rs=0, type1=0
    let encoding: u32 = 0x81800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_9_condition_ls_16_91800010() {
    // Encoding: 0x91800010
    // Test aarch32_ORR_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rs=0, Rm=0, Rn=0, type1=0, Rd=0, cond=9, S=0
    let encoding: u32 = 0x91800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_10_condition_ge_16_a1800010() {
    // Encoding: 0xA1800010
    // Test aarch32_ORR_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: type1=0, Rs=0, Rd=0, Rn=0, cond=10, Rm=0, S=0
    let encoding: u32 = 0xA1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_11_condition_lt_16_b1800010() {
    // Encoding: 0xB1800010
    // Test aarch32_ORR_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rm=0, S=0, type1=0, Rs=0, Rn=0, Rd=0
    let encoding: u32 = 0xB1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_12_condition_gt_16_c1800010() {
    // Encoding: 0xC1800010
    // Test aarch32_ORR_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Rs=0, S=0, Rn=0, type1=0, Rm=0, cond=12
    let encoding: u32 = 0xC1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_13_condition_le_16_d1800010() {
    // Encoding: 0xD1800010
    // Test aarch32_ORR_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, cond=13, Rn=0, Rs=0, Rd=0, type1=0, Rm=0
    let encoding: u32 = 0xD1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_14_condition_al_16_e1800010() {
    // Encoding: 0xE1800010
    // Test aarch32_ORR_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, type1=0, Rm=0, S=0, Rs=0, Rn=0
    let encoding: u32 = 0xE1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_orr_rr_a1_a_special_cond_15_condition_nv_16_f1800010() {
    // Encoding: 0xF1800010
    // Test aarch32_ORR_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: S=0, type1=0, Rm=0, cond=15, Rn=0, Rs=0, Rd=0
    let encoding: u32 = 0xF1800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_orr_rr_a1_a_special_s_0_size_variant_0_16_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, type1=0, Rs=0, Rm=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_orr_rr_a1_a_special_s_1_size_variant_1_16_01900010() {
    // Encoding: 0x01900010
    // Test aarch32_ORR_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, Rs=0, cond=0, S=1, Rn=0, Rm=0, type1=0
    let encoding: u32 = 0x01900010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_orr_rr_a1_a_invalid_0_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rs=0, Rm=0, cond=0, S=0, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_orr_rr_a1_a_invalid_1_10_01800010() {
    // Encoding: 0x01800010
    // Test aarch32_ORR_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rs=0, cond=0, Rd=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x01800010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_32_0_01820030() {
    // Test ORR shifted 32-bit: no shift (oracle)
    // Encoding: 0x01820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF);
    let encoding: u32 = 0x01820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_64_0_81820030() {
    // Test ORR shifted 64-bit: no shift (oracle)
    // Encoding: 0x81820030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x81820030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #8 (32)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_32_1_01822030() {
    // Test ORR shifted 32-bit: LSL #8 (oracle)
    // Encoding: 0x01822030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01822030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #8 (64)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_64_1_81822030() {
    // Test ORR shifted 64-bit: LSL #8 (oracle)
    // Encoding: 0x81822030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x81822030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSR #8 (32)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_32_2_01c22030() {
    // Test ORR shifted 32-bit: LSR #8 (oracle)
    // Encoding: 0x01C22030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF000000);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01C22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSR #8 (64)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_64_2_81c22030() {
    // Test ORR shifted 64-bit: LSR #8 (oracle)
    // Encoding: 0x81C22030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x81C22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ASR #4 negative (32)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_32_3_01821030() {
    // Test ORR shifted 32-bit: ASR #4 negative (oracle)
    // Encoding: 0x01821030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x01821030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF8000000, "W0 should be 0xF8000000");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ASR #4 negative (64)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_64_3_81821030() {
    // Test ORR shifted 64-bit: ASR #4 negative (oracle)
    // Encoding: 0x81821030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x81821030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x88000000,
        "X0 should be 0x0000000088000000"
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ROR #4 (32)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_32_4_01c21030() {
    // Test ORR shifted 32-bit: ROR #4 (oracle)
    // Encoding: 0x01C21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x01C21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1ABCDEF8, "W0 should be 0x1ABCDEF8");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ROR #4 (64)
#[test]
fn test_aarch32_orr_rr_a1_a_orr_shifted_oracle_64_4_81c21030() {
    // Test ORR shifted 64-bit: ROR #4 (oracle)
    // Encoding: 0x81C21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x81C21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x1ABCDEF8,
        "X0 should be 0x100000001ABCDEF8"
    );
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_orr_rr_a1_a_a32_logical_reg_0_01810002() {
    // Test A32 ORR: simple values (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x76, "R0 should be 0x00000076");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_orr_rr_a1_a_a32_logical_reg_1_01810002() {
    // Test A32 ORR: zero values (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_orr_rr_a1_a_a32_logical_reg_2_01810002() {
    // Test A32 ORR: max value (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_orr_rr_a1_a_a32_logical_reg_3_01810002() {
    // Test A32 ORR: MSB set (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_orr_rr_a1_a_a32_logical_reg_4_01810002() {
    // Test A32 ORR: mixed pattern (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9ABCDEF8, "R0 should be 0x9ABCDEF8");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_zeroresult_0_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_zeroresult_1_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_negativeresult_2_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_unsignedoverflow_3_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_unsignedoverflow_4_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_signedoverflow_5_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_signedoverflow_6_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_orr_rr_a1_a_flags_positiveresult_7_01910012() {
    // Test aarch32_ORR_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x01910012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x01910012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_ORR_r_A Tests
// ============================================================================

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_0_min_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, imm5=0, Rd=0, type1=0, Rn=0, S=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_1_poweroftwo_0_11800000() {
    // Encoding: 0x11800000
    // Test aarch32_ORR_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, type1=0, Rm=0, Rn=0, cond=1
    let encoding: u32 = 0x11800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_2_poweroftwo_0_21800000() {
    // Encoding: 0x21800000
    // Test aarch32_ORR_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, imm5=0, Rd=0, cond=2, type1=0
    let encoding: u32 = 0x21800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_3_poweroftwo_0_31800000() {
    // Encoding: 0x31800000
    // Test aarch32_ORR_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, imm5=0, type1=0, Rd=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0x31800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_4_poweroftwo_0_41800000() {
    // Encoding: 0x41800000
    // Test aarch32_ORR_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rn=0, cond=4, Rm=0, S=0, type1=0, Rd=0
    let encoding: u32 = 0x41800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_5_poweroftwo_0_51800000() {
    // Encoding: 0x51800000
    // Test aarch32_ORR_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm5=0, Rm=0, type1=0, cond=5
    let encoding: u32 = 0x51800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_6_poweroftwo_0_61800000() {
    // Encoding: 0x61800000
    // Test aarch32_ORR_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=6, imm5=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x61800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_7_poweroftwo_0_71800000() {
    // Encoding: 0x71800000
    // Test aarch32_ORR_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, cond=7, imm5=0, Rn=0, type1=0
    let encoding: u32 = 0x71800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_8_poweroftwo_0_81800000() {
    // Encoding: 0x81800000
    // Test aarch32_ORR_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, imm5=0, Rm=0, type1=0, cond=8
    let encoding: u32 = 0x81800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_9_poweroftwo_0_91800000() {
    // Encoding: 0x91800000
    // Test aarch32_ORR_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, cond=9, Rn=0, Rd=0
    let encoding: u32 = 0x91800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_10_poweroftwo_0_a1800000() {
    // Encoding: 0xA1800000
    // Test aarch32_ORR_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm5=0, type1=0, Rm=0, Rn=0, cond=10
    let encoding: u32 = 0xA1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_11_poweroftwo_0_b1800000() {
    // Encoding: 0xB1800000
    // Test aarch32_ORR_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm5=0, Rd=0, type1=0, Rm=0, Rn=0, cond=11
    let encoding: u32 = 0xB1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_12_poweroftwo_0_c1800000() {
    // Encoding: 0xC1800000
    // Test aarch32_ORR_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, cond=12, type1=0, Rd=0, imm5=0
    let encoding: u32 = 0xC1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_13_poweroftwo_0_d1800000() {
    // Encoding: 0xD1800000
    // Test aarch32_ORR_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, S=0, Rd=0, type1=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0xD1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_14_poweroftwo_0_e1800000() {
    // Encoding: 0xE1800000
    // Test aarch32_ORR_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rd=0, imm5=0, Rm=0, Rn=0, cond=14, S=0
    let encoding: u32 = 0xE1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_orr_r_a1_a_field_cond_15_max_0_f1800000() {
    // Encoding: 0xF1800000
    // Test aarch32_ORR_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: imm5=0, S=0, Rn=0, Rd=0, type1=0, Rm=0, cond=15
    let encoding: u32 = 0xF1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_orr_r_a1_a_field_s_0_min_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: imm5=0, Rd=0, type1=0, Rm=0, cond=0, Rn=0, S=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_orr_r_a1_a_field_s_1_max_0_01900000() {
    // Encoding: 0x01900000
    // Test aarch32_ORR_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: type1=0, cond=0, imm5=0, Rm=0, S=1, Rd=0, Rn=0
    let encoding: u32 = 0x01900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_a1_a_field_rn_0_min_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, S=0, imm5=0, Rm=0, type1=0, Rn=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_a1_a_field_rn_1_poweroftwo_0_01810000() {
    // Encoding: 0x01810000
    // Test aarch32_ORR_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, Rn=1, S=0, Rd=0, Rm=0, imm5=0
    let encoding: u32 = 0x01810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_a1_a_field_rd_0_min_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: type1=0, S=0, Rm=0, Rn=0, Rd=0, imm5=0, cond=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_a1_a_field_rd_1_poweroftwo_0_01801000() {
    // Encoding: 0x01801000
    // Test aarch32_ORR_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, type1=0, cond=0, Rn=0, Rm=0, S=0, imm5=0
    let encoding: u32 = 0x01801000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_0_zero_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rm=0, type1=0, S=0, Rn=0, cond=0, Rd=0, imm5=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_1_poweroftwo_0_01800080() {
    // Encoding: 0x01800080
    // Test aarch32_ORR_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm5=1, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0x01800080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_3_poweroftwominusone_0_01800180() {
    // Encoding: 0x01800180
    // Test aarch32_ORR_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, S=0, imm5=3, Rn=0, cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x01800180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_4_poweroftwo_0_01800200() {
    // Encoding: 0x01800200
    // Test aarch32_ORR_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, S=0, Rn=0, Rd=0, imm5=4, type1=0
    let encoding: u32 = 0x01800200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_7_poweroftwominusone_0_01800380() {
    // Encoding: 0x01800380
    // Test aarch32_ORR_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=7, type1=0, S=0, Rm=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x01800380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_8_poweroftwo_0_01800400() {
    // Encoding: 0x01800400
    // Test aarch32_ORR_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, Rd=0, S=0, type1=0, imm5=8
    let encoding: u32 = 0x01800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_15_poweroftwominusone_0_01800780() {
    // Encoding: 0x01800780
    // Test aarch32_ORR_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm5=15, type1=0, Rm=0, Rd=0, S=0, cond=0, Rn=0
    let encoding: u32 = 0x01800780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_16_poweroftwo_0_01800800() {
    // Encoding: 0x01800800
    // Test aarch32_ORR_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, imm5=16, type1=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x01800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_orr_r_a1_a_field_imm5_31_max_0_01800f80() {
    // Encoding: 0x01800F80
    // Test aarch32_ORR_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rd=0, imm5=31, type1=0, cond=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x01800F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_orr_r_a1_a_field_type1_0_min_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_orr_r_a1_a_field_type1_1_poweroftwo_0_01800020() {
    // Encoding: 0x01800020
    // Test aarch32_ORR_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, Rn=0, type1=1, imm5=0, S=0
    let encoding: u32 = 0x01800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_orr_r_a1_a_field_type1_3_max_0_01800060() {
    // Encoding: 0x01800060
    // Test aarch32_ORR_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: imm5=0, S=0, cond=0, Rn=0, Rd=0, type1=3, Rm=0
    let encoding: u32 = 0x01800060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_a1_a_field_rm_0_min_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, cond=0, S=0, Rd=0, imm5=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_a1_a_field_rm_1_poweroftwo_0_01800001() {
    // Encoding: 0x01800001
    // Test aarch32_ORR_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, cond=0, imm5=0, Rd=0, Rn=0, type1=0, S=0
    let encoding: u32 = 0x01800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_orr_r_a1_a_combo_0_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, type1=0, cond=0, S=0, Rn=0, imm5=0, Rm=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_0_condition_eq_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, type1=0, cond=0, imm5=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_1_condition_ne_0_11800000() {
    // Encoding: 0x11800000
    // Test aarch32_ORR_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, imm5=0, S=0, type1=0, Rm=0, cond=1, Rd=0
    let encoding: u32 = 0x11800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_2_condition_cs_hs_0_21800000() {
    // Encoding: 0x21800000
    // Test aarch32_ORR_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: imm5=0, cond=2, Rd=0, Rm=0, S=0, Rn=0, type1=0
    let encoding: u32 = 0x21800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_3_condition_cc_lo_0_31800000() {
    // Encoding: 0x31800000
    // Test aarch32_ORR_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: type1=0, cond=3, Rn=0, imm5=0, S=0, Rd=0, Rm=0
    let encoding: u32 = 0x31800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_4_condition_mi_0_41800000() {
    // Encoding: 0x41800000
    // Test aarch32_ORR_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, Rn=0, type1=0, cond=4, imm5=0
    let encoding: u32 = 0x41800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_5_condition_pl_0_51800000() {
    // Encoding: 0x51800000
    // Test aarch32_ORR_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, type1=0, cond=5, imm5=0, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x51800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_6_condition_vs_0_61800000() {
    // Encoding: 0x61800000
    // Test aarch32_ORR_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, cond=6, imm5=0, S=0, Rd=0
    let encoding: u32 = 0x61800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_7_condition_vc_0_71800000() {
    // Encoding: 0x71800000
    // Test aarch32_ORR_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Rn=0, imm5=0, cond=7, type1=0, S=0, Rm=0
    let encoding: u32 = 0x71800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_8_condition_hi_0_81800000() {
    // Encoding: 0x81800000
    // Test aarch32_ORR_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, cond=8, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x81800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_9_condition_ls_0_91800000() {
    // Encoding: 0x91800000
    // Test aarch32_ORR_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, cond=9, S=0, Rn=0, imm5=0
    let encoding: u32 = 0x91800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_10_condition_ge_0_a1800000() {
    // Encoding: 0xA1800000
    // Test aarch32_ORR_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, type1=0, Rm=0, Rd=0, S=0, imm5=0, Rn=0
    let encoding: u32 = 0xA1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_11_condition_lt_0_b1800000() {
    // Encoding: 0xB1800000
    // Test aarch32_ORR_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rn=0, Rm=0, type1=0, S=0, cond=11
    let encoding: u32 = 0xB1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_12_condition_gt_0_c1800000() {
    // Encoding: 0xC1800000
    // Test aarch32_ORR_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, imm5=0, type1=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0xC1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_13_condition_le_0_d1800000() {
    // Encoding: 0xD1800000
    // Test aarch32_ORR_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, imm5=0, type1=0, Rn=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0xD1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_14_condition_al_0_e1800000() {
    // Encoding: 0xE1800000
    // Test aarch32_ORR_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm5=0, Rd=0, Rm=0, cond=14, S=0, type1=0, Rn=0
    let encoding: u32 = 0xE1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_orr_r_a1_a_special_cond_15_condition_nv_0_f1800000() {
    // Encoding: 0xF1800000
    // Test aarch32_ORR_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, imm5=0, S=0, type1=0, cond=15, Rm=0, Rn=0
    let encoding: u32 = 0xF1800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_orr_r_a1_a_special_s_0_size_variant_0_0_01800000() {
    // Encoding: 0x01800000
    // Test aarch32_ORR_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, imm5=0, type1=0, cond=0, S=0
    let encoding: u32 = 0x01800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_orr_r_a1_a_special_s_1_size_variant_1_0_01900000() {
    // Encoding: 0x01900000
    // Test aarch32_ORR_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, imm5=0, type1=0, Rm=0, S=1
    let encoding: u32 = 0x01900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_t1_a_field_rm_0_min_0_43000000() {
    // Thumb encoding (32): 0x43000000
    // Test aarch32_ORR_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_t1_a_field_rm_1_poweroftwo_0_43080000() {
    // Thumb encoding (32): 0x43080000
    // Test aarch32_ORR_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_orr_r_t1_a_field_rdn_0_min_0_43000000() {
    // Thumb encoding (32): 0x43000000
    // Test aarch32_ORR_r_T1_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_orr_r_t1_a_field_rdn_1_poweroftwo_0_43010000() {
    // Thumb encoding (32): 0x43010000
    // Test aarch32_ORR_r_T1_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rdn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_orr_r_t1_a_field_rdn_7_max_0_43070000() {
    // Thumb encoding (32): 0x43070000
    // Test aarch32_ORR_r_T1_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: Rm=0, Rdn=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_orr_r_t1_a_combo_0_0_43000000() {
    // Thumb encoding (32): 0x43000000
    // Test aarch32_ORR_r_T1_A field combination: Rm=0, Rdn=0
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_orr_r_t2_a_field_s_0_min_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, imm2=0, type1=0, S=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_orr_r_t2_a_field_s_1_max_0_ea500000() {
    // Thumb encoding (32): 0xEA500000
    // Test aarch32_ORR_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, imm2=0, Rm=0, S=1, Rn=0, imm3=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_t2_a_field_rn_0_min_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=0, type1=0, S=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_t2_a_field_rn_1_poweroftwo_0_ea410000() {
    // Thumb encoding (32): 0xEA410000
    // Test aarch32_ORR_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, imm2=0, type1=0, Rm=0, S=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_orr_r_t2_a_field_imm3_0_zero_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, S=0, Rn=0, Rd=0, imm3=0, imm2=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_orr_r_t2_a_field_imm3_1_poweroftwo_0_ea401000() {
    // Thumb encoding (32): 0xEA401000
    // Test aarch32_ORR_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rm=0, imm2=0, S=0, imm3=1, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_orr_r_t2_a_field_imm3_3_poweroftwominusone_0_ea403000() {
    // Thumb encoding (32): 0xEA403000
    // Test aarch32_ORR_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=3, Rn=0, Rd=0, S=0, imm2=0, Rm=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA403000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_orr_r_t2_a_field_imm3_7_max_0_ea407000() {
    // Thumb encoding (32): 0xEA407000
    // Test aarch32_ORR_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: imm3=7, type1=0, imm2=0, Rm=0, Rn=0, S=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA407000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_t2_a_field_rd_0_min_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, imm3=0, Rd=0, type1=0, Rm=0, S=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_t2_a_field_rd_1_poweroftwo_0_ea400100() {
    // Thumb encoding (32): 0xEA400100
    // Test aarch32_ORR_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, Rm=0, S=0, Rn=0, imm3=0, Rd=1, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_orr_r_t2_a_field_imm2_0_zero_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: Rm=0, imm2=0, S=0, Rd=0, imm3=0, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_orr_r_t2_a_field_imm2_1_poweroftwo_0_ea400040() {
    // Thumb encoding (32): 0xEA400040
    // Test aarch32_ORR_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0, imm3=0, imm2=1, type1=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_orr_r_t2_a_field_imm2_3_max_0_ea4000c0() {
    // Thumb encoding (32): 0xEA4000C0
    // Test aarch32_ORR_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rn=0, S=0, imm3=0, imm2=3, Rd=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA4000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_orr_r_t2_a_field_type1_0_min_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: imm2=0, S=0, imm3=0, Rd=0, Rm=0, type1=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_orr_r_t2_a_field_type1_1_poweroftwo_0_ea400010() {
    // Thumb encoding (32): 0xEA400010
    // Test aarch32_ORR_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, imm3=0, S=0, imm2=0, type1=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_orr_r_t2_a_field_type1_3_max_0_ea400030() {
    // Thumb encoding (32): 0xEA400030
    // Test aarch32_ORR_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: imm2=0, type1=3, Rm=0, S=0, Rn=0, Rd=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_orr_r_t2_a_field_rm_0_min_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rd=0, imm2=0, imm3=0, Rn=0, Rm=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_orr_r_t2_a_field_rm_1_poweroftwo_0_ea400001() {
    // Thumb encoding (32): 0xEA400001
    // Test aarch32_ORR_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: type1=0, imm3=0, Rd=0, imm2=0, Rm=1, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_orr_r_t2_a_combo_0_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: imm2=0, type1=0, Rm=0, Rn=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_orr_r_t2_a_special_s_0_size_variant_0_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: imm2=0, Rn=0, type1=0, Rm=0, imm3=0, Rd=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_orr_r_t2_a_special_s_1_size_variant_1_0_ea500000() {
    // Thumb encoding (32): 0xEA500000
    // Test aarch32_ORR_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rm=0, imm2=0, Rn=0, imm3=0, Rd=0, type1=0, S=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_orr_r_t2_a_invalid_0_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm3=0, imm2=0, Rd=0, type1=0, Rm=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_orr_r_t2_a_invalid_1_0_ea400000() {
    // Thumb encoding (32): 0xEA400000
    // Test aarch32_ORR_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: type1=0, Rd=0, imm2=0, Rm=0, S=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_32_0_01820020() {
    // Test ORR shifted 32-bit: no shift (oracle)
    // Encoding: 0x01820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_64_0_81820020() {
    // Test ORR shifted 64-bit: no shift (oracle)
    // Encoding: 0x81820020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x81820020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #8 (32)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_32_1_01822020() {
    // Test ORR shifted 32-bit: LSL #8 (oracle)
    // Encoding: 0x01822020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01822020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #8 (64)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_64_1_81822020() {
    // Test ORR shifted 64-bit: LSL #8 (oracle)
    // Encoding: 0x81822020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x81822020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSR #8 (32)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_32_2_01c22020() {
    // Test ORR shifted 32-bit: LSR #8 (oracle)
    // Encoding: 0x01C22020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF000000);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x01C22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSR #8 (64)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_64_2_81c22020() {
    // Test ORR shifted 64-bit: LSR #8 (oracle)
    // Encoding: 0x81C22020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF000000);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x81C22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ASR #4 negative (32)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_32_3_01821020() {
    // Test ORR shifted 32-bit: ASR #4 negative (oracle)
    // Encoding: 0x01821020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x01821020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF8000000, "W0 should be 0xF8000000");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ASR #4 negative (64)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_64_3_81821020() {
    // Test ORR shifted 64-bit: ASR #4 negative (oracle)
    // Encoding: 0x81821020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x81821020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x88000000,
        "X0 should be 0x0000000088000000"
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ROR #4 (32)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_32_4_01c21020() {
    // Test ORR shifted 32-bit: ROR #4 (oracle)
    // Encoding: 0x01C21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x01C21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1ABCDEF8, "W0 should be 0x1ABCDEF8");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ROR #4 (64)
#[test]
fn test_aarch32_orr_r_a1_a_orr_shifted_oracle_64_4_81c21020() {
    // Test ORR shifted 64-bit: ROR #4 (oracle)
    // Encoding: 0x81C21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x81C21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x1ABCDEF8,
        "X0 should be 0x100000001ABCDEF8"
    );
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_orr_r_a1_a_a32_logical_reg_0_01810002() {
    // Test A32 ORR: simple values (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x76, "R0 should be 0x00000076");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_orr_r_a1_a_a32_logical_reg_1_01810002() {
    // Test A32 ORR: zero values (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_orr_r_a1_a_a32_logical_reg_2_01810002() {
    // Test A32 ORR: max value (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_orr_r_a1_a_a32_logical_reg_3_01810002() {
    // Test A32 ORR: MSB set (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `ORR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_orr_r_a1_a_a32_logical_reg_4_01810002() {
    // Test A32 ORR: mixed pattern (oracle)
    // Encoding: 0x01810002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x01810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x9ABCDEF8, "R0 should be 0x9ABCDEF8");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_zeroresult_0_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: ZeroResult
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_zeroresult_1_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: ZeroResult
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_negativeresult_2_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: NegativeResult
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_unsignedoverflow_3_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_unsignedoverflow_4_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_signedoverflow_5_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_orr_r_a1_a_flags_signedoverflow_6_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_orr_r_a1_a_flags_positiveresult_7_01910002() {
    // Test aarch32_ORR_r_A1_A flag computation: PositiveResult
    // Encoding: 0x01910002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x01910002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_32_0_43020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_64_0_c3020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_32_1_43020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_64_1_c3020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_32_2_43020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_64_2_c3020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_32_3_43020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_64_3_c3020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_32_4_43020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_64_4_c3020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_32_5_43020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_orr_r_t1_a_lslv_oracle_64_5_c3020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_orr_r_t1_a_t16_oracle_0_43100000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_orr_r_t1_a_t16_oracle_1_43100000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_orr_r_t1_a_t16_oracle_2_43100000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_orr_r_t1_a_t16_oracle_3_43100000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_zeroresult_0_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_zeroresult_1_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_negativeresult_2_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_unsignedoverflow_3_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_unsignedoverflow_4_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_signedoverflow_5_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_orr_r_t1_a_flags_signedoverflow_6_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_orr_r_t1_a_flags_positiveresult_7_43100000() {
    // Test aarch32_ORR_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_zeroresult_0_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_zeroresult_1_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_negativeresult_2_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_unsignedoverflow_3_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_unsignedoverflow_4_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_signedoverflow_5_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_orr_r_t2_a_flags_signedoverflow_6_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_ORR_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_orr_r_t2_a_flags_positiveresult_7_ea510002() {
    // Test aarch32_ORR_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEA510002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_EOR_rr_A Tests
// ============================================================================

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_1_poweroftwo_10_10200010() {
    // Encoding: 0x10200010
    // Test aarch32_EOR_rr_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=1, type1=0, Rm=0, Rs=0, Rn=0, S=0
    let encoding: u32 = 0x10200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_2_poweroftwo_10_20200010() {
    // Encoding: 0x20200010
    // Test aarch32_EOR_rr_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rm=0, Rn=0, Rs=0, S=0, Rd=0, cond=2
    let encoding: u32 = 0x20200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_3_poweroftwo_10_30200010() {
    // Encoding: 0x30200010
    // Test aarch32_EOR_rr_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rs=0, Rn=0, S=0, Rm=0, Rd=0, cond=3
    let encoding: u32 = 0x30200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_4_poweroftwo_10_40200010() {
    // Encoding: 0x40200010
    // Test aarch32_EOR_rr_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=4, Rn=0, S=0, Rd=0, type1=0, Rs=0
    let encoding: u32 = 0x40200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_5_poweroftwo_10_50200010() {
    // Encoding: 0x50200010
    // Test aarch32_EOR_rr_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, type1=0, cond=5, Rm=0, Rs=0, Rn=0, S=0
    let encoding: u32 = 0x50200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_6_poweroftwo_10_60200010() {
    // Encoding: 0x60200010
    // Test aarch32_EOR_rr_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=6, type1=0, Rn=0, Rs=0, Rm=0
    let encoding: u32 = 0x60200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_7_poweroftwo_10_70200010() {
    // Encoding: 0x70200010
    // Test aarch32_EOR_rr_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, Rn=0, Rm=0, S=0, cond=7, Rs=0, Rd=0
    let encoding: u32 = 0x70200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_8_poweroftwo_10_80200010() {
    // Encoding: 0x80200010
    // Test aarch32_EOR_rr_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, type1=0, S=0, Rd=0, cond=8, Rs=0, Rm=0
    let encoding: u32 = 0x80200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_9_poweroftwo_10_90200010() {
    // Encoding: 0x90200010
    // Test aarch32_EOR_rr_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=9, Rs=0, type1=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x90200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_10_poweroftwo_10_a0200010() {
    // Encoding: 0xA0200010
    // Test aarch32_EOR_rr_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, Rs=0, cond=10, type1=0, Rm=0
    let encoding: u32 = 0xA0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_11_poweroftwo_10_b0200010() {
    // Encoding: 0xB0200010
    // Test aarch32_EOR_rr_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rs=0, type1=0, Rm=0, cond=11, Rd=0
    let encoding: u32 = 0xB0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_12_poweroftwo_10_c0200010() {
    // Encoding: 0xC0200010
    // Test aarch32_EOR_rr_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rs=0, S=0, Rm=0, Rn=0, cond=12, Rd=0, type1=0
    let encoding: u32 = 0xC0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_13_poweroftwo_10_d0200010() {
    // Encoding: 0xD0200010
    // Test aarch32_EOR_rr_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, Rd=0, Rs=0, type1=0, cond=13
    let encoding: u32 = 0xD0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_14_poweroftwo_10_e0200010() {
    // Encoding: 0xE0200010
    // Test aarch32_EOR_rr_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rs=0, Rn=0, type1=0, S=0, cond=14, Rd=0
    let encoding: u32 = 0xE0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_eor_rr_a1_a_field_cond_15_max_10_f0200010() {
    // Encoding: 0xF0200010
    // Test aarch32_EOR_rr_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, S=0, Rm=0, Rs=0, type1=0, cond=15, Rd=0
    let encoding: u32 = 0xF0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_eor_rr_a1_a_field_s_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, Rn=0, type1=0, Rs=0, Rm=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_eor_rr_a1_a_field_s_1_max_10_00300010() {
    // Encoding: 0x00300010
    // Test aarch32_EOR_rr_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, cond=0, Rs=0, Rm=0, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x00300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rn_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, S=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rn_1_poweroftwo_10_00210010() {
    // Encoding: 0x00210010
    // Test aarch32_EOR_rr_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rs=0, type1=0, Rm=0, Rn=1, S=0
    let encoding: u32 = 0x00210010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rd_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rs=0, Rm=0, S=0, cond=0, type1=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rd_1_poweroftwo_10_00201010() {
    // Encoding: 0x00201010
    // Test aarch32_EOR_rr_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rs=0, Rd=1, S=0, Rn=0, type1=0
    let encoding: u32 = 0x00201010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rs_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field Rs = 0 (Min)
    // ISET: A32
    // Fields: cond=0, type1=0, Rd=0, Rm=0, Rs=0, Rn=0, S=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rs 8 +: 4`
/// Requirement: FieldBoundary { field: "Rs", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rs_1_poweroftwo_10_00200110() {
    // Encoding: 0x00200110
    // Test aarch32_EOR_rr_A1_A field Rs = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, Rd=0, S=0, Rs=1, Rn=0
    let encoding: u32 = 0x00200110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_eor_rr_a1_a_field_type1_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=0, Rs=0, Rn=0, type1=0, Rd=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_eor_rr_a1_a_field_type1_1_poweroftwo_10_00200030() {
    // Encoding: 0x00200030
    // Test aarch32_EOR_rr_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, S=0, Rn=0, Rs=0, type1=1
    let encoding: u32 = 0x00200030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_eor_rr_a1_a_field_type1_3_max_10_00200070() {
    // Encoding: 0x00200070
    // Test aarch32_EOR_rr_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: type1=3, cond=0, Rm=0, Rn=0, S=0, Rd=0, Rs=0
    let encoding: u32 = 0x00200070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rm_0_min_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rs=0, type1=0, Rm=0, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_rr_a1_a_field_rm_1_poweroftwo_10_00200011() {
    // Encoding: 0x00200011
    // Test aarch32_EOR_rr_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=0, S=0, Rd=0, Rn=0, Rs=0, Rm=1
    let encoding: u32 = 0x00200011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_eor_rr_a1_a_combo_0_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, Rs=0, type1=0, Rm=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, Rs=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_0_condition_eq_16_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rs=0, Rd=0, cond=0, S=0, type1=0, Rm=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_1_condition_ne_16_10200010() {
    // Encoding: 0x10200010
    // Test aarch32_EOR_rr_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rs=0, S=0, Rd=0, Rn=0, type1=0, Rm=0, cond=1
    let encoding: u32 = 0x10200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_2_condition_cs_hs_16_20200010() {
    // Encoding: 0x20200010
    // Test aarch32_EOR_rr_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, type1=0, Rm=0, cond=2, Rs=0
    let encoding: u32 = 0x20200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_3_condition_cc_lo_16_30200010() {
    // Encoding: 0x30200010
    // Test aarch32_EOR_rr_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=3, Rd=0, Rs=0, type1=0, S=0
    let encoding: u32 = 0x30200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_4_condition_mi_16_40200010() {
    // Encoding: 0x40200010
    // Test aarch32_EOR_rr_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, S=0, Rd=0, Rs=0, type1=0, Rm=0
    let encoding: u32 = 0x40200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_5_condition_pl_16_50200010() {
    // Encoding: 0x50200010
    // Test aarch32_EOR_rr_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: type1=0, cond=5, Rm=0, Rs=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x50200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_6_condition_vs_16_60200010() {
    // Encoding: 0x60200010
    // Test aarch32_EOR_rr_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, type1=0, Rn=0, S=0, Rs=0, Rm=0
    let encoding: u32 = 0x60200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_7_condition_vc_16_70200010() {
    // Encoding: 0x70200010
    // Test aarch32_EOR_rr_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rd=0, Rm=0, cond=7, Rs=0, type1=0, Rn=0
    let encoding: u32 = 0x70200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_8_condition_hi_16_80200010() {
    // Encoding: 0x80200010
    // Test aarch32_EOR_rr_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rs=0, type1=0, Rn=0, S=0, cond=8
    let encoding: u32 = 0x80200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_9_condition_ls_16_90200010() {
    // Encoding: 0x90200010
    // Test aarch32_EOR_rr_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: type1=0, Rn=0, S=0, Rs=0, cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x90200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_10_condition_ge_16_a0200010() {
    // Encoding: 0xA0200010
    // Test aarch32_EOR_rr_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, Rn=0, Rs=0, type1=0, Rm=0, cond=10, Rd=0
    let encoding: u32 = 0xA0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_11_condition_lt_16_b0200010() {
    // Encoding: 0xB0200010
    // Test aarch32_EOR_rr_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, cond=11, Rm=0, Rn=0, type1=0, Rs=0, Rd=0
    let encoding: u32 = 0xB0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_12_condition_gt_16_c0200010() {
    // Encoding: 0xC0200010
    // Test aarch32_EOR_rr_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0, S=0, Rn=0, type1=0, Rs=0
    let encoding: u32 = 0xC0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_13_condition_le_16_d0200010() {
    // Encoding: 0xD0200010
    // Test aarch32_EOR_rr_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, type1=0, Rn=0, Rd=0, Rm=0, Rs=0, S=0
    let encoding: u32 = 0xD0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_14_condition_al_16_e0200010() {
    // Encoding: 0xE0200010
    // Test aarch32_EOR_rr_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rs=0, cond=14, Rm=0, Rd=0, type1=0, S=0, Rn=0
    let encoding: u32 = 0xE0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_eor_rr_a1_a_special_cond_15_condition_nv_16_f0200010() {
    // Encoding: 0xF0200010
    // Test aarch32_EOR_rr_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, S=0, Rd=0, Rs=0, type1=0, Rm=0, Rn=0
    let encoding: u32 = 0xF0200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_eor_rr_a1_a_special_s_0_size_variant_0_16_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, type1=0, Rs=0, Rm=0, S=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_eor_rr_a1_a_special_s_1_size_variant_1_16_00300010() {
    // Encoding: 0x00300010
    // Test aarch32_EOR_rr_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, Rs=0, Rd=0, type1=0, S=1
    let encoding: u32 = 0x00300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"s\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eor_rr_a1_a_invalid_0_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "s" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, Rs=0, S=0, cond=0, type1=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eor_rr_a1_a_invalid_1_10_00200010() {
    // Encoding: 0x00200010
    // Test aarch32_EOR_rr_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rs=0, Rm=0, Rn=0, type1=0, S=0, Rd=0, cond=0
    let encoding: u32 = 0x00200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_32_0_00220030() {
    // Test EOR shifted 32-bit: no shift (oracle)
    // Encoding: 0x00220030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF);
    let encoding: u32 = 0x00220030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "W0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_64_0_80220030() {
    // Test EOR shifted 64-bit: no shift (oracle)
    // Encoding: 0x80220030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF);
    let encoding: u32 = 0x80220030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFF00,
        "X0 should be 0x00000000FFFFFF00"
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #8 (32)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_32_1_00222030() {
    // Test EOR shifted 32-bit: LSL #8 (oracle)
    // Encoding: 0x00222030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00222030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFEFF, "W0 should be 0xFFFFFEFF");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #8 (64)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_64_1_80222030() {
    // Test EOR shifted 64-bit: LSL #8 (oracle)
    // Encoding: 0x80222030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x80222030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFEFF,
        "X0 should be 0x00000000FFFFFEFF"
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSR #8 (32)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_32_2_00622030() {
    // Test EOR shifted 32-bit: LSR #8 (oracle)
    // Encoding: 0x00622030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x00622030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF00FFFF, "W0 should be 0xFF00FFFF");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSR #8 (64)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_64_2_80622030() {
    // Test EOR shifted 64-bit: LSR #8 (oracle)
    // Encoding: 0x80622030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x80622030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFF00FFFF,
        "X0 should be 0x00000000FF00FFFF"
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ASR #4 negative (32)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_32_3_00a21030() {
    // Test EOR shifted 32-bit: ASR #4 negative (oracle)
    // Encoding: 0x00A21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00A21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x78000000, "W0 should be 0x78000000");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ASR #4 negative (64)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_64_3_80a21030() {
    // Test EOR shifted 64-bit: ASR #4 negative (oracle)
    // Encoding: 0x80A21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x80A21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x88000000,
        "X0 should be 0x0000000088000000"
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ROR #4 (32)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_32_4_00e21030() {
    // Test EOR shifted 32-bit: ROR #4 (oracle)
    // Encoding: 0x00E21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00E21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x8888888, "W0 should be 0x08888888");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ROR #4 (64)
#[test]
fn test_aarch32_eor_rr_a1_a_eor_shifted_oracle_64_4_80e21030() {
    // Test EOR shifted 64-bit: ROR #4 (oracle)
    // Encoding: 0x80E21030
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x80E21030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x18888888,
        "X0 should be 0x1000000018888888"
    );
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_eor_rr_a1_a_a32_logical_reg_0_00210002() {
    // Test A32 EOR: simple values (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x56, "R0 should be 0x00000056");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_eor_rr_a1_a_a32_logical_reg_1_00210002() {
    // Test A32 EOR: zero values (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_eor_rr_a1_a_a32_logical_reg_2_00210002() {
    // Test A32 EOR: max value (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFE, "R0 should be 0xFFFFFFFE");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_eor_rr_a1_a_a32_logical_reg_3_00210002() {
    // Test A32 EOR: MSB set (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `EOR R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_eor_rr_a1_a_a32_logical_reg_4_00210002() {
    // Test A32 EOR: mixed pattern (oracle)
    // Encoding: 0x00210002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    let encoding: u32 = 0x00210002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x88888888, "R0 should be 0x88888888");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_zeroresult_0_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_zeroresult_1_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: ZeroResult
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_negativeresult_2_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: NegativeResult
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_unsignedoverflow_3_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_unsignedoverflow_4_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_signedoverflow_5_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_signedoverflow_6_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: SignedOverflow
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_rr_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_eor_rr_a1_a_flags_positiveresult_7_00310012() {
    // Test aarch32_EOR_rr_A1_A flag computation: PositiveResult
    // Encoding: 0x00310012
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00310012;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_BIC_i_A Tests
// ============================================================================

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_0_min_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, Rn=0, imm12=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_1_poweroftwo_0_13c00000() {
    // Encoding: 0x13C00000
    // Test aarch32_BIC_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=1, S=0, imm12=0
    let encoding: u32 = 0x13C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_2_poweroftwo_0_23c00000() {
    // Encoding: 0x23C00000
    // Test aarch32_BIC_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rd=0, imm12=0, Rn=0, S=0
    let encoding: u32 = 0x23C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_3_poweroftwo_0_33c00000() {
    // Encoding: 0x33C00000
    // Test aarch32_BIC_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=3, S=0, imm12=0
    let encoding: u32 = 0x33C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_4_poweroftwo_0_43c00000() {
    // Encoding: 0x43C00000
    // Test aarch32_BIC_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x43C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_5_poweroftwo_0_53c00000() {
    // Encoding: 0x53C00000
    // Test aarch32_BIC_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=5, Rn=0, imm12=0
    let encoding: u32 = 0x53C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_6_poweroftwo_0_63c00000() {
    // Encoding: 0x63C00000
    // Test aarch32_BIC_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, S=0, imm12=0, Rd=0, Rn=0
    let encoding: u32 = 0x63C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_7_poweroftwo_0_73c00000() {
    // Encoding: 0x73C00000
    // Test aarch32_BIC_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x73C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_8_poweroftwo_0_83c00000() {
    // Encoding: 0x83C00000
    // Test aarch32_BIC_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=8, imm12=0
    let encoding: u32 = 0x83C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_9_poweroftwo_0_93c00000() {
    // Encoding: 0x93C00000
    // Test aarch32_BIC_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=9, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x93C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_10_poweroftwo_0_a3c00000() {
    // Encoding: 0xA3C00000
    // Test aarch32_BIC_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=0, cond=10
    let encoding: u32 = 0xA3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_11_poweroftwo_0_b3c00000() {
    // Encoding: 0xB3C00000
    // Test aarch32_BIC_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, S=0, imm12=0, Rn=0
    let encoding: u32 = 0xB3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_12_poweroftwo_0_c3c00000() {
    // Encoding: 0xC3C00000
    // Test aarch32_BIC_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=12, imm12=0, Rn=0
    let encoding: u32 = 0xC3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_13_poweroftwo_0_d3c00000() {
    // Encoding: 0xD3C00000
    // Test aarch32_BIC_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, imm12=0, Rd=0, S=0
    let encoding: u32 = 0xD3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_14_poweroftwo_0_e3c00000() {
    // Encoding: 0xE3C00000
    // Test aarch32_BIC_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=14, S=0, Rd=0, Rn=0
    let encoding: u32 = 0xE3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_bic_i_a1_a_field_cond_15_max_0_f3c00000() {
    // Encoding: 0xF3C00000
    // Test aarch32_BIC_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rd=0, imm12=0, Rn=0, S=0
    let encoding: u32 = 0xF3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_bic_i_a1_a_field_s_0_min_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm12=0, cond=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_bic_i_a1_a_field_s_1_max_0_03d00000() {
    // Encoding: 0x03D00000
    // Test aarch32_BIC_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, Rn=0, cond=0, imm12=0, Rd=0
    let encoding: u32 = 0x03D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_i_a1_a_field_rn_0_min_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_i_a1_a_field_rn_1_poweroftwo_0_03c10000() {
    // Encoding: 0x03C10000
    // Test aarch32_BIC_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=1, cond=0, Rd=0, imm12=0
    let encoding: u32 = 0x03C10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_i_a1_a_field_rd_0_min_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, imm12=0, Rd=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_i_a1_a_field_rd_1_poweroftwo_0_03c01000() {
    // Encoding: 0x03C01000
    // Test aarch32_BIC_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, imm12=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x03C01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_0_zero_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: cond=0, Rn=0, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_1_poweroftwo_0_03c00001() {
    // Encoding: 0x03C00001
    // Test aarch32_BIC_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1, S=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x03C00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_3_poweroftwominusone_0_03c00003() {
    // Encoding: 0x03C00003
    // Test aarch32_BIC_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=3, S=0, cond=0, Rd=0
    let encoding: u32 = 0x03C00003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_4_poweroftwo_0_03c00004() {
    // Encoding: 0x03C00004
    // Test aarch32_BIC_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, imm12=4
    let encoding: u32 = 0x03C00004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_7_poweroftwominusone_0_03c00007() {
    // Encoding: 0x03C00007
    // Test aarch32_BIC_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=7, S=0, cond=0, Rd=0, Rn=0
    let encoding: u32 = 0x03C00007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_8_poweroftwo_0_03c00008() {
    // Encoding: 0x03C00008
    // Test aarch32_BIC_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=8, cond=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x03C00008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_15_poweroftwominusone_0_03c0000f() {
    // Encoding: 0x03C0000F
    // Test aarch32_BIC_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, Rd=0, imm12=15
    let encoding: u32 = 0x03C0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_16_poweroftwo_0_03c00010() {
    // Encoding: 0x03C00010
    // Test aarch32_BIC_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=16, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x03C00010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_31_poweroftwominusone_0_03c0001f() {
    // Encoding: 0x03C0001F
    // Test aarch32_BIC_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=31, S=0, cond=0, Rn=0
    let encoding: u32 = 0x03C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_32_poweroftwo_0_03c00020() {
    // Encoding: 0x03C00020
    // Test aarch32_BIC_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=32, Rn=0, cond=0, S=0
    let encoding: u32 = 0x03C00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_63_poweroftwominusone_0_03c0003f() {
    // Encoding: 0x03C0003F
    // Test aarch32_BIC_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, imm12=63, S=0, cond=0, Rd=0
    let encoding: u32 = 0x03C0003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_64_poweroftwo_0_03c00040() {
    // Encoding: 0x03C00040
    // Test aarch32_BIC_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=64, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x03C00040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_127_poweroftwominusone_0_03c0007f() {
    // Encoding: 0x03C0007F
    // Test aarch32_BIC_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=127, S=0, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x03C0007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_128_poweroftwo_0_03c00080() {
    // Encoding: 0x03C00080
    // Test aarch32_BIC_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=128, cond=0
    let encoding: u32 = 0x03C00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_255_poweroftwominusone_0_03c000ff() {
    // Encoding: 0x03C000FF
    // Test aarch32_BIC_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, S=0, imm12=255
    let encoding: u32 = 0x03C000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_256_poweroftwo_0_03c00100() {
    // Encoding: 0x03C00100
    // Test aarch32_BIC_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, S=0, imm12=256
    let encoding: u32 = 0x03C00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_511_poweroftwominusone_0_03c001ff() {
    // Encoding: 0x03C001FF
    // Test aarch32_BIC_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, imm12=511, Rn=0, S=0, cond=0
    let encoding: u32 = 0x03C001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_512_poweroftwo_0_03c00200() {
    // Encoding: 0x03C00200
    // Test aarch32_BIC_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, imm12=512, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x03C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_1023_poweroftwominusone_0_03c003ff() {
    // Encoding: 0x03C003FF
    // Test aarch32_BIC_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, Rd=0, imm12=1023
    let encoding: u32 = 0x03C003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_1024_poweroftwo_0_03c00400() {
    // Encoding: 0x03C00400
    // Test aarch32_BIC_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=0, imm12=1024
    let encoding: u32 = 0x03C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_2047_poweroftwominusone_0_03c007ff() {
    // Encoding: 0x03C007FF
    // Test aarch32_BIC_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm12=2047
    let encoding: u32 = 0x03C007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_2048_poweroftwo_0_03c00800() {
    // Encoding: 0x03C00800
    // Test aarch32_BIC_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=2048, cond=0
    let encoding: u32 = 0x03C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_bic_i_a1_a_field_imm12_4095_max_0_03c00fff() {
    // Encoding: 0x03C00FFF
    // Test aarch32_BIC_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: imm12=4095, cond=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x03C00FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_bic_i_a1_a_combo_0_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: imm12=0, Rn=0, S=0, Rd=0, cond=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_0_condition_eq_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, cond=0, S=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_1_condition_ne_0_13c00000() {
    // Encoding: 0x13C00000
    // Test aarch32_BIC_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rn=0, S=0, imm12=0, Rd=0
    let encoding: u32 = 0x13C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_2_condition_cs_hs_0_23c00000() {
    // Encoding: 0x23C00000
    // Test aarch32_BIC_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x23C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_3_condition_cc_lo_0_33c00000() {
    // Encoding: 0x33C00000
    // Test aarch32_BIC_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, cond=3, Rd=0, imm12=0, S=0
    let encoding: u32 = 0x33C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_4_condition_mi_0_43c00000() {
    // Encoding: 0x43C00000
    // Test aarch32_BIC_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, cond=4, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x43C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_5_condition_pl_0_53c00000() {
    // Encoding: 0x53C00000
    // Test aarch32_BIC_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, imm12=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x53C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_6_condition_vs_0_63c00000() {
    // Encoding: 0x63C00000
    // Test aarch32_BIC_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: imm12=0, Rn=0, Rd=0, cond=6, S=0
    let encoding: u32 = 0x63C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_7_condition_vc_0_73c00000() {
    // Encoding: 0x73C00000
    // Test aarch32_BIC_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, S=0, Rd=0, Rn=0, imm12=0
    let encoding: u32 = 0x73C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_8_condition_hi_0_83c00000() {
    // Encoding: 0x83C00000
    // Test aarch32_BIC_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, imm12=0, Rn=0, Rd=0, cond=8
    let encoding: u32 = 0x83C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_9_condition_ls_0_93c00000() {
    // Encoding: 0x93C00000
    // Test aarch32_BIC_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, cond=9, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x93C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_10_condition_ge_0_a3c00000() {
    // Encoding: 0xA3C00000
    // Test aarch32_BIC_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, S=0, cond=10
    let encoding: u32 = 0xA3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_11_condition_lt_0_b3c00000() {
    // Encoding: 0xB3C00000
    // Test aarch32_BIC_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, cond=11, Rn=0
    let encoding: u32 = 0xB3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_12_condition_gt_0_c3c00000() {
    // Encoding: 0xC3C00000
    // Test aarch32_BIC_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm12=0, cond=12
    let encoding: u32 = 0xC3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_13_condition_le_0_d3c00000() {
    // Encoding: 0xD3C00000
    // Test aarch32_BIC_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, cond=13, imm12=0
    let encoding: u32 = 0xD3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_14_condition_al_0_e3c00000() {
    // Encoding: 0xE3C00000
    // Test aarch32_BIC_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, Rd=0, cond=14
    let encoding: u32 = 0xE3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_bic_i_a1_a_special_cond_15_condition_nv_0_f3c00000() {
    // Encoding: 0xF3C00000
    // Test aarch32_BIC_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, cond=15, S=0, Rd=0, imm12=0
    let encoding: u32 = 0xF3C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_bic_i_a1_a_special_s_0_size_variant_0_0_03c00000() {
    // Encoding: 0x03C00000
    // Test aarch32_BIC_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Rd=0, imm12=0
    let encoding: u32 = 0x03C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_bic_i_a1_a_special_s_1_size_variant_1_0_03d00000() {
    // Encoding: 0x03D00000
    // Test aarch32_BIC_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, cond=0, imm12=0, S=1, Rn=0
    let encoding: u32 = 0x03D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_bic_i_t1_a_field_i_0_min_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field i = 0 (Min)
    // ISET: T32
    // Fields: imm8=0, i=0, imm3=0, S=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_bic_i_t1_a_field_i_1_max_0_f4200000() {
    // Thumb encoding (32): 0xF4200000
    // Test aarch32_BIC_i_T1_A field i = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, imm8=0, S=0, i=1, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF4200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_bic_i_t1_a_field_s_0_min_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: i=0, imm3=0, S=0, Rn=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_bic_i_t1_a_field_s_1_max_0_f0300000() {
    // Thumb encoding (32): 0xF0300000
    // Test aarch32_BIC_i_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, Rd=0, i=0, Rn=0, S=1, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_i_t1_a_field_rn_0_min_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm8=0, imm3=0, S=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_i_t1_a_field_rn_1_poweroftwo_0_f0210000() {
    // Thumb encoding (32): 0xF0210000
    // Test aarch32_BIC_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, i=0, S=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bic_i_t1_a_field_imm3_0_zero_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, S=0, Rn=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bic_i_t1_a_field_imm3_1_poweroftwo_0_f0201000() {
    // Thumb encoding (32): 0xF0201000
    // Test aarch32_BIC_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=1, i=0, Rn=0, Rd=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm3_3_poweroftwominusone_0_f0203000() {
    // Thumb encoding (32): 0xF0203000
    // Test aarch32_BIC_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rn=0, Rd=0, imm8=0, i=0, imm3=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0203000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm3_7_max_0_f0207000() {
    // Thumb encoding (32): 0xF0207000
    // Test aarch32_BIC_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rn=0, i=0, S=0, imm3=7, imm8=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0207000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_bic_i_t1_a_field_rd_0_min_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, imm8=0, S=0, Rd=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_bic_i_t1_a_field_rd_1_poweroftwo_0_f0200100() {
    // Thumb encoding (32): 0xF0200100
    // Test aarch32_BIC_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: i=0, imm8=0, Rd=1, imm3=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_0_zero_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, Rd=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_1_poweroftwo_0_f0200001() {
    // Thumb encoding (32): 0xF0200001
    // Test aarch32_BIC_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rd=0, Rn=0, imm8=1, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_3_poweroftwominusone_0_f0200003() {
    // Thumb encoding (32): 0xF0200003
    // Test aarch32_BIC_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, S=0, i=0, imm3=0, Rd=0, imm8=3
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_4_poweroftwo_0_f0200004() {
    // Thumb encoding (32): 0xF0200004
    // Test aarch32_BIC_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, S=0, Rn=0, i=0, Rd=0, imm8=4
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_7_poweroftwominusone_0_f0200007() {
    // Thumb encoding (32): 0xF0200007
    // Test aarch32_BIC_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, S=0, i=0, imm3=0, imm8=7, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_8_poweroftwo_0_f0200008() {
    // Thumb encoding (32): 0xF0200008
    // Test aarch32_BIC_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, imm3=0, S=0, i=0, Rd=0, imm8=8
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_15_poweroftwominusone_0_f020000f() {
    // Thumb encoding (32): 0xF020000F
    // Test aarch32_BIC_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=15, i=0, Rn=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF020000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_16_poweroftwo_0_f0200010() {
    // Thumb encoding (32): 0xF0200010
    // Test aarch32_BIC_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, imm8=16, imm3=0, Rd=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_31_poweroftwominusone_0_f020001f() {
    // Thumb encoding (32): 0xF020001F
    // Test aarch32_BIC_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, Rd=0, imm8=31
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF020001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_32_poweroftwo_0_f0200020() {
    // Thumb encoding (32): 0xF0200020
    // Test aarch32_BIC_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, i=0, S=0, imm8=32, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_63_poweroftwominusone_0_f020003f() {
    // Thumb encoding (32): 0xF020003F
    // Test aarch32_BIC_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm8=63, imm3=0, S=0, i=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF020003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_64_poweroftwo_0_f0200040() {
    // Thumb encoding (32): 0xF0200040
    // Test aarch32_BIC_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, imm8=64, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_127_poweroftwominusone_0_f020007f() {
    // Thumb encoding (32): 0xF020007F
    // Test aarch32_BIC_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, imm3=0, i=0, S=0, Rd=0, imm8=127
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF020007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_128_poweroftwo_0_f0200080() {
    // Thumb encoding (32): 0xF0200080
    // Test aarch32_BIC_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=128, i=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_bic_i_t1_a_field_imm8_255_max_0_f02000ff() {
    // Thumb encoding (32): 0xF02000FF
    // Test aarch32_BIC_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: i=0, Rn=0, Rd=0, imm8=255, imm3=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF02000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_bic_i_t1_a_combo_0_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: S=0, Rn=0, i=0, Rd=0, imm8=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_bic_i_t1_a_special_s_0_size_variant_0_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rn=0, imm8=0, S=0, imm3=0, i=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_bic_i_t1_a_special_s_1_size_variant_1_0_f0300000() {
    // Thumb encoding (32): 0xF0300000
    // Test aarch32_BIC_i_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: Rn=0, i=0, Rd=0, imm3=0, S=1, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bic_i_t1_a_invalid_0_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm8=0, Rd=0, Rn=0, i=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_bic_i_t1_a_invalid_1_0_f0200000() {
    // Thumb encoding (32): 0xF0200000
    // Test aarch32_BIC_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: imm8=0, imm3=0, S=0, Rn=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0x92401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0x92403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0x92407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // Encoding: 0x92400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // Encoding: 0x9240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x12001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x12003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_bic_i_a1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // Encoding: 0x12000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_0_0_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_0_ff_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_0_aaaaaaaa_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_0_55555555_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_0_ffffffff_0201000a() {
    // Test A32 AND: small immediate (oracle)
    // Encoding: 0x0201000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0201000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_1_0_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_1_ff_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_1_aaaaaaaa_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAA, "R0 should be 0x000000AA");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_1_55555555_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55, "R0 should be 0x00000055");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_1_ffffffff_020100ff() {
    // Test A32 AND: max imm8 (oracle)
    // Encoding: 0x020100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x020100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_2_0_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_2_ff_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_2_aaaaaaaa_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_2_55555555_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_2_ffffffff_02010180() {
    // Test A32 AND: rotated by 2 (oracle)
    // Encoding: 0x02010180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02010180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_3_0_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_3_ff_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_3_aaaaaaaa_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA000000, "R0 should be 0x0A000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_3_55555555_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5000000, "R0 should be 0x05000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_3_ffffffff_0201040f() {
    // Test A32 AND: rotated by 8 (oracle)
    // Encoding: 0x0201040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0201040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_4_0_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_4_ff_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_4_aaaaaaaa_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_4_55555555_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `AND R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_bic_i_a1_a_a32_logical_imm_4_ffffffff_02010000() {
    // Test A32 AND: zero immediate (oracle)
    // Encoding: 0x02010000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_zeroresult_0_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_zeroresult_1_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: ZeroResult
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_negativeresult_2_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: NegativeResult
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_unsignedoverflow_3_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_unsignedoverflow_4_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_signedoverflow_5_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_bic_i_a1_a_flags_signedoverflow_6_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_bic_i_a1_a_flags_positiveresult_7_03d10000() {
    // Test aarch32_BIC_i_A1_A flag computation: PositiveResult
    // Encoding: 0x03D10000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x03D10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_64_0_92401c20() {
    // Test AND 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_64_1_92403c20() {
    // Test AND 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "X0 should be 0x000000000000FFFF");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_64_2_92407c20() {
    // Test AND 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x92407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x00000000FFFFFFFF"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_64_3_92400020() {
    // Test AND 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0x92400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_64_4_9240f820() {
    // Test AND 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x9240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xAAAAAAAA,
        "X0 should be 0x2AAAAAAAAAAAAAAA"
    );
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_32_0_12001c20() {
    // Test AND 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_32_1_12003c20() {
    // Test AND 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x12003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF, "W0 should be 0x0000FFFF");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `AND W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_bic_i_t1_a_and_oracle_32_2_12000020() {
    // Test AND 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x12000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_zeroresult_0_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_zeroresult_1_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_negativeresult_2_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_unsignedoverflow_3_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_unsignedoverflow_4_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_signedoverflow_5_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_bic_i_t1_a_flags_signedoverflow_6_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_BIC_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_bic_i_t1_a_flags_positiveresult_7_f0310000() {
    // Test aarch32_BIC_i_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xF0310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_EOR_i_A Tests
// ============================================================================

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_0_min_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, cond=0, imm12=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_1_poweroftwo_0_12200000() {
    // Encoding: 0x12200000
    // Test aarch32_EOR_i_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, S=0, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0x12200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_2_poweroftwo_0_22200000() {
    // Encoding: 0x22200000
    // Test aarch32_EOR_i_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, cond=2, Rd=0
    let encoding: u32 = 0x22200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_3_poweroftwo_0_32200000() {
    // Encoding: 0x32200000
    // Test aarch32_EOR_i_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=3, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x32200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_4_poweroftwo_0_42200000() {
    // Encoding: 0x42200000
    // Test aarch32_EOR_i_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm12=0, cond=4, S=0, Rn=0
    let encoding: u32 = 0x42200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_5_poweroftwo_0_52200000() {
    // Encoding: 0x52200000
    // Test aarch32_EOR_i_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=5, Rn=0, S=0, imm12=0
    let encoding: u32 = 0x52200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_6_poweroftwo_0_62200000() {
    // Encoding: 0x62200000
    // Test aarch32_EOR_i_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=0, Rn=0, cond=6
    let encoding: u32 = 0x62200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_7_poweroftwo_0_72200000() {
    // Encoding: 0x72200000
    // Test aarch32_EOR_i_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, cond=7, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x72200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_8_poweroftwo_0_82200000() {
    // Encoding: 0x82200000
    // Test aarch32_EOR_i_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, imm12=0, Rd=0, S=0, cond=8
    let encoding: u32 = 0x82200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_9_poweroftwo_0_92200000() {
    // Encoding: 0x92200000
    // Test aarch32_EOR_i_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, imm12=0, cond=9, Rn=0
    let encoding: u32 = 0x92200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_10_poweroftwo_0_a2200000() {
    // Encoding: 0xA2200000
    // Test aarch32_EOR_i_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rn=0, imm12=0, S=0
    let encoding: u32 = 0xA2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_11_poweroftwo_0_b2200000() {
    // Encoding: 0xB2200000
    // Test aarch32_EOR_i_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=11, Rn=0, Rd=0, imm12=0
    let encoding: u32 = 0xB2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_12_poweroftwo_0_c2200000() {
    // Encoding: 0xC2200000
    // Test aarch32_EOR_i_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, S=0, cond=12, Rd=0, Rn=0
    let encoding: u32 = 0xC2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_13_poweroftwo_0_d2200000() {
    // Encoding: 0xD2200000
    // Test aarch32_EOR_i_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=13, Rd=0, imm12=0
    let encoding: u32 = 0xD2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_14_poweroftwo_0_e2200000() {
    // Encoding: 0xE2200000
    // Test aarch32_EOR_i_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=14, S=0, Rd=0, imm12=0
    let encoding: u32 = 0xE2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_eor_i_a1_a_field_cond_15_max_0_f2200000() {
    // Encoding: 0xF2200000
    // Test aarch32_EOR_i_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=15, S=0, imm12=0
    let encoding: u32 = 0xF2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_eor_i_a1_a_field_s_0_min_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_eor_i_a1_a_field_s_1_max_0_02300000() {
    // Encoding: 0x02300000
    // Test aarch32_EOR_i_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: cond=0, Rn=0, S=1, imm12=0, Rd=0
    let encoding: u32 = 0x02300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_i_a1_a_field_rn_0_min_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: imm12=0, S=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_i_a1_a_field_rn_1_poweroftwo_0_02210000() {
    // Encoding: 0x02210000
    // Test aarch32_EOR_i_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=0, Rn=1, S=0, Rd=0, cond=0
    let encoding: u32 = 0x02210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_i_a1_a_field_rd_0_min_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_i_a1_a_field_rd_1_poweroftwo_0_02201000() {
    // Encoding: 0x02201000
    // Test aarch32_EOR_i_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=1, S=0, Rn=0, imm12=0
    let encoding: u32 = 0x02201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_0_zero_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A field imm12 = 0 (Zero)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, Rn=0, cond=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_1_poweroftwo_0_02200001() {
    // Encoding: 0x02200001
    // Test aarch32_EOR_i_A1_A field imm12 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, imm12=1, Rd=0, S=0
    let encoding: u32 = 0x02200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_3_poweroftwominusone_0_02200003() {
    // Encoding: 0x02200003
    // Test aarch32_EOR_i_A1_A field imm12 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, imm12=3, Rn=0, cond=0
    let encoding: u32 = 0x02200003;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_4_poweroftwo_0_02200004() {
    // Encoding: 0x02200004
    // Test aarch32_EOR_i_A1_A field imm12 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=4
    let encoding: u32 = 0x02200004;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_7_poweroftwominusone_0_02200007() {
    // Encoding: 0x02200007
    // Test aarch32_EOR_i_A1_A field imm12 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, cond=0, imm12=7
    let encoding: u32 = 0x02200007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_8_poweroftwo_0_02200008() {
    // Encoding: 0x02200008
    // Test aarch32_EOR_i_A1_A field imm12 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, cond=0, imm12=8
    let encoding: u32 = 0x02200008;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_15_poweroftwominusone_0_0220000f() {
    // Encoding: 0x0220000F
    // Test aarch32_EOR_i_A1_A field imm12 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=0, imm12=15
    let encoding: u32 = 0x0220000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_16_poweroftwo_0_02200010() {
    // Encoding: 0x02200010
    // Test aarch32_EOR_i_A1_A field imm12 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=16, Rn=0, S=0
    let encoding: u32 = 0x02200010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_31_poweroftwominusone_0_0220001f() {
    // Encoding: 0x0220001F
    // Test aarch32_EOR_i_A1_A field imm12 = 31 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm12=31, cond=0
    let encoding: u32 = 0x0220001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_32_poweroftwo_0_02200020() {
    // Encoding: 0x02200020
    // Test aarch32_EOR_i_A1_A field imm12 = 32 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, cond=0, imm12=32
    let encoding: u32 = 0x02200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_63_poweroftwominusone_0_0220003f() {
    // Encoding: 0x0220003F
    // Test aarch32_EOR_i_A1_A field imm12 = 63 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=63, cond=0
    let encoding: u32 = 0x0220003F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_64_poweroftwo_0_02200040() {
    // Encoding: 0x02200040
    // Test aarch32_EOR_i_A1_A field imm12 = 64 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm12=64
    let encoding: u32 = 0x02200040;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_127_poweroftwominusone_0_0220007f() {
    // Encoding: 0x0220007F
    // Test aarch32_EOR_i_A1_A field imm12 = 127 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm12=127
    let encoding: u32 = 0x0220007F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_128_poweroftwo_0_02200080() {
    // Encoding: 0x02200080
    // Test aarch32_EOR_i_A1_A field imm12 = 128 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=128, Rd=0, cond=0
    let encoding: u32 = 0x02200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_255_poweroftwominusone_0_022000ff() {
    // Encoding: 0x022000FF
    // Test aarch32_EOR_i_A1_A field imm12 = 255 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=255, cond=0, Rd=0
    let encoding: u32 = 0x022000FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_256_poweroftwo_0_02200100() {
    // Encoding: 0x02200100
    // Test aarch32_EOR_i_A1_A field imm12 = 256 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, imm12=256, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x02200100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_511_poweroftwominusone_0_022001ff() {
    // Encoding: 0x022001FF
    // Test aarch32_EOR_i_A1_A field imm12 = 511 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rn=0, Rd=0, imm12=511
    let encoding: u32 = 0x022001FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_512_poweroftwo_0_02200200() {
    // Encoding: 0x02200200
    // Test aarch32_EOR_i_A1_A field imm12 = 512 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=512, cond=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x02200200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_1023_poweroftwominusone_0_022003ff() {
    // Encoding: 0x022003FF
    // Test aarch32_EOR_i_A1_A field imm12 = 1023 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=1023, Rd=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x022003FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_1024_poweroftwo_0_02200400() {
    // Encoding: 0x02200400
    // Test aarch32_EOR_i_A1_A field imm12 = 1024 (PowerOfTwo)
    // ISET: A32
    // Fields: imm12=1024, cond=0, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x02200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2047, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (2047)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_2047_poweroftwominusone_0_022007ff() {
    // Encoding: 0x022007FF
    // Test aarch32_EOR_i_A1_A field imm12 = 2047 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: imm12=2047, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x022007FF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_2048_poweroftwo_0_02200800() {
    // Encoding: 0x02200800
    // Test aarch32_EOR_i_A1_A field imm12 = 2048 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, cond=0, imm12=2048, Rn=0
    let encoding: u32 = 0x02200800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field imm12 0 +: 12`
/// Requirement: FieldBoundary { field: "imm12", value: 4095, boundary: Max }
/// maximum immediate (4095)
#[test]
fn test_aarch32_eor_i_a1_a_field_imm12_4095_max_0_02200fff() {
    // Encoding: 0x02200FFF
    // Test aarch32_EOR_i_A1_A field imm12 = 4095 (Max)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, imm12=4095
    let encoding: u32 = 0x02200FFF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_eor_i_a1_a_combo_0_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm12=0
    // ISET: A32
    // Fields: S=0, Rn=0, imm12=0, cond=0, Rd=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_0_condition_eq_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, S=0, imm12=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_1_condition_ne_0_12200000() {
    // Encoding: 0x12200000
    // Test aarch32_EOR_i_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: S=0, cond=1, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0x12200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_2_condition_cs_hs_0_22200000() {
    // Encoding: 0x22200000
    // Test aarch32_EOR_i_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, cond=2, imm12=0, Rd=0, S=0
    let encoding: u32 = 0x22200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_3_condition_cc_lo_0_32200000() {
    // Encoding: 0x32200000
    // Test aarch32_EOR_i_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm12=0, cond=3, S=0
    let encoding: u32 = 0x32200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_4_condition_mi_0_42200000() {
    // Encoding: 0x42200000
    // Test aarch32_EOR_i_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, Rn=0, Rd=0, imm12=0, cond=4
    let encoding: u32 = 0x42200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_5_condition_pl_0_52200000() {
    // Encoding: 0x52200000
    // Test aarch32_EOR_i_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, S=0, imm12=0, cond=5, Rd=0
    let encoding: u32 = 0x52200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_6_condition_vs_0_62200000() {
    // Encoding: 0x62200000
    // Test aarch32_EOR_i_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rn=0, imm12=0, S=0, Rd=0
    let encoding: u32 = 0x62200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_7_condition_vc_0_72200000() {
    // Encoding: 0x72200000
    // Test aarch32_EOR_i_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rn=0, Rd=0, S=0, imm12=0
    let encoding: u32 = 0x72200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_8_condition_hi_0_82200000() {
    // Encoding: 0x82200000
    // Test aarch32_EOR_i_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, imm12=0, S=0, Rn=0, cond=8
    let encoding: u32 = 0x82200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_9_condition_ls_0_92200000() {
    // Encoding: 0x92200000
    // Test aarch32_EOR_i_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm12=0, cond=9
    let encoding: u32 = 0x92200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_10_condition_ge_0_a2200000() {
    // Encoding: 0xA2200000
    // Test aarch32_EOR_i_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, imm12=0, cond=10
    let encoding: u32 = 0xA2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_11_condition_lt_0_b2200000() {
    // Encoding: 0xB2200000
    // Test aarch32_EOR_i_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, imm12=0, Rd=0, S=0, Rn=0
    let encoding: u32 = 0xB2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_12_condition_gt_0_c2200000() {
    // Encoding: 0xC2200000
    // Test aarch32_EOR_i_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=12, Rd=0, imm12=0
    let encoding: u32 = 0xC2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_13_condition_le_0_d2200000() {
    // Encoding: 0xD2200000
    // Test aarch32_EOR_i_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, S=0, Rd=0, imm12=0, Rn=0
    let encoding: u32 = 0xD2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_14_condition_al_0_e2200000() {
    // Encoding: 0xE2200000
    // Test aarch32_EOR_i_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: S=0, Rd=0, Rn=0, imm12=0, cond=14
    let encoding: u32 = 0xE2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_eor_i_a1_a_special_cond_15_condition_nv_0_f2200000() {
    // Encoding: 0xF2200000
    // Test aarch32_EOR_i_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, S=0, Rn=0, imm12=0, Rd=0
    let encoding: u32 = 0xF2200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_eor_i_a1_a_special_s_0_size_variant_0_0_02200000() {
    // Encoding: 0x02200000
    // Test aarch32_EOR_i_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm12=0, Rn=0, S=0
    let encoding: u32 = 0x02200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_eor_i_a1_a_special_s_1_size_variant_1_0_02300000() {
    // Encoding: 0x02300000
    // Test aarch32_EOR_i_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, imm12=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x02300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_eor_i_t1_a_field_i_0_min_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field i = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm3=0, imm8=0, Rn=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field i 26 +: 1`
/// Requirement: FieldBoundary { field: "i", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_eor_i_t1_a_field_i_1_max_0_f4800000() {
    // Thumb encoding (32): 0xF4800000
    // Test aarch32_EOR_i_T1_A field i = 1 (Max)
    // ISET: T32
    // Fields: imm3=0, S=0, i=1, Rd=0, Rn=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF4800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_eor_i_t1_a_field_s_0_min_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field S = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, imm8=0, imm3=0, Rn=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_eor_i_t1_a_field_s_1_max_0_f0900000() {
    // Thumb encoding (32): 0xF0900000
    // Test aarch32_EOR_i_T1_A field S = 1 (Max)
    // ISET: T32
    // Fields: imm8=0, S=1, imm3=0, i=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_i_t1_a_field_rn_0_min_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rn=0, i=0, Rd=0, imm8=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_i_t1_a_field_rn_1_poweroftwo_0_f0810000() {
    // Thumb encoding (32): 0xF0810000
    // Test aarch32_EOR_i_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, S=0, i=0, Rd=0, imm3=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_eor_i_t1_a_field_imm3_0_zero_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: imm8=0, Rn=0, i=0, S=0, imm3=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_eor_i_t1_a_field_imm3_1_poweroftwo_0_f0801000() {
    // Thumb encoding (32): 0xF0801000
    // Test aarch32_EOR_i_T1_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, imm3=1, imm8=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm3_3_poweroftwominusone_0_f0803000() {
    // Thumb encoding (32): 0xF0803000
    // Test aarch32_EOR_i_T1_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=3, imm8=0, Rn=0, Rd=0, S=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0803000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm3_7_max_0_f0807000() {
    // Thumb encoding (32): 0xF0807000
    // Test aarch32_EOR_i_T1_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: Rd=0, imm8=0, i=0, Rn=0, imm3=7, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0807000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_eor_i_t1_a_field_rd_0_min_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm3=0, i=0, S=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_eor_i_t1_a_field_rd_1_poweroftwo_0_f0800100() {
    // Thumb encoding (32): 0xF0800100
    // Test aarch32_EOR_i_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, imm3=0, S=0, Rn=0, imm8=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_0_zero_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field imm8 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, Rn=0, i=0, imm3=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_1_poweroftwo_0_f0800001() {
    // Thumb encoding (32): 0xF0800001
    // Test aarch32_EOR_i_T1_A field imm8 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=1, Rd=0, imm3=0, Rn=0, S=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_3_poweroftwominusone_0_f0800003() {
    // Thumb encoding (32): 0xF0800003
    // Test aarch32_EOR_i_T1_A field imm8 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rn=0, imm3=0, Rd=0, imm8=3, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800003;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_4_poweroftwo_0_f0800004() {
    // Thumb encoding (32): 0xF0800004
    // Test aarch32_EOR_i_T1_A field imm8 = 4 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, imm3=0, Rd=0, imm8=4, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800004;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_7_poweroftwominusone_0_f0800007() {
    // Thumb encoding (32): 0xF0800007
    // Test aarch32_EOR_i_T1_A field imm8 = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rd=0, S=0, i=0, imm8=7, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800007;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_8_poweroftwo_0_f0800008() {
    // Thumb encoding (32): 0xF0800008
    // Test aarch32_EOR_i_T1_A field imm8 = 8 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, imm8=8, S=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800008;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_15_poweroftwominusone_0_f080000f() {
    // Thumb encoding (32): 0xF080000F
    // Test aarch32_EOR_i_T1_A field imm8 = 15 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: i=0, Rn=0, S=0, imm3=0, Rd=0, imm8=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF080000F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_16_poweroftwo_0_f0800010() {
    // Thumb encoding (32): 0xF0800010
    // Test aarch32_EOR_i_T1_A field imm8 = 16 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=16, Rn=0, S=0, imm3=0, Rd=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_31_poweroftwominusone_0_f080001f() {
    // Thumb encoding (32): 0xF080001F
    // Test aarch32_EOR_i_T1_A field imm8 = 31 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=31, Rn=0, i=0, S=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF080001F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_32_poweroftwo_0_f0800020() {
    // Thumb encoding (32): 0xF0800020
    // Test aarch32_EOR_i_T1_A field imm8 = 32 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, i=0, imm8=32, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_63_poweroftwominusone_0_f080003f() {
    // Thumb encoding (32): 0xF080003F
    // Test aarch32_EOR_i_T1_A field imm8 = 63 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rd=0, imm8=63, imm3=0, S=0, i=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF080003F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_64_poweroftwo_0_f0800040() {
    // Thumb encoding (32): 0xF0800040
    // Test aarch32_EOR_i_T1_A field imm8 = 64 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, i=0, Rn=0, imm3=0, imm8=64, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_127_poweroftwominusone_0_f080007f() {
    // Thumb encoding (32): 0xF080007F
    // Test aarch32_EOR_i_T1_A field imm8 = 127 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm8=127, S=0, Rn=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF080007F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_128_poweroftwo_0_f0800080() {
    // Thumb encoding (32): 0xF0800080
    // Test aarch32_EOR_i_T1_A field imm8 = 128 (PowerOfTwo)
    // ISET: T32
    // Fields: imm8=128, Rd=0, S=0, Rn=0, i=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800080;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field imm8 0 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_aarch32_eor_i_t1_a_field_imm8_255_max_0_f08000ff() {
    // Thumb encoding (32): 0xF08000FF
    // Test aarch32_EOR_i_T1_A field imm8 = 255 (Max)
    // ISET: T32
    // Fields: imm3=0, i=0, Rn=0, S=0, Rd=0, imm8=255
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF08000FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i=0 (minimum value)
#[test]
fn test_aarch32_eor_i_t1_a_combo_0_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A field combination: i=0, S=0, Rn=0, imm3=0, Rd=0, imm8=0
    // ISET: T32
    // Fields: i=0, imm3=0, Rd=0, imm8=0, S=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_eor_i_t1_a_special_s_0_size_variant_0_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: imm3=0, Rn=0, S=0, Rd=0, i=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_eor_i_t1_a_special_s_1_size_variant_1_0_f0900000() {
    // Thumb encoding (32): 0xF0900000
    // Test aarch32_EOR_i_T1_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: S=1, Rn=0, imm3=0, i=0, Rd=0, imm8=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0900000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eor_i_t1_a_invalid_0_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: imm3=0, Rn=0, Rd=0, imm8=0, i=0, S=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_eor_i_t1_a_invalid_1_0_f0800000() {
    // Thumb encoding (32): 0xF0800000
    // Test aarch32_EOR_i_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: S=0, Rn=0, Rd=0, imm8=0, imm3=0, i=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xF0800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_64_0_d2401c20() {
    // Test EOR 64-bit: mask lower 8 bits (oracle)
    // Encoding: 0xD2401C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFF00,
        "X0 should be 0xFFFFFFFFFFFFFF00"
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_64_1_d2403c20() {
    // Test EOR 64-bit: mask lower 16 bits (oracle)
    // Encoding: 0xD2403C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF0000,
        "X0 should be 0xFFFFFFFFFFFF0000"
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_64_2_d2407c20() {
    // Test EOR 64-bit: mask lower 32 bits (oracle)
    // Encoding: 0xD2407C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_64_3_d2400020() {
    // Test EOR 64-bit: single bit mask (oracle)
    // Encoding: 0xD2400020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0xD2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xCAFEBABF,
        "X0 should be 0xDEADBEEFCAFEBABF"
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_64_4_d240f820() {
    // Test EOR 64-bit: all but MSB (oracle)
    // Encoding: 0xD240F820
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xD240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x55555555,
        "X0 should be 0xD555555555555555"
    );
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_32_0_52001c20() {
    // Test EOR 32-bit: mask lower 8 bits (oracle)
    // Encoding: 0x52001C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "W0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_32_1_52003c20() {
    // Test EOR 32-bit: mask lower 16 bits (oracle)
    // Encoding: 0x52003C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF0000, "W0 should be 0xFFFF0000");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_eor_i_a1_a_eor_oracle_32_2_52000020() {
    // Test EOR 32-bit: single bit mask (oracle)
    // Encoding: 0x52000020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x52000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDEADBEEE, "W0 should be 0xDEADBEEE");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x00000000)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_0_0_0221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0x0221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_0_ff_0221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0x0221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF5, "R0 should be 0x000000F5");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_0_aaaaaaaa_0221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0x0221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAA0, "R0 should be 0xAAAAAAA0");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0x55555555)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_0_55555555_0221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0x0221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5555555F, "R0 should be 0x5555555F");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #10`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// small immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_0_ffffffff_0221000a() {
    // Test A32 EOR: small immediate (oracle)
    // Encoding: 0x0221000A
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0221000A;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFF5, "R0 should be 0xFFFFFFF5");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x00000000)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_1_0_022100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0x022100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x022100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x000000FF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_1_ff_022100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0x022100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x022100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_1_aaaaaaaa_022100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0x022100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x022100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAA55, "R0 should be 0xAAAAAA55");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0x55555555)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_1_55555555_022100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0x022100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x022100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x555555AA, "R0 should be 0x555555AA");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #255`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max imm8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_1_ffffffff_022100ff() {
    // Test A32 EOR: max imm8 (oracle)
    // Encoding: 0x022100FF
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x022100FF;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "R0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x00000000)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_2_0_02210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0x02210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x000000FF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_2_ff_02210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0x02210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x02210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDF, "R0 should be 0x000000DF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_2_aaaaaaaa_02210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0x02210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x02210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAA8A, "R0 should be 0xAAAAAA8A");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0x55555555)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_2_55555555_02210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0x02210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x02210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555575, "R0 should be 0x55555575");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #32`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 2 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_2_ffffffff_02210180() {
    // Test A32 EOR: rotated by 2 (oracle)
    // Encoding: 0x02210180
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02210180;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFDF, "R0 should be 0xFFFFFFDF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x00000000)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_3_0_0221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0x0221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF000000, "R0 should be 0x0F000000");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x000000FF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_3_ff_0221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0x0221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x0221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0000FF, "R0 should be 0x0F0000FF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_3_aaaaaaaa_0221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0x0221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x0221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA5AAAAAA, "R0 should be 0xA5AAAAAA");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0x55555555)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_3_55555555_0221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0x0221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x0221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x5A555555, "R0 should be 0x5A555555");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #251658240`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// rotated by 8 (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_3_ffffffff_0221040f() {
    // Test A32 EOR: rotated by 8 (oracle)
    // Encoding: 0x0221040F
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0221040F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xF0FFFFFF, "R0 should be 0xF0FFFFFF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x00000000)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_4_0_02210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0x02210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x02210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x000000FF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_4_ff_02210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0x02210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u32 = 0x02210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xAAAAAAAA)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_4_aaaaaaaa_02210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0x02210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0x02210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xAAAAAAAA, "R0 should be 0xAAAAAAAA");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0x55555555)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_4_55555555_02210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0x02210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x55555555);
    let encoding: u32 = 0x02210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55555555, "R0 should be 0x55555555");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `EOR R0, R1, #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero immediate (Rn=0xFFFFFFFF)
#[test]
fn test_aarch32_eor_i_a1_a_a32_logical_imm_4_ffffffff_02210000() {
    // Test A32 EOR: zero immediate (oracle)
    // Encoding: 0x02210000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_zeroresult_0_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_zeroresult_1_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: ZeroResult
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_negativeresult_2_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: NegativeResult
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_unsignedoverflow_3_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_unsignedoverflow_4_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_signedoverflow_5_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_eor_i_a1_a_flags_signedoverflow_6_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: SignedOverflow
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_eor_i_a1_a_flags_positiveresult_7_02310000() {
    // Test aarch32_EOR_i_A1_A flag computation: PositiveResult
    // Encoding: 0x02310000
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x02310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR X0, X1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 8 bits (64)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_64_0_d2401c20() {
    // Test EOR 64-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2401C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFF00,
        "X0 should be 0xFFFFFFFFFFFFFF00"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR X0, X1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 16 bits (64)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_64_1_d2403c20() {
    // Test EOR 64-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2403C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFF0000,
        "X0 should be 0xFFFFFFFFFFFF0000"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR X0, X1, #0xFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// mask lower 32 bits (64)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_64_2_d2407c20() {
    // Test EOR 64-bit: mask lower 32 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xD2407C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR X0, X1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// single bit mask (64)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_64_3_d2400020() {
    // Test EOR 64-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xCAFEBABE);
    let encoding: u32 = 0xD2400020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xCAFEBABF,
        "X0 should be 0xDEADBEEFCAFEBABF"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR X0, X1, #0x7FFFFFFFFFFFFFFF`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all but MSB (64)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_64_4_d240f820() {
    // Test EOR 64-bit: all but MSB (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xAAAAAAAA);
    let encoding: u32 = 0xD240F820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x55555555,
        "X0 should be 0xD555555555555555"
    );
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR W0, W1, #0xFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 8 bits (32)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_32_0_52001c20() {
    // Test EOR 32-bit: mask lower 8 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52001C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFF00, "W0 should be 0xFFFFFF00");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR W0, W1, #0xFFFF`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mask lower 16 bits (32)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_32_1_52003c20() {
    // Test EOR 32-bit: mask lower 16 bits (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x52003C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFF0000, "W0 should be 0xFFFF0000");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `EOR W0, W1, #0x1`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// single bit mask (32)
#[test]
fn test_aarch32_eor_i_t1_a_eor_oracle_32_2_52000020() {
    // Test EOR 32-bit: single bit mask (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xDEADBEEF);
    let encoding: u32 = 0x52000020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xDEADBEEE, "W0 should be 0xDEADBEEE");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_zeroresult_0_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_zeroresult_1_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_negativeresult_2_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_unsignedoverflow_3_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_unsignedoverflow_4_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_signedoverflow_5_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_eor_i_t1_a_flags_signedoverflow_6_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_EOR_i_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_eor_i_t1_a_flags_positiveresult_7_f0910000() {
    // Test aarch32_EOR_i_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xF0910000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

// ============================================================================
// aarch32_AND_r_A Tests
// ============================================================================

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_0_min_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, imm5=0, Rm=0, Rd=0, Rn=0, type1=0, S=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_1_poweroftwo_0_10000000() {
    // Encoding: 0x10000000
    // Test aarch32_AND_r_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, type1=0, cond=1, imm5=0, Rm=0
    let encoding: u32 = 0x10000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_2_poweroftwo_0_20000000() {
    // Encoding: 0x20000000
    // Test aarch32_AND_r_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, cond=2, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x20000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_3_poweroftwo_0_30000000() {
    // Encoding: 0x30000000
    // Test aarch32_AND_r_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=3, type1=0, Rm=0, S=0, imm5=0, Rd=0
    let encoding: u32 = 0x30000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_4_poweroftwo_0_40000000() {
    // Encoding: 0x40000000
    // Test aarch32_AND_r_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, S=0, Rd=0, Rm=0, imm5=0, Rn=0, type1=0
    let encoding: u32 = 0x40000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_5_poweroftwo_0_50000000() {
    // Encoding: 0x50000000
    // Test aarch32_AND_r_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: type1=0, cond=5, Rd=0, imm5=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x50000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_6_poweroftwo_0_60000000() {
    // Encoding: 0x60000000
    // Test aarch32_AND_r_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, S=0, Rd=0, Rn=0, type1=0, imm5=0, Rm=0
    let encoding: u32 = 0x60000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_7_poweroftwo_0_70000000() {
    // Encoding: 0x70000000
    // Test aarch32_AND_r_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, S=0, cond=7, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x70000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_8_poweroftwo_0_80000000() {
    // Encoding: 0x80000000
    // Test aarch32_AND_r_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=8, imm5=0, type1=0, Rn=0, Rd=0
    let encoding: u32 = 0x80000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_9_poweroftwo_0_90000000() {
    // Encoding: 0x90000000
    // Test aarch32_AND_r_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rm=0, cond=9, type1=0, Rd=0, Rn=0, S=0
    let encoding: u32 = 0x90000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_10_poweroftwo_0_a0000000() {
    // Encoding: 0xA0000000
    // Test aarch32_AND_r_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, Rd=0, type1=0, S=0, Rm=0, cond=10, Rn=0
    let encoding: u32 = 0xA0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_11_poweroftwo_0_b0000000() {
    // Encoding: 0xB0000000
    // Test aarch32_AND_r_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, imm5=0, type1=0, cond=11, Rm=0, Rn=0
    let encoding: u32 = 0xB0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_12_poweroftwo_0_c0000000() {
    // Encoding: 0xC0000000
    // Test aarch32_AND_r_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, type1=0, Rm=0, imm5=0, Rd=0, cond=12
    let encoding: u32 = 0xC0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_13_poweroftwo_0_d0000000() {
    // Encoding: 0xD0000000
    // Test aarch32_AND_r_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=13, imm5=0, Rd=0, S=0, Rn=0, type1=0
    let encoding: u32 = 0xD0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_14_poweroftwo_0_e0000000() {
    // Encoding: 0xE0000000
    // Test aarch32_AND_r_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=14, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0xE0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_and_r_a1_a_field_cond_15_max_0_f0000000() {
    // Encoding: 0xF0000000
    // Test aarch32_AND_r_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: type1=0, cond=15, S=0, Rm=0, imm5=0, Rn=0, Rd=0
    let encoding: u32 = 0xF0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_and_r_a1_a_field_s_0_min_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: type1=0, Rd=0, Rm=0, Rn=0, cond=0, imm5=0, S=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_and_r_a1_a_field_s_1_max_0_00100000() {
    // Encoding: 0x00100000
    // Test aarch32_AND_r_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, imm5=0, type1=0, Rm=0, cond=0, Rn=0, S=1
    let encoding: u32 = 0x00100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_a1_a_field_rn_0_min_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, imm5=0, type1=0, S=0, Rm=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_a1_a_field_rn_1_poweroftwo_0_00010000() {
    // Encoding: 0x00010000
    // Test aarch32_AND_r_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, Rm=0, Rd=0, S=0, imm5=0, Rn=1
    let encoding: u32 = 0x00010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_a1_a_field_rd_0_min_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, S=0, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field Rd 12 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_a1_a_field_rd_1_poweroftwo_0_00001000() {
    // Encoding: 0x00001000
    // Test aarch32_AND_r_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, Rn=0, cond=0, Rd=1
    let encoding: u32 = 0x00001000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_0_zero_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field imm5 = 0 (Zero)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=0, type1=0, imm5=0, S=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_1_poweroftwo_0_00000080() {
    // Encoding: 0x00000080
    // Test aarch32_AND_r_A1_A field imm5 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=0, imm5=1, Rn=0, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x00000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_3_poweroftwominusone_0_00000180() {
    // Encoding: 0x00000180
    // Test aarch32_AND_r_A1_A field imm5 = 3 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: type1=0, imm5=3, S=0, Rd=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x00000180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_4_poweroftwo_0_00000200() {
    // Encoding: 0x00000200
    // Test aarch32_AND_r_A1_A field imm5 = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, imm5=4, Rm=0, cond=0, Rn=0, S=0, type1=0
    let encoding: u32 = 0x00000200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_7_poweroftwominusone_0_00000380() {
    // Encoding: 0x00000380
    // Test aarch32_AND_r_A1_A field imm5 = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: cond=0, S=0, Rm=0, type1=0, Rn=0, imm5=7, Rd=0
    let encoding: u32 = 0x00000380;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_8_poweroftwo_0_00000400() {
    // Encoding: 0x00000400
    // Test aarch32_AND_r_A1_A field imm5 = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, imm5=8, Rn=0, Rd=0, cond=0, type1=0
    let encoding: u32 = 0x00000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_15_poweroftwominusone_0_00000780() {
    // Encoding: 0x00000780
    // Test aarch32_AND_r_A1_A field imm5 = 15 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=0, type1=0, Rm=0, imm5=15, Rn=0
    let encoding: u32 = 0x00000780;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_16_poweroftwo_0_00000800() {
    // Encoding: 0x00000800
    // Test aarch32_AND_r_A1_A field imm5 = 16 (PowerOfTwo)
    // ISET: A32
    // Fields: imm5=16, S=0, Rd=0, type1=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x00000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field imm5 7 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_aarch32_and_r_a1_a_field_imm5_31_max_0_00000f80() {
    // Encoding: 0x00000F80
    // Test aarch32_AND_r_A1_A field imm5 = 31 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, imm5=31, S=0, type1=0, cond=0
    let encoding: u32 = 0x00000F80;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_and_r_a1_a_field_type1_0_min_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field type1 = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, S=0, Rd=0, imm5=0, type1=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_and_r_a1_a_field_type1_1_poweroftwo_0_00000020() {
    // Encoding: 0x00000020
    // Test aarch32_AND_r_A1_A field type1 = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, type1=1, Rd=0, S=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0x00000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field type1 5 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_and_r_a1_a_field_type1_3_max_0_00000060() {
    // Encoding: 0x00000060
    // Test aarch32_AND_r_A1_A field type1 = 3 (Max)
    // ISET: A32
    // Fields: S=0, type1=3, Rn=0, imm5=0, cond=0, Rm=0, Rd=0
    let encoding: u32 = 0x00000060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_a1_a_field_rm_0_min_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, Rd=0, imm5=0, cond=0, type1=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_a1_a_field_rm_1_poweroftwo_0_00000001() {
    // Encoding: 0x00000001
    // Test aarch32_AND_r_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, imm5=0, S=0, cond=0, type1=0, Rm=1
    let encoding: u32 = 0x00000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_and_r_a1_a_combo_0_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A field combination: cond=0, S=0, Rn=0, Rd=0, imm5=0, type1=0, Rm=0
    // ISET: A32
    // Fields: imm5=0, Rd=0, Rn=0, Rm=0, cond=0, type1=0, S=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_and_r_a1_a_special_cond_0_condition_eq_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: imm5=0, Rd=0, cond=0, Rn=0, type1=0, Rm=0, S=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_and_r_a1_a_special_cond_1_condition_ne_0_10000000() {
    // Encoding: 0x10000000
    // Test aarch32_AND_r_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rd=0, S=0, Rm=0, cond=1, Rn=0
    let encoding: u32 = 0x10000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_and_r_a1_a_special_cond_2_condition_cs_hs_0_20000000() {
    // Encoding: 0x20000000
    // Test aarch32_AND_r_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, imm5=0, Rm=0, S=0, type1=0, Rn=0, cond=2
    let encoding: u32 = 0x20000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_and_r_a1_a_special_cond_3_condition_cc_lo_0_30000000() {
    // Encoding: 0x30000000
    // Test aarch32_AND_r_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, cond=3, imm5=0, type1=0, Rm=0
    let encoding: u32 = 0x30000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_and_r_a1_a_special_cond_4_condition_mi_0_40000000() {
    // Encoding: 0x40000000
    // Test aarch32_AND_r_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: imm5=0, type1=0, Rm=0, S=0, cond=4, Rd=0, Rn=0
    let encoding: u32 = 0x40000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_and_r_a1_a_special_cond_5_condition_pl_0_50000000() {
    // Encoding: 0x50000000
    // Test aarch32_AND_r_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=5, type1=0, imm5=0, Rm=0, Rn=0
    let encoding: u32 = 0x50000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_and_r_a1_a_special_cond_6_condition_vs_0_60000000() {
    // Encoding: 0x60000000
    // Test aarch32_AND_r_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: type1=0, S=0, imm5=0, Rn=0, Rd=0, Rm=0, cond=6
    let encoding: u32 = 0x60000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_and_r_a1_a_special_cond_7_condition_vc_0_70000000() {
    // Encoding: 0x70000000
    // Test aarch32_AND_r_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, imm5=0, type1=0, Rm=0, Rn=0, cond=7, S=0
    let encoding: u32 = 0x70000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_and_r_a1_a_special_cond_8_condition_hi_0_80000000() {
    // Encoding: 0x80000000
    // Test aarch32_AND_r_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: type1=0, Rd=0, cond=8, imm5=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x80000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_and_r_a1_a_special_cond_9_condition_ls_0_90000000() {
    // Encoding: 0x90000000
    // Test aarch32_AND_r_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Rm=0, S=0, Rn=0, imm5=0, type1=0, cond=9
    let encoding: u32 = 0x90000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_and_r_a1_a_special_cond_10_condition_ge_0_a0000000() {
    // Encoding: 0xA0000000
    // Test aarch32_AND_r_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, type1=0, cond=10, Rd=0, imm5=0, Rm=0, S=0
    let encoding: u32 = 0xA0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_and_r_a1_a_special_cond_11_condition_lt_0_b0000000() {
    // Encoding: 0xB0000000
    // Test aarch32_AND_r_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, imm5=0, type1=0, Rd=0, cond=11
    let encoding: u32 = 0xB0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_and_r_a1_a_special_cond_12_condition_gt_0_c0000000() {
    // Encoding: 0xC0000000
    // Test aarch32_AND_r_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rn=0, S=0, type1=0, Rm=0, imm5=0, Rd=0
    let encoding: u32 = 0xC0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_and_r_a1_a_special_cond_13_condition_le_0_d0000000() {
    // Encoding: 0xD0000000
    // Test aarch32_AND_r_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, Rm=0, Rd=0, type1=0, cond=13, imm5=0, Rn=0
    let encoding: u32 = 0xD0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_and_r_a1_a_special_cond_14_condition_al_0_e0000000() {
    // Encoding: 0xE0000000
    // Test aarch32_AND_r_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, imm5=0, cond=14, type1=0, Rm=0
    let encoding: u32 = 0xE0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_and_r_a1_a_special_cond_15_condition_nv_0_f0000000() {
    // Encoding: 0xF0000000
    // Test aarch32_AND_r_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: S=0, Rd=0, imm5=0, Rn=0, type1=0, Rm=0, cond=15
    let encoding: u32 = 0xF0000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_and_r_a1_a_special_s_0_size_variant_0_0_00000000() {
    // Encoding: 0x00000000
    // Test aarch32_AND_r_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: cond=0, Rd=0, imm5=0, type1=0, Rn=0, Rm=0, S=0
    let encoding: u32 = 0x00000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_and_r_a1_a_special_s_1_size_variant_1_0_00100000() {
    // Encoding: 0x00100000
    // Test aarch32_AND_r_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, S=1, Rn=0, imm5=0, type1=0, Rm=0, Rd=0
    let encoding: u32 = 0x00100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_t1_a_field_rm_0_min_0_40000000() {
    // Thumb encoding (32): 0x40000000
    // Test aarch32_AND_r_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `field Rm 19 +: 3`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_t1_a_field_rm_1_poweroftwo_0_40080000() {
    // Thumb encoding (32): 0x40080000
    // Test aarch32_AND_r_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_and_r_t1_a_field_rdn_0_min_0_40000000() {
    // Thumb encoding (32): 0x40000000
    // Test aarch32_AND_r_T1_A field Rdn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_and_r_t1_a_field_rdn_1_poweroftwo_0_40010000() {
    // Thumb encoding (32): 0x40010000
    // Test aarch32_AND_r_T1_A field Rdn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `field Rdn 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdn", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_and_r_t1_a_field_rdn_7_max_0_40070000() {
    // Thumb encoding (32): 0x40070000
    // Test aarch32_AND_r_T1_A field Rdn = 7 (Max)
    // ISET: T32
    // Fields: Rdn=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40070000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_aarch32_and_r_t1_a_combo_0_0_40000000() {
    // Thumb encoding (32): 0x40000000
    // Test aarch32_AND_r_T1_A field combination: Rm=0, Rdn=0
    // ISET: T32
    // Fields: Rm=0, Rdn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x40000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_and_r_t2_a_field_s_0_min_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field S = 0 (Min)
    // ISET: T32
    // Fields: imm3=0, Rd=0, type1=0, S=0, Rn=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_and_r_t2_a_field_s_1_max_0_ea100000() {
    // Thumb encoding (32): 0xEA100000
    // Test aarch32_AND_r_T2_A field S = 1 (Max)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0, imm2=0, imm3=0, type1=0, S=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_t2_a_field_rn_0_min_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, type1=0, Rm=0, S=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_t2_a_field_rn_1_poweroftwo_0_ea010000() {
    // Thumb encoding (32): 0xEA010000
    // Test aarch32_AND_r_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, S=0, type1=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_and_r_t2_a_field_imm3_0_zero_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field imm3 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, Rn=0, imm3=0, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_and_r_t2_a_field_imm3_1_poweroftwo_0_ea001000() {
    // Thumb encoding (32): 0xEA001000
    // Test aarch32_AND_r_T2_A field imm3 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, S=0, Rn=0, imm2=0, type1=0, imm3=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_aarch32_and_r_t2_a_field_imm3_3_poweroftwominusone_0_ea003000() {
    // Thumb encoding (32): 0xEA003000
    // Test aarch32_AND_r_T2_A field imm3 = 3 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: S=0, Rd=0, type1=0, imm3=3, Rn=0, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA003000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm3 12 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_aarch32_and_r_t2_a_field_imm3_7_max_0_ea007000() {
    // Thumb encoding (32): 0xEA007000
    // Test aarch32_AND_r_T2_A field imm3 = 7 (Max)
    // ISET: T32
    // Fields: S=0, Rn=0, Rm=0, Rd=0, imm2=0, type1=0, imm3=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA007000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_t2_a_field_rd_0_min_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: type1=0, Rn=0, S=0, Rd=0, imm3=0, imm2=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_t2_a_field_rd_1_poweroftwo_0_ea000100() {
    // Thumb encoding (32): 0xEA000100
    // Test aarch32_AND_r_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, S=0, Rn=0, imm2=0, type1=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_aarch32_and_r_t2_a_field_imm2_0_zero_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field imm2 = 0 (Zero)
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, type1=0, Rm=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_aarch32_and_r_t2_a_field_imm2_1_poweroftwo_0_ea000040() {
    // Thumb encoding (32): 0xEA000040
    // Test aarch32_AND_r_T2_A field imm2 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rn=0, imm3=0, Rd=0, imm2=1, type1=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000040;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field imm2 6 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_aarch32_and_r_t2_a_field_imm2_3_max_0_ea0000c0() {
    // Thumb encoding (32): 0xEA0000C0
    // Test aarch32_AND_r_T2_A field imm2 = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, Rd=0, imm2=3, type1=0, S=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA0000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_and_r_t2_a_field_type1_0_min_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field type1 = 0 (Min)
    // ISET: T32
    // Fields: S=0, Rm=0, imm3=0, Rn=0, imm2=0, type1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_and_r_t2_a_field_type1_1_poweroftwo_0_ea000010() {
    // Thumb encoding (32): 0xEA000010
    // Test aarch32_AND_r_T2_A field type1 = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: S=0, Rd=0, imm3=0, Rn=0, type1=1, Rm=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field type1 4 +: 2`
/// Requirement: FieldBoundary { field: "type1", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_aarch32_and_r_t2_a_field_type1_3_max_0_ea000030() {
    // Thumb encoding (32): 0xEA000030
    // Test aarch32_AND_r_T2_A field type1 = 3 (Max)
    // ISET: T32
    // Fields: Rm=0, type1=3, S=0, Rn=0, imm3=0, Rd=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_and_r_t2_a_field_rm_0_min_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: S=0, imm2=0, imm3=0, Rn=0, Rm=0, Rd=0, type1=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_and_r_t2_a_field_rm_1_poweroftwo_0_ea000001() {
    // Thumb encoding (32): 0xEA000001
    // Test aarch32_AND_r_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: imm3=0, Rd=0, imm2=0, S=0, type1=0, Rm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// S=0 (8-bit / byte size)
#[test]
fn test_aarch32_and_r_t2_a_combo_0_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A field combination: S=0, Rn=0, imm3=0, Rd=0, imm2=0, type1=0, Rm=0
    // ISET: T32
    // Fields: S=0, imm3=0, Rd=0, Rn=0, Rm=0, type1=0, imm2=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_and_r_t2_a_special_s_0_size_variant_0_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A special value S = 0 (Size variant 0)
    // ISET: T32
    // Fields: Rm=0, type1=0, imm2=0, imm3=0, S=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_and_r_t2_a_special_s_1_size_variant_1_0_ea100000() {
    // Thumb encoding (32): 0xEA100000
    // Test aarch32_AND_r_T2_A special value S = 1 (Size variant 1)
    // ISET: T32
    // Fields: imm2=0, type1=0, Rm=0, S=1, Rd=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: \"setflags\" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_and_r_t2_a_invalid_0_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Or, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: And, lhs: LitInt(15), rhs: Unary { op: Not, operand: Var(QualifiedIdentifier { qualifier: Any, name: "setflags" }) } } }, rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, S=0, Rn=0, imm3=0, imm2=0, type1=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_and_r_t2_a_invalid_1_0_ea000000() {
    // Thumb encoding (32): 0xEA000000
    // Test aarch32_AND_r_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: S=0, Rd=0, imm2=0, type1=0, Rm=0, Rn=0, imm3=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xEA000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift (32)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_32_0_00020020() {
    // Test AND shifted 32-bit: no shift (oracle)
    // Encoding: 0x00020020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00020020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "W0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #0`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// no shift (64)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_64_0_80020020() {
    // Test AND shifted 64-bit: no shift (oracle)
    // Encoding: 0x80020020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF);
    let encoding: u32 = 0x80020020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "X0 should be 0x00000000000000FF");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSL #8 (32)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_32_1_00022020() {
    // Test AND shifted 32-bit: LSL #8 (oracle)
    // Encoding: 0x00022020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00022020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x100, "W0 should be 0x00000100");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSL #8 (64)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_64_1_80022020() {
    // Test AND shifted 64-bit: LSL #8 (oracle)
    // Encoding: 0x80022020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x80022020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x100, "X0 should be 0x0000000000000100");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSR #8 (32)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_32_2_00422020() {
    // Test AND shifted 32-bit: LSR #8 (oracle)
    // Encoding: 0x00422020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x00422020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0000, "W0 should be 0x00FF0000");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #8`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSR #8 (64)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_64_2_80422020() {
    // Test AND shifted 64-bit: LSR #8 (oracle)
    // Encoding: 0x80422020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFF000000);
    let encoding: u32 = 0x80422020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0000, "X0 should be 0x0000000000FF0000");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ASR #4 negative (32)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_32_3_00821020() {
    // Test AND shifted 32-bit: ASR #4 negative (oracle)
    // Encoding: 0x00821020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x00821020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ASR #4 negative (64)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_64_3_80821020() {
    // Test AND shifted 64-bit: ASR #4 negative (oracle)
    // Encoding: 0x80821020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x80821020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// ROR #4 (32)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_32_4_00c21020() {
    // Test AND shifted 32-bit: ROR #4 (oracle)
    // Encoding: 0x00C21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0x00C21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345670, "W0 should be 0x12345670");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND X0, X1, X2, shift #4`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// ROR #4 (64)
#[test]
fn test_aarch32_and_r_a1_a_and_shifted_oracle_64_4_80c21020() {
    // Test AND shifted 64-bit: ROR #4 (oracle)
    // Encoding: 0x80C21020
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xABCDEF01);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x80C21020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2345670, "X0 should be 0x0000000002345670");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_and_r_a1_a_a32_logical_reg_0_00010002() {
    // Test A32 AND: simple values (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x20, "R0 should be 0x00000020");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_and_r_a1_a_a32_logical_reg_1_00010002() {
    // Test A32 AND: zero values (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_and_r_a1_a_a32_logical_reg_2_00010002() {
    // Test A32 AND: max value (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "R0 should be 0x00000001");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_and_r_a1_a_a32_logical_reg_3_00010002() {
    // Test A32 AND: MSB set (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `AND R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_and_r_a1_a_a32_logical_reg_4_00010002() {
    // Test A32 AND: mixed pattern (oracle)
    // Encoding: 0x00010002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x00010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345670, "R0 should be 0x12345670");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_zeroresult_0_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_zeroresult_1_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: ZeroResult
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_negativeresult_2_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: NegativeResult
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_unsignedoverflow_3_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_unsignedoverflow_4_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_signedoverflow_5_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_and_r_a1_a_flags_signedoverflow_6_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: SignedOverflow
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_and_r_a1_a_flags_positiveresult_7_00110002() {
    // Test aarch32_AND_r_A1_A flag computation: PositiveResult
    // Encoding: 0x00110002
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_32_0_40020020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_64_0_c0020020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_32_1_40020020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_64_1_c0020020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_32_2_40020020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_64_2_c0020020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_32_3_40020020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_64_3_c0020020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_32_4_40020020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_64_4_c0020020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_32_5_40020020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_and_r_t1_a_lslv_oracle_64_5_c0020020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x20);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_and_r_t1_a_t16_oracle_0_40100000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_and_r_t1_a_t16_oracle_1_40100000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_and_r_t1_a_t16_oracle_2_40100000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_and_r_t1_a_t16_oracle_3_40100000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_zeroresult_0_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_zeroresult_1_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_negativeresult_2_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_unsignedoverflow_3_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_unsignedoverflow_4_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_signedoverflow_5_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_and_r_t1_a_flags_signedoverflow_6_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_and_r_t1_a_flags_positiveresult_7_40100000() {
    // Test aarch32_AND_r_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_zeroresult_0_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_zeroresult_1_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_negativeresult_2_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_unsignedoverflow_3_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_unsignedoverflow_4_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_signedoverflow_5_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_and_r_t2_a_flags_signedoverflow_6_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
}

/// Provenance: aarch32_AND_r_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_and_r_t2_a_flags_positiveresult_7_ea110002() {
    // Test aarch32_AND_r_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xEA110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
}
