//! A32 multiply mul tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers_32::*;

// ============================================================================
// aarch32_SMLALD_A Tests
// ============================================================================

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_0_min_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, RdHi=0, Rn=0, cond=0, M=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_1_poweroftwo_10_17400010() {
    // Encoding: 0x17400010
    // Test aarch32_SMLALD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=1, RdHi=0, Rn=0, RdLo=0, Rm=0
    let encoding: u32 = 0x17400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_2_poweroftwo_10_27400010() {
    // Encoding: 0x27400010
    // Test aarch32_SMLALD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, RdHi=0, RdLo=0, M=0, Rm=0, Rn=0
    let encoding: u32 = 0x27400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_3_poweroftwo_10_37400010() {
    // Encoding: 0x37400010
    // Test aarch32_SMLALD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, RdLo=0, RdHi=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x37400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_4_poweroftwo_10_47400010() {
    // Encoding: 0x47400010
    // Test aarch32_SMLALD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, Rm=0, cond=4, RdHi=0, M=0
    let encoding: u32 = 0x47400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_5_poweroftwo_10_57400010() {
    // Encoding: 0x57400010
    // Test aarch32_SMLALD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, RdHi=0, Rn=0, RdLo=0, cond=5, Rm=0
    let encoding: u32 = 0x57400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_6_poweroftwo_10_67400010() {
    // Encoding: 0x67400010
    // Test aarch32_SMLALD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, RdLo=0, Rm=0, RdHi=0, Rn=0, cond=6
    let encoding: u32 = 0x67400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_7_poweroftwo_10_77400010() {
    // Encoding: 0x77400010
    // Test aarch32_SMLALD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, M=0, Rn=0, cond=7, RdHi=0
    let encoding: u32 = 0x77400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_8_poweroftwo_10_87400010() {
    // Encoding: 0x87400010
    // Test aarch32_SMLALD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, RdLo=0, M=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x87400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_9_poweroftwo_10_97400010() {
    // Encoding: 0x97400010
    // Test aarch32_SMLALD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, RdLo=0, RdHi=0, cond=9, Rn=0, Rm=0
    let encoding: u32 = 0x97400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_10_poweroftwo_10_a7400010() {
    // Encoding: 0xA7400010
    // Test aarch32_SMLALD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rm=0, Rn=0, cond=10, M=0
    let encoding: u32 = 0xA7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_11_poweroftwo_10_b7400010() {
    // Encoding: 0xB7400010
    // Test aarch32_SMLALD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rm=0, M=0, cond=11, Rn=0
    let encoding: u32 = 0xB7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_12_poweroftwo_10_c7400010() {
    // Encoding: 0xC7400010
    // Test aarch32_SMLALD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=12, M=0, RdHi=0, Rn=0, Rm=0
    let encoding: u32 = 0xC7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_13_poweroftwo_10_d7400010() {
    // Encoding: 0xD7400010
    // Test aarch32_SMLALD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, RdLo=0, RdHi=0, M=0, Rm=0
    let encoding: u32 = 0xD7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_14_poweroftwo_10_e7400010() {
    // Encoding: 0xE7400010
    // Test aarch32_SMLALD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=14, RdLo=0, Rn=0, RdHi=0, M=0
    let encoding: u32 = 0xE7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlald_a1_a_field_cond_15_max_10_f7400010() {
    // Encoding: 0xF7400010
    // Test aarch32_SMLALD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, cond=15, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xF7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlald_a1_a_field_rdhi_0_min_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rm=0, M=0, cond=0, Rn=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlald_a1_a_field_rdhi_1_poweroftwo_10_07410010() {
    // Encoding: 0x07410010
    // Test aarch32_SMLALD_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, RdHi=1, M=0, Rm=0, RdLo=0, Rn=0
    let encoding: u32 = 0x07410010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlald_a1_a_field_rdhi_7_poweroftwominusone_10_07470010() {
    // Encoding: 0x07470010
    // Test aarch32_SMLALD_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdLo=0, M=0, cond=0, RdHi=7, Rn=0, Rm=0
    let encoding: u32 = 0x07470010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlald_a1_a_field_rdhi_15_max_10_074f0010() {
    // Encoding: 0x074F0010
    // Test aarch32_SMLALD_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: RdLo=0, M=0, cond=0, RdHi=15, Rn=0, Rm=0
    let encoding: u32 = 0x074F0010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlald_a1_a_field_rdlo_0_min_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, cond=0, M=0, Rm=0, Rn=0, RdHi=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlald_a1_a_field_rdlo_1_poweroftwo_10_07401010() {
    // Encoding: 0x07401010
    // Test aarch32_SMLALD_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=1, Rm=0, M=0, cond=0, Rn=0, RdHi=0
    let encoding: u32 = 0x07401010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlald_a1_a_field_rdlo_7_poweroftwominusone_10_07407010() {
    // Encoding: 0x07407010
    // Test aarch32_SMLALD_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, Rn=0, M=0, cond=0, RdLo=7
    let encoding: u32 = 0x07407010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlald_a1_a_field_rdlo_15_max_10_0740f010() {
    // Encoding: 0x0740F010
    // Test aarch32_SMLALD_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: cond=0, RdHi=0, Rm=0, M=0, Rn=0, RdLo=15
    let encoding: u32 = 0x0740F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlald_a1_a_field_rm_0_min_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, RdLo=0, Rm=0, RdHi=0, M=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlald_a1_a_field_rm_1_poweroftwo_10_07400110() {
    // Encoding: 0x07400110
    // Test aarch32_SMLALD_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, RdHi=0, Rn=0, Rm=1, cond=0, RdLo=0
    let encoding: u32 = 0x07400110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlald_a1_a_field_m_0_min_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=0, RdLo=0, RdHi=0, Rm=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlald_a1_a_field_m_1_max_10_07400030() {
    // Encoding: 0x07400030
    // Test aarch32_SMLALD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: RdHi=0, cond=0, Rm=0, RdLo=0, Rn=0, M=1
    let encoding: u32 = 0x07400030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlald_a1_a_field_rn_0_min_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=0, RdHi=0, Rm=0, M=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlald_a1_a_field_rn_1_poweroftwo_10_07400011() {
    // Encoding: 0x07400011
    // Test aarch32_SMLALD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, M=0, RdLo=0, Rm=0, RdHi=0, Rn=1
    let encoding: u32 = 0x07400011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlald_a1_a_combo_0_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A field combination: cond=0, RdHi=0, RdLo=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: M=0, cond=0, RdLo=0, Rm=0, Rn=0, RdHi=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlald_a1_a_special_cond_0_condition_eq_16_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, Rm=0, RdLo=0, M=0, cond=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlald_a1_a_special_cond_1_condition_ne_16_17400010() {
    // Encoding: 0x17400010
    // Test aarch32_SMLALD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: RdHi=0, cond=1, Rm=0, M=0, Rn=0, RdLo=0
    let encoding: u32 = 0x17400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlald_a1_a_special_cond_2_condition_cs_hs_16_27400010() {
    // Encoding: 0x27400010
    // Test aarch32_SMLALD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, M=0, cond=2, Rn=0, RdLo=0
    let encoding: u32 = 0x27400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlald_a1_a_special_cond_3_condition_cc_lo_16_37400010() {
    // Encoding: 0x37400010
    // Test aarch32_SMLALD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, M=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x37400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlald_a1_a_special_cond_4_condition_mi_16_47400010() {
    // Encoding: 0x47400010
    // Test aarch32_SMLALD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: RdHi=0, Rn=0, M=0, Rm=0, cond=4, RdLo=0
    let encoding: u32 = 0x47400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlald_a1_a_special_cond_5_condition_pl_16_57400010() {
    // Encoding: 0x57400010
    // Test aarch32_SMLALD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: RdLo=0, cond=5, RdHi=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x57400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlald_a1_a_special_cond_6_condition_vs_16_67400010() {
    // Encoding: 0x67400010
    // Test aarch32_SMLALD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, M=0, cond=6, RdHi=0, Rm=0
    let encoding: u32 = 0x67400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlald_a1_a_special_cond_7_condition_vc_16_77400010() {
    // Encoding: 0x77400010
    // Test aarch32_SMLALD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=7, Rm=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x77400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlald_a1_a_special_cond_8_condition_hi_16_87400010() {
    // Encoding: 0x87400010
    // Test aarch32_SMLALD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, Rm=0, cond=8, M=0, RdHi=0
    let encoding: u32 = 0x87400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlald_a1_a_special_cond_9_condition_ls_16_97400010() {
    // Encoding: 0x97400010
    // Test aarch32_SMLALD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rm=0, RdLo=0, RdHi=0, M=0, Rn=0
    let encoding: u32 = 0x97400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlald_a1_a_special_cond_10_condition_ge_16_a7400010() {
    // Encoding: 0xA7400010
    // Test aarch32_SMLALD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, M=0, RdHi=0, RdLo=0, cond=10, Rm=0
    let encoding: u32 = 0xA7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlald_a1_a_special_cond_11_condition_lt_16_b7400010() {
    // Encoding: 0xB7400010
    // Test aarch32_SMLALD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: M=0, Rm=0, cond=11, RdHi=0, Rn=0, RdLo=0
    let encoding: u32 = 0xB7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlald_a1_a_special_cond_12_condition_gt_16_c7400010() {
    // Encoding: 0xC7400010
    // Test aarch32_SMLALD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, M=0, RdLo=0, Rn=0, RdHi=0
    let encoding: u32 = 0xC7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlald_a1_a_special_cond_13_condition_le_16_d7400010() {
    // Encoding: 0xD7400010
    // Test aarch32_SMLALD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rm=0, M=0, Rn=0, cond=13
    let encoding: u32 = 0xD7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlald_a1_a_special_cond_14_condition_al_16_e7400010() {
    // Encoding: 0xE7400010
    // Test aarch32_SMLALD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, M=0, cond=14, RdHi=0, Rn=0
    let encoding: u32 = 0xE7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlald_a1_a_special_cond_15_condition_nv_16_f7400010() {
    // Encoding: 0xF7400010
    // Test aarch32_SMLALD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, RdLo=0, M=0, cond=15, Rn=0
    let encoding: u32 = 0xF7400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_a1_a_invalid_0_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rm=0, RdLo=0, M=0, RdHi=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_a1_a_invalid_1_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, RdHi=0, M=0, RdLo=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_a1_a_invalid_2_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: RdHi=0, M=0, cond=0, Rm=0, Rn=0, RdLo=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_a1_a_invalid_3_10_07400010() {
    // Encoding: 0x07400010
    // Test aarch32_SMLALD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, RdLo=0, RdHi=0, cond=0, Rm=0, M=0
    let encoding: u32 = 0x07400010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlald_t1_a_field_rn_0_min_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, RdLo=0, Rn=0, M=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlald_t1_a_field_rn_1_poweroftwo_c0_fbc100c0() {
    // Thumb encoding (32): 0xFBC100C0
    // Test aarch32_SMLALD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, M=0, RdHi=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC100C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlald_t1_a_field_rdlo_0_min_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, RdLo=0, Rm=0, M=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlald_t1_a_field_rdlo_1_poweroftwo_c0_fbc010c0() {
    // Thumb encoding (32): 0xFBC010C0
    // Test aarch32_SMLALD_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdLo=1, Rm=0, M=0, RdHi=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC010C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlald_t1_a_field_rdlo_7_poweroftwominusone_c0_fbc070c0() {
    // Thumb encoding (32): 0xFBC070C0
    // Test aarch32_SMLALD_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M=0, RdLo=7, Rn=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC070C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlald_t1_a_field_rdlo_15_max_c0_fbc0f0c0() {
    // Thumb encoding (32): 0xFBC0F0C0
    // Test aarch32_SMLALD_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, RdLo=15, RdHi=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC0F0C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlald_t1_a_field_rdhi_0_min_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: RdHi=0, Rn=0, M=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlald_t1_a_field_rdhi_1_poweroftwo_c0_fbc001c0() {
    // Thumb encoding (32): 0xFBC001C0
    // Test aarch32_SMLALD_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, RdLo=0, Rn=0, RdHi=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC001C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlald_t1_a_field_rdhi_7_poweroftwominusone_c0_fbc007c0() {
    // Thumb encoding (32): 0xFBC007C0
    // Test aarch32_SMLALD_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M=0, Rn=0, RdLo=0, RdHi=7, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlald_t1_a_field_rdhi_15_max_c0_fbc00fc0() {
    // Thumb encoding (32): 0xFBC00FC0
    // Test aarch32_SMLALD_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: RdLo=0, RdHi=15, M=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00FC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlald_t1_a_field_m_0_min_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, M=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlald_t1_a_field_m_1_max_c0_fbc000d0() {
    // Thumb encoding (32): 0xFBC000D0
    // Test aarch32_SMLALD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: RdLo=0, Rm=0, Rn=0, M=1, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlald_t1_a_field_rm_0_min_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, RdHi=0, Rn=0, RdLo=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlald_t1_a_field_rm_1_poweroftwo_c0_fbc000c1() {
    // Thumb encoding (32): 0xFBC000C1
    // Test aarch32_SMLALD_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdHi=0, Rn=0, RdLo=0, M=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlald_t1_a_combo_0_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A field combination: Rn=0, RdLo=0, RdHi=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rm=0, M=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_t1_a_invalid_0_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, RdLo=0, M=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_t1_a_invalid_1_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdHi=0, RdLo=0, Rn=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_t1_a_invalid_2_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rm=0, RdLo=0, RdHi=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLALD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlald_t1_a_invalid_3_c0_fbc000c0() {
    // Thumb encoding (32): 0xFBC000C0
    // Test aarch32_SMLALD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, M=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMMUL_A Tests
// ============================================================================

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_0_min_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rm=0, R=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_1_poweroftwo_f010_1750f010() {
    // Encoding: 0x1750F010
    // Test aarch32_SMMUL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, R=0, cond=1
    let encoding: u32 = 0x1750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_2_poweroftwo_f010_2750f010() {
    // Encoding: 0x2750F010
    // Test aarch32_SMMUL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, R=0, Rd=0, cond=2
    let encoding: u32 = 0x2750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_3_poweroftwo_f010_3750f010() {
    // Encoding: 0x3750F010
    // Test aarch32_SMMUL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rm=0, Rd=0, R=0, Rn=0
    let encoding: u32 = 0x3750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_4_poweroftwo_f010_4750f010() {
    // Encoding: 0x4750F010
    // Test aarch32_SMMUL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, Rn=0, Rm=0, cond=4
    let encoding: u32 = 0x4750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_5_poweroftwo_f010_5750f010() {
    // Encoding: 0x5750F010
    // Test aarch32_SMMUL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=5, Rd=0, R=0
    let encoding: u32 = 0x5750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_6_poweroftwo_f010_6750f010() {
    // Encoding: 0x6750F010
    // Test aarch32_SMMUL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=6, Rm=0, Rn=0
    let encoding: u32 = 0x6750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_7_poweroftwo_f010_7750f010() {
    // Encoding: 0x7750F010
    // Test aarch32_SMMUL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, R=0, Rm=0, Rd=0
    let encoding: u32 = 0x7750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_8_poweroftwo_f010_8750f010() {
    // Encoding: 0x8750F010
    // Test aarch32_SMMUL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=8, R=0, Rd=0
    let encoding: u32 = 0x8750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_9_poweroftwo_f010_9750f010() {
    // Encoding: 0x9750F010
    // Test aarch32_SMMUL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=9, Rm=0, R=0
    let encoding: u32 = 0x9750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_10_poweroftwo_f010_a750f010() {
    // Encoding: 0xA750F010
    // Test aarch32_SMMUL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rd=0, R=0, Rm=0
    let encoding: u32 = 0xA750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_11_poweroftwo_f010_b750f010() {
    // Encoding: 0xB750F010
    // Test aarch32_SMMUL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=11, Rm=0, Rn=0
    let encoding: u32 = 0xB750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_12_poweroftwo_f010_c750f010() {
    // Encoding: 0xC750F010
    // Test aarch32_SMMUL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=12, Rm=0, R=0
    let encoding: u32 = 0xC750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_13_poweroftwo_f010_d750f010() {
    // Encoding: 0xD750F010
    // Test aarch32_SMMUL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, cond=13, Rn=0, Rm=0
    let encoding: u32 = 0xD750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_14_poweroftwo_f010_e750f010() {
    // Encoding: 0xE750F010
    // Test aarch32_SMMUL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=14, R=0, Rm=0, Rn=0
    let encoding: u32 = 0xE750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smmul_a1_a_field_cond_15_max_f010_f750f010() {
    // Encoding: 0xF750F010
    // Test aarch32_SMMUL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: R=0, cond=15, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0xF750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmul_a1_a_field_rd_0_min_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, R=0, Rn=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmul_a1_a_field_rd_1_poweroftwo_f010_0751f010() {
    // Encoding: 0x0751F010
    // Test aarch32_SMMUL_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, cond=0, Rm=0, Rn=0, R=0
    let encoding: u32 = 0x0751F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmul_a1_a_field_rm_0_min_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: R=0, Rn=0, Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmul_a1_a_field_rm_1_poweroftwo_f010_0750f110() {
    // Encoding: 0x0750F110
    // Test aarch32_SMMUL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=1, R=0, cond=0
    let encoding: u32 = 0x0750F110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field R 5 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smmul_a1_a_field_r_0_min_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A field R = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, R=0, Rn=0, cond=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field R 5 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smmul_a1_a_field_r_1_max_f010_0750f030() {
    // Encoding: 0x0750F030
    // Test aarch32_SMMUL_A1_A field R = 1 (Max)
    // ISET: A32
    // Fields: cond=0, R=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x0750F030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmul_a1_a_field_rn_0_min_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, R=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmul_a1_a_field_rn_1_poweroftwo_f010_0750f011() {
    // Encoding: 0x0750F011
    // Test aarch32_SMMUL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, R=0, Rn=1
    let encoding: u32 = 0x0750F011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smmul_a1_a_combo_0_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A field combination: cond=0, Rd=0, Rm=0, R=0, Rn=0
    // ISET: A32
    // Fields: cond=0, R=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smmul_a1_a_special_cond_0_condition_eq_61456_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rm=0, R=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smmul_a1_a_special_cond_1_condition_ne_61456_1750f010() {
    // Encoding: 0x1750F010
    // Test aarch32_SMMUL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: R=0, cond=1, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x1750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smmul_a1_a_special_cond_2_condition_cs_hs_61456_2750f010() {
    // Encoding: 0x2750F010
    // Test aarch32_SMMUL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: R=0, Rm=0, Rd=0, Rn=0, cond=2
    let encoding: u32 = 0x2750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smmul_a1_a_special_cond_3_condition_cc_lo_61456_3750f010() {
    // Encoding: 0x3750F010
    // Test aarch32_SMMUL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, R=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x3750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smmul_a1_a_special_cond_4_condition_mi_61456_4750f010() {
    // Encoding: 0x4750F010
    // Test aarch32_SMMUL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rm=0, R=0, Rd=0
    let encoding: u32 = 0x4750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smmul_a1_a_special_cond_5_condition_pl_61456_5750f010() {
    // Encoding: 0x5750F010
    // Test aarch32_SMMUL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, cond=5, Rm=0, R=0, Rn=0
    let encoding: u32 = 0x5750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smmul_a1_a_special_cond_6_condition_vs_61456_6750f010() {
    // Encoding: 0x6750F010
    // Test aarch32_SMMUL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, Rn=0, Rm=0, R=0
    let encoding: u32 = 0x6750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smmul_a1_a_special_cond_7_condition_vc_61456_7750f010() {
    // Encoding: 0x7750F010
    // Test aarch32_SMMUL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, R=0, Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x7750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smmul_a1_a_special_cond_8_condition_hi_61456_8750f010() {
    // Encoding: 0x8750F010
    // Test aarch32_SMMUL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, R=0, Rm=0, Rn=0, cond=8
    let encoding: u32 = 0x8750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smmul_a1_a_special_cond_9_condition_ls_61456_9750f010() {
    // Encoding: 0x9750F010
    // Test aarch32_SMMUL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, cond=9, Rm=0, Rn=0, R=0
    let encoding: u32 = 0x9750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smmul_a1_a_special_cond_10_condition_ge_61456_a750f010() {
    // Encoding: 0xA750F010
    // Test aarch32_SMMUL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, R=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0xA750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smmul_a1_a_special_cond_11_condition_lt_61456_b750f010() {
    // Encoding: 0xB750F010
    // Test aarch32_SMMUL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, R=0, Rn=0, cond=11, Rd=0
    let encoding: u32 = 0xB750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smmul_a1_a_special_cond_12_condition_gt_61456_c750f010() {
    // Encoding: 0xC750F010
    // Test aarch32_SMMUL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rn=0, Rd=0, R=0
    let encoding: u32 = 0xC750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smmul_a1_a_special_cond_13_condition_le_61456_d750f010() {
    // Encoding: 0xD750F010
    // Test aarch32_SMMUL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: R=0, cond=13, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xD750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smmul_a1_a_special_cond_14_condition_al_61456_e750f010() {
    // Encoding: 0xE750F010
    // Test aarch32_SMMUL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=14, Rd=0, R=0
    let encoding: u32 = 0xE750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smmul_a1_a_special_cond_15_condition_nv_61456_f750f010() {
    // Encoding: 0xF750F010
    // Test aarch32_SMMUL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, R=0, Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmul_a1_a_invalid_0_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, R=0, Rm=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMUL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmul_a1_a_invalid_1_f010_0750f010() {
    // Encoding: 0x0750F010
    // Test aarch32_SMMUL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: R=0, cond=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x0750F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmul_t1_a_field_rn_0_min_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, R=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmul_t1_a_field_rn_1_poweroftwo_f000_fb51f000() {
    // Thumb encoding (32): 0xFB51F000
    // Test aarch32_SMMUL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Rd=0, R=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB51F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmul_t1_a_field_rd_0_min_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmul_t1_a_field_rd_1_poweroftwo_f000_fb50f100() {
    // Thumb encoding (32): 0xFB50F100
    // Test aarch32_SMMUL_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, R=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field R 4 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smmul_t1_a_field_r_0_min_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A field R = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field R 4 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smmul_t1_a_field_r_1_max_f000_fb50f010() {
    // Thumb encoding (32): 0xFB50F010
    // Test aarch32_SMMUL_T1_A field R = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, R=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmul_t1_a_field_rm_0_min_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmul_t1_a_field_rm_1_poweroftwo_f000_fb50f001() {
    // Thumb encoding (32): 0xFB50F001
    // Test aarch32_SMMUL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=1, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smmul_t1_a_combo_0_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A field combination: Rn=0, Rd=0, R=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rm=0, R=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmul_t1_a_invalid_0_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMUL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmul_t1_a_invalid_1_f000_fb50f000() {
    // Thumb encoding (32): 0xFB50F000
    // Test aarch32_SMMUL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: R=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB50F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMULL_A Tests
// ============================================================================

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smull_a1_a_field_cond_0_min_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, RdLo=0, Rn=0, cond=0, S=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smull_a1_a_field_cond_1_poweroftwo_90_10c00090() {
    // Encoding: 0x10C00090
    // Test aarch32_SMULL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, Rn=0, cond=1, S=0, RdHi=0
    let encoding: u32 = 0x10C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smull_a1_a_field_cond_2_poweroftwo_90_20c00090() {
    // Encoding: 0x20C00090
    // Test aarch32_SMULL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=2, RdLo=0, S=0, Rm=0, Rn=0
    let encoding: u32 = 0x20C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smull_a1_a_field_cond_3_poweroftwo_90_30c00090() {
    // Encoding: 0x30C00090
    // Test aarch32_SMULL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, RdHi=0, Rm=0, Rn=0, RdLo=0, S=0
    let encoding: u32 = 0x30C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smull_a1_a_field_cond_4_poweroftwo_90_40c00090() {
    // Encoding: 0x40C00090
    // Test aarch32_SMULL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, RdHi=0, cond=4, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x40C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smull_a1_a_field_cond_5_poweroftwo_90_50c00090() {
    // Encoding: 0x50C00090
    // Test aarch32_SMULL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=5, RdHi=0, Rm=0, RdLo=0
    let encoding: u32 = 0x50C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smull_a1_a_field_cond_6_poweroftwo_90_60c00090() {
    // Encoding: 0x60C00090
    // Test aarch32_SMULL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, RdLo=0, cond=6, Rn=0, RdHi=0, Rm=0
    let encoding: u32 = 0x60C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smull_a1_a_field_cond_7_poweroftwo_90_70c00090() {
    // Encoding: 0x70C00090
    // Test aarch32_SMULL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, Rn=0, S=0, RdLo=0, cond=7
    let encoding: u32 = 0x70C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smull_a1_a_field_cond_8_poweroftwo_90_80c00090() {
    // Encoding: 0x80C00090
    // Test aarch32_SMULL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, S=0, Rm=0, RdHi=0, RdLo=0, Rn=0
    let encoding: u32 = 0x80C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smull_a1_a_field_cond_9_poweroftwo_90_90c00090() {
    // Encoding: 0x90C00090
    // Test aarch32_SMULL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, S=0, RdHi=0, RdLo=0, Rm=0
    let encoding: u32 = 0x90C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smull_a1_a_field_cond_10_poweroftwo_90_a0c00090() {
    // Encoding: 0xA0C00090
    // Test aarch32_SMULL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rm=0, RdLo=0, S=0, Rn=0, RdHi=0
    let encoding: u32 = 0xA0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smull_a1_a_field_cond_11_poweroftwo_90_b0c00090() {
    // Encoding: 0xB0C00090
    // Test aarch32_SMULL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, RdLo=0, RdHi=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0xB0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smull_a1_a_field_cond_12_poweroftwo_90_c0c00090() {
    // Encoding: 0xC0C00090
    // Test aarch32_SMULL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, RdLo=0, RdHi=0, cond=12, Rm=0, Rn=0
    let encoding: u32 = 0xC0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smull_a1_a_field_cond_13_poweroftwo_90_d0c00090() {
    // Encoding: 0xD0C00090
    // Test aarch32_SMULL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, RdHi=0, S=0, cond=13, Rn=0
    let encoding: u32 = 0xD0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smull_a1_a_field_cond_14_poweroftwo_90_e0c00090() {
    // Encoding: 0xE0C00090
    // Test aarch32_SMULL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=14, Rm=0, RdLo=0, RdHi=0
    let encoding: u32 = 0xE0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smull_a1_a_field_cond_15_max_90_f0c00090() {
    // Encoding: 0xF0C00090
    // Test aarch32_SMULL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, S=0, RdHi=0, cond=15, Rn=0
    let encoding: u32 = 0xF0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_smull_a1_a_field_s_0_min_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, RdLo=0, Rm=0, RdHi=0, Rn=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_smull_a1_a_field_s_1_max_90_00d00090() {
    // Encoding: 0x00D00090
    // Test aarch32_SMULL_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: RdHi=0, S=1, RdLo=0, Rn=0, Rm=0, cond=0
    let encoding: u32 = 0x00D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smull_a1_a_field_rdhi_0_min_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, RdHi=0, RdLo=0, cond=0, Rn=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smull_a1_a_field_rdhi_1_poweroftwo_90_00c10090() {
    // Encoding: 0x00C10090
    // Test aarch32_SMULL_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=1, S=0, RdLo=0, Rn=0, cond=0
    let encoding: u32 = 0x00C10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smull_a1_a_field_rdhi_7_poweroftwominusone_90_00c70090() {
    // Encoding: 0x00C70090
    // Test aarch32_SMULL_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdHi=7, Rn=0, Rm=0, cond=0, S=0, RdLo=0
    let encoding: u32 = 0x00C70090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smull_a1_a_field_rdhi_15_max_90_00cf0090() {
    // Encoding: 0x00CF0090
    // Test aarch32_SMULL_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: S=0, RdLo=0, Rm=0, cond=0, Rn=0, RdHi=15
    let encoding: u32 = 0x00CF0090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smull_a1_a_field_rdlo_0_min_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, cond=0, S=0, RdHi=0, Rm=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smull_a1_a_field_rdlo_1_poweroftwo_90_00c01090() {
    // Encoding: 0x00C01090
    // Test aarch32_SMULL_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, Rn=0, cond=0, S=0, RdLo=1, Rm=0
    let encoding: u32 = 0x00C01090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smull_a1_a_field_rdlo_7_poweroftwominusone_90_00c07090() {
    // Encoding: 0x00C07090
    // Test aarch32_SMULL_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=0, Rn=0, RdHi=0, RdLo=7
    let encoding: u32 = 0x00C07090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smull_a1_a_field_rdlo_15_max_90_00c0f090() {
    // Encoding: 0x00C0F090
    // Test aarch32_SMULL_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: S=0, RdLo=15, Rn=0, RdHi=0, cond=0, Rm=0
    let encoding: u32 = 0x00C0F090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smull_a1_a_field_rm_0_min_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, RdLo=0, Rm=0, RdHi=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smull_a1_a_field_rm_1_poweroftwo_90_00c00190() {
    // Encoding: 0x00C00190
    // Test aarch32_SMULL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=0, Rm=1, RdHi=0, S=0
    let encoding: u32 = 0x00C00190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smull_a1_a_field_rn_0_min_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, RdHi=0, S=0, RdLo=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smull_a1_a_field_rn_1_poweroftwo_90_00c00091() {
    // Encoding: 0x00C00091
    // Test aarch32_SMULL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, S=0, RdLo=0, Rm=0, RdHi=0, Rn=1
    let encoding: u32 = 0x00C00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smull_a1_a_combo_0_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A field combination: cond=0, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=0, RdHi=0, Rm=0, S=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smull_a1_a_special_cond_0_condition_eq_144_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, S=0, Rn=0, RdLo=0, cond=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smull_a1_a_special_cond_1_condition_ne_144_10c00090() {
    // Encoding: 0x10C00090
    // Test aarch32_SMULL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rm=0, Rn=0, RdLo=0, S=0, RdHi=0
    let encoding: u32 = 0x10C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smull_a1_a_special_cond_2_condition_cs_hs_144_20c00090() {
    // Encoding: 0x20C00090
    // Test aarch32_SMULL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, Rn=0, S=0, RdHi=0, cond=2
    let encoding: u32 = 0x20C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smull_a1_a_special_cond_3_condition_cc_lo_144_30c00090() {
    // Encoding: 0x30C00090
    // Test aarch32_SMULL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, S=0, RdLo=0, Rm=0, RdHi=0, Rn=0
    let encoding: u32 = 0x30C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smull_a1_a_special_cond_4_condition_mi_144_40c00090() {
    // Encoding: 0x40C00090
    // Test aarch32_SMULL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: RdLo=0, cond=4, Rn=0, RdHi=0, S=0, Rm=0
    let encoding: u32 = 0x40C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smull_a1_a_special_cond_5_condition_pl_144_50c00090() {
    // Encoding: 0x50C00090
    // Test aarch32_SMULL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rm=0, Rn=0, RdHi=0, RdLo=0, S=0
    let encoding: u32 = 0x50C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smull_a1_a_special_cond_6_condition_vs_144_60c00090() {
    // Encoding: 0x60C00090
    // Test aarch32_SMULL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: RdLo=0, S=0, RdHi=0, Rm=0, Rn=0, cond=6
    let encoding: u32 = 0x60C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smull_a1_a_special_cond_7_condition_vc_144_70c00090() {
    // Encoding: 0x70C00090
    // Test aarch32_SMULL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=7, RdHi=0, Rm=0, RdLo=0
    let encoding: u32 = 0x70C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smull_a1_a_special_cond_8_condition_hi_144_80c00090() {
    // Encoding: 0x80C00090
    // Test aarch32_SMULL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: RdLo=0, cond=8, S=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x80C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smull_a1_a_special_cond_9_condition_ls_144_90c00090() {
    // Encoding: 0x90C00090
    // Test aarch32_SMULL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, S=0, cond=9, Rm=0, Rn=0
    let encoding: u32 = 0x90C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smull_a1_a_special_cond_10_condition_ge_144_a0c00090() {
    // Encoding: 0xA0C00090
    // Test aarch32_SMULL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, cond=10, RdLo=0, Rn=0, S=0
    let encoding: u32 = 0xA0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smull_a1_a_special_cond_11_condition_lt_144_b0c00090() {
    // Encoding: 0xB0C00090
    // Test aarch32_SMULL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0xB0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smull_a1_a_special_cond_12_condition_gt_144_c0c00090() {
    // Encoding: 0xC0C00090
    // Test aarch32_SMULL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, RdHi=0, cond=12, Rm=0, S=0
    let encoding: u32 = 0xC0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smull_a1_a_special_cond_13_condition_le_144_d0c00090() {
    // Encoding: 0xD0C00090
    // Test aarch32_SMULL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, cond=13, RdHi=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0xD0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smull_a1_a_special_cond_14_condition_al_144_e0c00090() {
    // Encoding: 0xE0C00090
    // Test aarch32_SMULL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: S=0, RdHi=0, RdLo=0, cond=14, Rn=0, Rm=0
    let encoding: u32 = 0xE0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smull_a1_a_special_cond_15_condition_nv_144_f0c00090() {
    // Encoding: 0xF0C00090
    // Test aarch32_SMULL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, RdLo=0, Rn=0, S=0, Rm=0, RdHi=0
    let encoding: u32 = 0xF0C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_smull_a1_a_special_s_0_size_variant_0_144_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: RdLo=0, cond=0, Rm=0, RdHi=0, S=0, Rn=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_smull_a1_a_special_s_1_size_variant_1_144_00d00090() {
    // Encoding: 0x00D00090
    // Test aarch32_SMULL_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, cond=0, RdHi=0, Rn=0, Rm=0, RdLo=0
    let encoding: u32 = 0x00D00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_a1_a_invalid_0_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: RdLo=0, S=0, Rn=0, cond=0, Rm=0, RdHi=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_a1_a_invalid_1_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, RdLo=0, RdHi=0, S=0, Rm=0, Rn=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_a1_a_invalid_2_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: S=0, Rm=0, cond=0, RdLo=0, Rn=0, RdHi=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_a1_a_invalid_3_90_00c00090() {
    // Encoding: 0x00C00090
    // Test aarch32_SMULL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: S=0, cond=0, Rn=0, RdLo=0, RdHi=0, Rm=0
    let encoding: u32 = 0x00C00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smull_t1_a_field_rn_0_min_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smull_t1_a_field_rn_1_poweroftwo_0_fb810000() {
    // Thumb encoding (32): 0xFB810000
    // Test aarch32_SMULL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdLo=0, Rn=1, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB810000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smull_t1_a_field_rdlo_0_min_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, RdLo=0, Rm=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smull_t1_a_field_rdlo_1_poweroftwo_0_fb801000() {
    // Thumb encoding (32): 0xFB801000
    // Test aarch32_SMULL_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, RdLo=1, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB801000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smull_t1_a_field_rdlo_7_poweroftwominusone_0_fb807000() {
    // Thumb encoding (32): 0xFB807000
    // Test aarch32_SMULL_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=7, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB807000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smull_t1_a_field_rdlo_15_max_0_fb80f000() {
    // Thumb encoding (32): 0xFB80F000
    // Test aarch32_SMULL_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: RdLo=15, Rm=0, RdHi=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB80F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smull_t1_a_field_rdhi_0_min_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smull_t1_a_field_rdhi_1_poweroftwo_0_fb800100() {
    // Thumb encoding (32): 0xFB800100
    // Test aarch32_SMULL_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=0, RdHi=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smull_t1_a_field_rdhi_7_poweroftwominusone_0_fb800700() {
    // Thumb encoding (32): 0xFB800700
    // Test aarch32_SMULL_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, RdHi=7, RdLo=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smull_t1_a_field_rdhi_15_max_0_fb800f00() {
    // Thumb encoding (32): 0xFB800F00
    // Test aarch32_SMULL_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, RdHi=15, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smull_t1_a_field_rm_0_min_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, RdHi=0, Rn=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smull_t1_a_field_rm_1_poweroftwo_0_fb800001() {
    // Thumb encoding (32): 0xFB800001
    // Test aarch32_SMULL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdLo=0, Rm=1, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smull_t1_a_combo_0_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A field combination: Rn=0, RdLo=0, RdHi=0, Rm=0
    // ISET: T32
    // Fields: RdLo=0, Rn=0, Rm=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_t1_a_invalid_0_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, RdLo=0, Rm=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_t1_a_invalid_1_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_t1_a_invalid_2_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smull_t1_a_invalid_3_0_fb800000() {
    // Thumb encoding (32): 0xFB800000
    // Test aarch32_SMULL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rm=0, RdLo=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB800000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_smull_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_smull_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_smull_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_smull_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_smull_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_smull_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_smull_a1_a_flags_zeroresult_0_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: ZeroResult
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_smull_a1_a_flags_zeroresult_1_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: ZeroResult
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_smull_a1_a_flags_negativeresult_2_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: NegativeResult
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_smull_a1_a_flags_unsignedoverflow_3_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_smull_a1_a_flags_unsignedoverflow_4_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_smull_a1_a_flags_signedoverflow_5_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_smull_a1_a_flags_signedoverflow_6_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_smull_a1_a_flags_positiveresult_7_00d00291() {
    // Test aarch32_SMULL_A1_A flag computation: PositiveResult
    // Encoding: 0x00D00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00D00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_smull_t1_a_flags_zeroresult_0_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_smull_t1_a_flags_zeroresult_1_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_smull_t1_a_flags_negativeresult_2_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_smull_t1_a_flags_unsignedoverflow_3_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_smull_t1_a_flags_unsignedoverflow_4_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_smull_t1_a_flags_signedoverflow_5_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_smull_t1_a_flags_signedoverflow_6_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_smull_t1_a_flags_positiveresult_7_fb810002() {
    // Test aarch32_SMULL_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xFB810002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

// ============================================================================
// aarch32_MLA_A Tests
// ============================================================================

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_mla_a1_a_field_cond_0_min_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, Ra=0, Rm=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_mla_a1_a_field_cond_1_poweroftwo_90_10200090() {
    // Encoding: 0x10200090
    // Test aarch32_MLA_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rd=0, Rn=0, Ra=0, cond=1
    let encoding: u32 = 0x10200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_mla_a1_a_field_cond_2_poweroftwo_90_20200090() {
    // Encoding: 0x20200090
    // Test aarch32_MLA_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Ra=0, Rd=0, Rm=0, Rn=0, cond=2
    let encoding: u32 = 0x20200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_mla_a1_a_field_cond_3_poweroftwo_90_30200090() {
    // Encoding: 0x30200090
    // Test aarch32_MLA_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, Rd=0, Ra=0, cond=3
    let encoding: u32 = 0x30200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_mla_a1_a_field_cond_4_poweroftwo_90_40200090() {
    // Encoding: 0x40200090
    // Test aarch32_MLA_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, Ra=0, cond=4, Rm=0
    let encoding: u32 = 0x40200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_mla_a1_a_field_cond_5_poweroftwo_90_50200090() {
    // Encoding: 0x50200090
    // Test aarch32_MLA_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, Rn=0, S=0, Ra=0, Rm=0, Rd=0
    let encoding: u32 = 0x50200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_mla_a1_a_field_cond_6_poweroftwo_90_60200090() {
    // Encoding: 0x60200090
    // Test aarch32_MLA_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, S=0, Rd=0, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0x60200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_mla_a1_a_field_cond_7_poweroftwo_90_70200090() {
    // Encoding: 0x70200090
    // Test aarch32_MLA_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rn=0, S=0, cond=7, Rm=0
    let encoding: u32 = 0x70200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_mla_a1_a_field_cond_8_poweroftwo_90_80200090() {
    // Encoding: 0x80200090
    // Test aarch32_MLA_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=8, Ra=0, S=0, Rn=0, Rm=0
    let encoding: u32 = 0x80200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_mla_a1_a_field_cond_9_poweroftwo_90_90200090() {
    // Encoding: 0x90200090
    // Test aarch32_MLA_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, S=0, Rd=0, cond=9, Rn=0, Rm=0
    let encoding: u32 = 0x90200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_mla_a1_a_field_cond_10_poweroftwo_90_a0200090() {
    // Encoding: 0xA0200090
    // Test aarch32_MLA_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Ra=0, Rn=0, Rd=0, Rm=0, S=0
    let encoding: u32 = 0xA0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_mla_a1_a_field_cond_11_poweroftwo_90_b0200090() {
    // Encoding: 0xB0200090
    // Test aarch32_MLA_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rm=0, S=0, cond=11, Rn=0, Rd=0
    let encoding: u32 = 0xB0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_mla_a1_a_field_cond_12_poweroftwo_90_c0200090() {
    // Encoding: 0xC0200090
    // Test aarch32_MLA_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Ra=0, S=0, cond=12, Rd=0
    let encoding: u32 = 0xC0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_mla_a1_a_field_cond_13_poweroftwo_90_d0200090() {
    // Encoding: 0xD0200090
    // Test aarch32_MLA_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, S=0, Rd=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0xD0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_mla_a1_a_field_cond_14_poweroftwo_90_e0200090() {
    // Encoding: 0xE0200090
    // Test aarch32_MLA_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, S=0, Rd=0, Ra=0, cond=14, Rm=0
    let encoding: u32 = 0xE0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_mla_a1_a_field_cond_15_max_90_f0200090() {
    // Encoding: 0xF0200090
    // Test aarch32_MLA_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Ra=0, S=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xF0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_mla_a1_a_field_s_0_min_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, S=0, Ra=0, cond=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_mla_a1_a_field_s_1_max_90_00300090() {
    // Encoding: 0x00300090
    // Test aarch32_MLA_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=0, Ra=0, Rm=0, S=1, Rn=0
    let encoding: u32 = 0x00300090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_a1_a_field_rd_0_min_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Ra=0, S=0, Rm=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_a1_a_field_rd_1_poweroftwo_90_00210090() {
    // Encoding: 0x00210090
    // Test aarch32_MLA_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rd=1, Rn=0, cond=0, S=0
    let encoding: u32 = 0x00210090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_a1_a_field_ra_0_min_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Ra=0, Rn=0, S=0, Rd=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_a1_a_field_ra_1_poweroftwo_90_00201090() {
    // Encoding: 0x00201090
    // Test aarch32_MLA_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, S=0, Ra=1, Rd=0, Rm=0
    let encoding: u32 = 0x00201090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_a1_a_field_rm_0_min_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, S=0, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_a1_a_field_rm_1_poweroftwo_90_00200190() {
    // Encoding: 0x00200190
    // Test aarch32_MLA_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Ra=0, Rm=1, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x00200190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_a1_a_field_rn_0_min_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, cond=0, Rd=0, Ra=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_a1_a_field_rn_1_poweroftwo_90_00200091() {
    // Encoding: 0x00200091
    // Test aarch32_MLA_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rm=0, S=0, Rd=0, cond=0, Rn=1
    let encoding: u32 = 0x00200091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_mla_a1_a_combo_0_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A field combination: cond=0, S=0, Rd=0, Ra=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, cond=0, Ra=0, Rd=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_mla_a1_a_special_cond_0_condition_eq_144_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rd=0, S=0, Rn=0, cond=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_mla_a1_a_special_cond_1_condition_ne_144_10200090() {
    // Encoding: 0x10200090
    // Test aarch32_MLA_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, cond=1, S=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x10200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_mla_a1_a_special_cond_2_condition_cs_hs_144_20200090() {
    // Encoding: 0x20200090
    // Test aarch32_MLA_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: S=0, Rn=0, Rm=0, Rd=0, cond=2, Ra=0
    let encoding: u32 = 0x20200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_mla_a1_a_special_cond_3_condition_cc_lo_144_30200090() {
    // Encoding: 0x30200090
    // Test aarch32_MLA_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Rn=0, S=0, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x30200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_mla_a1_a_special_cond_4_condition_mi_144_40200090() {
    // Encoding: 0x40200090
    // Test aarch32_MLA_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=4, Ra=0, S=0, Rm=0
    let encoding: u32 = 0x40200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_mla_a1_a_special_cond_5_condition_pl_144_50200090() {
    // Encoding: 0x50200090
    // Test aarch32_MLA_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Ra=0, cond=5, Rn=0, Rm=0, S=0, Rd=0
    let encoding: u32 = 0x50200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_mla_a1_a_special_cond_6_condition_vs_144_60200090() {
    // Encoding: 0x60200090
    // Test aarch32_MLA_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Ra=0, Rd=0, cond=6, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x60200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_mla_a1_a_special_cond_7_condition_vc_144_70200090() {
    // Encoding: 0x70200090
    // Test aarch32_MLA_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Ra=0, Rd=0, Rm=0, Rn=0, cond=7, S=0
    let encoding: u32 = 0x70200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_mla_a1_a_special_cond_8_condition_hi_144_80200090() {
    // Encoding: 0x80200090
    // Test aarch32_MLA_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=8, S=0, Rd=0, Ra=0
    let encoding: u32 = 0x80200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_mla_a1_a_special_cond_9_condition_ls_144_90200090() {
    // Encoding: 0x90200090
    // Test aarch32_MLA_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, cond=9, Rd=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x90200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_mla_a1_a_special_cond_10_condition_ge_144_a0200090() {
    // Encoding: 0xA0200090
    // Test aarch32_MLA_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rd=0, Ra=0, S=0, Rm=0
    let encoding: u32 = 0xA0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_mla_a1_a_special_cond_11_condition_lt_144_b0200090() {
    // Encoding: 0xB0200090
    // Test aarch32_MLA_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, S=0, Ra=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0xB0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_mla_a1_a_special_cond_12_condition_gt_144_c0200090() {
    // Encoding: 0xC0200090
    // Test aarch32_MLA_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, S=0, Rd=0, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0xC0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_mla_a1_a_special_cond_13_condition_le_144_d0200090() {
    // Encoding: 0xD0200090
    // Test aarch32_MLA_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: S=0, Rd=0, Rm=0, cond=13, Ra=0, Rn=0
    let encoding: u32 = 0xD0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_mla_a1_a_special_cond_14_condition_al_144_e0200090() {
    // Encoding: 0xE0200090
    // Test aarch32_MLA_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Ra=0, Rd=0, cond=14, S=0, Rm=0, Rn=0
    let encoding: u32 = 0xE0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_mla_a1_a_special_cond_15_condition_nv_144_f0200090() {
    // Encoding: 0xF0200090
    // Test aarch32_MLA_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, S=0, Rn=0, Rm=0, cond=15, Ra=0
    let encoding: u32 = 0xF0200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_mla_a1_a_special_s_0_size_variant_0_144_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Ra=0, Rd=0, Rm=0, cond=0, S=0, Rn=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_mla_a1_a_special_s_1_size_variant_1_144_00300090() {
    // Encoding: 0x00300090
    // Test aarch32_MLA_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=0, Rm=0, Rn=0, S=1
    let encoding: u32 = 0x00300090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mla_a1_a_invalid_0_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, S=0, Rm=0, Ra=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mla_a1_a_invalid_1_90_00200090() {
    // Encoding: 0x00200090
    // Test aarch32_MLA_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rm=0, S=0, Rn=0, Rd=0, Ra=0
    let encoding: u32 = 0x00200090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_t1_a_field_rn_0_min_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_t1_a_field_rn_1_poweroftwo_0_fb010000() {
    // Thumb encoding (32): 0xFB010000
    // Test aarch32_MLA_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, Ra=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB010000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_t1_a_field_ra_0_min_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_t1_a_field_ra_1_poweroftwo_0_fb001000() {
    // Thumb encoding (32): 0xFB001000
    // Test aarch32_MLA_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=1, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB001000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_t1_a_field_rd_0_min_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_t1_a_field_rd_1_poweroftwo_0_fb000100() {
    // Thumb encoding (32): 0xFB000100
    // Test aarch32_MLA_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rd=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mla_t1_a_field_rm_0_min_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mla_t1_a_field_rm_1_poweroftwo_0_fb000001() {
    // Thumb encoding (32): 0xFB000001
    // Test aarch32_MLA_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_mla_t1_a_combo_0_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A field combination: Rn=0, Ra=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Ra=0, Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mla_t1_a_invalid_0_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mla_t1_a_invalid_1_0_fb000000() {
    // Thumb encoding (32): 0xFB000000
    // Test aarch32_MLA_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_mla_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_mla_a1_a_a32_mul_0_0020f291() {
    // Test A32 MLA: simple values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_mla_a1_a_a32_mul_1_0020f291() {
    // Test A32 MLA: zero values (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_mla_a1_a_a32_mul_2_0020f291() {
    // Test A32 MLA: max value (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_mla_a1_a_a32_mul_3_0020f291() {
    // Test A32 MLA: MSB set (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x80000000);
    set_w(&mut cpu, 1, 0x80000000);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `MLA R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_mla_a1_a_a32_mul_4_0020f291() {
    // Test A32 MLA: mixed pattern (oracle)
    // Encoding: 0x0020F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0020F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_mla_a1_a_flags_zeroresult_0_00300291() {
    // Test aarch32_MLA_A1_A flag computation: ZeroResult
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_mla_a1_a_flags_zeroresult_1_00300291() {
    // Test aarch32_MLA_A1_A flag computation: ZeroResult
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_mla_a1_a_flags_negativeresult_2_00300291() {
    // Test aarch32_MLA_A1_A flag computation: NegativeResult
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_mla_a1_a_flags_unsignedoverflow_3_00300291() {
    // Test aarch32_MLA_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_mla_a1_a_flags_unsignedoverflow_4_00300291() {
    // Test aarch32_MLA_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_mla_a1_a_flags_signedoverflow_5_00300291() {
    // Test aarch32_MLA_A1_A flag computation: SignedOverflow
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_mla_a1_a_flags_signedoverflow_6_00300291() {
    // Test aarch32_MLA_A1_A flag computation: SignedOverflow
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_mla_a1_a_flags_positiveresult_7_00300291() {
    // Test aarch32_MLA_A1_A flag computation: PositiveResult
    // Encoding: 0x00300291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00300291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFF);
    set_w(&mut cpu, 1, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_mla_t1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_mla_t1_a_t32_oracle_0_fb010002() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_mla_t1_a_t32_oracle_1_fb010002() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_mla_t1_a_t32_oracle_2_fb010002() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_mla_t1_a_t32_oracle_3_fb010002() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_mla_t1_a_flags_zeroresult_0_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_mla_t1_a_flags_zeroresult_1_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_mla_t1_a_flags_negativeresult_2_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_mla_t1_a_flags_unsignedoverflow_3_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_mla_t1_a_flags_unsignedoverflow_4_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_mla_t1_a_flags_signedoverflow_5_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_mla_t1_a_flags_signedoverflow_6_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MLA_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_mla_t1_a_flags_positiveresult_7_fb010002() {
    // Test aarch32_MLA_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xFB010002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

// ============================================================================
// aarch32_SMLAL_A Tests
// ============================================================================

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_0_min_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, RdLo=0, Rm=0, Rn=0, RdHi=0, cond=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_1_poweroftwo_90_10e00090() {
    // Encoding: 0x10E00090
    // Test aarch32_SMLAL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, S=0, cond=1, Rn=0, Rm=0
    let encoding: u32 = 0x10E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_2_poweroftwo_90_20e00090() {
    // Encoding: 0x20E00090
    // Test aarch32_SMLAL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=2, RdHi=0, RdLo=0, Rn=0, S=0
    let encoding: u32 = 0x20E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_3_poweroftwo_90_30e00090() {
    // Encoding: 0x30E00090
    // Test aarch32_SMLAL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=3, Rn=0, S=0, Rm=0, RdHi=0
    let encoding: u32 = 0x30E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_4_poweroftwo_90_40e00090() {
    // Encoding: 0x40E00090
    // Test aarch32_SMLAL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, Rm=0, S=0, cond=4, RdLo=0
    let encoding: u32 = 0x40E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_5_poweroftwo_90_50e00090() {
    // Encoding: 0x50E00090
    // Test aarch32_SMLAL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, RdLo=0, RdHi=0, S=0, Rn=0
    let encoding: u32 = 0x50E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_6_poweroftwo_90_60e00090() {
    // Encoding: 0x60E00090
    // Test aarch32_SMLAL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, S=0, Rm=0, RdLo=0, Rn=0, cond=6
    let encoding: u32 = 0x60E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_7_poweroftwo_90_70e00090() {
    // Encoding: 0x70E00090
    // Test aarch32_SMLAL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rm=0, RdLo=0, Rn=0, S=0, RdHi=0
    let encoding: u32 = 0x70E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_8_poweroftwo_90_80e00090() {
    // Encoding: 0x80E00090
    // Test aarch32_SMLAL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, S=0, cond=8, Rm=0, RdLo=0, Rn=0
    let encoding: u32 = 0x80E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_9_poweroftwo_90_90e00090() {
    // Encoding: 0x90E00090
    // Test aarch32_SMLAL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rn=0, RdHi=0, RdLo=0, Rm=0, S=0
    let encoding: u32 = 0x90E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_10_poweroftwo_90_a0e00090() {
    // Encoding: 0xA0E00090
    // Test aarch32_SMLAL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, RdHi=0, cond=10, RdLo=0, Rm=0
    let encoding: u32 = 0xA0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_11_poweroftwo_90_b0e00090() {
    // Encoding: 0xB0E00090
    // Test aarch32_SMLAL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, RdHi=0, Rm=0, S=0, RdLo=0
    let encoding: u32 = 0xB0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_12_poweroftwo_90_c0e00090() {
    // Encoding: 0xC0E00090
    // Test aarch32_SMLAL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, cond=12, S=0, RdHi=0, Rm=0
    let encoding: u32 = 0xC0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_13_poweroftwo_90_d0e00090() {
    // Encoding: 0xD0E00090
    // Test aarch32_SMLAL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, S=0, cond=13
    let encoding: u32 = 0xD0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_14_poweroftwo_90_e0e00090() {
    // Encoding: 0xE0E00090
    // Test aarch32_SMLAL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rm=0, Rn=0, cond=14, S=0
    let encoding: u32 = 0xE0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlal_a1_a_field_cond_15_max_90_f0e00090() {
    // Encoding: 0xF0E00090
    // Test aarch32_SMLAL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, S=0, cond=15
    let encoding: u32 = 0xF0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_smlal_a1_a_field_s_0_min_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: S=0, Rn=0, Rm=0, RdHi=0, cond=0, RdLo=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_smlal_a1_a_field_s_1_max_90_00f00090() {
    // Encoding: 0x00F00090
    // Test aarch32_SMLAL_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: RdHi=0, cond=0, RdLo=0, Rn=0, Rm=0, S=1
    let encoding: u32 = 0x00F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlal_a1_a_field_rdhi_0_min_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: RdHi=0, Rn=0, S=0, RdLo=0, cond=0, Rm=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlal_a1_a_field_rdhi_1_poweroftwo_90_00e10090() {
    // Encoding: 0x00E10090
    // Test aarch32_SMLAL_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdHi=1, S=0, cond=0, Rm=0, RdLo=0
    let encoding: u32 = 0x00E10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlal_a1_a_field_rdhi_7_poweroftwominusone_90_00e70090() {
    // Encoding: 0x00E70090
    // Test aarch32_SMLAL_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, Rm=0, cond=0, S=0, RdHi=7
    let encoding: u32 = 0x00E70090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlal_a1_a_field_rdhi_15_max_90_00ef0090() {
    // Encoding: 0x00EF0090
    // Test aarch32_SMLAL_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, cond=0, S=0, RdHi=15, Rm=0
    let encoding: u32 = 0x00EF0090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlal_a1_a_field_rdlo_0_min_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, cond=0, S=0, Rm=0, Rn=0, RdHi=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlal_a1_a_field_rdlo_1_poweroftwo_90_00e01090() {
    // Encoding: 0x00E01090
    // Test aarch32_SMLAL_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdLo=1, S=0, cond=0, Rm=0, RdHi=0
    let encoding: u32 = 0x00E01090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlal_a1_a_field_rdlo_7_poweroftwominusone_90_00e07090() {
    // Encoding: 0x00E07090
    // Test aarch32_SMLAL_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdLo=7, RdHi=0, cond=0, S=0
    let encoding: u32 = 0x00E07090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlal_a1_a_field_rdlo_15_max_90_00e0f090() {
    // Encoding: 0x00E0F090
    // Test aarch32_SMLAL_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdHi=0, RdLo=15, cond=0, S=0
    let encoding: u32 = 0x00E0F090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlal_a1_a_field_rm_0_min_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, S=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlal_a1_a_field_rm_1_poweroftwo_90_00e00190() {
    // Encoding: 0x00E00190
    // Test aarch32_SMLAL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, Rn=0, S=0, RdHi=0, cond=0, RdLo=0
    let encoding: u32 = 0x00E00190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlal_a1_a_field_rn_0_min_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, RdHi=0, cond=0, Rm=0, S=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlal_a1_a_field_rn_1_poweroftwo_90_00e00091() {
    // Encoding: 0x00E00091
    // Test aarch32_SMLAL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=0, S=0, RdLo=0, Rm=0, Rn=1
    let encoding: u32 = 0x00E00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlal_a1_a_combo_0_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A field combination: cond=0, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, S=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlal_a1_a_special_cond_0_condition_eq_144_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, RdHi=0, RdLo=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlal_a1_a_special_cond_1_condition_ne_144_10e00090() {
    // Encoding: 0x10E00090
    // Test aarch32_SMLAL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rm=0, RdLo=0, Rn=0, S=0, RdHi=0
    let encoding: u32 = 0x10E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlal_a1_a_special_cond_2_condition_cs_hs_144_20e00090() {
    // Encoding: 0x20E00090
    // Test aarch32_SMLAL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, S=0, RdHi=0, Rn=0, cond=2
    let encoding: u32 = 0x20E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlal_a1_a_special_cond_3_condition_cc_lo_144_30e00090() {
    // Encoding: 0x30E00090
    // Test aarch32_SMLAL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: S=0, cond=3, Rm=0, Rn=0, RdLo=0, RdHi=0
    let encoding: u32 = 0x30E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlal_a1_a_special_cond_4_condition_mi_144_40e00090() {
    // Encoding: 0x40E00090
    // Test aarch32_SMLAL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, RdLo=0, RdHi=0, Rn=0, Rm=0, cond=4
    let encoding: u32 = 0x40E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlal_a1_a_special_cond_5_condition_pl_144_50e00090() {
    // Encoding: 0x50E00090
    // Test aarch32_SMLAL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: S=0, cond=5, RdLo=0, Rn=0, Rm=0, RdHi=0
    let encoding: u32 = 0x50E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlal_a1_a_special_cond_6_condition_vs_144_60e00090() {
    // Encoding: 0x60E00090
    // Test aarch32_SMLAL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, RdHi=0, RdLo=0, S=0, Rm=0, Rn=0
    let encoding: u32 = 0x60E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlal_a1_a_special_cond_7_condition_vc_144_70e00090() {
    // Encoding: 0x70E00090
    // Test aarch32_SMLAL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, Rm=0, RdHi=0, cond=7, RdLo=0, S=0
    let encoding: u32 = 0x70E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlal_a1_a_special_cond_8_condition_hi_144_80e00090() {
    // Encoding: 0x80E00090
    // Test aarch32_SMLAL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, Rn=0, cond=8, S=0, RdHi=0
    let encoding: u32 = 0x80E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlal_a1_a_special_cond_9_condition_ls_144_90e00090() {
    // Encoding: 0x90E00090
    // Test aarch32_SMLAL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, S=0, cond=9
    let encoding: u32 = 0x90E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlal_a1_a_special_cond_10_condition_ge_144_a0e00090() {
    // Encoding: 0xA0E00090
    // Test aarch32_SMLAL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rm=0, RdLo=0, cond=10, RdHi=0, S=0
    let encoding: u32 = 0xA0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlal_a1_a_special_cond_11_condition_lt_144_b0e00090() {
    // Encoding: 0xB0E00090
    // Test aarch32_SMLAL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdLo=0, RdHi=0, cond=11, S=0
    let encoding: u32 = 0xB0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlal_a1_a_special_cond_12_condition_gt_144_c0e00090() {
    // Encoding: 0xC0E00090
    // Test aarch32_SMLAL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0xC0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlal_a1_a_special_cond_13_condition_le_144_d0e00090() {
    // Encoding: 0xD0E00090
    // Test aarch32_SMLAL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, cond=13, RdHi=0, S=0, Rm=0, RdLo=0
    let encoding: u32 = 0xD0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlal_a1_a_special_cond_14_condition_al_144_e0e00090() {
    // Encoding: 0xE0E00090
    // Test aarch32_SMLAL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, S=0, Rn=0, cond=14
    let encoding: u32 = 0xE0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlal_a1_a_special_cond_15_condition_nv_144_f0e00090() {
    // Encoding: 0xF0E00090
    // Test aarch32_SMLAL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: S=0, RdLo=0, Rn=0, cond=15, Rm=0, RdHi=0
    let encoding: u32 = 0xF0E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_smlal_a1_a_special_s_0_size_variant_0_144_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: Rn=0, cond=0, RdLo=0, S=0, RdHi=0, Rm=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_smlal_a1_a_special_s_1_size_variant_1_144_00f00090() {
    // Encoding: 0x00F00090
    // Test aarch32_SMLAL_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rn=0, cond=0, S=1, Rm=0
    let encoding: u32 = 0x00F00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_a1_a_invalid_0_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: S=0, RdLo=0, Rm=0, cond=0, Rn=0, RdHi=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_a1_a_invalid_1_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, cond=0, S=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_a1_a_invalid_2_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: cond=0, S=0, RdLo=0, Rn=0, Rm=0, RdHi=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_a1_a_invalid_3_90_00e00090() {
    // Encoding: 0x00E00090
    // Test aarch32_SMLAL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, RdLo=0, Rm=0, S=0, RdHi=0
    let encoding: u32 = 0x00E00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlal_t1_a_field_rn_0_min_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlal_t1_a_field_rn_1_poweroftwo_0_fbc10000() {
    // Thumb encoding (32): 0xFBC10000
    // Test aarch32_SMLAL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, Rm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlal_t1_a_field_rdlo_0_min_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlal_t1_a_field_rdlo_1_poweroftwo_0_fbc01000() {
    // Thumb encoding (32): 0xFBC01000
    // Test aarch32_SMLAL_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, RdHi=0, Rm=0, RdLo=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlal_t1_a_field_rdlo_7_poweroftwominusone_0_fbc07000() {
    // Thumb encoding (32): 0xFBC07000
    // Test aarch32_SMLAL_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, RdLo=7, RdHi=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlal_t1_a_field_rdlo_15_max_0_fbc0f000() {
    // Thumb encoding (32): 0xFBC0F000
    // Test aarch32_SMLAL_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: RdHi=0, RdLo=15, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlal_t1_a_field_rdhi_0_min_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlal_t1_a_field_rdhi_1_poweroftwo_0_fbc00100() {
    // Thumb encoding (32): 0xFBC00100
    // Test aarch32_SMLAL_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdLo=0, Rm=0, Rn=0, RdHi=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlal_t1_a_field_rdhi_7_poweroftwominusone_0_fbc00700() {
    // Thumb encoding (32): 0xFBC00700
    // Test aarch32_SMLAL_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: RdLo=0, Rn=0, Rm=0, RdHi=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlal_t1_a_field_rdhi_15_max_0_fbc00f00() {
    // Thumb encoding (32): 0xFBC00F00
    // Test aarch32_SMLAL_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, RdLo=0, Rm=0, RdHi=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlal_t1_a_field_rm_0_min_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: RdHi=0, Rn=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlal_t1_a_field_rm_1_poweroftwo_0_fbc00001() {
    // Thumb encoding (32): 0xFBC00001
    // Test aarch32_SMLAL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rm=1, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlal_t1_a_combo_0_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A field combination: Rn=0, RdLo=0, RdHi=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_t1_a_invalid_0_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_t1_a_invalid_1_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_t1_a_invalid_2_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rm=0, RdLo=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlal_t1_a_invalid_3_0_fbc00000() {
    // Thumb encoding (32): 0xFBC00000
    // Test aarch32_SMLAL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdHi=0, Rn=0, Rm=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBC00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_smlal_a1_a_smull_oracle_0_9b227c20() {
    // Test SMULL: simple multiply (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_smlal_a1_a_smull_oracle_1_9b227c20() {
    // Test SMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0xFFFFFFFFFFFFFFFE"
    );
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_smlal_a1_a_smull_oracle_2_9b227c20() {
    // Test SMULL: large positive * large positive (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_smlal_a1_a_smull_oracle_3_9b227c20() {
    // Test SMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_smlal_a1_a_smull_oracle_4_9b227c20() {
    // Test SMULL: medium values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `SMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_smlal_a1_a_smull_oracle_5_9b227c20() {
    // Test SMULL: 16-bit values (oracle)
    // Encoding: 0x9B227C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1234);
    set_w(&mut cpu, 2, 0x5678);
    let encoding: u32 = 0x9B227C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_zeroresult_0_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: ZeroResult
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_zeroresult_1_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: ZeroResult
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_negativeresult_2_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: NegativeResult
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_unsignedoverflow_3_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_unsignedoverflow_4_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_signedoverflow_5_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_smlal_a1_a_flags_signedoverflow_6_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_smlal_a1_a_flags_positiveresult_7_00f00291() {
    // Test aarch32_SMLAL_A1_A flag computation: PositiveResult
    // Encoding: 0x00F00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x00F00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_zeroresult_0_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_zeroresult_1_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_negativeresult_2_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_unsignedoverflow_3_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_unsignedoverflow_4_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_signedoverflow_5_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_smlal_t1_a_flags_signedoverflow_6_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_SMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_smlal_t1_a_flags_positiveresult_7_fbc10002() {
    // Test aarch32_SMLAL_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xFBC10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

// ============================================================================
// aarch32_MLS_A Tests
// ============================================================================

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_mls_a1_a_field_cond_0_min_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_mls_a1_a_field_cond_1_poweroftwo_90_10600090() {
    // Encoding: 0x10600090
    // Test aarch32_MLS_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=1, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x10600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_mls_a1_a_field_cond_2_poweroftwo_90_20600090() {
    // Encoding: 0x20600090
    // Test aarch32_MLS_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=2, Rd=0, Rn=0
    let encoding: u32 = 0x20600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_mls_a1_a_field_cond_3_poweroftwo_90_30600090() {
    // Encoding: 0x30600090
    // Test aarch32_MLS_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=3, Ra=0, Rm=0
    let encoding: u32 = 0x30600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_mls_a1_a_field_cond_4_poweroftwo_90_40600090() {
    // Encoding: 0x40600090
    // Test aarch32_MLS_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0x40600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_mls_a1_a_field_cond_5_poweroftwo_90_50600090() {
    // Encoding: 0x50600090
    // Test aarch32_MLS_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=5, Ra=0, Rm=0
    let encoding: u32 = 0x50600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_mls_a1_a_field_cond_6_poweroftwo_90_60600090() {
    // Encoding: 0x60600090
    // Test aarch32_MLS_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rm=0, cond=6, Rd=0, Rn=0
    let encoding: u32 = 0x60600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_mls_a1_a_field_cond_7_poweroftwo_90_70600090() {
    // Encoding: 0x70600090
    // Test aarch32_MLS_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, Ra=0, cond=7
    let encoding: u32 = 0x70600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_mls_a1_a_field_cond_8_poweroftwo_90_80600090() {
    // Encoding: 0x80600090
    // Test aarch32_MLS_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Ra=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x80600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_mls_a1_a_field_cond_9_poweroftwo_90_90600090() {
    // Encoding: 0x90600090
    // Test aarch32_MLS_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=9, Ra=0
    let encoding: u32 = 0x90600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_mls_a1_a_field_cond_10_poweroftwo_90_a0600090() {
    // Encoding: 0xA0600090
    // Test aarch32_MLS_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=10, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0xA0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_mls_a1_a_field_cond_11_poweroftwo_90_b0600090() {
    // Encoding: 0xB0600090
    // Test aarch32_MLS_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Ra=0, cond=11, Rn=0
    let encoding: u32 = 0xB0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_mls_a1_a_field_cond_12_poweroftwo_90_c0600090() {
    // Encoding: 0xC0600090
    // Test aarch32_MLS_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Ra=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0xC0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_mls_a1_a_field_cond_13_poweroftwo_90_d0600090() {
    // Encoding: 0xD0600090
    // Test aarch32_MLS_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Ra=0, Rm=0, Rd=0
    let encoding: u32 = 0xD0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_mls_a1_a_field_cond_14_poweroftwo_90_e0600090() {
    // Encoding: 0xE0600090
    // Test aarch32_MLS_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=14, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0xE0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_mls_a1_a_field_cond_15_max_90_f0600090() {
    // Encoding: 0xF0600090
    // Test aarch32_MLS_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, cond=15, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0xF0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_a1_a_field_rd_0_min_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, Rn=0, cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_a1_a_field_rd_1_poweroftwo_90_00610090() {
    // Encoding: 0x00610090
    // Test aarch32_MLS_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=0, Rm=0, Rd=1
    let encoding: u32 = 0x00610090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_a1_a_field_ra_0_min_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_a1_a_field_ra_1_poweroftwo_90_00601090() {
    // Encoding: 0x00601090
    // Test aarch32_MLS_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=1, Rn=0, Rm=0, cond=0
    let encoding: u32 = 0x00601090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_a1_a_field_rm_0_min_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Rm=0, Ra=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_a1_a_field_rm_1_poweroftwo_90_00600190() {
    // Encoding: 0x00600190
    // Test aarch32_MLS_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, Rm=1, cond=0
    let encoding: u32 = 0x00600190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_a1_a_field_rn_0_min_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, Ra=0, cond=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_a1_a_field_rn_1_poweroftwo_90_00600091() {
    // Encoding: 0x00600091
    // Test aarch32_MLS_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, Rn=1, Ra=0
    let encoding: u32 = 0x00600091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_mls_a1_a_combo_0_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0, cond=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_mls_a1_a_special_cond_0_condition_eq_144_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_mls_a1_a_special_cond_1_condition_ne_144_10600090() {
    // Encoding: 0x10600090
    // Test aarch32_MLS_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, cond=1, Rn=0, Rm=0, Ra=0
    let encoding: u32 = 0x10600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_mls_a1_a_special_cond_2_condition_cs_hs_144_20600090() {
    // Encoding: 0x20600090
    // Test aarch32_MLS_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=2, Ra=0
    let encoding: u32 = 0x20600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_mls_a1_a_special_cond_3_condition_cc_lo_144_30600090() {
    // Encoding: 0x30600090
    // Test aarch32_MLS_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, Ra=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x30600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_mls_a1_a_special_cond_4_condition_mi_144_40600090() {
    // Encoding: 0x40600090
    // Test aarch32_MLS_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, Ra=0, cond=4
    let encoding: u32 = 0x40600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_mls_a1_a_special_cond_5_condition_pl_144_50600090() {
    // Encoding: 0x50600090
    // Test aarch32_MLS_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Ra=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x50600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_mls_a1_a_special_cond_6_condition_vs_144_60600090() {
    // Encoding: 0x60600090
    // Test aarch32_MLS_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, Ra=0, cond=6
    let encoding: u32 = 0x60600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_mls_a1_a_special_cond_7_condition_vc_144_70600090() {
    // Encoding: 0x70600090
    // Test aarch32_MLS_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, cond=7, Ra=0, Rd=0, Rn=0
    let encoding: u32 = 0x70600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_mls_a1_a_special_cond_8_condition_hi_144_80600090() {
    // Encoding: 0x80600090
    // Test aarch32_MLS_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=8, Rm=0, Rd=0
    let encoding: u32 = 0x80600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_mls_a1_a_special_cond_9_condition_ls_144_90600090() {
    // Encoding: 0x90600090
    // Test aarch32_MLS_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=9, Rn=0, Rm=0
    let encoding: u32 = 0x90600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_mls_a1_a_special_cond_10_condition_ge_144_a0600090() {
    // Encoding: 0xA0600090
    // Test aarch32_MLS_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=0, Rn=0, cond=10
    let encoding: u32 = 0xA0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_mls_a1_a_special_cond_11_condition_lt_144_b0600090() {
    // Encoding: 0xB0600090
    // Test aarch32_MLS_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, cond=11, Ra=0
    let encoding: u32 = 0xB0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_mls_a1_a_special_cond_12_condition_gt_144_c0600090() {
    // Encoding: 0xC0600090
    // Test aarch32_MLS_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, cond=12, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0xC0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_mls_a1_a_special_cond_13_condition_le_144_d0600090() {
    // Encoding: 0xD0600090
    // Test aarch32_MLS_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=13, Rn=0, Rd=0
    let encoding: u32 = 0xD0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_mls_a1_a_special_cond_14_condition_al_144_e0600090() {
    // Encoding: 0xE0600090
    // Test aarch32_MLS_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=14, Rm=0, Rd=0
    let encoding: u32 = 0xE0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_mls_a1_a_special_cond_15_condition_nv_144_f0600090() {
    // Encoding: 0xF0600090
    // Test aarch32_MLS_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: cond=15, Rm=0, Rd=0, Ra=0, Rn=0
    let encoding: u32 = 0xF0600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mls_a1_a_invalid_0_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Ra=0, Rm=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mls_a1_a_invalid_1_90_00600090() {
    // Encoding: 0x00600090
    // Test aarch32_MLS_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x00600090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_t1_a_field_rn_0_min_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_t1_a_field_rn_1_poweroftwo_10_fb010010() {
    // Thumb encoding (32): 0xFB010010
    // Test aarch32_MLS_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=1, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB010010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_t1_a_field_ra_0_min_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_t1_a_field_ra_1_poweroftwo_10_fb001010() {
    // Thumb encoding (32): 0xFB001010
    // Test aarch32_MLS_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Ra=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB001010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_t1_a_field_rd_0_min_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_t1_a_field_rd_1_poweroftwo_10_fb000110() {
    // Thumb encoding (32): 0xFB000110
    // Test aarch32_MLS_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=1, Rn=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000110;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mls_t1_a_field_rm_0_min_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mls_t1_a_field_rm_1_poweroftwo_10_fb000011() {
    // Thumb encoding (32): 0xFB000011
    // Test aarch32_MLS_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000011;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_mls_t1_a_combo_0_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A field combination: Rn=0, Ra=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mls_t1_a_invalid_0_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MLS_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mls_t1_a_invalid_1_10_fb000010() {
    // Thumb encoding (32): 0xFB000010
    // Test aarch32_MLS_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB000010;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply
#[test]
fn test_aarch32_mls_a1_a_umull_oracle_0_9ba27c20() {
    // Test UMULL: simple multiply (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max 32-bit * 2
#[test]
fn test_aarch32_mls_a1_a_umull_oracle_1_9ba27c20() {
    // Test UMULL: max 32-bit * 2 (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFE,
        "X0 should be 0x00000001FFFFFFFE"
    );
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// large positive * large positive
#[test]
fn test_aarch32_mls_a1_a_umull_oracle_2_9ba27c20() {
    // Test UMULL: large positive * large positive (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7FFFFFFF);
    set_w(&mut cpu, 2, 0x7FFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x3FFFFFFF00000001");
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max unsigned * max unsigned
#[test]
fn test_aarch32_mls_a1_a_umull_oracle_3_9ba27c20() {
    // Test UMULL: max unsigned * max unsigned (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// medium values
#[test]
fn test_aarch32_mls_a1_a_umull_oracle_4_9ba27c20() {
    // Test UMULL: medium values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xC8);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_MLS_A1_A
/// ASL: `UMULL X0, W1, W2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit values
#[test]
fn test_aarch32_mls_a1_a_umull_oracle_5_9ba27c20() {
    // Test UMULL: 16-bit values (oracle)
    // Encoding: 0x9BA27C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x5678);
    set_w(&mut cpu, 1, 0x1234);
    let encoding: u32 = 0x9BA27C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6260060, "X0 should be 0x0000000006260060");
}

// ============================================================================
// aarch32_SMLSLD_A Tests
// ============================================================================

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_0_min_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, M=0, Rm=0, RdLo=0, cond=0, RdHi=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_1_poweroftwo_50_17400050() {
    // Encoding: 0x17400050
    // Test aarch32_SMLSLD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rm=0, Rn=0, M=0, cond=1
    let encoding: u32 = 0x17400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_2_poweroftwo_50_27400050() {
    // Encoding: 0x27400050
    // Test aarch32_SMLSLD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, M=0, cond=2, Rn=0
    let encoding: u32 = 0x27400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_3_poweroftwo_50_37400050() {
    // Encoding: 0x37400050
    // Test aarch32_SMLSLD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, RdHi=0, RdLo=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x37400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_4_poweroftwo_50_47400050() {
    // Encoding: 0x47400050
    // Test aarch32_SMLSLD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=4, RdLo=0, M=0, Rn=0, RdHi=0
    let encoding: u32 = 0x47400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_5_poweroftwo_50_57400050() {
    // Encoding: 0x57400050
    // Test aarch32_SMLSLD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdHi=0, RdLo=0, M=0, cond=5
    let encoding: u32 = 0x57400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_6_poweroftwo_50_67400050() {
    // Encoding: 0x67400050
    // Test aarch32_SMLSLD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, RdHi=0, cond=6, M=0, Rn=0
    let encoding: u32 = 0x67400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_7_poweroftwo_50_77400050() {
    // Encoding: 0x77400050
    // Test aarch32_SMLSLD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, Rm=0, RdHi=0, RdLo=0, cond=7
    let encoding: u32 = 0x77400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_8_poweroftwo_50_87400050() {
    // Encoding: 0x87400050
    // Test aarch32_SMLSLD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, Rn=0, cond=8, M=0
    let encoding: u32 = 0x87400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_9_poweroftwo_50_97400050() {
    // Encoding: 0x97400050
    // Test aarch32_SMLSLD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, cond=9, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x97400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_10_poweroftwo_50_a7400050() {
    // Encoding: 0xA7400050
    // Test aarch32_SMLSLD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, RdHi=0, M=0, Rn=0, RdLo=0, Rm=0
    let encoding: u32 = 0xA7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_11_poweroftwo_50_b7400050() {
    // Encoding: 0xB7400050
    // Test aarch32_SMLSLD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, M=0, RdHi=0, cond=11, Rn=0, RdLo=0
    let encoding: u32 = 0xB7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_12_poweroftwo_50_c7400050() {
    // Encoding: 0xC7400050
    // Test aarch32_SMLSLD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=12, Rm=0, Rn=0, RdHi=0, M=0
    let encoding: u32 = 0xC7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_13_poweroftwo_50_d7400050() {
    // Encoding: 0xD7400050
    // Test aarch32_SMLSLD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, RdLo=0, M=0, cond=13, Rm=0
    let encoding: u32 = 0xD7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_14_poweroftwo_50_e7400050() {
    // Encoding: 0xE7400050
    // Test aarch32_SMLSLD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, cond=14, RdLo=0, M=0, Rn=0
    let encoding: u32 = 0xE7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlsld_a1_a_field_cond_15_max_50_f7400050() {
    // Encoding: 0xF7400050
    // Test aarch32_SMLSLD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, RdHi=0, Rm=0, M=0, RdLo=0, Rn=0
    let encoding: u32 = 0xF7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsld_a1_a_field_rdhi_0_min_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rm=0, M=0, Rn=0, cond=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlsld_a1_a_field_rdhi_1_poweroftwo_50_07410050() {
    // Encoding: 0x07410050
    // Test aarch32_SMLSLD_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=1, Rm=0, Rn=0, cond=0, RdLo=0, M=0
    let encoding: u32 = 0x07410050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlsld_a1_a_field_rdhi_7_poweroftwominusone_50_07470050() {
    // Encoding: 0x07470050
    // Test aarch32_SMLSLD_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, RdHi=7, cond=0, RdLo=0
    let encoding: u32 = 0x07470050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlsld_a1_a_field_rdhi_15_max_50_074f0050() {
    // Encoding: 0x074F0050
    // Test aarch32_SMLSLD_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: RdHi=15, M=0, cond=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x074F0050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsld_a1_a_field_rdlo_0_min_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, cond=0, RdHi=0, M=0, Rm=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlsld_a1_a_field_rdlo_1_poweroftwo_50_07401050() {
    // Encoding: 0x07401050
    // Test aarch32_SMLSLD_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, RdHi=0, M=0, RdLo=1, Rm=0, Rn=0
    let encoding: u32 = 0x07401050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlsld_a1_a_field_rdlo_7_poweroftwominusone_50_07407050() {
    // Encoding: 0x07407050
    // Test aarch32_SMLSLD_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: M=0, RdHi=0, cond=0, RdLo=7, Rm=0, Rn=0
    let encoding: u32 = 0x07407050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlsld_a1_a_field_rdlo_15_max_50_0740f050() {
    // Encoding: 0x0740F050
    // Test aarch32_SMLSLD_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, M=0, RdHi=0, RdLo=15
    let encoding: u32 = 0x0740F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsld_a1_a_field_rm_0_min_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, RdHi=0, RdLo=0, M=0, Rm=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsld_a1_a_field_rm_1_poweroftwo_50_07400150() {
    // Encoding: 0x07400150
    // Test aarch32_SMLSLD_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, RdLo=0, M=0, Rn=0, RdHi=0, cond=0
    let encoding: u32 = 0x07400150;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsld_a1_a_field_m_0_min_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=0, M=0, Rm=0, RdHi=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlsld_a1_a_field_m_1_max_50_07400070() {
    // Encoding: 0x07400070
    // Test aarch32_SMLSLD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, RdLo=0, cond=0, M=1, Rn=0
    let encoding: u32 = 0x07400070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsld_a1_a_field_rn_0_min_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, M=0, Rn=0, RdLo=0, cond=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsld_a1_a_field_rn_1_poweroftwo_50_07400051() {
    // Encoding: 0x07400051
    // Test aarch32_SMLSLD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=0, Rm=0, Rn=1, M=0, RdLo=0
    let encoding: u32 = 0x07400051;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlsld_a1_a_combo_0_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A field combination: cond=0, RdHi=0, RdLo=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: RdHi=0, Rm=0, cond=0, M=0, RdLo=0, Rn=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_0_condition_eq_80_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, RdHi=0, Rm=0, M=0, Rn=0, RdLo=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_1_condition_ne_80_17400050() {
    // Encoding: 0x17400050
    // Test aarch32_SMLSLD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: M=0, cond=1, Rm=0, Rn=0, RdHi=0, RdLo=0
    let encoding: u32 = 0x17400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_2_condition_cs_hs_80_27400050() {
    // Encoding: 0x27400050
    // Test aarch32_SMLSLD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, Rm=0, RdHi=0, cond=2, M=0
    let encoding: u32 = 0x27400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_3_condition_cc_lo_80_37400050() {
    // Encoding: 0x37400050
    // Test aarch32_SMLSLD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: RdLo=0, cond=3, Rm=0, M=0, Rn=0, RdHi=0
    let encoding: u32 = 0x37400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_4_condition_mi_80_47400050() {
    // Encoding: 0x47400050
    // Test aarch32_SMLSLD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: RdLo=0, cond=4, RdHi=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x47400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_5_condition_pl_80_57400050() {
    // Encoding: 0x57400050
    // Test aarch32_SMLSLD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: RdLo=0, cond=5, Rm=0, RdHi=0, M=0, Rn=0
    let encoding: u32 = 0x57400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_6_condition_vs_80_67400050() {
    // Encoding: 0x67400050
    // Test aarch32_SMLSLD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, M=0, RdLo=0, Rn=0, cond=6
    let encoding: u32 = 0x67400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_7_condition_vc_80_77400050() {
    // Encoding: 0x77400050
    // Test aarch32_SMLSLD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, cond=7, RdHi=0, M=0, Rn=0
    let encoding: u32 = 0x77400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_8_condition_hi_80_87400050() {
    // Encoding: 0x87400050
    // Test aarch32_SMLSLD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, RdHi=0, Rn=0, RdLo=0, M=0, Rm=0
    let encoding: u32 = 0x87400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_9_condition_ls_80_97400050() {
    // Encoding: 0x97400050
    // Test aarch32_SMLSLD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, Rn=0, cond=9, M=0, RdHi=0
    let encoding: u32 = 0x97400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_10_condition_ge_80_a7400050() {
    // Encoding: 0xA7400050
    // Test aarch32_SMLSLD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, RdHi=0, RdLo=0, Rm=0, M=0
    let encoding: u32 = 0xA7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_11_condition_lt_80_b7400050() {
    // Encoding: 0xB7400050
    // Test aarch32_SMLSLD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: RdHi=0, cond=11, M=0, Rm=0, Rn=0, RdLo=0
    let encoding: u32 = 0xB7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_12_condition_gt_80_c7400050() {
    // Encoding: 0xC7400050
    // Test aarch32_SMLSLD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: RdLo=0, cond=12, RdHi=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0xC7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_13_condition_le_80_d7400050() {
    // Encoding: 0xD7400050
    // Test aarch32_SMLSLD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, RdLo=0, M=0, Rn=0, cond=13, RdHi=0
    let encoding: u32 = 0xD7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_14_condition_al_80_e7400050() {
    // Encoding: 0xE7400050
    // Test aarch32_SMLSLD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, Rn=0, M=0, cond=14, RdLo=0
    let encoding: u32 = 0xE7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlsld_a1_a_special_cond_15_condition_nv_80_f7400050() {
    // Encoding: 0xF7400050
    // Test aarch32_SMLSLD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, RdHi=0, cond=15, RdLo=0
    let encoding: u32 = 0xF7400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_a1_a_invalid_0_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: RdHi=0, cond=0, M=0, Rm=0, RdLo=0, Rn=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_a1_a_invalid_1_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, RdHi=0, M=0, cond=0, Rn=0, RdLo=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_a1_a_invalid_2_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: Rn=0, RdHi=0, cond=0, Rm=0, M=0, RdLo=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_a1_a_invalid_3_50_07400050() {
    // Encoding: 0x07400050
    // Test aarch32_SMLSLD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, M=0, RdLo=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x07400050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsld_t1_a_field_rn_0_min_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, RdLo=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsld_t1_a_field_rn_1_poweroftwo_c0_fbd100c0() {
    // Thumb encoding (32): 0xFBD100C0
    // Test aarch32_SMLSLD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, M=0, RdHi=0, RdLo=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD100C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsld_t1_a_field_rdlo_0_min_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=0, M=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlsld_t1_a_field_rdlo_1_poweroftwo_c0_fbd010c0() {
    // Thumb encoding (32): 0xFBD010C0
    // Test aarch32_SMLSLD_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Rn=0, RdHi=0, Rm=0, RdLo=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD010C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlsld_t1_a_field_rdlo_7_poweroftwominusone_c0_fbd070c0() {
    // Thumb encoding (32): 0xFBD070C0
    // Test aarch32_SMLSLD_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: RdLo=7, RdHi=0, Rm=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD070C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlsld_t1_a_field_rdlo_15_max_c0_fbd0f0c0() {
    // Thumb encoding (32): 0xFBD0F0C0
    // Test aarch32_SMLSLD_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: RdHi=0, M=0, Rm=0, Rn=0, RdLo=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD0F0C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsld_t1_a_field_rdhi_0_min_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: RdHi=0, Rm=0, Rn=0, RdLo=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_smlsld_t1_a_field_rdhi_1_poweroftwo_c0_fbd001c0() {
    // Thumb encoding (32): 0xFBD001C0
    // Test aarch32_SMLSLD_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdLo=0, Rm=0, M=0, RdHi=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD001C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_smlsld_t1_a_field_rdhi_7_poweroftwominusone_c0_fbd007c0() {
    // Thumb encoding (32): 0xFBD007C0
    // Test aarch32_SMLSLD_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: M=0, RdLo=0, Rm=0, Rn=0, RdHi=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD007C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_smlsld_t1_a_field_rdhi_15_max_c0_fbd00fc0() {
    // Thumb encoding (32): 0xFBD00FC0
    // Test aarch32_SMLSLD_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: RdLo=0, Rn=0, M=0, RdHi=15, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD00FC0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsld_t1_a_field_m_0_min_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, M=0, Rn=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlsld_t1_a_field_m_1_max_c0_fbd000d0() {
    // Thumb encoding (32): 0xFBD000D0
    // Test aarch32_SMLSLD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, RdHi=0, Rm=0, M=1, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000D0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsld_t1_a_field_rm_0_min_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rm=0, RdLo=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsld_t1_a_field_rm_1_poweroftwo_c0_fbd000c1() {
    // Thumb encoding (32): 0xFBD000C1
    // Test aarch32_SMLSLD_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, M=0, Rm=1, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlsld_t1_a_combo_0_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A field combination: Rn=0, RdLo=0, RdHi=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, RdLo=0, RdHi=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_t1_a_invalid_0_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: RdLo=0, Rm=0, M=0, RdHi=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_t1_a_invalid_1_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdLo=0, M=0, Rm=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_t1_a_invalid_2_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rn=0, RdLo=0, M=0, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSLD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsld_t1_a_invalid_3_c0_fbd000c0() {
    // Thumb encoding (32): 0xFBD000C0
    // Test aarch32_SMLSLD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rm=0, Rn=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBD000C0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMUAD_A Tests
// ============================================================================

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_0_min_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_1_poweroftwo_f010_1700f010() {
    // Encoding: 0x1700F010
    // Test aarch32_SMUAD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, M=0, Rd=0, Rm=0, cond=1
    let encoding: u32 = 0x1700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_2_poweroftwo_f010_2700f010() {
    // Encoding: 0x2700F010
    // Test aarch32_SMUAD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, M=0, Rm=0, cond=2
    let encoding: u32 = 0x2700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_3_poweroftwo_f010_3700f010() {
    // Encoding: 0x3700F010
    // Test aarch32_SMUAD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=3, M=0, Rm=0, Rn=0
    let encoding: u32 = 0x3700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_4_poweroftwo_f010_4700f010() {
    // Encoding: 0x4700F010
    // Test aarch32_SMUAD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=4, Rm=0, M=0
    let encoding: u32 = 0x4700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_5_poweroftwo_f010_5700f010() {
    // Encoding: 0x5700F010
    // Test aarch32_SMUAD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, M=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x5700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_6_poweroftwo_f010_6700f010() {
    // Encoding: 0x6700F010
    // Test aarch32_SMUAD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, M=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x6700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_7_poweroftwo_f010_7700f010() {
    // Encoding: 0x7700F010
    // Test aarch32_SMUAD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rm=0, M=0, Rn=0, Rd=0
    let encoding: u32 = 0x7700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_8_poweroftwo_f010_8700f010() {
    // Encoding: 0x8700F010
    // Test aarch32_SMUAD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=0, Rn=0, cond=8
    let encoding: u32 = 0x8700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_9_poweroftwo_f010_9700f010() {
    // Encoding: 0x9700F010
    // Test aarch32_SMUAD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=9, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x9700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_10_poweroftwo_f010_a700f010() {
    // Encoding: 0xA700F010
    // Test aarch32_SMUAD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=10, Rm=0, Rd=0, M=0
    let encoding: u32 = 0xA700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_11_poweroftwo_f010_b700f010() {
    // Encoding: 0xB700F010
    // Test aarch32_SMUAD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, Rm=0, cond=11, Rd=0
    let encoding: u32 = 0xB700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_12_poweroftwo_f010_c700f010() {
    // Encoding: 0xC700F010
    // Test aarch32_SMUAD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rm=0, cond=12, Rn=0, Rd=0
    let encoding: u32 = 0xC700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_13_poweroftwo_f010_d700f010() {
    // Encoding: 0xD700F010
    // Test aarch32_SMUAD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, M=0, Rm=0, cond=13, Rn=0
    let encoding: u32 = 0xD700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_14_poweroftwo_f010_e700f010() {
    // Encoding: 0xE700F010
    // Test aarch32_SMUAD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, M=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0xE700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smuad_a1_a_field_cond_15_max_f010_f700f010() {
    // Encoding: 0xF700F010
    // Test aarch32_SMUAD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: M=0, Rd=0, cond=15, Rn=0, Rm=0
    let encoding: u32 = 0xF700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smuad_a1_a_field_rd_0_min_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=0, M=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smuad_a1_a_field_rd_1_poweroftwo_f010_0701f010() {
    // Encoding: 0x0701F010
    // Test aarch32_SMUAD_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=0, Rd=1, Rm=0
    let encoding: u32 = 0x0701F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smuad_a1_a_field_rm_0_min_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: M=0, Rm=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smuad_a1_a_field_rm_1_poweroftwo_f010_0700f110() {
    // Encoding: 0x0700F110
    // Test aarch32_SMUAD_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rm=1, Rd=0, Rn=0, cond=0
    let encoding: u32 = 0x0700F110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smuad_a1_a_field_m_0_min_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smuad_a1_a_field_m_1_max_f010_0700f030() {
    // Encoding: 0x0700F030
    // Test aarch32_SMUAD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rd=0, M=1, cond=0, Rn=0
    let encoding: u32 = 0x0700F030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smuad_a1_a_field_rn_0_min_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, M=0, cond=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smuad_a1_a_field_rn_1_poweroftwo_f010_0700f011() {
    // Encoding: 0x0700F011
    // Test aarch32_SMUAD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=1, Rm=0, cond=0, M=0
    let encoding: u32 = 0x0700F011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smuad_a1_a_combo_0_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A field combination: cond=0, Rd=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smuad_a1_a_special_cond_0_condition_eq_61456_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rm=0, M=0, cond=0, Rd=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smuad_a1_a_special_cond_1_condition_ne_61456_1700f010() {
    // Encoding: 0x1700F010
    // Test aarch32_SMUAD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x1700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smuad_a1_a_special_cond_2_condition_cs_hs_61456_2700f010() {
    // Encoding: 0x2700F010
    // Test aarch32_SMUAD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rn=0, Rd=0, M=0
    let encoding: u32 = 0x2700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smuad_a1_a_special_cond_3_condition_cc_lo_61456_3700f010() {
    // Encoding: 0x3700F010
    // Test aarch32_SMUAD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: M=0, Rn=0, Rd=0, cond=3, Rm=0
    let encoding: u32 = 0x3700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smuad_a1_a_special_cond_4_condition_mi_61456_4700f010() {
    // Encoding: 0x4700F010
    // Test aarch32_SMUAD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Rd=0, M=0, cond=4, Rm=0
    let encoding: u32 = 0x4700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smuad_a1_a_special_cond_5_condition_pl_61456_5700f010() {
    // Encoding: 0x5700F010
    // Test aarch32_SMUAD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, M=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x5700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smuad_a1_a_special_cond_6_condition_vs_61456_6700f010() {
    // Encoding: 0x6700F010
    // Test aarch32_SMUAD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=6, Rm=0, Rd=0
    let encoding: u32 = 0x6700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smuad_a1_a_special_cond_7_condition_vc_61456_7700f010() {
    // Encoding: 0x7700F010
    // Test aarch32_SMUAD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: M=0, Rm=0, Rn=0, cond=7, Rd=0
    let encoding: u32 = 0x7700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smuad_a1_a_special_cond_8_condition_hi_61456_8700f010() {
    // Encoding: 0x8700F010
    // Test aarch32_SMUAD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rn=0, cond=8, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x8700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smuad_a1_a_special_cond_9_condition_ls_61456_9700f010() {
    // Encoding: 0x9700F010
    // Test aarch32_SMUAD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x9700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smuad_a1_a_special_cond_10_condition_ge_61456_a700f010() {
    // Encoding: 0xA700F010
    // Test aarch32_SMUAD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, cond=10, Rd=0
    let encoding: u32 = 0xA700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smuad_a1_a_special_cond_11_condition_lt_61456_b700f010() {
    // Encoding: 0xB700F010
    // Test aarch32_SMUAD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=11, Rm=0, M=0
    let encoding: u32 = 0xB700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smuad_a1_a_special_cond_12_condition_gt_61456_c700f010() {
    // Encoding: 0xC700F010
    // Test aarch32_SMUAD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rm=0, cond=12, M=0, Rd=0, Rn=0
    let encoding: u32 = 0xC700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smuad_a1_a_special_cond_13_condition_le_61456_d700f010() {
    // Encoding: 0xD700F010
    // Test aarch32_SMUAD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, cond=13, Rd=0
    let encoding: u32 = 0xD700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smuad_a1_a_special_cond_14_condition_al_61456_e700f010() {
    // Encoding: 0xE700F010
    // Test aarch32_SMUAD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rn=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0xE700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smuad_a1_a_special_cond_15_condition_nv_61456_f700f010() {
    // Encoding: 0xF700F010
    // Test aarch32_SMUAD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, cond=15, Rn=0, Rd=0, M=0
    let encoding: u32 = 0xF700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smuad_a1_a_invalid_0_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMUAD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smuad_a1_a_invalid_1_f010_0700f010() {
    // Encoding: 0x0700F010
    // Test aarch32_SMUAD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, Rd=0, M=0
    let encoding: u32 = 0x0700F010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smuad_t1_a_field_rn_0_min_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, M=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smuad_t1_a_field_rn_1_poweroftwo_f000_fb21f000() {
    // Thumb encoding (32): 0xFB21F000
    // Test aarch32_SMUAD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, M=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB21F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smuad_t1_a_field_rd_0_min_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smuad_t1_a_field_rd_1_poweroftwo_f000_fb20f100() {
    // Thumb encoding (32): 0xFB20F100
    // Test aarch32_SMUAD_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=1, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smuad_t1_a_field_m_0_min_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smuad_t1_a_field_m_1_max_f000_fb20f010() {
    // Thumb encoding (32): 0xFB20F010
    // Test aarch32_SMUAD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smuad_t1_a_field_rm_0_min_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smuad_t1_a_field_rm_1_poweroftwo_f000_fb20f001() {
    // Thumb encoding (32): 0xFB20F001
    // Test aarch32_SMUAD_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, M=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smuad_t1_a_combo_0_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A field combination: Rn=0, Rd=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, M=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smuad_t1_a_invalid_0_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMUAD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smuad_t1_a_invalid_1_f000_fb20f000() {
    // Thumb encoding (32): 0xFB20F000
    // Test aarch32_SMUAD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, M=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB20F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_MUL_A Tests
// ============================================================================

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_mul_a1_a_field_cond_0_min_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: S=0, cond=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_mul_a1_a_field_cond_1_poweroftwo_90_10000090() {
    // Encoding: 0x10000090
    // Test aarch32_MUL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, cond=1, Rm=0
    let encoding: u32 = 0x10000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_mul_a1_a_field_cond_2_poweroftwo_90_20000090() {
    // Encoding: 0x20000090
    // Test aarch32_MUL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=2, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x20000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_mul_a1_a_field_cond_3_poweroftwo_90_30000090() {
    // Encoding: 0x30000090
    // Test aarch32_MUL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, Rm=0, cond=3, Rn=0
    let encoding: u32 = 0x30000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_mul_a1_a_field_cond_4_poweroftwo_90_40000090() {
    // Encoding: 0x40000090
    // Test aarch32_MUL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=4, Rm=0, Rn=0
    let encoding: u32 = 0x40000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_mul_a1_a_field_cond_5_poweroftwo_90_50000090() {
    // Encoding: 0x50000090
    // Test aarch32_MUL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, S=0, cond=5
    let encoding: u32 = 0x50000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_mul_a1_a_field_cond_6_poweroftwo_90_60000090() {
    // Encoding: 0x60000090
    // Test aarch32_MUL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, S=0, cond=6
    let encoding: u32 = 0x60000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_mul_a1_a_field_cond_7_poweroftwo_90_70000090() {
    // Encoding: 0x70000090
    // Test aarch32_MUL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, S=0, Rm=0, Rn=0, cond=7
    let encoding: u32 = 0x70000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_mul_a1_a_field_cond_8_poweroftwo_90_80000090() {
    // Encoding: 0x80000090
    // Test aarch32_MUL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=8, S=0, Rm=0, Rd=0
    let encoding: u32 = 0x80000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_mul_a1_a_field_cond_9_poweroftwo_90_90000090() {
    // Encoding: 0x90000090
    // Test aarch32_MUL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=9, S=0
    let encoding: u32 = 0x90000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_mul_a1_a_field_cond_10_poweroftwo_90_a0000090() {
    // Encoding: 0xA0000090
    // Test aarch32_MUL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, Rm=0, Rd=0, cond=10
    let encoding: u32 = 0xA0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_mul_a1_a_field_cond_11_poweroftwo_90_b0000090() {
    // Encoding: 0xB0000090
    // Test aarch32_MUL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=11, S=0, Rd=0
    let encoding: u32 = 0xB0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_mul_a1_a_field_cond_12_poweroftwo_90_c0000090() {
    // Encoding: 0xC0000090
    // Test aarch32_MUL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, S=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0xC0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_mul_a1_a_field_cond_13_poweroftwo_90_d0000090() {
    // Encoding: 0xD0000090
    // Test aarch32_MUL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, S=0, Rm=0, Rd=0
    let encoding: u32 = 0xD0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_mul_a1_a_field_cond_14_poweroftwo_90_e0000090() {
    // Encoding: 0xE0000090
    // Test aarch32_MUL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=14, Rn=0, Rm=0, S=0
    let encoding: u32 = 0xE0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_mul_a1_a_field_cond_15_max_90_f0000090() {
    // Encoding: 0xF0000090
    // Test aarch32_MUL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, Rd=0, cond=15
    let encoding: u32 = 0xF0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_mul_a1_a_field_s_0_min_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, S=0, Rd=0, Rn=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_mul_a1_a_field_s_1_max_90_00100090() {
    // Encoding: 0x00100090
    // Test aarch32_MUL_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: S=1, Rd=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x00100090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_a1_a_field_rd_0_min_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, S=0, Rm=0, cond=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_a1_a_field_rd_1_poweroftwo_90_00010090() {
    // Encoding: 0x00010090
    // Test aarch32_MUL_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=0, S=0, Rm=0, Rd=1
    let encoding: u32 = 0x00010090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_a1_a_field_rm_0_min_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, S=0, cond=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_a1_a_field_rm_1_poweroftwo_90_00000190() {
    // Encoding: 0x00000190
    // Test aarch32_MUL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=1, Rd=0, S=0, Rn=0
    let encoding: u32 = 0x00000190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_a1_a_field_rn_0_min_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_a1_a_field_rn_1_poweroftwo_90_00000091() {
    // Encoding: 0x00000091
    // Test aarch32_MUL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rn=1, Rd=0, S=0, Rm=0
    let encoding: u32 = 0x00000091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_mul_a1_a_combo_0_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A field combination: cond=0, S=0, Rd=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, cond=0, Rd=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_mul_a1_a_special_cond_0_condition_eq_144_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, S=0, Rd=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_mul_a1_a_special_cond_1_condition_ne_144_10000090() {
    // Encoding: 0x10000090
    // Test aarch32_MUL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, S=0, Rn=0, Rm=0
    let encoding: u32 = 0x10000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_mul_a1_a_special_cond_2_condition_cs_hs_144_20000090() {
    // Encoding: 0x20000090
    // Test aarch32_MUL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, S=0, cond=2, Rm=0
    let encoding: u32 = 0x20000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_mul_a1_a_special_cond_3_condition_cc_lo_144_30000090() {
    // Encoding: 0x30000090
    // Test aarch32_MUL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, cond=3, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x30000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_mul_a1_a_special_cond_4_condition_mi_144_40000090() {
    // Encoding: 0x40000090
    // Test aarch32_MUL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, cond=4, S=0, Rn=0, Rm=0
    let encoding: u32 = 0x40000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_mul_a1_a_special_cond_5_condition_pl_144_50000090() {
    // Encoding: 0x50000090
    // Test aarch32_MUL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rm=0, Rn=0, Rd=0, S=0
    let encoding: u32 = 0x50000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_mul_a1_a_special_cond_6_condition_vs_144_60000090() {
    // Encoding: 0x60000090
    // Test aarch32_MUL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, cond=6, S=0, Rn=0, Rd=0
    let encoding: u32 = 0x60000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_mul_a1_a_special_cond_7_condition_vc_144_70000090() {
    // Encoding: 0x70000090
    // Test aarch32_MUL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=7, Rm=0, Rd=0
    let encoding: u32 = 0x70000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_mul_a1_a_special_cond_8_condition_hi_144_80000090() {
    // Encoding: 0x80000090
    // Test aarch32_MUL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, S=0, Rm=0, Rn=0, cond=8
    let encoding: u32 = 0x80000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_mul_a1_a_special_cond_9_condition_ls_144_90000090() {
    // Encoding: 0x90000090
    // Test aarch32_MUL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, Rd=0, cond=9, Rn=0, Rm=0
    let encoding: u32 = 0x90000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_mul_a1_a_special_cond_10_condition_ge_144_a0000090() {
    // Encoding: 0xA0000090
    // Test aarch32_MUL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rn=0, S=0, cond=10, Rd=0
    let encoding: u32 = 0xA0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_mul_a1_a_special_cond_11_condition_lt_144_b0000090() {
    // Encoding: 0xB0000090
    // Test aarch32_MUL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, cond=11, Rd=0, Rn=0, S=0
    let encoding: u32 = 0xB0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_mul_a1_a_special_cond_12_condition_gt_144_c0000090() {
    // Encoding: 0xC0000090
    // Test aarch32_MUL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=12, Rd=0, Rm=0
    let encoding: u32 = 0xC0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_mul_a1_a_special_cond_13_condition_le_144_d0000090() {
    // Encoding: 0xD0000090
    // Test aarch32_MUL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rd=0, Rm=0, Rn=0, S=0
    let encoding: u32 = 0xD0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_mul_a1_a_special_cond_14_condition_al_144_e0000090() {
    // Encoding: 0xE0000090
    // Test aarch32_MUL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: S=0, Rn=0, Rm=0, cond=14, Rd=0
    let encoding: u32 = 0xE0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_mul_a1_a_special_cond_15_condition_nv_144_f0000090() {
    // Encoding: 0xF0000090
    // Test aarch32_MUL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, Rd=0, S=0, cond=15, Rn=0
    let encoding: u32 = 0xF0000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_mul_a1_a_special_s_0_size_variant_0_144_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: S=0, Rm=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_mul_a1_a_special_s_1_size_variant_1_144_00100090() {
    // Encoding: 0x00100090
    // Test aarch32_MUL_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: S=1, Rn=0, Rd=0, Rm=0, cond=0
    let encoding: u32 = 0x00100090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mul_a1_a_invalid_0_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: S=0, Rm=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mul_a1_a_invalid_1_90_00000090() {
    // Encoding: 0x00000090
    // Test aarch32_MUL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rm=0, S=0
    let encoding: u32 = 0x00000090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_t1_a_field_rn_0_min_0_43400000() {
    // Thumb encoding (32): 0x43400000
    // Test aarch32_MUL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rdm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `field Rn 19 +: 3`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_t1_a_field_rn_1_poweroftwo_0_43480000() {
    // Thumb encoding (32): 0x43480000
    // Test aarch32_MUL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdm=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43480000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `field Rdm 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdm", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_mul_t1_a_field_rdm_0_min_0_43400000() {
    // Thumb encoding (32): 0x43400000
    // Test aarch32_MUL_T1_A field Rdm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rdm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `field Rdm 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdm", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_mul_t1_a_field_rdm_1_poweroftwo_0_43410000() {
    // Thumb encoding (32): 0x43410000
    // Test aarch32_MUL_T1_A field Rdm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rdm=1, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `field Rdm 16 +: 3`
/// Requirement: FieldBoundary { field: "Rdm", value: 7, boundary: Max }
/// maximum value (7)
#[test]
fn test_aarch32_mul_t1_a_field_rdm_7_max_0_43470000() {
    // Thumb encoding (32): 0x43470000
    // Test aarch32_MUL_T1_A field Rdm = 7 (Max)
    // ISET: T32
    // Fields: Rn=0, Rdm=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43470000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_mul_t1_a_combo_0_0_43400000() {
    // Thumb encoding (32): 0x43400000
    // Test aarch32_MUL_T1_A field combination: Rn=0, Rdm=0
    // ISET: T32
    // Fields: Rdm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0x43400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_t2_a_field_rn_0_min_f000_fb00f000() {
    // Thumb encoding (32): 0xFB00F000
    // Test aarch32_MUL_T2_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_t2_a_field_rn_1_poweroftwo_f000_fb01f000() {
    // Thumb encoding (32): 0xFB01F000
    // Test aarch32_MUL_T2_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB01F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_t2_a_field_rd_0_min_f000_fb00f000() {
    // Thumb encoding (32): 0xFB00F000
    // Test aarch32_MUL_T2_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_t2_a_field_rd_1_poweroftwo_f000_fb00f100() {
    // Thumb encoding (32): 0xFB00F100
    // Test aarch32_MUL_T2_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_mul_t2_a_field_rm_0_min_f000_fb00f000() {
    // Thumb encoding (32): 0xFB00F000
    // Test aarch32_MUL_T2_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_mul_t2_a_field_rm_1_poweroftwo_f000_fb00f001() {
    // Thumb encoding (32): 0xFB00F001
    // Test aarch32_MUL_T2_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_mul_t2_a_combo_0_f000_fb00f000() {
    // Thumb encoding (32): 0xFB00F000
    // Test aarch32_MUL_T2_A field combination: Rn=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mul_t2_a_invalid_0_f000_fb00f000() {
    // Thumb encoding (32): 0xFB00F000
    // Test aarch32_MUL_T2_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_mul_t2_a_invalid_1_f000_fb00f000() {
    // Thumb encoding (32): 0xFB00F000
    // Test aarch32_MUL_T2_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB00F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x2);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // Encoding: 0x1B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xB);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_mul_a1_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // Encoding: 0x9B027C20
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_mul_a1_a_a32_mul_0_0000f291() {
    // Test A32 MUL: simple values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_mul_a1_a_a32_mul_1_0000f291() {
    // Test A32 MUL: zero values (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_mul_a1_a_a32_mul_2_0000f291() {
    // Test A32 MUL: max value (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set
#[test]
fn test_aarch32_mul_a1_a_a32_mul_3_0000f291() {
    // Test A32 MUL: MSB set (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x80000000);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_mul_a1_a_a32_mul_4_0000f291() {
    // Test A32 MUL: mixed pattern (oracle)
    // Encoding: 0x0000F291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x9ABCDEF0);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x0000F291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x242D2080, "R0 should be 0x242D2080");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_mul_a1_a_flags_zeroresult_0_00100291() {
    // Test aarch32_MUL_A1_A flag computation: ZeroResult
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_mul_a1_a_flags_zeroresult_1_00100291() {
    // Test aarch32_MUL_A1_A flag computation: ZeroResult
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_mul_a1_a_flags_negativeresult_2_00100291() {
    // Test aarch32_MUL_A1_A flag computation: NegativeResult
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_mul_a1_a_flags_unsignedoverflow_3_00100291() {
    // Test aarch32_MUL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_mul_a1_a_flags_unsignedoverflow_4_00100291() {
    // Test aarch32_MUL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_mul_a1_a_flags_signedoverflow_5_00100291() {
    // Test aarch32_MUL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_mul_a1_a_flags_signedoverflow_6_00100291() {
    // Test aarch32_MUL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_mul_a1_a_flags_positiveresult_7_00100291() {
    // Test aarch32_MUL_A1_A flag computation: PositiveResult
    // Encoding: 0x00100291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00100291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 0 (32)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_32_0_43420020() {
    // Test LSLV 32-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x12345678, "W0 should be 0x12345678");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 0 (64)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_64_0_c3420020() {
    // Test LSLV 64-bit: shift by 0 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x12345678,
        "X0 should be 0x0000000012345678"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4 (32)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_32_1_43420020() {
    // Test LSLV 32-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x23456780, "W0 should be 0x23456780");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 4 (64)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_64_1_c3420020() {
    // Test LSLV 64-bit: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x4);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x23456780,
        "X0 should be 0x0000000123456780"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 8 (32)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_32_2_43420020() {
    // Test LSLV 32-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x8);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x34567800, "W0 should be 0x34567800");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift by 8 (64)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_64_2_c3420020() {
    // Test LSLV 64-bit: shift by 8 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x8);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x34567800,
        "X0 should be 0x0000001234567800"
    );
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1 (32)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_32_3_43420020() {
    // Test LSLV 32-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set, shift 1 (64)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_64_3_c3420020() {
    // Test LSLV 64-bit: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// LSB set, max shift (32)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_32_4_43420020() {
    // Test LSLV 32-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3F);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "W0 should be 0x80000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// LSB set, max shift (64)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_64_4_c3420020() {
    // Test LSLV 64-bit: LSB set, max shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x3F);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x8000000000000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// all ones, shift 32 (32)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_32_5_43420020() {
    // Test LSLV 32-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "W0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// all ones, shift 32 (64)
#[test]
fn test_aarch32_mul_t1_a_lslv_oracle_64_5_c3420020() {
    // Test LSLV 64-bit: all ones, shift 32 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x20);
    let encoding: u16 = 0x0020;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0xFFFFFFFF00000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// no shift
#[test]
fn test_aarch32_mul_t1_a_t16_oracle_0_43480000() {
    // Test T16 LSLS: no shift (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF, "R0 should be 0x000000FF");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift by 4
#[test]
fn test_aarch32_mul_t1_a_t16_oracle_1_43480000() {
    // Test T16 LSLS: shift by 4 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFF);
    set_w(&mut cpu, 2, 0x4);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFF0, "R0 should be 0x00000FF0");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set, shift 1
#[test]
fn test_aarch32_mul_t1_a_t16_oracle_2_43480000() {
    // Test T16 LSLS: MSB set, shift 1 (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x80000000);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `LSLS R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift to MSB
#[test]
fn test_aarch32_mul_t1_a_t16_oracle_3_43480000() {
    // Test T16 LSLS: shift to MSB (oracle)
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1F);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x80000000, "R0 should be 0x80000000");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_mul_t1_a_flags_zeroresult_0_43480000() {
    // Test aarch32_MUL_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_mul_t1_a_flags_zeroresult_1_43480000() {
    // Test aarch32_MUL_T1_A flag computation: ZeroResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_mul_t1_a_flags_negativeresult_2_43480000() {
    // Test aarch32_MUL_T1_A flag computation: NegativeResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_mul_t1_a_flags_unsignedoverflow_3_43480000() {
    // Test aarch32_MUL_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_mul_t1_a_flags_unsignedoverflow_4_43480000() {
    // Test aarch32_MUL_T1_A flag computation: UnsignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_mul_t1_a_flags_signedoverflow_5_43480000() {
    // Test aarch32_MUL_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_mul_t1_a_flags_signedoverflow_6_43480000() {
    // Test aarch32_MUL_T1_A flag computation: SignedOverflow
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_mul_t1_a_flags_positiveresult_7_43480000() {
    // Test aarch32_MUL_T1_A flag computation: PositiveResult
    // ISET: T16
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u16 = 0x0000;
    // T16: Write 16-bit instruction
    cpu.write_memory(0, &(encoding as u32).to_le_bytes())
        .unwrap();
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple multiply (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_0_1b027c20() {
    // Test MUL 32-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "W0 should be 0x00000006");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple multiply (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_0_9b027c20() {
    // Test MUL 64-bit: simple multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x2);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x6, "X0 should be 0x0000000000000006");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by zero (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_1_1b027c20() {
    // Test MUL 32-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by zero (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_1_9b027c20() {
    // Test MUL 64-bit: multiply by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x64);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// multiply by one (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_2_1b027c20() {
    // Test MUL 32-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// multiply by one (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_2_9b027c20() {
    // Test MUL 64-bit: multiply by one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 16-bit max * 16-bit max (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_3_1b027c20() {
    // Test MUL 32-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFE0001, "W0 should be 0xFFFE0001");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 16-bit max * 16-bit max (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_3_9b027c20() {
    // Test MUL 64-bit: 16-bit max * 16-bit max (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFF);
    set_w(&mut cpu, 2, 0xFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFE0001,
        "X0 should be 0x00000000FFFE0001"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// shift-like multiply (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_4_1b027c20() {
    // Test MUL 32-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x2468ACF0, "W0 should be 0x2468ACF0");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// shift-like multiply (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_4_9b027c20() {
    // Test MUL 64-bit: shift-like multiply (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x12345678);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0x2468ACF0,
        "X0 should be 0x000000002468ACF0"
    );
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// larger values (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_5_1b027c20() {
    // Test MUL 32-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "W0 should be 0x00004E20");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// larger values (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_5_9b027c20() {
    // Test MUL 64-bit: larger values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xC8);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4E20, "X0 should be 0x0000000000004E20");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// 32-bit overflow (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_6_1b027c20() {
    // Test MUL 32-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// 32-bit overflow (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_6_9b027c20() {
    // Test MUL 64-bit: 32-bit overflow (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0xFFFFFFFE00000001");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// prime numbers (32)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_32_7_1b027c20() {
    // Test MUL 32-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x1B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "W0 should be 0x0000004D");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// prime numbers (64)
#[test]
fn test_aarch32_mul_t2_a_mul_oracle_64_7_9b027c20() {
    // Test MUL 64-bit: prime numbers (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0xB);
    let encoding: u32 = 0x9B027C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x4D, "X0 should be 0x000000000000004D");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple values
#[test]
fn test_aarch32_mul_t2_a_t32_oracle_0_fb01f002() {
    // Test T32 MUL: simple values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1388, "R0 should be 0x00001388");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero values
#[test]
fn test_aarch32_mul_t2_a_t32_oracle_1_fb01f002() {
    // Test T32 MUL: zero values (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value
#[test]
fn test_aarch32_mul_t2_a_t32_oracle_2_fb01f002() {
    // Test T32 MUL: max value (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xFFFFFFFF, "R0 should be 0xFFFFFFFF");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `MUL R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// mixed pattern
#[test]
fn test_aarch32_mul_t2_a_t32_oracle_3_fb01f002() {
    // Test T32 MUL: mixed pattern (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x12345678);
    set_w(&mut cpu, 2, 0xABCDEF01);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x55065E78, "R0 should be 0x55065E78");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_mul_t2_a_flags_zeroresult_0_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_mul_t2_a_flags_zeroresult_1_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_mul_t2_a_flags_negativeresult_2_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_mul_t2_a_flags_unsignedoverflow_3_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_mul_t2_a_flags_unsignedoverflow_4_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_mul_t2_a_flags_signedoverflow_5_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_mul_t2_a_flags_signedoverflow_6_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_MUL_T2_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_mul_t2_a_flags_positiveresult_7_fb01f002() {
    // Test aarch32_MUL_T2_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xFB01F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

// ============================================================================
// aarch32_UDIV_A Tests
// ============================================================================

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_0_min_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_1_poweroftwo_10_17300010() {
    // Encoding: 0x17300010
    // Test aarch32_UDIV_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0, cond=1
    let encoding: u32 = 0x17300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_2_poweroftwo_10_27300010() {
    // Encoding: 0x27300010
    // Test aarch32_UDIV_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=2, Rd=0, Ra=0
    let encoding: u32 = 0x27300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_3_poweroftwo_10_37300010() {
    // Encoding: 0x37300010
    // Test aarch32_UDIV_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rd=0, cond=3, Rm=0, Rn=0
    let encoding: u32 = 0x37300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_4_poweroftwo_10_47300010() {
    // Encoding: 0x47300010
    // Test aarch32_UDIV_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rd=0, Rn=0, Rm=0, Ra=0
    let encoding: u32 = 0x47300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_5_poweroftwo_10_57300010() {
    // Encoding: 0x57300010
    // Test aarch32_UDIV_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=5, Ra=0
    let encoding: u32 = 0x57300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_6_poweroftwo_10_67300010() {
    // Encoding: 0x67300010
    // Test aarch32_UDIV_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=6, Ra=0, Rn=0
    let encoding: u32 = 0x67300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_7_poweroftwo_10_77300010() {
    // Encoding: 0x77300010
    // Test aarch32_UDIV_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Rd=0, Rm=0, Ra=0
    let encoding: u32 = 0x77300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_8_poweroftwo_10_87300010() {
    // Encoding: 0x87300010
    // Test aarch32_UDIV_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, cond=8, Rm=0
    let encoding: u32 = 0x87300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_9_poweroftwo_10_97300010() {
    // Encoding: 0x97300010
    // Test aarch32_UDIV_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=9, Rn=0, Rm=0, Ra=0
    let encoding: u32 = 0x97300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_10_poweroftwo_10_a7300010() {
    // Encoding: 0xA7300010
    // Test aarch32_UDIV_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, Rn=0, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0xA7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_11_poweroftwo_10_b7300010() {
    // Encoding: 0xB7300010
    // Test aarch32_UDIV_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=11, Rd=0, Ra=0
    let encoding: u32 = 0xB7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_12_poweroftwo_10_c7300010() {
    // Encoding: 0xC7300010
    // Test aarch32_UDIV_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=12, Rd=0, Rn=0
    let encoding: u32 = 0xC7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_13_poweroftwo_10_d7300010() {
    // Encoding: 0xD7300010
    // Test aarch32_UDIV_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13, Rn=0, Ra=0
    let encoding: u32 = 0xD7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_14_poweroftwo_10_e7300010() {
    // Encoding: 0xE7300010
    // Test aarch32_UDIV_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, cond=14, Rm=0
    let encoding: u32 = 0xE7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_udiv_a1_a_field_cond_15_max_10_f7300010() {
    // Encoding: 0xF7300010
    // Test aarch32_UDIV_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=15, Rd=0, Rm=0
    let encoding: u32 = 0xF7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_a1_a_field_rd_0_min_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_a1_a_field_rd_1_poweroftwo_10_07310010() {
    // Encoding: 0x07310010
    // Test aarch32_UDIV_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, Rn=0, Rm=0, cond=0, Ra=0
    let encoding: u32 = 0x07310010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_a1_a_field_ra_0_min_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=0, Rn=0, Ra=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_a1_a_field_ra_1_poweroftwo_10_07301010() {
    // Encoding: 0x07301010
    // Test aarch32_UDIV_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=1, Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x07301010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_a1_a_field_rm_0_min_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_a1_a_field_rm_1_poweroftwo_10_07300110() {
    // Encoding: 0x07300110
    // Test aarch32_UDIV_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=1, Rn=0, cond=0
    let encoding: u32 = 0x07300110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_a1_a_field_rn_0_min_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, Rd=0, Ra=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_a1_a_field_rn_1_poweroftwo_10_07300011() {
    // Encoding: 0x07300011
    // Test aarch32_UDIV_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, Ra=0, Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x07300011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_udiv_a1_a_combo_0_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, cond=0, Rm=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_udiv_a1_a_special_cond_0_condition_eq_16_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Ra=0, Rd=0, Rn=0, cond=0, Rm=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_udiv_a1_a_special_cond_1_condition_ne_16_17300010() {
    // Encoding: 0x17300010
    // Test aarch32_UDIV_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=1, Ra=0
    let encoding: u32 = 0x17300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_udiv_a1_a_special_cond_2_condition_cs_hs_16_27300010() {
    // Encoding: 0x27300010
    // Test aarch32_UDIV_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rd=0, cond=2, Rn=0
    let encoding: u32 = 0x27300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_udiv_a1_a_special_cond_3_condition_cc_lo_16_37300010() {
    // Encoding: 0x37300010
    // Test aarch32_UDIV_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rm=0, cond=3, Rd=0
    let encoding: u32 = 0x37300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_udiv_a1_a_special_cond_4_condition_mi_16_47300010() {
    // Encoding: 0x47300010
    // Test aarch32_UDIV_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rd=0, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0x47300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_udiv_a1_a_special_cond_5_condition_pl_16_57300010() {
    // Encoding: 0x57300010
    // Test aarch32_UDIV_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Ra=0, Rd=0, Rn=0, cond=5, Rm=0
    let encoding: u32 = 0x57300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_udiv_a1_a_special_cond_6_condition_vs_16_67300010() {
    // Encoding: 0x67300010
    // Test aarch32_UDIV_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=6, Rd=0, Ra=0
    let encoding: u32 = 0x67300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_udiv_a1_a_special_cond_7_condition_vc_16_77300010() {
    // Encoding: 0x77300010
    // Test aarch32_UDIV_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, cond=7, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x77300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_udiv_a1_a_special_cond_8_condition_hi_16_87300010() {
    // Encoding: 0x87300010
    // Test aarch32_UDIV_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rm=0, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0x87300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_udiv_a1_a_special_cond_9_condition_ls_16_97300010() {
    // Encoding: 0x97300010
    // Test aarch32_UDIV_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x97300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_udiv_a1_a_special_cond_10_condition_ge_16_a7300010() {
    // Encoding: 0xA7300010
    // Test aarch32_UDIV_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Ra=0, cond=10, Rd=0
    let encoding: u32 = 0xA7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_udiv_a1_a_special_cond_11_condition_lt_16_b7300010() {
    // Encoding: 0xB7300010
    // Test aarch32_UDIV_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=11, Rm=0, Rn=0
    let encoding: u32 = 0xB7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_udiv_a1_a_special_cond_12_condition_gt_16_c7300010() {
    // Encoding: 0xC7300010
    // Test aarch32_UDIV_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rn=0, cond=12, Rm=0
    let encoding: u32 = 0xC7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_udiv_a1_a_special_cond_13_condition_le_16_d7300010() {
    // Encoding: 0xD7300010
    // Test aarch32_UDIV_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=13, Rd=0, Rm=0
    let encoding: u32 = 0xD7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_udiv_a1_a_special_cond_14_condition_al_16_e7300010() {
    // Encoding: 0xE7300010
    // Test aarch32_UDIV_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=14, Ra=0, Rm=0
    let encoding: u32 = 0xE7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_udiv_a1_a_special_cond_15_condition_nv_16_f7300010() {
    // Encoding: 0xF7300010
    // Test aarch32_UDIV_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=15, Ra=0
    let encoding: u32 = 0xF7300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_udiv_a1_a_invalid_0_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UDIV_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_udiv_a1_a_invalid_1_10_07300010() {
    // Encoding: 0x07300010
    // Test aarch32_UDIV_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x07300010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_t1_a_field_rn_0_min_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_t1_a_field_rn_1_poweroftwo_f0_fbb100f0() {
    // Thumb encoding (32): 0xFBB100F0
    // Test aarch32_UDIV_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rd=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_t1_a_field_ra_0_min_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_t1_a_field_ra_1_poweroftwo_f0_fbb010f0() {
    // Thumb encoding (32): 0xFBB010F0
    // Test aarch32_UDIV_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=1, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB010F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_t1_a_field_rd_0_min_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_t1_a_field_rd_1_poweroftwo_f0_fbb001f0() {
    // Thumb encoding (32): 0xFBB001F0
    // Test aarch32_UDIV_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rn=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_udiv_t1_a_field_rm_0_min_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_udiv_t1_a_field_rm_1_poweroftwo_f0_fbb000f1() {
    // Thumb encoding (32): 0xFBB000F1
    // Test aarch32_UDIV_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Rn=0, Rd=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_udiv_t1_a_combo_0_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A field combination: Rn=0, Ra=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Ra=0, Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_udiv_t1_a_invalid_0_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UDIV_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_udiv_t1_a_invalid_1_f0_fbb000f0() {
    // Thumb encoding (32): 0xFBB000F0
    // Test aarch32_UDIV_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBB000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMLAD_A Tests
// ============================================================================

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_0_min_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, M=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_1_poweroftwo_10_17000010() {
    // Encoding: 0x17000010
    // Test aarch32_SMLAD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=1, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x17000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_2_poweroftwo_10_27000010() {
    // Encoding: 0x27000010
    // Test aarch32_SMLAD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=2, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x27000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_3_poweroftwo_10_37000010() {
    // Encoding: 0x37000010
    // Test aarch32_SMLAD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=3, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x37000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_4_poweroftwo_10_47000010() {
    // Encoding: 0x47000010
    // Test aarch32_SMLAD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, Ra=0, M=0, cond=4
    let encoding: u32 = 0x47000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_5_poweroftwo_10_57000010() {
    // Encoding: 0x57000010
    // Test aarch32_SMLAD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, Rd=0, cond=5, Ra=0
    let encoding: u32 = 0x57000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_6_poweroftwo_10_67000010() {
    // Encoding: 0x67000010
    // Test aarch32_SMLAD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rd=0, Ra=0, cond=6, Rm=0, Rn=0
    let encoding: u32 = 0x67000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_7_poweroftwo_10_77000010() {
    // Encoding: 0x77000010
    // Test aarch32_SMLAD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rd=0, M=0, cond=7, Rn=0
    let encoding: u32 = 0x77000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_8_poweroftwo_10_87000010() {
    // Encoding: 0x87000010
    // Test aarch32_SMLAD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, M=0, Ra=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x87000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_9_poweroftwo_10_97000010() {
    // Encoding: 0x97000010
    // Test aarch32_SMLAD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=9, Rn=0, Ra=0, Rd=0, Rm=0
    let encoding: u32 = 0x97000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_10_poweroftwo_10_a7000010() {
    // Encoding: 0xA7000010
    // Test aarch32_SMLAD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, M=0, Rd=0, Ra=0, cond=10
    let encoding: u32 = 0xA7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_11_poweroftwo_10_b7000010() {
    // Encoding: 0xB7000010
    // Test aarch32_SMLAD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, M=0, Rn=0, Rm=0, Ra=0
    let encoding: u32 = 0xB7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_12_poweroftwo_10_c7000010() {
    // Encoding: 0xC7000010
    // Test aarch32_SMLAD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, M=0, Rm=0, Rd=0, Rn=0, cond=12
    let encoding: u32 = 0xC7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_13_poweroftwo_10_d7000010() {
    // Encoding: 0xD7000010
    // Test aarch32_SMLAD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rn=0, M=0, Rd=0, cond=13
    let encoding: u32 = 0xD7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_14_poweroftwo_10_e7000010() {
    // Encoding: 0xE7000010
    // Test aarch32_SMLAD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, M=0, cond=14, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0xE7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlad_a1_a_field_cond_15_max_10_f7000010() {
    // Encoding: 0xF7000010
    // Test aarch32_SMLAD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: M=0, Ra=0, Rd=0, cond=15, Rm=0, Rn=0
    let encoding: u32 = 0xF7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_a1_a_field_rd_0_min_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, M=0, Ra=0, Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_a1_a_field_rd_1_poweroftwo_10_07010010() {
    // Encoding: 0x07010010
    // Test aarch32_SMLAD_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, Rd=1, Rm=0, cond=0, Ra=0
    let encoding: u32 = 0x07010010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_a1_a_field_ra_0_min_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, M=0, cond=0, Ra=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_a1_a_field_ra_1_poweroftwo_10_07001010() {
    // Encoding: 0x07001010
    // Test aarch32_SMLAD_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rm=0, Rn=0, cond=0, Rd=0, Ra=1
    let encoding: u32 = 0x07001010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_a1_a_field_rm_0_min_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=0, Ra=0, M=0, Rn=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_a1_a_field_rm_1_poweroftwo_10_07000110() {
    // Encoding: 0x07000110
    // Test aarch32_SMLAD_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rm=1, cond=0, M=0, Rd=0, Rn=0
    let encoding: u32 = 0x07000110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlad_a1_a_field_m_0_min_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, Rd=0, Ra=0, cond=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlad_a1_a_field_m_1_max_10_07000030() {
    // Encoding: 0x07000030
    // Test aarch32_SMLAD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=1, Ra=0, Rn=0, cond=0
    let encoding: u32 = 0x07000030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_a1_a_field_rn_0_min_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, M=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_a1_a_field_rn_1_poweroftwo_10_07000011() {
    // Encoding: 0x07000011
    // Test aarch32_SMLAD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rn=1, cond=0, Rm=0, M=0, Rd=0
    let encoding: u32 = 0x07000011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlad_a1_a_combo_0_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Ra=0, Rm=0, M=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlad_a1_a_special_cond_0_condition_eq_16_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, M=0, Rm=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlad_a1_a_special_cond_1_condition_ne_16_17000010() {
    // Encoding: 0x17000010
    // Test aarch32_SMLAD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=1, Rd=0, Ra=0, M=0
    let encoding: u32 = 0x17000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlad_a1_a_special_cond_2_condition_cs_hs_16_27000010() {
    // Encoding: 0x27000010
    // Test aarch32_SMLAD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, M=0, Rd=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x27000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlad_a1_a_special_cond_3_condition_cc_lo_16_37000010() {
    // Encoding: 0x37000010
    // Test aarch32_SMLAD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Ra=0, Rn=0, cond=3, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x37000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlad_a1_a_special_cond_4_condition_mi_16_47000010() {
    // Encoding: 0x47000010
    // Test aarch32_SMLAD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=4, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x47000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlad_a1_a_special_cond_5_condition_pl_16_57000010() {
    // Encoding: 0x57000010
    // Test aarch32_SMLAD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Ra=0, Rm=0, M=0, Rn=0, Rd=0
    let encoding: u32 = 0x57000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlad_a1_a_special_cond_6_condition_vs_16_67000010() {
    // Encoding: 0x67000010
    // Test aarch32_SMLAD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, M=0, Rm=0, Ra=0, cond=6
    let encoding: u32 = 0x67000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlad_a1_a_special_cond_7_condition_vc_16_77000010() {
    // Encoding: 0x77000010
    // Test aarch32_SMLAD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, cond=7, M=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x77000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlad_a1_a_special_cond_8_condition_hi_16_87000010() {
    // Encoding: 0x87000010
    // Test aarch32_SMLAD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: cond=8, Rm=0, Ra=0, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x87000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlad_a1_a_special_cond_9_condition_ls_16_97000010() {
    // Encoding: 0x97000010
    // Test aarch32_SMLAD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, cond=9, Rd=0, Ra=0
    let encoding: u32 = 0x97000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlad_a1_a_special_cond_10_condition_ge_16_a7000010() {
    // Encoding: 0xA7000010
    // Test aarch32_SMLAD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=10, Ra=0, Rm=0, Rd=0
    let encoding: u32 = 0xA7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlad_a1_a_special_cond_11_condition_lt_16_b7000010() {
    // Encoding: 0xB7000010
    // Test aarch32_SMLAD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rm=0, M=0, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0xB7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlad_a1_a_special_cond_12_condition_gt_16_c7000010() {
    // Encoding: 0xC7000010
    // Test aarch32_SMLAD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rn=0, Ra=0, M=0, Rd=0
    let encoding: u32 = 0xC7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlad_a1_a_special_cond_13_condition_le_16_d7000010() {
    // Encoding: 0xD7000010
    // Test aarch32_SMLAD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, M=0, Rm=0, Rn=0, Rd=0, Ra=0
    let encoding: u32 = 0xD7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlad_a1_a_special_cond_14_condition_al_16_e7000010() {
    // Encoding: 0xE7000010
    // Test aarch32_SMLAD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rm=0, cond=14, M=0, Rd=0, Ra=0, Rn=0
    let encoding: u32 = 0xE7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlad_a1_a_special_cond_15_condition_nv_16_f7000010() {
    // Encoding: 0xF7000010
    // Test aarch32_SMLAD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Ra=0, M=0, cond=15, Rm=0, Rn=0
    let encoding: u32 = 0xF7000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlad_a1_a_invalid_0_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rd=0, cond=0, M=0, Rn=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlad_a1_a_invalid_1_10_07000010() {
    // Encoding: 0x07000010
    // Test aarch32_SMLAD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, Rm=0, Rd=0, M=0, Rn=0, Ra=0
    let encoding: u32 = 0x07000010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_t1_a_field_rn_0_min_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rd=0, Rm=0, Ra=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_t1_a_field_rn_1_poweroftwo_0_fb210000() {
    // Thumb encoding (32): 0xFB210000
    // Test aarch32_SMLAD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=1, M=0, Ra=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB210000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_t1_a_field_ra_0_min_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0, Ra=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_t1_a_field_ra_1_poweroftwo_0_fb201000() {
    // Thumb encoding (32): 0xFB201000
    // Test aarch32_SMLAD_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=1, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_t1_a_field_rd_0_min_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, Ra=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_t1_a_field_rd_1_poweroftwo_0_fb200100() {
    // Thumb encoding (32): 0xFB200100
    // Test aarch32_SMLAD_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Rd=1, Rm=0, M=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlad_t1_a_field_m_0_min_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, Rm=0, Rd=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlad_t1_a_field_m_1_max_0_fb200010() {
    // Thumb encoding (32): 0xFB200010
    // Test aarch32_SMLAD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlad_t1_a_field_rm_0_min_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rd=0, Rn=0, Rm=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlad_t1_a_field_rm_1_poweroftwo_0_fb200001() {
    // Thumb encoding (32): 0xFB200001
    // Test aarch32_SMLAD_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Ra=0, M=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlad_t1_a_combo_0_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A field combination: Rn=0, Ra=0, Rd=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, M=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlad_t1_a_invalid_0_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: M=0, Rm=0, Rd=0, Rn=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlad_t1_a_invalid_1_0_fb200000() {
    // Thumb encoding (32): 0xFB200000
    // Test aarch32_SMLAD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Ra=0, Rd=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB200000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMUSD_A Tests
// ============================================================================

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_0_min_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_1_poweroftwo_f050_1700f050() {
    // Encoding: 0x1700F050
    // Test aarch32_SMUSD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=1, M=0, Rn=0, Rd=0
    let encoding: u32 = 0x1700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_2_poweroftwo_f050_2700f050() {
    // Encoding: 0x2700F050
    // Test aarch32_SMUSD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, Rm=0, cond=2, Rd=0
    let encoding: u32 = 0x2700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_3_poweroftwo_f050_3700f050() {
    // Encoding: 0x3700F050
    // Test aarch32_SMUSD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rd=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x3700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_4_poweroftwo_f050_4700f050() {
    // Encoding: 0x4700F050
    // Test aarch32_SMUSD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x4700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_5_poweroftwo_f050_5700f050() {
    // Encoding: 0x5700F050
    // Test aarch32_SMUSD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=5, Rn=0, M=0
    let encoding: u32 = 0x5700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_6_poweroftwo_f050_6700f050() {
    // Encoding: 0x6700F050
    // Test aarch32_SMUSD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rm=0, cond=6, Rn=0, Rd=0
    let encoding: u32 = 0x6700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_7_poweroftwo_f050_7700f050() {
    // Encoding: 0x7700F050
    // Test aarch32_SMUSD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, M=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x7700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_8_poweroftwo_f050_8700f050() {
    // Encoding: 0x8700F050
    // Test aarch32_SMUSD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, M=0, Rm=0, Rn=0
    let encoding: u32 = 0x8700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_9_poweroftwo_f050_9700f050() {
    // Encoding: 0x9700F050
    // Test aarch32_SMUSD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=9, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x9700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_10_poweroftwo_f050_a700f050() {
    // Encoding: 0xA700F050
    // Test aarch32_SMUSD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, M=0, cond=10, Rn=0
    let encoding: u32 = 0xA700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_11_poweroftwo_f050_b700f050() {
    // Encoding: 0xB700F050
    // Test aarch32_SMUSD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0xB700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_12_poweroftwo_f050_c700f050() {
    // Encoding: 0xC700F050
    // Test aarch32_SMUSD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xC700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_13_poweroftwo_f050_d700f050() {
    // Encoding: 0xD700F050
    // Test aarch32_SMUSD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=13, M=0, Rn=0
    let encoding: u32 = 0xD700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_14_poweroftwo_f050_e700f050() {
    // Encoding: 0xE700F050
    // Test aarch32_SMUSD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, M=0, Rn=0, cond=14
    let encoding: u32 = 0xE700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smusd_a1_a_field_cond_15_max_f050_f700f050() {
    // Encoding: 0xF700F050
    // Test aarch32_SMUSD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rd=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xF700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smusd_a1_a_field_rd_0_min_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: M=0, Rd=0, Rn=0, cond=0, Rm=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smusd_a1_a_field_rd_1_poweroftwo_f050_0701f050() {
    // Encoding: 0x0701F050
    // Test aarch32_SMUSD_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, M=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x0701F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smusd_a1_a_field_rm_0_min_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=0, M=0, Rd=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smusd_a1_a_field_rm_1_poweroftwo_f050_0700f150() {
    // Encoding: 0x0700F150
    // Test aarch32_SMUSD_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, M=0, cond=0, Rm=1
    let encoding: u32 = 0x0700F150;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smusd_a1_a_field_m_0_min_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: M=0, Rd=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smusd_a1_a_field_m_1_max_f050_0700f070() {
    // Encoding: 0x0700F070
    // Test aarch32_SMUSD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, M=1, cond=0, Rm=0, Rd=0
    let encoding: u32 = 0x0700F070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smusd_a1_a_field_rn_0_min_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smusd_a1_a_field_rn_1_poweroftwo_f050_0700f051() {
    // Encoding: 0x0700F051
    // Test aarch32_SMUSD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=0, Rn=1, cond=0
    let encoding: u32 = 0x0700F051;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smusd_a1_a_combo_0_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A field combination: cond=0, Rd=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smusd_a1_a_special_cond_0_condition_eq_61520_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rm=0, cond=0, M=0, Rd=0, Rn=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smusd_a1_a_special_cond_1_condition_ne_61520_1700f050() {
    // Encoding: 0x1700F050
    // Test aarch32_SMUSD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=0, Rn=0, cond=1
    let encoding: u32 = 0x1700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smusd_a1_a_special_cond_2_condition_cs_hs_61520_2700f050() {
    // Encoding: 0x2700F050
    // Test aarch32_SMUSD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x2700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smusd_a1_a_special_cond_3_condition_cc_lo_61520_3700f050() {
    // Encoding: 0x3700F050
    // Test aarch32_SMUSD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, Rn=0, M=0, cond=3, Rd=0
    let encoding: u32 = 0x3700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smusd_a1_a_special_cond_4_condition_mi_61520_4700f050() {
    // Encoding: 0x4700F050
    // Test aarch32_SMUSD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, Rn=0, M=0, Rd=0, cond=4
    let encoding: u32 = 0x4700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smusd_a1_a_special_cond_5_condition_pl_61520_5700f050() {
    // Encoding: 0x5700F050
    // Test aarch32_SMUSD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, M=0, cond=5, Rm=0, Rn=0
    let encoding: u32 = 0x5700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smusd_a1_a_special_cond_6_condition_vs_61520_6700f050() {
    // Encoding: 0x6700F050
    // Test aarch32_SMUSD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rd=0, cond=6, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x6700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smusd_a1_a_special_cond_7_condition_vc_61520_7700f050() {
    // Encoding: 0x7700F050
    // Test aarch32_SMUSD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, M=0, cond=7, Rd=0, Rn=0
    let encoding: u32 = 0x7700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smusd_a1_a_special_cond_8_condition_hi_61520_8700f050() {
    // Encoding: 0x8700F050
    // Test aarch32_SMUSD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: M=0, Rn=0, Rd=0, Rm=0, cond=8
    let encoding: u32 = 0x8700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smusd_a1_a_special_cond_9_condition_ls_61520_9700f050() {
    // Encoding: 0x9700F050
    // Test aarch32_SMUSD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=9, Rd=0, M=0
    let encoding: u32 = 0x9700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smusd_a1_a_special_cond_10_condition_ge_61520_a700f050() {
    // Encoding: 0xA700F050
    // Test aarch32_SMUSD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: M=0, Rn=0, Rd=0, cond=10, Rm=0
    let encoding: u32 = 0xA700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smusd_a1_a_special_cond_11_condition_lt_61520_b700f050() {
    // Encoding: 0xB700F050
    // Test aarch32_SMUSD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, M=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0xB700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smusd_a1_a_special_cond_12_condition_gt_61520_c700f050() {
    // Encoding: 0xC700F050
    // Test aarch32_SMUSD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0xC700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smusd_a1_a_special_cond_13_condition_le_61520_d700f050() {
    // Encoding: 0xD700F050
    // Test aarch32_SMUSD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, cond=13, M=0, Rn=0, Rm=0
    let encoding: u32 = 0xD700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smusd_a1_a_special_cond_14_condition_al_61520_e700f050() {
    // Encoding: 0xE700F050
    // Test aarch32_SMUSD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: M=0, Rd=0, cond=14, Rm=0, Rn=0
    let encoding: u32 = 0xE700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smusd_a1_a_special_cond_15_condition_nv_61520_f700f050() {
    // Encoding: 0xF700F050
    // Test aarch32_SMUSD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, M=0, cond=15
    let encoding: u32 = 0xF700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smusd_a1_a_invalid_0_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: M=0, cond=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMUSD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smusd_a1_a_invalid_1_f050_0700f050() {
    // Encoding: 0x0700F050
    // Test aarch32_SMUSD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x0700F050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smusd_t1_a_field_rn_0_min_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smusd_t1_a_field_rn_1_poweroftwo_f000_fb41f000() {
    // Thumb encoding (32): 0xFB41F000
    // Test aarch32_SMUSD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, M=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB41F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smusd_t1_a_field_rd_0_min_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smusd_t1_a_field_rd_1_poweroftwo_f000_fb40f100() {
    // Thumb encoding (32): 0xFB40F100
    // Test aarch32_SMUSD_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Rd=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smusd_t1_a_field_m_0_min_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, M=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smusd_t1_a_field_m_1_max_f000_fb40f010() {
    // Thumb encoding (32): 0xFB40F010
    // Test aarch32_SMUSD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, M=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smusd_t1_a_field_rm_0_min_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smusd_t1_a_field_rm_1_poweroftwo_f000_fb40f001() {
    // Thumb encoding (32): 0xFB40F001
    // Test aarch32_SMUSD_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, M=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smusd_t1_a_combo_0_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A field combination: Rn=0, Rd=0, M=0, Rm=0
    // ISET: T32
    // Fields: M=0, Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smusd_t1_a_invalid_0_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rd=0, M=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMUSD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smusd_t1_a_invalid_1_f000_fb40f000() {
    // Thumb encoding (32): 0xFB40F000
    // Test aarch32_SMUSD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rn=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB40F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMMLS_A Tests
// ============================================================================

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_0_min_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, cond=0, R=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_1_poweroftwo_d0_175000d0() {
    // Encoding: 0x175000D0
    // Test aarch32_SMMLS_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=1, Rd=0, Rm=0, R=0
    let encoding: u32 = 0x175000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_2_poweroftwo_d0_275000d0() {
    // Encoding: 0x275000D0
    // Test aarch32_SMMLS_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=2, Rn=0, R=0, Rd=0
    let encoding: u32 = 0x275000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_3_poweroftwo_d0_375000d0() {
    // Encoding: 0x375000D0
    // Test aarch32_SMMLS_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Ra=0, Rd=0, cond=3, R=0
    let encoding: u32 = 0x375000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_4_poweroftwo_d0_475000d0() {
    // Encoding: 0x475000D0
    // Test aarch32_SMMLS_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, R=0, Ra=0, Rm=0, Rn=0, cond=4
    let encoding: u32 = 0x475000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_5_poweroftwo_d0_575000d0() {
    // Encoding: 0x575000D0
    // Test aarch32_SMMLS_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rd=0, Rm=0, R=0, Ra=0
    let encoding: u32 = 0x575000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_6_poweroftwo_d0_675000d0() {
    // Encoding: 0x675000D0
    // Test aarch32_SMMLS_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, R=0, Rn=0, cond=6, Rd=0, Ra=0
    let encoding: u32 = 0x675000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_7_poweroftwo_d0_775000d0() {
    // Encoding: 0x775000D0
    // Test aarch32_SMMLS_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, Rm=0, Rn=0, Ra=0, R=0
    let encoding: u32 = 0x775000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_8_poweroftwo_d0_875000d0() {
    // Encoding: 0x875000D0
    // Test aarch32_SMMLS_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=8, R=0, Rn=0, Rd=0, Ra=0
    let encoding: u32 = 0x875000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_9_poweroftwo_d0_975000d0() {
    // Encoding: 0x975000D0
    // Test aarch32_SMMLS_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=9, R=0, Rd=0, Rm=0
    let encoding: u32 = 0x975000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_10_poweroftwo_d0_a75000d0() {
    // Encoding: 0xA75000D0
    // Test aarch32_SMMLS_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rn=0, cond=10, Rd=0, R=0
    let encoding: u32 = 0xA75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_11_poweroftwo_d0_b75000d0() {
    // Encoding: 0xB75000D0
    // Test aarch32_SMMLS_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Rn=0, Rm=0, Ra=0, R=0
    let encoding: u32 = 0xB75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_12_poweroftwo_d0_c75000d0() {
    // Encoding: 0xC75000D0
    // Test aarch32_SMMLS_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rd=0, R=0, Rn=0, Ra=0
    let encoding: u32 = 0xC75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_13_poweroftwo_d0_d75000d0() {
    // Encoding: 0xD75000D0
    // Test aarch32_SMMLS_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=0, cond=13, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xD75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_14_poweroftwo_d0_e75000d0() {
    // Encoding: 0xE75000D0
    // Test aarch32_SMMLS_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=0, R=0, cond=14, Rn=0
    let encoding: u32 = 0xE75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smmls_a1_a_field_cond_15_max_d0_f75000d0() {
    // Encoding: 0xF75000D0
    // Test aarch32_SMMLS_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=15, Ra=0, R=0
    let encoding: u32 = 0xF75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_a1_a_field_rd_0_min_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: R=0, cond=0, Rn=0, Ra=0, Rm=0, Rd=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_a1_a_field_rd_1_poweroftwo_d0_075100d0() {
    // Encoding: 0x075100D0
    // Test aarch32_SMMLS_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, R=0, cond=0, Rm=0, Rd=1, Rn=0
    let encoding: u32 = 0x075100D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_a1_a_field_ra_0_min_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=0, Rd=0, R=0, Rm=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_a1_a_field_ra_1_poweroftwo_d0_075010d0() {
    // Encoding: 0x075010D0
    // Test aarch32_SMMLS_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, R=0, Rn=0, Ra=1
    let encoding: u32 = 0x075010D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_a1_a_field_rm_0_min_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Ra=0, Rn=0, cond=0, R=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_a1_a_field_rm_1_poweroftwo_d0_075001d0() {
    // Encoding: 0x075001D0
    // Test aarch32_SMMLS_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, R=0, cond=0, Ra=0, Rd=0, Rm=1
    let encoding: u32 = 0x075001D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field R 5 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smmls_a1_a_field_r_0_min_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field R = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, R=0, Ra=0, Rm=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field R 5 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smmls_a1_a_field_r_1_max_d0_075000f0() {
    // Encoding: 0x075000F0
    // Test aarch32_SMMLS_A1_A field R = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=0, R=1, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x075000F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_a1_a_field_rn_0_min_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, R=0, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_a1_a_field_rn_1_poweroftwo_d0_075000d1() {
    // Encoding: 0x075000D1
    // Test aarch32_SMMLS_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=1, Ra=0, R=0, cond=0, Rd=0
    let encoding: u32 = 0x075000D1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smmls_a1_a_combo_0_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, R=0, Rn=0
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, R=0, Ra=0, cond=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smmls_a1_a_special_cond_0_condition_eq_208_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: R=0, cond=0, Ra=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smmls_a1_a_special_cond_1_condition_ne_208_175000d0() {
    // Encoding: 0x175000D0
    // Test aarch32_SMMLS_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rd=0, R=0, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0x175000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smmls_a1_a_special_cond_2_condition_cs_hs_208_275000d0() {
    // Encoding: 0x275000D0
    // Test aarch32_SMMLS_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rm=0, R=0, Rn=0, cond=2, Ra=0, Rd=0
    let encoding: u32 = 0x275000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smmls_a1_a_special_cond_3_condition_cc_lo_208_375000d0() {
    // Encoding: 0x375000D0
    // Test aarch32_SMMLS_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=3, Ra=0, Rm=0, R=0
    let encoding: u32 = 0x375000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smmls_a1_a_special_cond_4_condition_mi_208_475000d0() {
    // Encoding: 0x475000D0
    // Test aarch32_SMMLS_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=4, R=0, Rd=0, Ra=0
    let encoding: u32 = 0x475000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smmls_a1_a_special_cond_5_condition_pl_208_575000d0() {
    // Encoding: 0x575000D0
    // Test aarch32_SMMLS_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Ra=0, Rm=0, Rn=0, R=0
    let encoding: u32 = 0x575000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smmls_a1_a_special_cond_6_condition_vs_208_675000d0() {
    // Encoding: 0x675000D0
    // Test aarch32_SMMLS_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=6, Ra=0, R=0, Rd=0
    let encoding: u32 = 0x675000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smmls_a1_a_special_cond_7_condition_vc_208_775000d0() {
    // Encoding: 0x775000D0
    // Test aarch32_SMMLS_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Ra=0, Rm=0, R=0, Rn=0, Rd=0
    let encoding: u32 = 0x775000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smmls_a1_a_special_cond_8_condition_hi_208_875000d0() {
    // Encoding: 0x875000D0
    // Test aarch32_SMMLS_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, Rd=0, R=0, cond=8, Ra=0, Rn=0
    let encoding: u32 = 0x875000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smmls_a1_a_special_cond_9_condition_ls_208_975000d0() {
    // Encoding: 0x975000D0
    // Test aarch32_SMMLS_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Ra=0, cond=9, Rd=0, Rm=0, R=0, Rn=0
    let encoding: u32 = 0x975000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smmls_a1_a_special_cond_10_condition_ge_208_a75000d0() {
    // Encoding: 0xA75000D0
    // Test aarch32_SMMLS_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, cond=10, R=0, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xA75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smmls_a1_a_special_cond_11_condition_lt_208_b75000d0() {
    // Encoding: 0xB75000D0
    // Test aarch32_SMMLS_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=11, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0xB75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smmls_a1_a_special_cond_12_condition_gt_208_c75000d0() {
    // Encoding: 0xC75000D0
    // Test aarch32_SMMLS_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Ra=0, cond=12, Rm=0, R=0, Rd=0, Rn=0
    let encoding: u32 = 0xC75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smmls_a1_a_special_cond_13_condition_le_208_d75000d0() {
    // Encoding: 0xD75000D0
    // Test aarch32_SMMLS_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Ra=0, Rd=0, R=0, Rm=0, Rn=0
    let encoding: u32 = 0xD75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smmls_a1_a_special_cond_14_condition_al_208_e75000d0() {
    // Encoding: 0xE75000D0
    // Test aarch32_SMMLS_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, R=0, Rm=0, cond=14, Ra=0
    let encoding: u32 = 0xE75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smmls_a1_a_special_cond_15_condition_nv_208_f75000d0() {
    // Encoding: 0xF75000D0
    // Test aarch32_SMMLS_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=15, Ra=0, R=0, Rn=0
    let encoding: u32 = 0xF75000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmls_a1_a_invalid_0_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, R=0, Rm=0, Rd=0, cond=0, Ra=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMLS_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmls_a1_a_invalid_1_d0_075000d0() {
    // Encoding: 0x075000D0
    // Test aarch32_SMMLS_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: R=0, Rn=0, Rd=0, Rm=0, cond=0, Ra=0
    let encoding: u32 = 0x075000D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_t1_a_field_rn_0_min_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, R=0, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_t1_a_field_rn_1_poweroftwo_0_fb610000() {
    // Thumb encoding (32): 0xFB610000
    // Test aarch32_SMMLS_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, R=0, Rn=1, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB610000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_t1_a_field_ra_0_min_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rd=0, R=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_t1_a_field_ra_1_poweroftwo_0_fb601000() {
    // Thumb encoding (32): 0xFB601000
    // Test aarch32_SMMLS_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=1, Rn=0, Rd=0, R=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB601000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_t1_a_field_rd_0_min_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rm=0, Ra=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_t1_a_field_rd_1_poweroftwo_0_fb600100() {
    // Thumb encoding (32): 0xFB600100
    // Test aarch32_SMMLS_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=1, Rn=0, R=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field R 4 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smmls_t1_a_field_r_0_min_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A field R = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, R=0, Rm=0, Rd=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field R 4 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smmls_t1_a_field_r_1_max_0_fb600010() {
    // Thumb encoding (32): 0xFB600010
    // Test aarch32_SMMLS_T1_A field R = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, R=1, Rd=0, Rm=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmls_t1_a_field_rm_0_min_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rd=0, Rm=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmls_t1_a_field_rm_1_poweroftwo_0_fb600001() {
    // Thumb encoding (32): 0xFB600001
    // Test aarch32_SMMLS_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, Ra=0, Rn=0, Rd=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smmls_t1_a_combo_0_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A field combination: Rn=0, Ra=0, Rd=0, R=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, Rn=0, Ra=0, R=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmls_t1_a_invalid_0_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0, R=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMLS_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmls_t1_a_invalid_1_0_fb600000() {
    // Thumb encoding (32): 0xFB600000
    // Test aarch32_SMMLS_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rn=0, R=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB600000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMULBB_A Tests
// ============================================================================

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_0_min_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, M=0, Rd=0, N=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_1_poweroftwo_80_11600080() {
    // Encoding: 0x11600080
    // Test aarch32_SMULBB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, N=0, cond=1, Rd=0, M=0
    let encoding: u32 = 0x11600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_2_poweroftwo_80_21600080() {
    // Encoding: 0x21600080
    // Test aarch32_SMULBB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, M=0, Rd=0, cond=2, Rm=0, N=0
    let encoding: u32 = 0x21600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_3_poweroftwo_80_31600080() {
    // Encoding: 0x31600080
    // Test aarch32_SMULBB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rd=0, Rm=0, M=0, N=0, Rn=0
    let encoding: u32 = 0x31600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_4_poweroftwo_80_41600080() {
    // Encoding: 0x41600080
    // Test aarch32_SMULBB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, M=0, N=0, cond=4, Rn=0
    let encoding: u32 = 0x41600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_5_poweroftwo_80_51600080() {
    // Encoding: 0x51600080
    // Test aarch32_SMULBB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=5, M=0, N=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x51600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_6_poweroftwo_80_61600080() {
    // Encoding: 0x61600080
    // Test aarch32_SMULBB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=6, Rm=0, Rn=0, Rd=0, M=0
    let encoding: u32 = 0x61600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_7_poweroftwo_80_71600080() {
    // Encoding: 0x71600080
    // Test aarch32_SMULBB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, N=0, Rm=0, M=0, Rd=0
    let encoding: u32 = 0x71600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_8_poweroftwo_80_81600080() {
    // Encoding: 0x81600080
    // Test aarch32_SMULBB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, M=0, Rn=0, cond=8, Rd=0, N=0
    let encoding: u32 = 0x81600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_9_poweroftwo_80_91600080() {
    // Encoding: 0x91600080
    // Test aarch32_SMULBB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, Rd=0, Rm=0, N=0, M=0
    let encoding: u32 = 0x91600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_10_poweroftwo_80_a1600080() {
    // Encoding: 0xA1600080
    // Test aarch32_SMULBB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=10, M=0, N=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xA1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_11_poweroftwo_80_b1600080() {
    // Encoding: 0xB1600080
    // Test aarch32_SMULBB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, N=0, Rm=0, M=0, Rn=0, Rd=0
    let encoding: u32 = 0xB1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_12_poweroftwo_80_c1600080() {
    // Encoding: 0xC1600080
    // Test aarch32_SMULBB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, N=0, Rn=0, cond=12, Rd=0, Rm=0
    let encoding: u32 = 0xC1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_13_poweroftwo_80_d1600080() {
    // Encoding: 0xD1600080
    // Test aarch32_SMULBB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=13, Rn=0, Rm=0, Rd=0, M=0
    let encoding: u32 = 0xD1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_14_poweroftwo_80_e1600080() {
    // Encoding: 0xE1600080
    // Test aarch32_SMULBB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rn=0, Rd=0, Rm=0, N=0, M=0
    let encoding: u32 = 0xE1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smulbb_a1_a_field_cond_15_max_80_f1600080() {
    // Encoding: 0xF1600080
    // Test aarch32_SMULBB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: cond=15, Rd=0, M=0, Rn=0, Rm=0, N=0
    let encoding: u32 = 0xF1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulbb_a1_a_field_rd_0_min_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Rn=0, cond=0, Rm=0, M=0, N=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulbb_a1_a_field_rd_1_poweroftwo_80_01610080() {
    // Encoding: 0x01610080
    // Test aarch32_SMULBB_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=0, Rm=0, Rn=0, N=0, Rd=1
    let encoding: u32 = 0x01610080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulbb_a1_a_field_rm_0_min_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, M=0, Rd=0, N=0, Rn=0, cond=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulbb_a1_a_field_rm_1_poweroftwo_80_01600180() {
    // Encoding: 0x01600180
    // Test aarch32_SMULBB_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, M=0, Rn=0, N=0, cond=0, Rm=1
    let encoding: u32 = 0x01600180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smulbb_a1_a_field_m_0_min_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, M=0, Rd=0, cond=0, N=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smulbb_a1_a_field_m_1_max_80_016000c0() {
    // Encoding: 0x016000C0
    // Test aarch32_SMULBB_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: N=0, Rm=0, cond=0, Rd=0, M=1, Rn=0
    let encoding: u32 = 0x016000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smulbb_a1_a_field_n_0_min_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: cond=0, M=0, Rd=0, N=0, Rm=0, Rn=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smulbb_a1_a_field_n_1_max_80_016000a0() {
    // Encoding: 0x016000A0
    // Test aarch32_SMULBB_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, N=1, Rn=0, Rd=0, M=0, cond=0
    let encoding: u32 = 0x016000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulbb_a1_a_field_rn_0_min_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, M=0, Rd=0, Rm=0, N=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulbb_a1_a_field_rn_1_poweroftwo_80_01600081() {
    // Encoding: 0x01600081
    // Test aarch32_SMULBB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, N=0, Rd=0, M=0, cond=0, Rm=0
    let encoding: u32 = 0x01600081;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smulbb_a1_a_combo_0_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A field combination: cond=0, Rd=0, Rm=0, M=0, N=0, Rn=0
    // ISET: A32
    // Fields: M=0, Rn=0, N=0, Rm=0, Rd=0, cond=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_0_condition_eq_128_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, Rd=0, M=0, Rm=0, cond=0, N=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_1_condition_ne_128_11600080() {
    // Encoding: 0x11600080
    // Test aarch32_SMULBB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rm=0, M=0, Rd=0, N=0, Rn=0
    let encoding: u32 = 0x11600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_2_condition_cs_hs_128_21600080() {
    // Encoding: 0x21600080
    // Test aarch32_SMULBB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, Rn=0, N=0, cond=2, M=0, Rm=0
    let encoding: u32 = 0x21600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_3_condition_cc_lo_128_31600080() {
    // Encoding: 0x31600080
    // Test aarch32_SMULBB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: N=0, Rd=0, Rm=0, cond=3, M=0, Rn=0
    let encoding: u32 = 0x31600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_4_condition_mi_128_41600080() {
    // Encoding: 0x41600080
    // Test aarch32_SMULBB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: M=0, Rd=0, cond=4, Rm=0, N=0, Rn=0
    let encoding: u32 = 0x41600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_5_condition_pl_128_51600080() {
    // Encoding: 0x51600080
    // Test aarch32_SMULBB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: N=0, Rd=0, Rn=0, M=0, cond=5, Rm=0
    let encoding: u32 = 0x51600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_6_condition_vs_128_61600080() {
    // Encoding: 0x61600080
    // Test aarch32_SMULBB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, cond=6, M=0, N=0
    let encoding: u32 = 0x61600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_7_condition_vc_128_71600080() {
    // Encoding: 0x71600080
    // Test aarch32_SMULBB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, cond=7, Rd=0, M=0, N=0, Rn=0
    let encoding: u32 = 0x71600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_8_condition_hi_128_81600080() {
    // Encoding: 0x81600080
    // Test aarch32_SMULBB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rm=0, cond=8, M=0, N=0, Rn=0
    let encoding: u32 = 0x81600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_9_condition_ls_128_91600080() {
    // Encoding: 0x91600080
    // Test aarch32_SMULBB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, M=0, cond=9, N=0
    let encoding: u32 = 0x91600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_10_condition_ge_128_a1600080() {
    // Encoding: 0xA1600080
    // Test aarch32_SMULBB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: N=0, Rd=0, M=0, Rn=0, cond=10, Rm=0
    let encoding: u32 = 0xA1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_11_condition_lt_128_b1600080() {
    // Encoding: 0xB1600080
    // Test aarch32_SMULBB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, N=0, Rn=0, M=0, Rd=0, cond=11
    let encoding: u32 = 0xB1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_12_condition_gt_128_c1600080() {
    // Encoding: 0xC1600080
    // Test aarch32_SMULBB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rn=0, M=0, Rd=0, Rm=0, N=0, cond=12
    let encoding: u32 = 0xC1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_13_condition_le_128_d1600080() {
    // Encoding: 0xD1600080
    // Test aarch32_SMULBB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Rn=0, M=0, N=0, Rd=0, Rm=0
    let encoding: u32 = 0xD1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_14_condition_al_128_e1600080() {
    // Encoding: 0xE1600080
    // Test aarch32_SMULBB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, cond=14, M=0, Rd=0, Rm=0, N=0
    let encoding: u32 = 0xE1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smulbb_a1_a_special_cond_15_condition_nv_128_f1600080() {
    // Encoding: 0xF1600080
    // Test aarch32_SMULBB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, M=0, N=0, cond=15, Rn=0, Rm=0
    let encoding: u32 = 0xF1600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulbb_a1_a_invalid_0_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, N=0, cond=0, M=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULBB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulbb_a1_a_invalid_1_80_01600080() {
    // Encoding: 0x01600080
    // Test aarch32_SMULBB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: M=0, Rd=0, Rm=0, N=0, Rn=0, cond=0
    let encoding: u32 = 0x01600080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulbb_t1_a_field_rn_0_min_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, N=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulbb_t1_a_field_rn_1_poweroftwo_f000_fb11f000() {
    // Thumb encoding (32): 0xFB11F000
    // Test aarch32_SMULBB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Rd=0, N=0, Rn=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB11F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulbb_t1_a_field_rd_0_min_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, N=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulbb_t1_a_field_rd_1_poweroftwo_f000_fb10f100() {
    // Thumb encoding (32): 0xFB10F100
    // Test aarch32_SMULBB_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, N=0, Rn=0, M=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smulbb_t1_a_field_n_0_min_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: N=0, Rm=0, Rn=0, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smulbb_t1_a_field_n_1_max_f000_fb10f020() {
    // Thumb encoding (32): 0xFB10F020
    // Test aarch32_SMULBB_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: M=0, Rd=0, Rn=0, Rm=0, N=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smulbb_t1_a_field_m_0_min_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: N=0, Rn=0, Rm=0, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smulbb_t1_a_field_m_1_max_f000_fb10f010() {
    // Thumb encoding (32): 0xFB10F010
    // Test aarch32_SMULBB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: N=0, Rn=0, M=1, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulbb_t1_a_field_rm_0_min_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, M=0, Rm=0, N=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulbb_t1_a_field_rm_1_poweroftwo_f000_fb10f001() {
    // Thumb encoding (32): 0xFB10F001
    // Test aarch32_SMULBB_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Rn=0, M=0, Rm=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smulbb_t1_a_combo_0_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A field combination: Rn=0, Rd=0, N=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, N=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulbb_t1_a_invalid_0_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, M=0, N=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulbb_t1_a_invalid_1_f000_fb10f000() {
    // Thumb encoding (32): 0xFB10F000
    // Test aarch32_SMULBB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rn=0, Rm=0, Rd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB10F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_smulbb_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_smulbb_t1_a_t32_oracle_0_fb11f002() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xFB11F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_smulbb_t1_a_t32_oracle_1_fb11f002() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xFB11F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_smulbb_t1_a_t32_oracle_2_fb11f002() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFB11F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SMULBB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_smulbb_t1_a_t32_oracle_3_fb11f002() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0xFB11F002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_SMLSD_A Tests
// ============================================================================

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_0_min_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, cond=0, M=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_1_poweroftwo_50_17000050() {
    // Encoding: 0x17000050
    // Test aarch32_SMLSD_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=1, Rd=0, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0x17000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_2_poweroftwo_50_27000050() {
    // Encoding: 0x27000050
    // Test aarch32_SMLSD_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=2, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x27000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_3_poweroftwo_50_37000050() {
    // Encoding: 0x37000050
    // Test aarch32_SMLSD_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, M=0, Rn=0, cond=3, Ra=0, Rm=0
    let encoding: u32 = 0x37000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_4_poweroftwo_50_47000050() {
    // Encoding: 0x47000050
    // Test aarch32_SMLSD_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=4, Rd=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x47000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_5_poweroftwo_50_57000050() {
    // Encoding: 0x57000050
    // Test aarch32_SMLSD_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=5, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0x57000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_6_poweroftwo_50_67000050() {
    // Encoding: 0x67000050
    // Test aarch32_SMLSD_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=6, M=0, Ra=0, Rd=0, Rn=0
    let encoding: u32 = 0x67000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_7_poweroftwo_50_77000050() {
    // Encoding: 0x77000050
    // Test aarch32_SMLSD_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rd=0, cond=7, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x77000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_8_poweroftwo_50_87000050() {
    // Encoding: 0x87000050
    // Test aarch32_SMLSD_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, M=0, Rd=0, Rn=0, cond=8
    let encoding: u32 = 0x87000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_9_poweroftwo_50_97000050() {
    // Encoding: 0x97000050
    // Test aarch32_SMLSD_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, M=0, cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x97000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_10_poweroftwo_50_a7000050() {
    // Encoding: 0xA7000050
    // Test aarch32_SMLSD_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=10, M=0, Ra=0, Rn=0, Rd=0
    let encoding: u32 = 0xA7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_11_poweroftwo_50_b7000050() {
    // Encoding: 0xB7000050
    // Test aarch32_SMLSD_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=11, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xB7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_12_poweroftwo_50_c7000050() {
    // Encoding: 0xC7000050
    // Test aarch32_SMLSD_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rm=0, Ra=0, M=0, Rd=0, Rn=0
    let encoding: u32 = 0xC7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_13_poweroftwo_50_d7000050() {
    // Encoding: 0xD7000050
    // Test aarch32_SMLSD_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Rd=0, Rm=0, Ra=0, M=0
    let encoding: u32 = 0xD7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_14_poweroftwo_50_e7000050() {
    // Encoding: 0xE7000050
    // Test aarch32_SMLSD_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=14, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xE7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlsd_a1_a_field_cond_15_max_50_f7000050() {
    // Encoding: 0xF7000050
    // Test aarch32_SMLSD_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=15, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xF7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_a1_a_field_rd_0_min_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Ra=0, M=0, Rd=0, cond=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_a1_a_field_rd_1_poweroftwo_50_07010050() {
    // Encoding: 0x07010050
    // Test aarch32_SMLSD_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=0, Rd=1, Ra=0, Rm=0
    let encoding: u32 = 0x07010050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_a1_a_field_ra_0_min_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: cond=0, M=0, Rm=0, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_a1_a_field_ra_1_poweroftwo_50_07001050() {
    // Encoding: 0x07001050
    // Test aarch32_SMLSD_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=1, M=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x07001050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_a1_a_field_rm_0_min_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=0, Ra=0, M=0, Rd=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_a1_a_field_rm_1_poweroftwo_50_07000150() {
    // Encoding: 0x07000150
    // Test aarch32_SMLSD_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=0, Ra=0, Rm=1, Rd=0, M=0
    let encoding: u32 = 0x07000150;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsd_a1_a_field_m_0_min_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, M=0, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field M 5 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlsd_a1_a_field_m_1_max_50_07000070() {
    // Encoding: 0x07000070
    // Test aarch32_SMLSD_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rd=0, M=1, Rn=0, cond=0
    let encoding: u32 = 0x07000070;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_a1_a_field_rn_0_min_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, M=0, Rn=0, Ra=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_a1_a_field_rn_1_poweroftwo_50_07000051() {
    // Encoding: 0x07000051
    // Test aarch32_SMLSD_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, Ra=0, Rm=0, M=0, Rn=1
    let encoding: u32 = 0x07000051;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlsd_a1_a_combo_0_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: M=0, Ra=0, Rn=0, cond=0, Rm=0, Rd=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_0_condition_eq_80_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, Rd=0, Ra=0, M=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_1_condition_ne_80_17000050() {
    // Encoding: 0x17000050
    // Test aarch32_SMLSD_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, Rm=0, Ra=0, Rn=0, Rd=0, M=0
    let encoding: u32 = 0x17000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_2_condition_cs_hs_80_27000050() {
    // Encoding: 0x27000050
    // Test aarch32_SMLSD_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=2, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x27000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_3_condition_cc_lo_80_37000050() {
    // Encoding: 0x37000050
    // Test aarch32_SMLSD_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=3, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x37000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_4_condition_mi_80_47000050() {
    // Encoding: 0x47000050
    // Test aarch32_SMLSD_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, M=0, Ra=0, Rm=0, Rn=0, cond=4
    let encoding: u32 = 0x47000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_5_condition_pl_80_57000050() {
    // Encoding: 0x57000050
    // Test aarch32_SMLSD_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: M=0, Rm=0, Rn=0, cond=5, Rd=0, Ra=0
    let encoding: u32 = 0x57000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_6_condition_vs_80_67000050() {
    // Encoding: 0x67000050
    // Test aarch32_SMLSD_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, M=0, Rd=0, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0x67000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_7_condition_vc_80_77000050() {
    // Encoding: 0x77000050
    // Test aarch32_SMLSD_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rm=0, Rd=0, M=0, Rn=0, cond=7, Ra=0
    let encoding: u32 = 0x77000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_8_condition_hi_80_87000050() {
    // Encoding: 0x87000050
    // Test aarch32_SMLSD_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Ra=0, Rm=0, M=0, Rn=0, cond=8, Rd=0
    let encoding: u32 = 0x87000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_9_condition_ls_80_97000050() {
    // Encoding: 0x97000050
    // Test aarch32_SMLSD_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Ra=0, cond=9, Rm=0, M=0, Rd=0, Rn=0
    let encoding: u32 = 0x97000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_10_condition_ge_80_a7000050() {
    // Encoding: 0xA7000050
    // Test aarch32_SMLSD_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, cond=10, Rn=0, Rm=0, M=0, Ra=0
    let encoding: u32 = 0xA7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_11_condition_lt_80_b7000050() {
    // Encoding: 0xB7000050
    // Test aarch32_SMLSD_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=11, Rn=0, Ra=0, M=0
    let encoding: u32 = 0xB7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_12_condition_gt_80_c7000050() {
    // Encoding: 0xC7000050
    // Test aarch32_SMLSD_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, Ra=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xC7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_13_condition_le_80_d7000050() {
    // Encoding: 0xD7000050
    // Test aarch32_SMLSD_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Ra=0, cond=13, Rd=0, M=0
    let encoding: u32 = 0xD7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_14_condition_al_80_e7000050() {
    // Encoding: 0xE7000050
    // Test aarch32_SMLSD_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Ra=0, Rd=0, M=0, Rm=0, cond=14, Rn=0
    let encoding: u32 = 0xE7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlsd_a1_a_special_cond_15_condition_nv_80_f7000050() {
    // Encoding: 0xF7000050
    // Test aarch32_SMLSD_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: M=0, Rd=0, Rn=0, Ra=0, Rm=0, cond=15
    let encoding: u32 = 0xF7000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsd_a1_a_invalid_0_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, cond=0, M=0, Rm=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSD_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsd_a1_a_invalid_1_50_07000050() {
    // Encoding: 0x07000050
    // Test aarch32_SMLSD_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, cond=0, Ra=0, M=0
    let encoding: u32 = 0x07000050;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_t1_a_field_rn_0_min_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: M=0, Ra=0, Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_t1_a_field_rn_1_poweroftwo_0_fb410000() {
    // Thumb encoding (32): 0xFB410000
    // Test aarch32_SMLSD_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, Rn=1, Rd=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB410000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_t1_a_field_ra_0_min_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, Ra=0, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_t1_a_field_ra_1_poweroftwo_0_fb401000() {
    // Thumb encoding (32): 0xFB401000
    // Test aarch32_SMLSD_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=0, Rm=0, Ra=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB401000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_t1_a_field_rd_0_min_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Ra=0, Rn=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_t1_a_field_rd_1_poweroftwo_0_fb400100() {
    // Thumb encoding (32): 0xFB400100
    // Test aarch32_SMLSD_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rm=0, M=0, Ra=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlsd_t1_a_field_m_0_min_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rd=0, Rn=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlsd_t1_a_field_m_1_max_0_fb400010() {
    // Thumb encoding (32): 0xFB400010
    // Test aarch32_SMLSD_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0, Ra=0, M=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlsd_t1_a_field_rm_0_min_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, M=0, Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlsd_t1_a_field_rm_1_poweroftwo_0_fb400001() {
    // Thumb encoding (32): 0xFB400001
    // Test aarch32_SMLSD_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, M=0, Rd=0, Rn=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlsd_t1_a_combo_0_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A field combination: Rn=0, Ra=0, Rd=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsd_t1_a_invalid_0_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rd=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLSD_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlsd_t1_a_invalid_1_0_fb400000() {
    // Thumb encoding (32): 0xFB400000
    // Test aarch32_SMLSD_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, Rm=0, Ra=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB400000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMULWB_A Tests
// ============================================================================

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_0_min_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: M=0, cond=0, Rm=0, Rd=0, Rn=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_1_poweroftwo_a0_112000a0() {
    // Encoding: 0x112000A0
    // Test aarch32_SMULWB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, M=0, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x112000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_2_poweroftwo_a0_212000a0() {
    // Encoding: 0x212000A0
    // Test aarch32_SMULWB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=0, Rn=0, cond=2
    let encoding: u32 = 0x212000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_3_poweroftwo_a0_312000a0() {
    // Encoding: 0x312000A0
    // Test aarch32_SMULWB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, Rn=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x312000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_4_poweroftwo_a0_412000a0() {
    // Encoding: 0x412000A0
    // Test aarch32_SMULWB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, M=0, cond=4, Rn=0, Rm=0
    let encoding: u32 = 0x412000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_5_poweroftwo_a0_512000a0() {
    // Encoding: 0x512000A0
    // Test aarch32_SMULWB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, M=0, cond=5, Rm=0
    let encoding: u32 = 0x512000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_6_poweroftwo_a0_612000a0() {
    // Encoding: 0x612000A0
    // Test aarch32_SMULWB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=6, Rn=0, M=0
    let encoding: u32 = 0x612000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_7_poweroftwo_a0_712000a0() {
    // Encoding: 0x712000A0
    // Test aarch32_SMULWB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, Rd=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x712000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_8_poweroftwo_a0_812000a0() {
    // Encoding: 0x812000A0
    // Test aarch32_SMULWB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x812000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_9_poweroftwo_a0_912000a0() {
    // Encoding: 0x912000A0
    // Test aarch32_SMULWB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Rd=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x912000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_10_poweroftwo_a0_a12000a0() {
    // Encoding: 0xA12000A0
    // Test aarch32_SMULWB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=10, M=0, Rd=0
    let encoding: u32 = 0xA12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_11_poweroftwo_a0_b12000a0() {
    // Encoding: 0xB12000A0
    // Test aarch32_SMULWB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, M=0, cond=11
    let encoding: u32 = 0xB12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_12_poweroftwo_a0_c12000a0() {
    // Encoding: 0xC12000A0
    // Test aarch32_SMULWB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rn=0, cond=12, Rd=0, Rm=0
    let encoding: u32 = 0xC12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_13_poweroftwo_a0_d12000a0() {
    // Encoding: 0xD12000A0
    // Test aarch32_SMULWB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=13, M=0, Rm=0
    let encoding: u32 = 0xD12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_14_poweroftwo_a0_e12000a0() {
    // Encoding: 0xE12000A0
    // Test aarch32_SMULWB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=14, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xE12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smulwb_a1_a_field_cond_15_max_a0_f12000a0() {
    // Encoding: 0xF12000A0
    // Test aarch32_SMULWB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: M=0, Rd=0, Rn=0, cond=15, Rm=0
    let encoding: u32 = 0xF12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulwb_a1_a_field_rd_0_min_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulwb_a1_a_field_rd_1_poweroftwo_a0_012100a0() {
    // Encoding: 0x012100A0
    // Test aarch32_SMULWB_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, cond=0, Rd=1, Rm=0, Rn=0
    let encoding: u32 = 0x012100A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulwb_a1_a_field_rm_0_min_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rm=0, Rd=0, M=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulwb_a1_a_field_rm_1_poweroftwo_a0_012001a0() {
    // Encoding: 0x012001A0
    // Test aarch32_SMULWB_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rd=0, Rm=1, Rn=0, cond=0
    let encoding: u32 = 0x012001A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smulwb_a1_a_field_m_0_min_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, M=0, Rn=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smulwb_a1_a_field_m_1_max_a0_012000e0() {
    // Encoding: 0x012000E0
    // Test aarch32_SMULWB_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=0, M=1
    let encoding: u32 = 0x012000E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulwb_a1_a_field_rn_0_min_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rn=0, Rd=0, Rm=0, M=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulwb_a1_a_field_rn_1_poweroftwo_a0_012000a1() {
    // Encoding: 0x012000A1
    // Test aarch32_SMULWB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=1, cond=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0x012000A1;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smulwb_a1_a_combo_0_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A field combination: cond=0, Rd=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: Rm=0, M=0, Rd=0, cond=0, Rn=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_0_condition_eq_160_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, M=0, Rn=0, Rm=0, cond=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_1_condition_ne_160_112000a0() {
    // Encoding: 0x112000A0
    // Test aarch32_SMULWB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, M=0, Rm=0, cond=1, Rd=0
    let encoding: u32 = 0x112000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_2_condition_cs_hs_160_212000a0() {
    // Encoding: 0x212000A0
    // Test aarch32_SMULWB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rd=0, M=0, Rm=0, Rn=0, cond=2
    let encoding: u32 = 0x212000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_3_condition_cc_lo_160_312000a0() {
    // Encoding: 0x312000A0
    // Test aarch32_SMULWB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, M=0, cond=3
    let encoding: u32 = 0x312000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_4_condition_mi_160_412000a0() {
    // Encoding: 0x412000A0
    // Test aarch32_SMULWB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=4, M=0
    let encoding: u32 = 0x412000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_5_condition_pl_160_512000a0() {
    // Encoding: 0x512000A0
    // Test aarch32_SMULWB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rn=0, cond=5, Rm=0, Rd=0, M=0
    let encoding: u32 = 0x512000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_6_condition_vs_160_612000a0() {
    // Encoding: 0x612000A0
    // Test aarch32_SMULWB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: cond=6, Rd=0, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x612000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_7_condition_vc_160_712000a0() {
    // Encoding: 0x712000A0
    // Test aarch32_SMULWB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: M=0, Rn=0, Rd=0, Rm=0, cond=7
    let encoding: u32 = 0x712000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_8_condition_hi_160_812000a0() {
    // Encoding: 0x812000A0
    // Test aarch32_SMULWB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: M=0, Rn=0, Rd=0, cond=8, Rm=0
    let encoding: u32 = 0x812000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_9_condition_ls_160_912000a0() {
    // Encoding: 0x912000A0
    // Test aarch32_SMULWB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: cond=9, Rn=0, Rd=0, M=0, Rm=0
    let encoding: u32 = 0x912000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_10_condition_ge_160_a12000a0() {
    // Encoding: 0xA12000A0
    // Test aarch32_SMULWB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, M=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0xA12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_11_condition_lt_160_b12000a0() {
    // Encoding: 0xB12000A0
    // Test aarch32_SMULWB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: M=0, Rd=0, cond=11, Rm=0, Rn=0
    let encoding: u32 = 0xB12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_12_condition_gt_160_c12000a0() {
    // Encoding: 0xC12000A0
    // Test aarch32_SMULWB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Rd=0, cond=12, Rm=0, M=0, Rn=0
    let encoding: u32 = 0xC12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_13_condition_le_160_d12000a0() {
    // Encoding: 0xD12000A0
    // Test aarch32_SMULWB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=13, M=0
    let encoding: u32 = 0xD12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_14_condition_al_160_e12000a0() {
    // Encoding: 0xE12000A0
    // Test aarch32_SMULWB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, M=0, Rm=0, cond=14
    let encoding: u32 = 0xE12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smulwb_a1_a_special_cond_15_condition_nv_160_f12000a0() {
    // Encoding: 0xF12000A0
    // Test aarch32_SMULWB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rn=0, M=0, cond=15, Rd=0, Rm=0
    let encoding: u32 = 0xF12000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulwb_a1_a_invalid_0_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rn=0, M=0, Rm=0, cond=0, Rd=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULWB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulwb_a1_a_invalid_1_a0_012000a0() {
    // Encoding: 0x012000A0
    // Test aarch32_SMULWB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, cond=0, Rm=0, Rd=0, M=0
    let encoding: u32 = 0x012000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulwb_t1_a_field_rn_0_min_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rn=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulwb_t1_a_field_rn_1_poweroftwo_f000_fb31f000() {
    // Thumb encoding (32): 0xFB31F000
    // Test aarch32_SMULWB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB31F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulwb_t1_a_field_rd_0_min_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulwb_t1_a_field_rd_1_poweroftwo_f000_fb30f100() {
    // Thumb encoding (32): 0xFB30F100
    // Test aarch32_SMULWB_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Rm=0, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smulwb_t1_a_field_m_0_min_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rd=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smulwb_t1_a_field_m_1_max_f000_fb30f010() {
    // Thumb encoding (32): 0xFB30F010
    // Test aarch32_SMULWB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rm=0, M=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smulwb_t1_a_field_rm_0_min_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smulwb_t1_a_field_rm_1_poweroftwo_f000_fb30f001() {
    // Thumb encoding (32): 0xFB30F001
    // Test aarch32_SMULWB_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rm=1, Rn=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smulwb_t1_a_combo_0_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A field combination: Rn=0, Rd=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rd=0, M=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulwb_t1_a_invalid_0_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rd=0, M=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMULWB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smulwb_t1_a_invalid_1_f000_fb30f000() {
    // Thumb encoding (32): 0xFB30F000
    // Test aarch32_SMULWB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, M=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB30F000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_UMLAL_A Tests
// ============================================================================

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_0_min_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, cond=0, RdLo=0, RdHi=0, S=0, Rm=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_1_poweroftwo_90_10a00090() {
    // Encoding: 0x10A00090
    // Test aarch32_UMLAL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=1, Rn=0, Rm=0, S=0, RdLo=0
    let encoding: u32 = 0x10A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_2_poweroftwo_90_20a00090() {
    // Encoding: 0x20A00090
    // Test aarch32_UMLAL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, RdHi=0, Rn=0, cond=2, RdLo=0, Rm=0
    let encoding: u32 = 0x20A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_3_poweroftwo_90_30a00090() {
    // Encoding: 0x30A00090
    // Test aarch32_UMLAL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, S=0, cond=3, RdLo=0, Rn=0
    let encoding: u32 = 0x30A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_4_poweroftwo_90_40a00090() {
    // Encoding: 0x40A00090
    // Test aarch32_UMLAL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, RdHi=0, Rm=0, RdLo=0, Rn=0, S=0
    let encoding: u32 = 0x40A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_5_poweroftwo_90_50a00090() {
    // Encoding: 0x50A00090
    // Test aarch32_UMLAL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, S=0, cond=5, RdLo=0, Rm=0
    let encoding: u32 = 0x50A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_6_poweroftwo_90_60a00090() {
    // Encoding: 0x60A00090
    // Test aarch32_UMLAL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rn=0, cond=6, RdLo=0, RdHi=0, Rm=0
    let encoding: u32 = 0x60A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_7_poweroftwo_90_70a00090() {
    // Encoding: 0x70A00090
    // Test aarch32_UMLAL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, S=0, cond=7, RdHi=0, RdLo=0, Rn=0
    let encoding: u32 = 0x70A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_8_poweroftwo_90_80a00090() {
    // Encoding: 0x80A00090
    // Test aarch32_UMLAL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, cond=8, Rn=0, RdLo=0, Rm=0, RdHi=0
    let encoding: u32 = 0x80A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_9_poweroftwo_90_90a00090() {
    // Encoding: 0x90A00090
    // Test aarch32_UMLAL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, RdLo=0, S=0, RdHi=0, Rm=0
    let encoding: u32 = 0x90A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_10_poweroftwo_90_a0a00090() {
    // Encoding: 0xA0A00090
    // Test aarch32_UMLAL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, S=0, cond=10, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0xA0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_11_poweroftwo_90_b0a00090() {
    // Encoding: 0xB0A00090
    // Test aarch32_UMLAL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, cond=11, Rm=0, Rn=0, S=0
    let encoding: u32 = 0xB0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_12_poweroftwo_90_c0a00090() {
    // Encoding: 0xC0A00090
    // Test aarch32_UMLAL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, S=0, Rm=0, RdLo=0, Rn=0, RdHi=0
    let encoding: u32 = 0xC0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_13_poweroftwo_90_d0a00090() {
    // Encoding: 0xD0A00090
    // Test aarch32_UMLAL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=13, Rn=0, Rm=0, RdHi=0, S=0
    let encoding: u32 = 0xD0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_14_poweroftwo_90_e0a00090() {
    // Encoding: 0xE0A00090
    // Test aarch32_UMLAL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=14, RdLo=0, RdHi=0, S=0
    let encoding: u32 = 0xE0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_umlal_a1_a_field_cond_15_max_90_f0a00090() {
    // Encoding: 0xF0A00090
    // Test aarch32_UMLAL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, S=0, Rm=0, RdLo=0, cond=15, RdHi=0
    let encoding: u32 = 0xF0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_umlal_a1_a_field_s_0_min_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, RdLo=0, S=0, RdHi=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_umlal_a1_a_field_s_1_max_90_00b00090() {
    // Encoding: 0x00B00090
    // Test aarch32_UMLAL_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: RdHi=0, S=1, cond=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x00B00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umlal_a1_a_field_rdhi_0_min_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: S=0, RdHi=0, RdLo=0, Rm=0, Rn=0, cond=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umlal_a1_a_field_rdhi_1_poweroftwo_90_00a10090() {
    // Encoding: 0x00A10090
    // Test aarch32_UMLAL_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, RdHi=1, Rm=0, Rn=0, RdLo=0, cond=0
    let encoding: u32 = 0x00A10090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umlal_a1_a_field_rdhi_7_poweroftwominusone_90_00a70090() {
    // Encoding: 0x00A70090
    // Test aarch32_UMLAL_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdLo=0, S=0, RdHi=7, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x00A70090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umlal_a1_a_field_rdhi_15_max_90_00af0090() {
    // Encoding: 0x00AF0090
    // Test aarch32_UMLAL_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, RdHi=15, S=0, cond=0, RdLo=0, Rm=0
    let encoding: u32 = 0x00AF0090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umlal_a1_a_field_rdlo_0_min_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=0, RdHi=0, Rm=0, S=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umlal_a1_a_field_rdlo_1_poweroftwo_90_00a01090() {
    // Encoding: 0x00A01090
    // Test aarch32_UMLAL_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=1, Rn=0, S=0, RdHi=0, Rm=0, cond=0
    let encoding: u32 = 0x00A01090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umlal_a1_a_field_rdlo_7_poweroftwominusone_90_00a07090() {
    // Encoding: 0x00A07090
    // Test aarch32_UMLAL_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: RdLo=7, RdHi=0, cond=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x00A07090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umlal_a1_a_field_rdlo_15_max_90_00a0f090() {
    // Encoding: 0x00A0F090
    // Test aarch32_UMLAL_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: S=0, RdLo=15, Rn=0, cond=0, RdHi=0, Rm=0
    let encoding: u32 = 0x00A0F090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umlal_a1_a_field_rm_0_min_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, RdLo=0, S=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umlal_a1_a_field_rm_1_poweroftwo_90_00a00190() {
    // Encoding: 0x00A00190
    // Test aarch32_UMLAL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=0, RdHi=0, Rm=1, S=0, Rn=0
    let encoding: u32 = 0x00A00190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umlal_a1_a_field_rn_0_min_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, Rn=0, cond=0, RdHi=0, S=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umlal_a1_a_field_rn_1_poweroftwo_90_00a00091() {
    // Encoding: 0x00A00091
    // Test aarch32_UMLAL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=1, RdHi=0, cond=0, RdLo=0, S=0
    let encoding: u32 = 0x00A00091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_umlal_a1_a_combo_0_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A field combination: cond=0, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, S=0, cond=0, RdLo=0, RdHi=0, Rm=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_umlal_a1_a_special_cond_0_condition_eq_144_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: RdLo=0, cond=0, Rn=0, RdHi=0, S=0, Rm=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_umlal_a1_a_special_cond_1_condition_ne_144_10a00090() {
    // Encoding: 0x10A00090
    // Test aarch32_UMLAL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rn=0, cond=1, RdHi=0, Rm=0, RdLo=0, S=0
    let encoding: u32 = 0x10A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_umlal_a1_a_special_cond_2_condition_cs_hs_144_20a00090() {
    // Encoding: 0x20A00090
    // Test aarch32_UMLAL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rn=0, S=0, cond=2, Rm=0
    let encoding: u32 = 0x20A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_umlal_a1_a_special_cond_3_condition_cc_lo_144_30a00090() {
    // Encoding: 0x30A00090
    // Test aarch32_UMLAL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=3, S=0, RdLo=0, RdHi=0
    let encoding: u32 = 0x30A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_umlal_a1_a_special_cond_4_condition_mi_144_40a00090() {
    // Encoding: 0x40A00090
    // Test aarch32_UMLAL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: S=0, RdLo=0, cond=4, Rm=0, RdHi=0, Rn=0
    let encoding: u32 = 0x40A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_umlal_a1_a_special_cond_5_condition_pl_144_50a00090() {
    // Encoding: 0x50A00090
    // Test aarch32_UMLAL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, cond=5, S=0, Rn=0, RdLo=0
    let encoding: u32 = 0x50A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_umlal_a1_a_special_cond_6_condition_vs_144_60a00090() {
    // Encoding: 0x60A00090
    // Test aarch32_UMLAL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdHi=0, cond=6, S=0, RdLo=0
    let encoding: u32 = 0x60A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_umlal_a1_a_special_cond_7_condition_vc_144_70a00090() {
    // Encoding: 0x70A00090
    // Test aarch32_UMLAL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: RdLo=0, cond=7, Rn=0, RdHi=0, Rm=0, S=0
    let encoding: u32 = 0x70A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_umlal_a1_a_special_cond_8_condition_hi_144_80a00090() {
    // Encoding: 0x80A00090
    // Test aarch32_UMLAL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, RdHi=0, cond=8, Rm=0, S=0
    let encoding: u32 = 0x80A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_umlal_a1_a_special_cond_9_condition_ls_144_90a00090() {
    // Encoding: 0x90A00090
    // Test aarch32_UMLAL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: S=0, cond=9, RdLo=0, Rm=0, Rn=0, RdHi=0
    let encoding: u32 = 0x90A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_umlal_a1_a_special_cond_10_condition_ge_144_a0a00090() {
    // Encoding: 0xA0A00090
    // Test aarch32_UMLAL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: S=0, RdLo=0, Rm=0, Rn=0, cond=10, RdHi=0
    let encoding: u32 = 0xA0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_umlal_a1_a_special_cond_11_condition_lt_144_b0a00090() {
    // Encoding: 0xB0A00090
    // Test aarch32_UMLAL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: RdHi=0, RdLo=0, Rm=0, S=0, cond=11, Rn=0
    let encoding: u32 = 0xB0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_umlal_a1_a_special_cond_12_condition_gt_144_c0a00090() {
    // Encoding: 0xC0A00090
    // Test aarch32_UMLAL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: RdLo=0, cond=12, RdHi=0, S=0, Rm=0, Rn=0
    let encoding: u32 = 0xC0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_umlal_a1_a_special_cond_13_condition_le_144_d0a00090() {
    // Encoding: 0xD0A00090
    // Test aarch32_UMLAL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: RdLo=0, cond=13, RdHi=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0xD0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_umlal_a1_a_special_cond_14_condition_al_144_e0a00090() {
    // Encoding: 0xE0A00090
    // Test aarch32_UMLAL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, RdLo=0, Rm=0, cond=14, S=0, RdHi=0
    let encoding: u32 = 0xE0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_umlal_a1_a_special_cond_15_condition_nv_144_f0a00090() {
    // Encoding: 0xF0A00090
    // Test aarch32_UMLAL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rm=0, cond=15, Rn=0, RdHi=0, S=0, RdLo=0
    let encoding: u32 = 0xF0A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_umlal_a1_a_special_s_0_size_variant_0_144_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: RdLo=0, S=0, RdHi=0, cond=0, Rn=0, Rm=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_umlal_a1_a_special_s_1_size_variant_1_144_00b00090() {
    // Encoding: 0x00B00090
    // Test aarch32_UMLAL_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: cond=0, S=1, RdHi=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x00B00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_a1_a_invalid_0_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, RdLo=0, RdHi=0, Rm=0, S=0, Rn=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_a1_a_invalid_1_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: RdLo=0, Rm=0, cond=0, Rn=0, RdHi=0, S=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_a1_a_invalid_2_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rn=0, S=0, Rm=0, cond=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_a1_a_invalid_3_90_00a00090() {
    // Encoding: 0x00A00090
    // Test aarch32_UMLAL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, RdLo=0, Rm=0, Rn=0, RdHi=0, S=0
    let encoding: u32 = 0x00A00090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umlal_t1_a_field_rn_0_min_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: RdHi=0, RdLo=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umlal_t1_a_field_rn_1_poweroftwo_0_fbe10000() {
    // Thumb encoding (32): 0xFBE10000
    // Test aarch32_UMLAL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, RdHi=0, Rn=1, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umlal_t1_a_field_rdlo_0_min_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, Rm=0, RdHi=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umlal_t1_a_field_rdlo_1_poweroftwo_0_fbe01000() {
    // Thumb encoding (32): 0xFBE01000
    // Test aarch32_UMLAL_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, RdLo=1, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umlal_t1_a_field_rdlo_7_poweroftwominusone_0_fbe07000() {
    // Thumb encoding (32): 0xFBE07000
    // Test aarch32_UMLAL_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=7
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umlal_t1_a_field_rdlo_15_max_0_fbe0f000() {
    // Thumb encoding (32): 0xFBE0F000
    // Test aarch32_UMLAL_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: Rm=0, RdLo=15, RdHi=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umlal_t1_a_field_rdhi_0_min_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rn=0, RdLo=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umlal_t1_a_field_rdhi_1_poweroftwo_0_fbe00100() {
    // Thumb encoding (32): 0xFBE00100
    // Test aarch32_UMLAL_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, RdLo=0, RdHi=1, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umlal_t1_a_field_rdhi_7_poweroftwominusone_0_fbe00700() {
    // Thumb encoding (32): 0xFBE00700
    // Test aarch32_UMLAL_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, RdHi=7, RdLo=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umlal_t1_a_field_rdhi_15_max_0_fbe00f00() {
    // Thumb encoding (32): 0xFBE00F00
    // Test aarch32_UMLAL_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: RdLo=0, Rn=0, Rm=0, RdHi=15
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umlal_t1_a_field_rm_0_min_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umlal_t1_a_field_rm_1_poweroftwo_0_fbe00001() {
    // Thumb encoding (32): 0xFBE00001
    // Test aarch32_UMLAL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdHi=0, Rn=0, Rm=1, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_umlal_t1_a_combo_0_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A field combination: Rn=0, RdLo=0, RdHi=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, RdHi=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_t1_a_invalid_0_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: RdHi=0, RdLo=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_t1_a_invalid_1_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdHi=0, RdLo=0, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_t1_a_invalid_2_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umlal_t1_a_invalid_3_0_fbe00000() {
    // Thumb encoding (32): 0xFBE00000
    // Test aarch32_UMLAL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: RdLo=0, Rm=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBE00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_zeroresult_0_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: ZeroResult
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_zeroresult_1_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: ZeroResult
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_negativeresult_2_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: NegativeResult
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_unsignedoverflow_3_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_unsignedoverflow_4_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_signedoverflow_5_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_umlal_a1_a_flags_signedoverflow_6_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_umlal_a1_a_flags_positiveresult_7_00b00291() {
    // Test aarch32_UMLAL_A1_A flag computation: PositiveResult
    // Encoding: 0x00B00291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00B00291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_zeroresult_0_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_zeroresult_1_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_negativeresult_2_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_unsignedoverflow_3_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_unsignedoverflow_4_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_signedoverflow_5_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_umlal_t1_a_flags_signedoverflow_6_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMLAL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_umlal_t1_a_flags_positiveresult_7_fbe10002() {
    // Test aarch32_UMLAL_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0xFBE10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

// ============================================================================
// aarch32_SMLAWB_A Tests
// ============================================================================

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_0_min_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rm=0, Rd=0, cond=0, M=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_1_poweroftwo_80_11200080() {
    // Encoding: 0x11200080
    // Test aarch32_SMLAWB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rm=0, M=0, Ra=0, Rn=0, Rd=0
    let encoding: u32 = 0x11200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_2_poweroftwo_80_21200080() {
    // Encoding: 0x21200080
    // Test aarch32_SMLAWB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=2, Rm=0, Rd=0, M=0, Ra=0, Rn=0
    let encoding: u32 = 0x21200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_3_poweroftwo_80_31200080() {
    // Encoding: 0x31200080
    // Test aarch32_SMLAWB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, Rd=0, cond=3, Ra=0, Rn=0, Rm=0
    let encoding: u32 = 0x31200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_4_poweroftwo_80_41200080() {
    // Encoding: 0x41200080
    // Test aarch32_SMLAWB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rd=0, Rm=0, M=0, Rn=0, Ra=0
    let encoding: u32 = 0x41200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_5_poweroftwo_80_51200080() {
    // Encoding: 0x51200080
    // Test aarch32_SMLAWB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=0, Rn=0, Ra=0, cond=5
    let encoding: u32 = 0x51200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_6_poweroftwo_80_61200080() {
    // Encoding: 0x61200080
    // Test aarch32_SMLAWB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, cond=6, Rm=0, M=0
    let encoding: u32 = 0x61200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_7_poweroftwo_80_71200080() {
    // Encoding: 0x71200080
    // Test aarch32_SMLAWB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=7, M=0, Rn=0, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0x71200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_8_poweroftwo_80_81200080() {
    // Encoding: 0x81200080
    // Test aarch32_SMLAWB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rn=0, M=0, Rm=0, Ra=0
    let encoding: u32 = 0x81200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_9_poweroftwo_80_91200080() {
    // Encoding: 0x91200080
    // Test aarch32_SMLAWB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, M=0, Rn=0, Ra=0, cond=9
    let encoding: u32 = 0x91200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_10_poweroftwo_80_a1200080() {
    // Encoding: 0xA1200080
    // Test aarch32_SMLAWB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, M=0, cond=10, Ra=0, Rn=0, Rd=0
    let encoding: u32 = 0xA1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_11_poweroftwo_80_b1200080() {
    // Encoding: 0xB1200080
    // Test aarch32_SMLAWB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, M=0, cond=11, Ra=0, Rn=0
    let encoding: u32 = 0xB1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_12_poweroftwo_80_c1200080() {
    // Encoding: 0xC1200080
    // Test aarch32_SMLAWB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, M=0, Rm=0, cond=12
    let encoding: u32 = 0xC1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_13_poweroftwo_80_d1200080() {
    // Encoding: 0xD1200080
    // Test aarch32_SMLAWB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Ra=0, Rn=0, M=0, Rm=0, Rd=0
    let encoding: u32 = 0xD1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_14_poweroftwo_80_e1200080() {
    // Encoding: 0xE1200080
    // Test aarch32_SMLAWB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Rd=0, M=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0xE1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlawb_a1_a_field_cond_15_max_80_f1200080() {
    // Encoding: 0xF1200080
    // Test aarch32_SMLAWB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, cond=15, M=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0xF1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_a1_a_field_rd_0_min_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, M=0, Rd=0, Ra=0, cond=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_a1_a_field_rd_1_poweroftwo_80_01210080() {
    // Encoding: 0x01210080
    // Test aarch32_SMLAWB_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Ra=0, M=0, Rd=1, Rn=0, cond=0
    let encoding: u32 = 0x01210080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_a1_a_field_ra_0_min_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, M=0, Ra=0, Rn=0, Rd=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_a1_a_field_ra_1_poweroftwo_80_01201080() {
    // Encoding: 0x01201080
    // Test aarch32_SMLAWB_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Ra=1, Rm=0, Rn=0, Rd=0, M=0
    let encoding: u32 = 0x01201080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_a1_a_field_rm_0_min_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rn=0, M=0, cond=0, Rm=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_a1_a_field_rm_1_poweroftwo_80_01200180() {
    // Encoding: 0x01200180
    // Test aarch32_SMLAWB_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=1, M=0, Ra=0, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x01200180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlawb_a1_a_field_m_0_min_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, cond=0, Rm=0, Rn=0, M=0, Rd=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlawb_a1_a_field_m_1_max_80_012000c0() {
    // Encoding: 0x012000C0
    // Test aarch32_SMLAWB_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Ra=0, M=1, Rn=0, cond=0, Rd=0
    let encoding: u32 = 0x012000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_a1_a_field_rn_0_min_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Ra=0, cond=0, Rd=0, M=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_a1_a_field_rn_1_poweroftwo_80_01200081() {
    // Encoding: 0x01200081
    // Test aarch32_SMLAWB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, M=0, Rn=1, Ra=0
    let encoding: u32 = 0x01200081;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlawb_a1_a_combo_0_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, M=0, Rn=0
    // ISET: A32
    // Fields: Rd=0, cond=0, Rm=0, M=0, Rn=0, Ra=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_0_condition_eq_128_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Ra=0, Rm=0, cond=0, M=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_1_condition_ne_128_11200080() {
    // Encoding: 0x11200080
    // Test aarch32_SMLAWB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, cond=1, Rm=0, Rn=0, Ra=0, M=0
    let encoding: u32 = 0x11200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_2_condition_cs_hs_128_21200080() {
    // Encoding: 0x21200080
    // Test aarch32_SMLAWB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Ra=0, Rd=0, Rm=0, Rn=0, M=0
    let encoding: u32 = 0x21200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_3_condition_cc_lo_128_31200080() {
    // Encoding: 0x31200080
    // Test aarch32_SMLAWB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: cond=3, M=0, Rd=0, Rn=0, Ra=0, Rm=0
    let encoding: u32 = 0x31200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_4_condition_mi_128_41200080() {
    // Encoding: 0x41200080
    // Test aarch32_SMLAWB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rd=0, M=0, Rm=0, cond=4, Ra=0, Rn=0
    let encoding: u32 = 0x41200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_5_condition_pl_128_51200080() {
    // Encoding: 0x51200080
    // Test aarch32_SMLAWB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rm=0, cond=5, Ra=0, Rd=0, M=0, Rn=0
    let encoding: u32 = 0x51200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_6_condition_vs_128_61200080() {
    // Encoding: 0x61200080
    // Test aarch32_SMLAWB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: M=0, cond=6, Rm=0, Rd=0, Ra=0, Rn=0
    let encoding: u32 = 0x61200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_7_condition_vc_128_71200080() {
    // Encoding: 0x71200080
    // Test aarch32_SMLAWB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: cond=7, Rm=0, Rn=0, Rd=0, M=0, Ra=0
    let encoding: u32 = 0x71200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_8_condition_hi_128_81200080() {
    // Encoding: 0x81200080
    // Test aarch32_SMLAWB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Ra=0, Rd=0, M=0, cond=8, Rm=0, Rn=0
    let encoding: u32 = 0x81200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_9_condition_ls_128_91200080() {
    // Encoding: 0x91200080
    // Test aarch32_SMLAWB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rn=0, Rm=0, M=0, cond=9
    let encoding: u32 = 0x91200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_10_condition_ge_128_a1200080() {
    // Encoding: 0xA1200080
    // Test aarch32_SMLAWB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=10, Ra=0, M=0
    let encoding: u32 = 0xA1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_11_condition_lt_128_b1200080() {
    // Encoding: 0xB1200080
    // Test aarch32_SMLAWB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rm=0, Rn=0, M=0, Ra=0, Rd=0
    let encoding: u32 = 0xB1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_12_condition_gt_128_c1200080() {
    // Encoding: 0xC1200080
    // Test aarch32_SMLAWB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: M=0, cond=12, Rn=0, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0xC1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_13_condition_le_128_d1200080() {
    // Encoding: 0xD1200080
    // Test aarch32_SMLAWB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=13, M=0, Rm=0, Rn=0
    let encoding: u32 = 0xD1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_14_condition_al_128_e1200080() {
    // Encoding: 0xE1200080
    // Test aarch32_SMLAWB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=14, M=0, Rd=0, Ra=0
    let encoding: u32 = 0xE1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlawb_a1_a_special_cond_15_condition_nv_128_f1200080() {
    // Encoding: 0xF1200080
    // Test aarch32_SMLAWB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, Ra=0, cond=15, M=0
    let encoding: u32 = 0xF1200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlawb_a1_a_invalid_0_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, Rn=0, M=0, Ra=0, cond=0, Rm=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAWB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlawb_a1_a_invalid_1_80_01200080() {
    // Encoding: 0x01200080
    // Test aarch32_SMLAWB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, cond=0, Ra=0, M=0
    let encoding: u32 = 0x01200080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_t1_a_field_rn_0_min_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rn=0, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_t1_a_field_rn_1_poweroftwo_0_fb310000() {
    // Thumb encoding (32): 0xFB310000
    // Test aarch32_SMLAWB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, M=0, Rm=0, Rn=1, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB310000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_t1_a_field_ra_0_min_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rd=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_t1_a_field_ra_1_poweroftwo_0_fb301000() {
    // Thumb encoding (32): 0xFB301000
    // Test aarch32_SMLAWB_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Ra=1, M=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB301000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_t1_a_field_rd_0_min_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, M=0, Rm=0, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_t1_a_field_rd_1_poweroftwo_0_fb300100() {
    // Thumb encoding (32): 0xFB300100
    // Test aarch32_SMLAWB_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Ra=0, Rn=0, Rd=1, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlawb_t1_a_field_m_0_min_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Ra=0, Rn=0, Rm=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlawb_t1_a_field_m_1_max_0_fb300010() {
    // Thumb encoding (32): 0xFB300010
    // Test aarch32_SMLAWB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Rm=0, M=1, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlawb_t1_a_field_rm_0_min_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, M=0, Ra=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlawb_t1_a_field_rm_1_poweroftwo_0_fb300001() {
    // Thumb encoding (32): 0xFB300001
    // Test aarch32_SMLAWB_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: M=0, Ra=0, Rn=0, Rd=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlawb_t1_a_combo_0_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A field combination: Rn=0, Ra=0, Rd=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, M=0, Rm=0, Ra=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlawb_t1_a_invalid_0_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rm=0, Rn=0, M=0, Rd=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLAWB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlawb_t1_a_invalid_1_0_fb300000() {
    // Thumb encoding (32): 0xFB300000
    // Test aarch32_SMLAWB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rd=0, Rn=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB300000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SDIV_A Tests
// ============================================================================

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_0_min_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Ra=0, cond=0, Rd=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_1_poweroftwo_10_17100010() {
    // Encoding: 0x17100010
    // Test aarch32_SDIV_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=1, Rd=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x17100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_2_poweroftwo_10_27100010() {
    // Encoding: 0x27100010
    // Test aarch32_SDIV_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=2, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x27100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_3_poweroftwo_10_37100010() {
    // Encoding: 0x37100010
    // Test aarch32_SDIV_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, cond=3, Ra=0, Rn=0
    let encoding: u32 = 0x37100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_4_poweroftwo_10_47100010() {
    // Encoding: 0x47100010
    // Test aarch32_SDIV_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, cond=4, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0x47100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_5_poweroftwo_10_57100010() {
    // Encoding: 0x57100010
    // Test aarch32_SDIV_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=5, Rn=0, Rd=0, Ra=0
    let encoding: u32 = 0x57100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_6_poweroftwo_10_67100010() {
    // Encoding: 0x67100010
    // Test aarch32_SDIV_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=6, Rd=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0x67100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_7_poweroftwo_10_77100010() {
    // Encoding: 0x77100010
    // Test aarch32_SDIV_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rd=0, Rm=0, cond=7, Rn=0
    let encoding: u32 = 0x77100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_8_poweroftwo_10_87100010() {
    // Encoding: 0x87100010
    // Test aarch32_SDIV_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=0, Rn=0, cond=8
    let encoding: u32 = 0x87100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_9_poweroftwo_10_97100010() {
    // Encoding: 0x97100010
    // Test aarch32_SDIV_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=9, Ra=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x97100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_10_poweroftwo_10_a7100010() {
    // Encoding: 0xA7100010
    // Test aarch32_SDIV_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, cond=10, Ra=0
    let encoding: u32 = 0xA7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_11_poweroftwo_10_b7100010() {
    // Encoding: 0xB7100010
    // Test aarch32_SDIV_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Rd=0, Ra=0, Rm=0, Rn=0
    let encoding: u32 = 0xB7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_12_poweroftwo_10_c7100010() {
    // Encoding: 0xC7100010
    // Test aarch32_SDIV_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Ra=0, Rm=0, cond=12
    let encoding: u32 = 0xC7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_13_poweroftwo_10_d7100010() {
    // Encoding: 0xD7100010
    // Test aarch32_SDIV_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, Rm=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0xD7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_14_poweroftwo_10_e7100010() {
    // Encoding: 0xE7100010
    // Test aarch32_SDIV_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=14, Rm=0, Rd=0
    let encoding: u32 = 0xE7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_sdiv_a1_a_field_cond_15_max_10_f7100010() {
    // Encoding: 0xF7100010
    // Test aarch32_SDIV_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Ra=0, cond=15, Rn=0
    let encoding: u32 = 0xF7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_a1_a_field_rd_0_min_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_a1_a_field_rd_1_poweroftwo_10_07110010() {
    // Encoding: 0x07110010
    // Test aarch32_SDIV_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, Ra=0, Rm=0, cond=0, Rn=0
    let encoding: u32 = 0x07110010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_a1_a_field_ra_0_min_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_a1_a_field_ra_1_poweroftwo_10_07101010() {
    // Encoding: 0x07101010
    // Test aarch32_SDIV_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Ra=1, cond=0, Rn=0
    let encoding: u32 = 0x07101010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_a1_a_field_rm_0_min_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_a1_a_field_rm_1_poweroftwo_10_07100110() {
    // Encoding: 0x07100110
    // Test aarch32_SDIV_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rn=0, Rm=1, Ra=0
    let encoding: u32 = 0x07100110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_a1_a_field_rn_0_min_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Ra=0, cond=0, Rn=0, Rd=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_a1_a_field_rn_1_poweroftwo_10_07100011() {
    // Encoding: 0x07100011
    // Test aarch32_SDIV_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, Rn=1, Rd=0, Ra=0
    let encoding: u32 = 0x07100011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_sdiv_a1_a_combo_0_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rd=0, cond=0, Ra=0, Rm=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_0_condition_eq_16_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Ra=0, cond=0, Rd=0, Rn=0, Rm=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_1_condition_ne_16_17100010() {
    // Encoding: 0x17100010
    // Test aarch32_SDIV_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Ra=0, cond=1, Rn=0, Rm=0, Rd=0
    let encoding: u32 = 0x17100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_2_condition_cs_hs_16_27100010() {
    // Encoding: 0x27100010
    // Test aarch32_SDIV_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: cond=2, Rd=0, Rm=0, Ra=0, Rn=0
    let encoding: u32 = 0x27100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_3_condition_cc_lo_16_37100010() {
    // Encoding: 0x37100010
    // Test aarch32_SDIV_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rd=0, cond=3, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0x37100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_4_condition_mi_16_47100010() {
    // Encoding: 0x47100010
    // Test aarch32_SDIV_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: cond=4, Rm=0, Rd=0, Ra=0, Rn=0
    let encoding: u32 = 0x47100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_5_condition_pl_16_57100010() {
    // Encoding: 0x57100010
    // Test aarch32_SDIV_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: cond=5, Rd=0, Ra=0, Rn=0, Rm=0
    let encoding: u32 = 0x57100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_6_condition_vs_16_67100010() {
    // Encoding: 0x67100010
    // Test aarch32_SDIV_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Ra=0, Rd=0, cond=6, Rm=0
    let encoding: u32 = 0x67100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_7_condition_vc_16_77100010() {
    // Encoding: 0x77100010
    // Test aarch32_SDIV_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Ra=0, cond=7, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0x77100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_8_condition_hi_16_87100010() {
    // Encoding: 0x87100010
    // Test aarch32_SDIV_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=8, Ra=0, Rd=0
    let encoding: u32 = 0x87100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_9_condition_ls_16_97100010() {
    // Encoding: 0x97100010
    // Test aarch32_SDIV_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=9, Rd=0, Rm=0
    let encoding: u32 = 0x97100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_10_condition_ge_16_a7100010() {
    // Encoding: 0xA7100010
    // Test aarch32_SDIV_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Ra=0, cond=10, Rm=0
    let encoding: u32 = 0xA7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_11_condition_lt_16_b7100010() {
    // Encoding: 0xB7100010
    // Test aarch32_SDIV_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: cond=11, Rn=0, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xB7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_12_condition_gt_16_c7100010() {
    // Encoding: 0xC7100010
    // Test aarch32_SDIV_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: Ra=0, cond=12, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xC7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_13_condition_le_16_d7100010() {
    // Encoding: 0xD7100010
    // Test aarch32_SDIV_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: cond=13, Ra=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0xD7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_14_condition_al_16_e7100010() {
    // Encoding: 0xE7100010
    // Test aarch32_SDIV_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: cond=14, Rd=0, Rm=0, Rn=0, Ra=0
    let encoding: u32 = 0xE7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_sdiv_a1_a_special_cond_15_condition_nv_16_f7100010() {
    // Encoding: 0xF7100010
    // Test aarch32_SDIV_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rn=0, cond=15, Rm=0
    let encoding: u32 = 0xF7100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sdiv_a1_a_invalid_0_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: cond=0, Rm=0, Rn=0, Ra=0, Rd=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SDIV_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sdiv_a1_a_invalid_1_10_07100010() {
    // Encoding: 0x07100010
    // Test aarch32_SDIV_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, cond=0, Rd=0, Rn=0, Ra=0
    let encoding: u32 = 0x07100010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_t1_a_field_rn_0_min_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_t1_a_field_rn_1_poweroftwo_f0_fb9100f0() {
    // Thumb encoding (32): 0xFB9100F0
    // Test aarch32_SDIV_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Rn=1, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9100F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_t1_a_field_ra_0_min_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Rd=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_t1_a_field_ra_1_poweroftwo_f0_fb9010f0() {
    // Thumb encoding (32): 0xFB9010F0
    // Test aarch32_SDIV_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rd=0, Rn=0, Ra=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9010F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_t1_a_field_rd_0_min_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_t1_a_field_rd_1_poweroftwo_f0_fb9001f0() {
    // Thumb encoding (32): 0xFB9001F0
    // Test aarch32_SDIV_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, Rd=1, Rm=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9001F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_sdiv_t1_a_field_rm_0_min_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_sdiv_t1_a_field_rm_1_poweroftwo_f0_fb9000f1() {
    // Thumb encoding (32): 0xFB9000F1
    // Test aarch32_SDIV_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, Rd=0, Rn=0, Rm=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F1;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_sdiv_t1_a_combo_0_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A field combination: Rn=0, Ra=0, Rd=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sdiv_t1_a_invalid_0_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A invalid encoding: Binary { op: Ne, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Rn=0, Rm=0, Ra=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SDIV_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_sdiv_t1_a_invalid_1_f0_fb9000f0() {
    // Thumb encoding (32): 0xFB9000F0
    // Test aarch32_SDIV_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rd=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB9000F0;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

// ============================================================================
// aarch32_SMLABB_A Tests
// ============================================================================

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=0, Rm=0, Rd=0, N=0, M=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_1_poweroftwo_80_11000080() {
    // Encoding: 0x11000080
    // Test aarch32_SMLABB_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, Ra=0, M=0, N=0, cond=1
    let encoding: u32 = 0x11000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_2_poweroftwo_80_21000080() {
    // Encoding: 0x21000080
    // Test aarch32_SMLABB_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, cond=2, Rn=0, Rd=0, Ra=0, Rm=0, M=0
    let encoding: u32 = 0x21000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_3_poweroftwo_80_31000080() {
    // Encoding: 0x31000080
    // Test aarch32_SMLABB_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=0, Rm=0, Rn=0, M=0, N=0, cond=3, Ra=0
    let encoding: u32 = 0x31000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_4_poweroftwo_80_41000080() {
    // Encoding: 0x41000080
    // Test aarch32_SMLABB_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Rn=0, cond=4, Ra=0, M=0, Rd=0, Rm=0
    let encoding: u32 = 0x41000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_5_poweroftwo_80_51000080() {
    // Encoding: 0x51000080
    // Test aarch32_SMLABB_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rd=0, cond=5, Rm=0, M=0, N=0, Rn=0
    let encoding: u32 = 0x51000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_6_poweroftwo_80_61000080() {
    // Encoding: 0x61000080
    // Test aarch32_SMLABB_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, cond=6, Ra=0, N=0, M=0, Rd=0
    let encoding: u32 = 0x61000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_7_poweroftwo_80_71000080() {
    // Encoding: 0x71000080
    // Test aarch32_SMLABB_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=7, Ra=0, Rd=0, Rm=0, M=0, N=0
    let encoding: u32 = 0x71000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_8_poweroftwo_80_81000080() {
    // Encoding: 0x81000080
    // Test aarch32_SMLABB_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Ra=0, Rm=0, N=0, M=0, Rn=0
    let encoding: u32 = 0x81000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_9_poweroftwo_80_91000080() {
    // Encoding: 0x91000080
    // Test aarch32_SMLABB_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Ra=0, cond=9, M=0, N=0, Rn=0
    let encoding: u32 = 0x91000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_10_poweroftwo_80_a1000080() {
    // Encoding: 0xA1000080
    // Test aarch32_SMLABB_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, N=0, Ra=0, Rn=0, Rd=0, cond=10, M=0
    let encoding: u32 = 0xA1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_11_poweroftwo_80_b1000080() {
    // Encoding: 0xB1000080
    // Test aarch32_SMLABB_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=11, Rd=0, N=0, Rn=0, Ra=0, M=0
    let encoding: u32 = 0xB1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_12_poweroftwo_80_c1000080() {
    // Encoding: 0xC1000080
    // Test aarch32_SMLABB_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, Rd=0, M=0, N=0, Ra=0, cond=12
    let encoding: u32 = 0xC1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_13_poweroftwo_80_d1000080() {
    // Encoding: 0xD1000080
    // Test aarch32_SMLABB_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, N=0, Rm=0, Ra=0, M=0, Rn=0, Rd=0
    let encoding: u32 = 0xD1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_14_poweroftwo_80_e1000080() {
    // Encoding: 0xE1000080
    // Test aarch32_SMLABB_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, Ra=0, Rd=0, Rn=0, N=0, M=0, Rm=0
    let encoding: u32 = 0xE1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smlabb_a1_a_field_cond_15_max_80_f1000080() {
    // Encoding: 0xF1000080
    // Test aarch32_SMLABB_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, Ra=0, cond=15, Rm=0, M=0, Rd=0, N=0
    let encoding: u32 = 0xF1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_a1_a_field_rd_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=0, M=0, N=0, Rn=0, Rm=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_a1_a_field_rd_1_poweroftwo_80_01010080() {
    // Encoding: 0x01010080
    // Test aarch32_SMLABB_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, N=0, Rd=1, M=0, Rn=0, Ra=0, cond=0
    let encoding: u32 = 0x01010080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_a1_a_field_ra_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, N=0, cond=0, M=0, Rd=0, Ra=0, Rn=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_a1_a_field_ra_1_poweroftwo_80_01001080() {
    // Encoding: 0x01001080
    // Test aarch32_SMLABB_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: N=0, Rn=0, cond=0, Rd=0, M=0, Ra=1, Rm=0
    let encoding: u32 = 0x01001080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_a1_a_field_rm_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, N=0, Rd=0, cond=0, M=0, Rm=0, Rn=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_a1_a_field_rm_1_poweroftwo_80_01000180() {
    // Encoding: 0x01000180
    // Test aarch32_SMLABB_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rd=0, Rm=1, Ra=0, M=0, N=0, Rn=0
    let encoding: u32 = 0x01000180;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlabb_a1_a_field_m_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field M = 0 (Min)
    // ISET: A32
    // Fields: N=0, Rd=0, Ra=0, cond=0, Rn=0, Rm=0, M=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field M 6 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlabb_a1_a_field_m_1_max_80_010000c0() {
    // Encoding: 0x010000C0
    // Test aarch32_SMLABB_A1_A field M = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, M=1, Rn=0, Ra=0, Rd=0, cond=0, N=0
    let encoding: u32 = 0x010000C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlabb_a1_a_field_n_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field N = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, N=0, M=0, Rn=0, Ra=0, cond=0, Rm=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlabb_a1_a_field_n_1_max_80_010000a0() {
    // Encoding: 0x010000A0
    // Test aarch32_SMLABB_A1_A field N = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, N=1, Rn=0, Rd=0, M=0, cond=0, Ra=0
    let encoding: u32 = 0x010000A0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_a1_a_field_rn_0_min_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: M=0, N=0, Ra=0, Rn=0, cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_a1_a_field_rn_1_poweroftwo_80_01000081() {
    // Encoding: 0x01000081
    // Test aarch32_SMLABB_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: M=0, N=0, Ra=0, Rn=1, cond=0, Rd=0, Rm=0
    let encoding: u32 = 0x01000081;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smlabb_a1_a_combo_0_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, M=0, N=0, Rn=0
    // ISET: A32
    // Fields: Rn=0, Rm=0, M=0, cond=0, Rd=0, Ra=0, N=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_0_condition_eq_128_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rn=0, cond=0, M=0, N=0, Rd=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_1_condition_ne_128_11000080() {
    // Encoding: 0x11000080
    // Test aarch32_SMLABB_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, cond=1, Ra=0, Rn=0, M=0, Rm=0, N=0
    let encoding: u32 = 0x11000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_2_condition_cs_hs_128_21000080() {
    // Encoding: 0x21000080
    // Test aarch32_SMLABB_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: M=0, N=0, cond=2, Rn=0, Ra=0, Rd=0, Rm=0
    let encoding: u32 = 0x21000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_3_condition_cc_lo_128_31000080() {
    // Encoding: 0x31000080
    // Test aarch32_SMLABB_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: M=0, N=0, Rn=0, cond=3, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x31000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_4_condition_mi_128_41000080() {
    // Encoding: 0x41000080
    // Test aarch32_SMLABB_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rm=0, Rd=0, Rn=0, M=0, cond=4, N=0, Ra=0
    let encoding: u32 = 0x41000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_5_condition_pl_128_51000080() {
    // Encoding: 0x51000080
    // Test aarch32_SMLABB_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: N=0, M=0, Rm=0, Rd=0, Ra=0, Rn=0, cond=5
    let encoding: u32 = 0x51000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_6_condition_vs_128_61000080() {
    // Encoding: 0x61000080
    // Test aarch32_SMLABB_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Ra=0, Rd=0, N=0, cond=6, Rn=0, M=0, Rm=0
    let encoding: u32 = 0x61000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_7_condition_vc_128_71000080() {
    // Encoding: 0x71000080
    // Test aarch32_SMLABB_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: N=0, Rn=0, M=0, cond=7, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0x71000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_8_condition_hi_128_81000080() {
    // Encoding: 0x81000080
    // Test aarch32_SMLABB_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, N=0, Ra=0, cond=8, M=0, Rn=0, Rm=0
    let encoding: u32 = 0x81000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_9_condition_ls_128_91000080() {
    // Encoding: 0x91000080
    // Test aarch32_SMLABB_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: N=0, Rn=0, Ra=0, cond=9, Rm=0, M=0, Rd=0
    let encoding: u32 = 0x91000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_10_condition_ge_128_a1000080() {
    // Encoding: 0xA1000080
    // Test aarch32_SMLABB_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Ra=0, cond=10, Rm=0, M=0, N=0
    let encoding: u32 = 0xA1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_11_condition_lt_128_b1000080() {
    // Encoding: 0xB1000080
    // Test aarch32_SMLABB_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Ra=0, cond=11, Rm=0, Rn=0, M=0, N=0, Rd=0
    let encoding: u32 = 0xB1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_12_condition_gt_128_c1000080() {
    // Encoding: 0xC1000080
    // Test aarch32_SMLABB_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rm=0, N=0, Rd=0, M=0, Rn=0, Ra=0
    let encoding: u32 = 0xC1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_13_condition_le_128_d1000080() {
    // Encoding: 0xD1000080
    // Test aarch32_SMLABB_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=13, M=0, N=0, Rn=0, Rm=0
    let encoding: u32 = 0xD1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_14_condition_al_128_e1000080() {
    // Encoding: 0xE1000080
    // Test aarch32_SMLABB_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: Ra=0, Rn=0, Rd=0, cond=14, M=0, N=0, Rm=0
    let encoding: u32 = 0xE1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smlabb_a1_a_special_cond_15_condition_nv_128_f1000080() {
    // Encoding: 0xF1000080
    // Test aarch32_SMLABB_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Ra=0, Rd=0, N=0, Rn=0, Rm=0, cond=15, M=0
    let encoding: u32 = 0xF1000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"a\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlabb_a1_a_invalid_0_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "a" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Rd=0, M=0, N=0, Rm=0, Ra=0, cond=0, Rn=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLABB_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlabb_a1_a_invalid_1_80_01000080() {
    // Encoding: 0x01000080
    // Test aarch32_SMLABB_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rm=0, Ra=0, N=0, Rn=0, M=0, cond=0, Rd=0
    let encoding: u32 = 0x01000080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_t1_a_field_rn_0_min_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, N=0, Rn=0, Ra=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_t1_a_field_rn_1_poweroftwo_0_fb110000() {
    // Thumb encoding (32): 0xFB110000
    // Test aarch32_SMLABB_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, M=0, N=0, Rn=1, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB110000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_t1_a_field_ra_0_min_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Ra=0, Rd=0, Rn=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_t1_a_field_ra_1_poweroftwo_0_fb101000() {
    // Thumb encoding (32): 0xFB101000
    // Test aarch32_SMLABB_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, Ra=1, Rm=0, N=0, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB101000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_t1_a_field_rd_0_min_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Ra=0, Rm=0, N=0, Rd=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_t1_a_field_rd_1_poweroftwo_0_fb100100() {
    // Thumb encoding (32): 0xFB100100
    // Test aarch32_SMLABB_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Rn=0, Ra=0, M=0, Rm=0, Rd=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlabb_t1_a_field_n_0_min_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field N = 0 (Min)
    // ISET: T32
    // Fields: M=0, Rm=0, N=0, Rd=0, Rn=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field N 5 +: 1`
/// Requirement: FieldBoundary { field: "N", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlabb_t1_a_field_n_1_max_0_fb100020() {
    // Thumb encoding (32): 0xFB100020
    // Test aarch32_SMLABB_T1_A field N = 1 (Max)
    // ISET: T32
    // Fields: Ra=0, Rm=0, N=1, M=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smlabb_t1_a_field_m_0_min_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field M = 0 (Min)
    // ISET: T32
    // Fields: Rd=0, Rm=0, Rn=0, Ra=0, N=0, M=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field M 4 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smlabb_t1_a_field_m_1_max_0_fb100010() {
    // Thumb encoding (32): 0xFB100010
    // Test aarch32_SMLABB_T1_A field M = 1 (Max)
    // ISET: T32
    // Fields: Rn=0, M=1, N=0, Ra=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smlabb_t1_a_field_rm_0_min_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, Rd=0, N=0, M=0, Rm=0, Ra=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smlabb_t1_a_field_rm_1_poweroftwo_0_fb100001() {
    // Thumb encoding (32): 0xFB100001
    // Test aarch32_SMLABB_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: N=0, Rm=1, Ra=0, Rn=0, M=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smlabb_t1_a_combo_0_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A field combination: Rn=0, Ra=0, Rd=0, N=0, M=0, Rm=0
    // ISET: T32
    // Fields: Rn=0, N=0, Ra=0, Rd=0, M=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlabb_t1_a_invalid_0_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Ra=0, Rn=0, M=0, N=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smlabb_t1_a_invalid_1_0_fb100000() {
    // Thumb encoding (32): 0xFB100000
    // Test aarch32_SMLABB_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: M=0, Rn=0, Rm=0, Ra=0, Rd=0, N=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB100000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// simple division (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_0_1ac20820() {
    // Test UDIV 32-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "W0 should be 0x0000000A");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// simple division (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_0_9ac20820() {
    // Test UDIV 64-bit: simple division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "X0 should be 0x000000000000000A");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// division with remainder (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_1_1ac20820() {
    // Test UDIV 32-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "W0 should be 0x00000021");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// division with remainder (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_1_9ac20820() {
    // Test UDIV 64-bit: division with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x3);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "X0 should be 0x0000000000000021");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_2_1ac20820() {
    // Test UDIV 32-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// zero dividend (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_2_9ac20820() {
    // Test UDIV 64-bit: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xA);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero - result is 0 (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_3_1ac20820() {
    // Test UDIV 32-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0xA);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// divide by zero - result is 0 (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_3_9ac20820() {
    // Test UDIV 64-bit: divide by zero - result is 0 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x0000000000000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// max value / 2 (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_4_1ac20820() {
    // Test UDIV 32-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x7FFFFFFF, "W0 should be 0x7FFFFFFF");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// max value / 2 (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_4_9ac20820() {
    // Test UDIV 64-bit: max value / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(
        get_w(&cpu, 0),
        0xFFFFFFFF,
        "X0 should be 0x7FFFFFFFFFFFFFFF"
    );
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// MSB set / 2 (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_5_1ac20820() {
    // Test UDIV 32-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "W0 should be 0x00000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// MSB set / 2 (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_5_9ac20820() {
    // Test UDIV 64-bit: MSB set / 2 (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x2);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "X0 should be 0x4000000000000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// self-division (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_6_1ac20820() {
    // Test UDIV 32-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x7);
    set_w(&mut cpu, 1, 0x7);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// self-division (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_6_9ac20820() {
    // Test UDIV 64-bit: self-division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x7);
    set_w(&mut cpu, 2, 0x7);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// one / one (32)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_32_7_1ac20820() {
    // Test UDIV 32-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x1AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "W0 should be 0x00000001");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV X0, X1, X2`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "Rd" }
/// one / one (64)
#[test]
fn test_aarch32_smlabb_t1_a_udiv_oracle_64_7_9ac20820() {
    // Test UDIV 64-bit: one / one (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x1);
    set_w(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x9AC20820;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x1, "X0 should be 0x0000000000000001");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// exact division
#[test]
fn test_aarch32_smlabb_t1_a_t32_oracle_0_fb110002() {
    // Test T32 UDIV: exact division (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xFB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0xA, "R0 should be 0x0000000A");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// with remainder
#[test]
fn test_aarch32_smlabb_t1_a_t32_oracle_1_fb110002() {
    // Test T32 UDIV: with remainder (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x3);
    let encoding: u32 = 0xFB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x21, "R0 should be 0x00000021");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// zero dividend
#[test]
fn test_aarch32_smlabb_t1_a_t32_oracle_2_fb110002() {
    // Test T32 UDIV: zero dividend (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xA);
    let encoding: u32 = 0xFB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

/// Provenance: aarch32_SMLABB_T1_A
/// ASL: `UDIV R0, R1, R2`
/// Requirement: RegisterWrite { reg_type: Gp32, dest_field: "Rd" }
/// divide by zero
#[test]
fn test_aarch32_smlabb_t1_a_t32_oracle_3_fb110002() {
    // Test T32 UDIV: divide by zero (oracle)
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xA);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0xFB110002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_w(&cpu, 0), 0x0, "R0 should be 0x00000000");
}

// ============================================================================
// aarch32_UMULL_A Tests
// ============================================================================

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_umull_a1_a_field_cond_0_min_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: cond=0, RdHi=0, Rn=0, S=0, RdLo=0, Rm=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_umull_a1_a_field_cond_1_poweroftwo_90_10800090() {
    // Encoding: 0x10800090
    // Test aarch32_UMULL_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, RdHi=0, cond=1, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0x10800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_umull_a1_a_field_cond_2_poweroftwo_90_20800090() {
    // Encoding: 0x20800090
    // Test aarch32_UMULL_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=2, RdLo=0, S=0, RdHi=0
    let encoding: u32 = 0x20800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_umull_a1_a_field_cond_3_poweroftwo_90_30800090() {
    // Encoding: 0x30800090
    // Test aarch32_UMULL_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=3, S=0, RdLo=0, Rm=0, RdHi=0, Rn=0
    let encoding: u32 = 0x30800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_umull_a1_a_field_cond_4_poweroftwo_90_40800090() {
    // Encoding: 0x40800090
    // Test aarch32_UMULL_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=4, Rn=0, RdHi=0, RdLo=0, S=0, Rm=0
    let encoding: u32 = 0x40800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_umull_a1_a_field_cond_5_poweroftwo_90_50800090() {
    // Encoding: 0x50800090
    // Test aarch32_UMULL_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, Rn=0, RdLo=0, cond=5, S=0
    let encoding: u32 = 0x50800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_umull_a1_a_field_cond_6_poweroftwo_90_60800090() {
    // Encoding: 0x60800090
    // Test aarch32_UMULL_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=0, cond=6, Rm=0, S=0, RdLo=0, Rn=0
    let encoding: u32 = 0x60800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_umull_a1_a_field_cond_7_poweroftwo_90_70800090() {
    // Encoding: 0x70800090
    // Test aarch32_UMULL_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, Rm=0, RdHi=0, S=0, RdLo=0, cond=7
    let encoding: u32 = 0x70800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_umull_a1_a_field_cond_8_poweroftwo_90_80800090() {
    // Encoding: 0x80800090
    // Test aarch32_UMULL_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, cond=8, RdHi=0, RdLo=0
    let encoding: u32 = 0x80800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_umull_a1_a_field_cond_9_poweroftwo_90_90800090() {
    // Encoding: 0x90800090
    // Test aarch32_UMULL_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=9, RdLo=0, S=0, RdHi=0, Rm=0
    let encoding: u32 = 0x90800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_umull_a1_a_field_cond_10_poweroftwo_90_a0800090() {
    // Encoding: 0xA0800090
    // Test aarch32_UMULL_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=10, RdHi=0, Rn=0, RdLo=0, S=0
    let encoding: u32 = 0xA0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_umull_a1_a_field_cond_11_poweroftwo_90_b0800090() {
    // Encoding: 0xB0800090
    // Test aarch32_UMULL_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=11, Rm=0, RdLo=0, RdHi=0, S=0
    let encoding: u32 = 0xB0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_umull_a1_a_field_cond_12_poweroftwo_90_c0800090() {
    // Encoding: 0xC0800090
    // Test aarch32_UMULL_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rm=0, RdLo=0, Rn=0, RdHi=0, S=0
    let encoding: u32 = 0xC0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_umull_a1_a_field_cond_13_poweroftwo_90_d0800090() {
    // Encoding: 0xD0800090
    // Test aarch32_UMULL_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=13, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    let encoding: u32 = 0xD0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_umull_a1_a_field_cond_14_poweroftwo_90_e0800090() {
    // Encoding: 0xE0800090
    // Test aarch32_UMULL_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=14, S=0, Rm=0, RdLo=0, RdHi=0, Rn=0
    let encoding: u32 = 0xE0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_umull_a1_a_field_cond_15_max_90_f0800090() {
    // Encoding: 0xF0800090
    // Test aarch32_UMULL_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rn=0, S=0, RdLo=0, cond=15, RdHi=0, Rm=0
    let encoding: u32 = 0xF0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_aarch32_umull_a1_a_field_s_0_min_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field S = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, S=0, Rn=0, RdHi=0, Rm=0, cond=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field S 20 +: 1`
/// Requirement: FieldBoundary { field: "S", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_aarch32_umull_a1_a_field_s_1_max_90_00900090() {
    // Encoding: 0x00900090
    // Test aarch32_UMULL_A1_A field S = 1 (Max)
    // ISET: A32
    // Fields: Rm=0, Rn=0, RdLo=0, cond=0, RdHi=0, S=1
    let encoding: u32 = 0x00900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umull_a1_a_field_rdhi_0_min_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field RdHi = 0 (Min)
    // ISET: A32
    // Fields: cond=0, RdLo=0, Rm=0, Rn=0, RdHi=0, S=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umull_a1_a_field_rdhi_1_poweroftwo_90_00810090() {
    // Encoding: 0x00810090
    // Test aarch32_UMULL_A1_A field RdHi = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdHi=1, Rm=0, Rn=0, RdLo=0, cond=0, S=0
    let encoding: u32 = 0x00810090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umull_a1_a_field_rdhi_7_poweroftwominusone_90_00870090() {
    // Encoding: 0x00870090
    // Test aarch32_UMULL_A1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: S=0, Rn=0, RdLo=0, Rm=0, cond=0, RdHi=7
    let encoding: u32 = 0x00870090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdHi 16 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umull_a1_a_field_rdhi_15_max_90_008f0090() {
    // Encoding: 0x008F0090
    // Test aarch32_UMULL_A1_A field RdHi = 15 (Max)
    // ISET: A32
    // Fields: cond=0, RdHi=15, RdLo=0, Rn=0, S=0, Rm=0
    let encoding: u32 = 0x008F0090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umull_a1_a_field_rdlo_0_min_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field RdLo = 0 (Min)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, Rn=0, S=0, cond=0, RdHi=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umull_a1_a_field_rdlo_1_poweroftwo_90_00801090() {
    // Encoding: 0x00801090
    // Test aarch32_UMULL_A1_A field RdLo = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=1, Rm=0, Rn=0, RdHi=0, cond=0, S=0
    let encoding: u32 = 0x00801090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umull_a1_a_field_rdlo_7_poweroftwominusone_90_00807090() {
    // Encoding: 0x00807090
    // Test aarch32_UMULL_A1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, S=0, RdLo=7, cond=0, Rm=0
    let encoding: u32 = 0x00807090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umull_a1_a_field_rdlo_15_max_90_0080f090() {
    // Encoding: 0x0080F090
    // Test aarch32_UMULL_A1_A field RdLo = 15 (Max)
    // ISET: A32
    // Fields: S=0, RdHi=0, cond=0, RdLo=15, Rm=0, Rn=0
    let encoding: u32 = 0x0080F090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umull_a1_a_field_rm_0_min_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, S=0, Rn=0, cond=0, RdLo=0, RdHi=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umull_a1_a_field_rm_1_poweroftwo_90_00800190() {
    // Encoding: 0x00800190
    // Test aarch32_UMULL_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: RdLo=0, cond=0, S=0, RdHi=0, Rn=0, Rm=1
    let encoding: u32 = 0x00800190;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umull_a1_a_field_rn_0_min_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: cond=0, RdLo=0, Rm=0, S=0, Rn=0, RdHi=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umull_a1_a_field_rn_1_poweroftwo_90_00800091() {
    // Encoding: 0x00800091
    // Test aarch32_UMULL_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, RdLo=0, Rm=0, RdHi=0, S=0, Rn=1
    let encoding: u32 = 0x00800091;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_umull_a1_a_combo_0_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A field combination: cond=0, S=0, RdHi=0, RdLo=0, Rm=0, Rn=0
    // ISET: A32
    // Fields: S=0, Rn=0, cond=0, RdHi=0, RdLo=0, Rm=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_umull_a1_a_special_cond_0_condition_eq_144_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: cond=0, Rm=0, RdLo=0, S=0, RdHi=0, Rn=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_umull_a1_a_special_cond_1_condition_ne_144_10800090() {
    // Encoding: 0x10800090
    // Test aarch32_UMULL_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: cond=1, S=0, Rm=0, RdLo=0, RdHi=0, Rn=0
    let encoding: u32 = 0x10800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_umull_a1_a_special_cond_2_condition_cs_hs_144_20800090() {
    // Encoding: 0x20800090
    // Test aarch32_UMULL_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, RdHi=0, S=0, Rn=0, cond=2
    let encoding: u32 = 0x20800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_umull_a1_a_special_cond_3_condition_cc_lo_144_30800090() {
    // Encoding: 0x30800090
    // Test aarch32_UMULL_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: RdHi=0, Rm=0, cond=3, Rn=0, RdLo=0, S=0
    let encoding: u32 = 0x30800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_umull_a1_a_special_cond_4_condition_mi_144_40800090() {
    // Encoding: 0x40800090
    // Test aarch32_UMULL_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: Rn=0, cond=4, RdHi=0, RdLo=0, S=0, Rm=0
    let encoding: u32 = 0x40800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_umull_a1_a_special_cond_5_condition_pl_144_50800090() {
    // Encoding: 0x50800090
    // Test aarch32_UMULL_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: RdLo=0, Rn=0, cond=5, RdHi=0, S=0, Rm=0
    let encoding: u32 = 0x50800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_umull_a1_a_special_cond_6_condition_vs_144_60800090() {
    // Encoding: 0x60800090
    // Test aarch32_UMULL_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: S=0, Rm=0, Rn=0, RdLo=0, RdHi=0, cond=6
    let encoding: u32 = 0x60800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_umull_a1_a_special_cond_7_condition_vc_144_70800090() {
    // Encoding: 0x70800090
    // Test aarch32_UMULL_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rn=0, RdHi=0, RdLo=0, Rm=0, S=0, cond=7
    let encoding: u32 = 0x70800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_umull_a1_a_special_cond_8_condition_hi_144_80800090() {
    // Encoding: 0x80800090
    // Test aarch32_UMULL_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: S=0, RdHi=0, Rm=0, cond=8, Rn=0, RdLo=0
    let encoding: u32 = 0x80800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_umull_a1_a_special_cond_9_condition_ls_144_90800090() {
    // Encoding: 0x90800090
    // Test aarch32_UMULL_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rm=0, RdHi=0, cond=9, S=0, RdLo=0, Rn=0
    let encoding: u32 = 0x90800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_umull_a1_a_special_cond_10_condition_ge_144_a0800090() {
    // Encoding: 0xA0800090
    // Test aarch32_UMULL_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: RdLo=0, RdHi=0, Rm=0, cond=10, S=0, Rn=0
    let encoding: u32 = 0xA0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_umull_a1_a_special_cond_11_condition_lt_144_b0800090() {
    // Encoding: 0xB0800090
    // Test aarch32_UMULL_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: S=0, RdHi=0, cond=11, RdLo=0, Rn=0, Rm=0
    let encoding: u32 = 0xB0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_umull_a1_a_special_cond_12_condition_gt_144_c0800090() {
    // Encoding: 0xC0800090
    // Test aarch32_UMULL_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: S=0, Rn=0, RdHi=0, cond=12, RdLo=0, Rm=0
    let encoding: u32 = 0xC0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_umull_a1_a_special_cond_13_condition_le_144_d0800090() {
    // Encoding: 0xD0800090
    // Test aarch32_UMULL_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: Rn=0, S=0, cond=13, RdLo=0, Rm=0, RdHi=0
    let encoding: u32 = 0xD0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_umull_a1_a_special_cond_14_condition_al_144_e0800090() {
    // Encoding: 0xE0800090
    // Test aarch32_UMULL_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: S=0, Rn=0, RdLo=0, Rm=0, RdHi=0, cond=14
    let encoding: u32 = 0xE0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_umull_a1_a_special_cond_15_condition_nv_144_f0800090() {
    // Encoding: 0xF0800090
    // Test aarch32_UMULL_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: RdHi=0, cond=15, Rm=0, Rn=0, S=0, RdLo=0
    let encoding: u32 = 0xF0800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field S = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "S", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_aarch32_umull_a1_a_special_s_0_size_variant_0_144_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A special value S = 0 (Size variant 0)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, cond=0, RdHi=0, Rn=0, S=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `field S = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "S", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_aarch32_umull_a1_a_special_s_1_size_variant_1_144_00900090() {
    // Encoding: 0x00900090
    // Test aarch32_UMULL_A1_A special value S = 1 (Size variant 1)
    // ISET: A32
    // Fields: RdLo=0, Rm=0, Rn=0, cond=0, S=1, RdHi=0
    let encoding: u32 = 0x00900090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_a1_a_invalid_0_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: RdHi=0, cond=0, Rn=0, S=0, Rm=0, RdLo=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_a1_a_invalid_1_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Rn=0, RdHi=0, S=0, Rm=0, RdLo=0, cond=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_a1_a_invalid_2_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: A32
    // Fields: cond=0, S=0, RdLo=0, RdHi=0, Rm=0, Rn=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_a1_a_invalid_3_90_00800090() {
    // Encoding: 0x00800090
    // Test aarch32_UMULL_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: cond=0, S=0, RdHi=0, Rm=0, Rn=0, RdLo=0
    let encoding: u32 = 0x00800090;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umull_t1_a_field_rn_0_min_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: RdHi=0, Rn=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umull_t1_a_field_rn_1_poweroftwo_0_fba10000() {
    // Thumb encoding (32): 0xFBA10000
    // Test aarch32_UMULL_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: RdHi=0, Rm=0, RdLo=0, Rn=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA10000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umull_t1_a_field_rdlo_0_min_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A field RdLo = 0 (Min)
    // ISET: T32
    // Fields: RdHi=0, Rm=0, Rn=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umull_t1_a_field_rdlo_1_poweroftwo_0_fba01000() {
    // Thumb encoding (32): 0xFBA01000
    // Test aarch32_UMULL_T1_A field RdLo = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, RdLo=1, RdHi=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA01000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umull_t1_a_field_rdlo_7_poweroftwominusone_0_fba07000() {
    // Thumb encoding (32): 0xFBA07000
    // Test aarch32_UMULL_T1_A field RdLo = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdLo=7, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA07000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdLo 12 +: 4`
/// Requirement: FieldBoundary { field: "RdLo", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umull_t1_a_field_rdlo_15_max_0_fba0f000() {
    // Thumb encoding (32): 0xFBA0F000
    // Test aarch32_UMULL_T1_A field RdLo = 15 (Max)
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdLo=15, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_umull_t1_a_field_rdhi_0_min_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A field RdHi = 0 (Min)
    // ISET: T32
    // Fields: Rn=0, RdHi=0, Rm=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_aarch32_umull_t1_a_field_rdhi_1_poweroftwo_0_fba00100() {
    // Thumb encoding (32): 0xFBA00100
    // Test aarch32_UMULL_T1_A field RdHi = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rn=0, RdHi=1, Rm=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_aarch32_umull_t1_a_field_rdhi_7_poweroftwominusone_0_fba00700() {
    // Thumb encoding (32): 0xFBA00700
    // Test aarch32_UMULL_T1_A field RdHi = 7 (PowerOfTwoMinusOne)
    // ISET: T32
    // Fields: Rm=0, RdHi=7, Rn=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00700;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field RdHi 8 +: 4`
/// Requirement: FieldBoundary { field: "RdHi", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_aarch32_umull_t1_a_field_rdhi_15_max_0_fba00f00() {
    // Thumb encoding (32): 0xFBA00F00
    // Test aarch32_UMULL_T1_A field RdHi = 15 (Max)
    // ISET: T32
    // Fields: RdHi=15, RdLo=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00F00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_umull_t1_a_field_rm_0_min_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, RdLo=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_umull_t1_a_field_rm_1_poweroftwo_0_fba00001() {
    // Thumb encoding (32): 0xFBA00001
    // Test aarch32_UMULL_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=1, RdLo=0, Rn=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_umull_t1_a_combo_0_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A field combination: Rn=0, RdLo=0, RdHi=0, Rm=0
    // ISET: T32
    // Fields: RdLo=0, RdHi=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_t1_a_invalid_0_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: RdLo=0, Rn=0, Rm=0, RdHi=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_t1_a_invalid_1_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, RdHi=0, RdLo=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dHi\" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"dLo\" }) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_t1_a_invalid_2_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "dHi" }), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "dLo" }) }
    // ISET: T32
    // Fields: RdHi=0, Rm=0, RdLo=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_umull_t1_a_invalid_3_0_fba00000() {
    // Thumb encoding (32): 0xFBA00000
    // Test aarch32_UMULL_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rn=0, Rm=0, RdHi=0, RdLo=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFBA00000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_umull_a1_a_flags_zeroresult_0_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: ZeroResult
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_umull_a1_a_flags_zeroresult_1_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: ZeroResult
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_umull_a1_a_flags_negativeresult_2_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: NegativeResult
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_umull_a1_a_flags_unsignedoverflow_3_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_umull_a1_a_flags_unsignedoverflow_4_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: UnsignedOverflow
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_umull_a1_a_flags_signedoverflow_5_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_umull_a1_a_flags_signedoverflow_6_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: SignedOverflow
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x0);
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_A1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_umull_a1_a_flags_positiveresult_7_00900291() {
    // Test aarch32_UMULL_A1_A flag computation: PositiveResult
    // Encoding: 0x00900291
    // ISET: A32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x32);
    set_w(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x00900291;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_aarch32_umull_t1_a_flags_zeroresult_0_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_aarch32_umull_t1_a_flags_zeroresult_1_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: ZeroResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x1);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_aarch32_umull_t1_a_flags_negativeresult_2_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: NegativeResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x0);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_aarch32_umull_t1_a_flags_unsignedoverflow_3_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_aarch32_umull_t1_a_flags_unsignedoverflow_4_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: UnsignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    set_w(&mut cpu, 2, 0x2);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_aarch32_umull_t1_a_flags_signedoverflow_5_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0x1);
    set_w(&mut cpu, 1, 0xFFFFFFFF);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_aarch32_umull_t1_a_flags_signedoverflow_6_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: SignedOverflow
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 2, 0xFFFFFFFF);
    set_w(&mut cpu, 1, 0x0);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

/// Provenance: aarch32_UMULL_T1_A
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_aarch32_umull_t1_a_flags_positiveresult_7_fba10002() {
    // Test aarch32_UMULL_T1_A flag computation: PositiveResult
    // ISET: T32
    let mut cpu = create_test_cpu();
    set_w(&mut cpu, 1, 0x64);
    set_w(&mut cpu, 2, 0x32);
    let encoding: u32 = 0xFBA10002;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
}

// ============================================================================
// aarch32_SMMLA_A Tests
// ============================================================================

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 0, boundary: Min }
/// condition EQ (equal)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_0_min_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field cond = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, Rm=0, cond=0, Rn=0, R=0, Rd=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 1, boundary: PowerOfTwo }
/// condition NE (not equal)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_1_poweroftwo_10_17500010() {
    // Encoding: 0x17500010
    // Test aarch32_SMMLA_A1_A field cond = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, Rm=0, R=0, cond=1, Rn=0, Rd=0
    let encoding: u32 = 0x17500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 2, boundary: PowerOfTwo }
/// condition CS/HS (carry set)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_2_poweroftwo_10_27500010() {
    // Encoding: 0x27500010
    // Test aarch32_SMMLA_A1_A field cond = 2 (PowerOfTwo)
    // ISET: A32
    // Fields: Ra=0, cond=2, Rd=0, Rm=0, R=0, Rn=0
    let encoding: u32 = 0x27500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 3, boundary: PowerOfTwo }
/// condition CC/LO (carry clear)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_3_poweroftwo_10_37500010() {
    // Encoding: 0x37500010
    // Test aarch32_SMMLA_A1_A field cond = 3 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Ra=0, Rn=0, cond=3, Rd=0, Rm=0
    let encoding: u32 = 0x37500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 4, boundary: PowerOfTwo }
/// condition MI (minus/negative)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_4_poweroftwo_10_47500010() {
    // Encoding: 0x47500010
    // Test aarch32_SMMLA_A1_A field cond = 4 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=4, Rn=0, Ra=0, Rd=0, Rm=0
    let encoding: u32 = 0x47500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 5, boundary: PowerOfTwo }
/// condition PL (plus/positive)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_5_poweroftwo_10_57500010() {
    // Encoding: 0x57500010
    // Test aarch32_SMMLA_A1_A field cond = 5 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rd=0, cond=5, Ra=0, Rn=0, Rm=0
    let encoding: u32 = 0x57500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 6, boundary: PowerOfTwo }
/// condition VS (overflow set)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_6_poweroftwo_10_67500010() {
    // Encoding: 0x67500010
    // Test aarch32_SMMLA_A1_A field cond = 6 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=6, Ra=0, Rd=0, Rm=0, R=0
    let encoding: u32 = 0x67500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 7, boundary: PowerOfTwo }
/// condition VC (overflow clear)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_7_poweroftwo_10_77500010() {
    // Encoding: 0x77500010
    // Test aarch32_SMMLA_A1_A field cond = 7 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, R=0, cond=7, Rd=0, Ra=0
    let encoding: u32 = 0x77500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 8, boundary: PowerOfTwo }
/// condition HI (unsigned higher)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_8_poweroftwo_10_87500010() {
    // Encoding: 0x87500010
    // Test aarch32_SMMLA_A1_A field cond = 8 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=8, Rd=0, Rm=0, Ra=0, R=0, Rn=0
    let encoding: u32 = 0x87500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 9, boundary: PowerOfTwo }
/// condition LS (unsigned lower or same)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_9_poweroftwo_10_97500010() {
    // Encoding: 0x97500010
    // Test aarch32_SMMLA_A1_A field cond = 9 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, Rn=0, Rd=0, cond=9, Ra=0, Rm=0
    let encoding: u32 = 0x97500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 10, boundary: PowerOfTwo }
/// condition GE (signed >=)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_10_poweroftwo_10_a7500010() {
    // Encoding: 0xA7500010
    // Test aarch32_SMMLA_A1_A field cond = 10 (PowerOfTwo)
    // ISET: A32
    // Fields: R=0, cond=10, Ra=0, Rm=0, Rn=0, Rd=0
    let encoding: u32 = 0xA7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 11, boundary: PowerOfTwo }
/// condition LT (signed <)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_11_poweroftwo_10_b7500010() {
    // Encoding: 0xB7500010
    // Test aarch32_SMMLA_A1_A field cond = 11 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=11, Ra=0, Rm=0, Rd=0, R=0, Rn=0
    let encoding: u32 = 0xB7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 12, boundary: PowerOfTwo }
/// condition GT (signed >)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_12_poweroftwo_10_c7500010() {
    // Encoding: 0xC7500010
    // Test aarch32_SMMLA_A1_A field cond = 12 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=12, Rm=0, Rd=0, Rn=0, Ra=0, R=0
    let encoding: u32 = 0xC7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 13, boundary: PowerOfTwo }
/// condition LE (signed <=)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_13_poweroftwo_10_d7500010() {
    // Encoding: 0xD7500010
    // Test aarch32_SMMLA_A1_A field cond = 13 (PowerOfTwo)
    // ISET: A32
    // Fields: Rn=0, cond=13, Ra=0, R=0, Rm=0, Rd=0
    let encoding: u32 = 0xD7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 14, boundary: PowerOfTwo }
/// condition AL (always)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_14_poweroftwo_10_e7500010() {
    // Encoding: 0xE7500010
    // Test aarch32_SMMLA_A1_A field cond = 14 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, Rn=0, Rd=0, Ra=0, cond=14, R=0
    let encoding: u32 = 0xE7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond 28 +: 4`
/// Requirement: FieldBoundary { field: "cond", value: 15, boundary: Max }
/// condition NV (never, reserved)
#[test]
fn test_aarch32_smmla_a1_a_field_cond_15_max_10_f7500010() {
    // Encoding: 0xF7500010
    // Test aarch32_SMMLA_A1_A field cond = 15 (Max)
    // ISET: A32
    // Fields: Rd=0, R=0, Ra=0, cond=15, Rm=0, Rn=0
    let encoding: u32 = 0xF7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_a1_a_field_rd_0_min_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field Rd = 0 (Min)
    // ISET: A32
    // Fields: Rm=0, Ra=0, Rn=0, R=0, Rd=0, cond=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Rd 16 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_a1_a_field_rd_1_poweroftwo_10_07510010() {
    // Encoding: 0x07510010
    // Test aarch32_SMMLA_A1_A field Rd = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rd=1, Rm=0, Rn=0, cond=0, Ra=0, R=0
    let encoding: u32 = 0x07510010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_a1_a_field_ra_0_min_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field Ra = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, R=0, Rd=0, cond=0, Rm=0, Rn=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_a1_a_field_ra_1_poweroftwo_10_07501010() {
    // Encoding: 0x07501010
    // Test aarch32_SMMLA_A1_A field Ra = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Rm=0, R=0, Rn=0, Ra=1, Rd=0
    let encoding: u32 = 0x07501010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_a1_a_field_rm_0_min_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field Rm = 0 (Min)
    // ISET: A32
    // Fields: cond=0, R=0, Rn=0, Rm=0, Ra=0, Rd=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Rm 8 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_a1_a_field_rm_1_poweroftwo_10_07500110() {
    // Encoding: 0x07500110
    // Test aarch32_SMMLA_A1_A field Rm = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: cond=0, Ra=0, R=0, Rm=1, Rd=0, Rn=0
    let encoding: u32 = 0x07500110;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field R 5 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smmla_a1_a_field_r_0_min_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field R = 0 (Min)
    // ISET: A32
    // Fields: Rd=0, Ra=0, Rm=0, Rn=0, cond=0, R=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field R 5 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smmla_a1_a_field_r_1_max_10_07500030() {
    // Encoding: 0x07500030
    // Test aarch32_SMMLA_A1_A field R = 1 (Max)
    // ISET: A32
    // Fields: Rn=0, Rm=0, cond=0, Ra=0, R=1, Rd=0
    let encoding: u32 = 0x07500030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_a1_a_field_rn_0_min_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field Rn = 0 (Min)
    // ISET: A32
    // Fields: Ra=0, Rd=0, Rn=0, Rm=0, R=0, cond=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field Rn 0 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_a1_a_field_rn_1_poweroftwo_10_07500011() {
    // Encoding: 0x07500011
    // Test aarch32_SMMLA_A1_A field Rn = 1 (PowerOfTwo)
    // ISET: A32
    // Fields: Rm=0, cond=0, R=0, Rn=1, Rd=0, Ra=0
    let encoding: u32 = 0x07500011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// cond=0 (condition EQ (equal))
#[test]
fn test_aarch32_smmla_a1_a_combo_0_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A field combination: cond=0, Rd=0, Ra=0, Rm=0, R=0, Rn=0
    // ISET: A32
    // Fields: Ra=0, R=0, cond=0, Rd=0, Rm=0, Rn=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 0 (Condition EQ)`
/// Requirement: FieldSpecial { field: "cond", value: 0, meaning: "Condition EQ" }
/// Condition EQ
#[test]
fn test_aarch32_smmla_a1_a_special_cond_0_condition_eq_16_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A special value cond = 0 (Condition EQ)
    // ISET: A32
    // Fields: Ra=0, R=0, Rn=0, Rd=0, cond=0, Rm=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 1 (Condition NE)`
/// Requirement: FieldSpecial { field: "cond", value: 1, meaning: "Condition NE" }
/// Condition NE
#[test]
fn test_aarch32_smmla_a1_a_special_cond_1_condition_ne_16_17500010() {
    // Encoding: 0x17500010
    // Test aarch32_SMMLA_A1_A special value cond = 1 (Condition NE)
    // ISET: A32
    // Fields: Rd=0, Ra=0, cond=1, Rn=0, Rm=0, R=0
    let encoding: u32 = 0x17500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 2 (Condition CS/HS)`
/// Requirement: FieldSpecial { field: "cond", value: 2, meaning: "Condition CS/HS" }
/// Condition CS/HS
#[test]
fn test_aarch32_smmla_a1_a_special_cond_2_condition_cs_hs_16_27500010() {
    // Encoding: 0x27500010
    // Test aarch32_SMMLA_A1_A special value cond = 2 (Condition CS/HS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, R=0, Ra=0, cond=2
    let encoding: u32 = 0x27500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 3 (Condition CC/LO)`
/// Requirement: FieldSpecial { field: "cond", value: 3, meaning: "Condition CC/LO" }
/// Condition CC/LO
#[test]
fn test_aarch32_smmla_a1_a_special_cond_3_condition_cc_lo_16_37500010() {
    // Encoding: 0x37500010
    // Test aarch32_SMMLA_A1_A special value cond = 3 (Condition CC/LO)
    // ISET: A32
    // Fields: Rm=0, R=0, Rn=0, cond=3, Rd=0, Ra=0
    let encoding: u32 = 0x37500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 4 (Condition MI)`
/// Requirement: FieldSpecial { field: "cond", value: 4, meaning: "Condition MI" }
/// Condition MI
#[test]
fn test_aarch32_smmla_a1_a_special_cond_4_condition_mi_16_47500010() {
    // Encoding: 0x47500010
    // Test aarch32_SMMLA_A1_A special value cond = 4 (Condition MI)
    // ISET: A32
    // Fields: R=0, cond=4, Ra=0, Rn=0, Rd=0, Rm=0
    let encoding: u32 = 0x47500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 5 (Condition PL)`
/// Requirement: FieldSpecial { field: "cond", value: 5, meaning: "Condition PL" }
/// Condition PL
#[test]
fn test_aarch32_smmla_a1_a_special_cond_5_condition_pl_16_57500010() {
    // Encoding: 0x57500010
    // Test aarch32_SMMLA_A1_A special value cond = 5 (Condition PL)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, Ra=0, cond=5, R=0
    let encoding: u32 = 0x57500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 6 (Condition VS)`
/// Requirement: FieldSpecial { field: "cond", value: 6, meaning: "Condition VS" }
/// Condition VS
#[test]
fn test_aarch32_smmla_a1_a_special_cond_6_condition_vs_16_67500010() {
    // Encoding: 0x67500010
    // Test aarch32_SMMLA_A1_A special value cond = 6 (Condition VS)
    // ISET: A32
    // Fields: Rn=0, Rm=0, R=0, Rd=0, cond=6, Ra=0
    let encoding: u32 = 0x67500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 7 (Condition VC)`
/// Requirement: FieldSpecial { field: "cond", value: 7, meaning: "Condition VC" }
/// Condition VC
#[test]
fn test_aarch32_smmla_a1_a_special_cond_7_condition_vc_16_77500010() {
    // Encoding: 0x77500010
    // Test aarch32_SMMLA_A1_A special value cond = 7 (Condition VC)
    // ISET: A32
    // Fields: Rd=0, Ra=0, R=0, cond=7, Rm=0, Rn=0
    let encoding: u32 = 0x77500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 8 (Condition HI)`
/// Requirement: FieldSpecial { field: "cond", value: 8, meaning: "Condition HI" }
/// Condition HI
#[test]
fn test_aarch32_smmla_a1_a_special_cond_8_condition_hi_16_87500010() {
    // Encoding: 0x87500010
    // Test aarch32_SMMLA_A1_A special value cond = 8 (Condition HI)
    // ISET: A32
    // Fields: Rd=0, Rn=0, Rm=0, cond=8, R=0, Ra=0
    let encoding: u32 = 0x87500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 9 (Condition LS)`
/// Requirement: FieldSpecial { field: "cond", value: 9, meaning: "Condition LS" }
/// Condition LS
#[test]
fn test_aarch32_smmla_a1_a_special_cond_9_condition_ls_16_97500010() {
    // Encoding: 0x97500010
    // Test aarch32_SMMLA_A1_A special value cond = 9 (Condition LS)
    // ISET: A32
    // Fields: Rn=0, Rd=0, Rm=0, Ra=0, cond=9, R=0
    let encoding: u32 = 0x97500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 10 (Condition GE)`
/// Requirement: FieldSpecial { field: "cond", value: 10, meaning: "Condition GE" }
/// Condition GE
#[test]
fn test_aarch32_smmla_a1_a_special_cond_10_condition_ge_16_a7500010() {
    // Encoding: 0xA7500010
    // Test aarch32_SMMLA_A1_A special value cond = 10 (Condition GE)
    // ISET: A32
    // Fields: cond=10, Rd=0, Rm=0, Ra=0, R=0, Rn=0
    let encoding: u32 = 0xA7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 11 (Condition LT)`
/// Requirement: FieldSpecial { field: "cond", value: 11, meaning: "Condition LT" }
/// Condition LT
#[test]
fn test_aarch32_smmla_a1_a_special_cond_11_condition_lt_16_b7500010() {
    // Encoding: 0xB7500010
    // Test aarch32_SMMLA_A1_A special value cond = 11 (Condition LT)
    // ISET: A32
    // Fields: Ra=0, cond=11, Rm=0, Rn=0, Rd=0, R=0
    let encoding: u32 = 0xB7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 12 (Condition GT)`
/// Requirement: FieldSpecial { field: "cond", value: 12, meaning: "Condition GT" }
/// Condition GT
#[test]
fn test_aarch32_smmla_a1_a_special_cond_12_condition_gt_16_c7500010() {
    // Encoding: 0xC7500010
    // Test aarch32_SMMLA_A1_A special value cond = 12 (Condition GT)
    // ISET: A32
    // Fields: cond=12, Rd=0, Rm=0, Rn=0, R=0, Ra=0
    let encoding: u32 = 0xC7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 13 (Condition LE)`
/// Requirement: FieldSpecial { field: "cond", value: 13, meaning: "Condition LE" }
/// Condition LE
#[test]
fn test_aarch32_smmla_a1_a_special_cond_13_condition_le_16_d7500010() {
    // Encoding: 0xD7500010
    // Test aarch32_SMMLA_A1_A special value cond = 13 (Condition LE)
    // ISET: A32
    // Fields: R=0, Rn=0, cond=13, Rd=0, Ra=0, Rm=0
    let encoding: u32 = 0xD7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 14 (Condition AL)`
/// Requirement: FieldSpecial { field: "cond", value: 14, meaning: "Condition AL" }
/// Condition AL
#[test]
fn test_aarch32_smmla_a1_a_special_cond_14_condition_al_16_e7500010() {
    // Encoding: 0xE7500010
    // Test aarch32_SMMLA_A1_A special value cond = 14 (Condition AL)
    // ISET: A32
    // Fields: R=0, Ra=0, Rd=0, Rm=0, Rn=0, cond=14
    let encoding: u32 = 0xE7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `field cond = 15 (Condition NV)`
/// Requirement: FieldSpecial { field: "cond", value: 15, meaning: "Condition NV" }
/// Condition NV
#[test]
fn test_aarch32_smmla_a1_a_special_cond_15_condition_nv_16_f7500010() {
    // Encoding: 0xF7500010
    // Test aarch32_SMMLA_A1_A special value cond = 15 (Condition NV)
    // ISET: A32
    // Fields: Ra=0, R=0, Rn=0, Rm=0, cond=15, Rd=0
    let encoding: u32 = 0xF7500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "A32 instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmla_a1_a_invalid_0_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: A32
    // Fields: Ra=0, Rm=0, Rd=0, cond=0, Rn=0, R=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMLA_A1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmla_a1_a_invalid_1_10_07500010() {
    // Encoding: 0x07500010
    // Test aarch32_SMMLA_A1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: A32
    // Fields: Ra=0, Rm=0, R=0, Rn=0, Rd=0, cond=0
    let encoding: u32 = 0x07500010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    // UNPREDICTABLE - behavior is implementation-defined
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_t1_a_field_rn_0_min_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A field Rn = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Ra=0, Rn=0, Rd=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Rn 16 +: 4`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_t1_a_field_rn_1_poweroftwo_0_fb510000() {
    // Thumb encoding (32): 0xFB510000
    // Test aarch32_SMMLA_T1_A field Rn = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rm=0, Rn=1, Rd=0, Ra=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB510000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_t1_a_field_ra_0_min_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A field Ra = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rn=0, R=0, Rd=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Ra 12 +: 4`
/// Requirement: FieldBoundary { field: "Ra", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_t1_a_field_ra_1_poweroftwo_0_fb501000() {
    // Thumb encoding (32): 0xFB501000
    // Test aarch32_SMMLA_T1_A field Ra = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=0, Ra=1, Rm=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB501000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_t1_a_field_rd_0_min_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A field Rd = 0 (Min)
    // ISET: T32
    // Fields: Ra=0, Rm=0, Rd=0, Rn=0, R=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Rd 8 +: 4`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_t1_a_field_rd_1_poweroftwo_0_fb500100() {
    // Thumb encoding (32): 0xFB500100
    // Test aarch32_SMMLA_T1_A field Rd = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Rd=1, Ra=0, R=0, Rn=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500100;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field R 4 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_aarch32_smmla_t1_a_field_r_0_min_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A field R = 0 (Min)
    // ISET: T32
    // Fields: Rm=0, Rd=0, R=0, Ra=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field R 4 +: 1`
/// Requirement: FieldBoundary { field: "R", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_aarch32_smmla_t1_a_field_r_1_max_0_fb500010() {
    // Thumb encoding (32): 0xFB500010
    // Test aarch32_SMMLA_T1_A field R = 1 (Max)
    // ISET: T32
    // Fields: Ra=0, Rn=0, Rd=0, Rm=0, R=1
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_aarch32_smmla_t1_a_field_rm_0_min_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A field Rm = 0 (Min)
    // ISET: T32
    // Fields: R=0, Rm=0, Ra=0, Rd=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field Rm 0 +: 4`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_aarch32_smmla_t1_a_field_rm_1_poweroftwo_0_fb500001() {
    // Thumb encoding (32): 0xFB500001
    // Test aarch32_SMMLA_T1_A field Rm = 1 (PowerOfTwo)
    // ISET: T32
    // Fields: Ra=0, R=0, Rm=1, Rn=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500001;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_aarch32_smmla_t1_a_combo_0_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A field combination: Rn=0, Ra=0, Rd=0, R=0, Rm=0
    // ISET: T32
    // Fields: Rm=0, Ra=0, Rd=0, R=0, Rn=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "T32 instruction should execute successfully"
    );
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"d\" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"n\" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: \"m\" }) } }, rhs: LitInt(15) }" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmla_t1_a_invalid_0_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A invalid encoding: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "d" }), rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "n" }) } }, rhs: Binary { op: Or, lhs: LitInt(15), rhs: Var(QualifiedIdentifier { qualifier: Any, name: "m" }) } }, rhs: LitInt(15) }
    // ISET: T32
    // Fields: Ra=0, R=0, Rn=0, Rm=0, Rd=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}

/// Provenance: aarch32_SMMLA_T1_A
/// ASL: `Unconditional UNPREDICTABLE`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNPREDICTABLE" }
/// triggers Unpredictable
#[test]
fn test_aarch32_smmla_t1_a_invalid_1_0_fb500000() {
    // Thumb encoding (32): 0xFB500000
    // Test aarch32_SMMLA_T1_A invalid encoding: Unconditional UNPREDICTABLE
    // ISET: T32
    // Fields: Rd=0, R=0, Rn=0, Ra=0, Rm=0
    let mut cpu = create_thumb_cpu();
    let encoding: u32 = 0xFB500000;
    write_insn(&mut cpu, 0, encoding);
    let _ = cpu.step();
}
