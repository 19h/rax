//! A64 misc other tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// LDNT1B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a401c000() {
    // Encoding: 0xA401C000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=1
    let encoding: u32 = 0xA401C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a41ec000() {
    // Encoding: 0xA41EC000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=30, Rn=0, Pg=0
    let encoding: u32 = 0xA41EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rm_31_max_c000_a41fc000() {
    // Encoding: 0xA41FC000
    // Test LDNT1B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA41FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_pg_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a400c400() {
    // Encoding: 0xA400C400
    // Test LDNT1B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xA400C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a400c020() {
    // Encoding: 0xA400C020
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=1
    let encoding: u32 = 0xA400C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a400c3c0() {
    // Encoding: 0xA400C3C0
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Rm=0
    let encoding: u32 = 0xA400C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_rn_31_max_c000_a400c3e0() {
    // Encoding: 0xA400C3E0
    // Test LDNT1B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA400C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_0_min_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a400c001() {
    // Encoding: 0xA400C001
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Zt=1, Pg=0
    let encoding: u32 = 0xA400C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a400c01e() {
    // Encoding: 0xA400C01E
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xA400C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1b_z_p_br_contiguous_field_zt_31_max_c000_a400c01f() {
    // Encoding: 0xA400C01F
    // Test LDNT1B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rm=0, Rn=0
    let encoding: u32 = 0xA400C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_0_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_1_c000_a401c000() {
    // Encoding: 0xA401C000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=1, Zt=0, Pg=0
    let encoding: u32 = 0xA401C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_2_c000_a41ec000() {
    // Encoding: 0xA41EC000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=30, Pg=0
    let encoding: u32 = 0xA41EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_3_c000_a41fc000() {
    // Encoding: 0xA41FC000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Rm=31, Pg=0
    let encoding: u32 = 0xA41FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_4_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_5_c000_a400c400() {
    // Encoding: 0xA400C400
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Pg=1, Rm=0, Zt=0
    let encoding: u32 = 0xA400C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_6_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_7_c000_a400c020() {
    // Encoding: 0xA400C020
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA400C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_8_c000_a400c3c0() {
    // Encoding: 0xA400C3C0
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=30
    let encoding: u32 = 0xA400C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_9_c000_a400c3e0() {
    // Encoding: 0xA400C3E0
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA400C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_10_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_11_c000_a400c001() {
    // Encoding: 0xA400C001
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, Rn=0, Rm=0
    let encoding: u32 = 0xA400C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_12_c000_a400c01e() {
    // Encoding: 0xA400C01E
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Zt=30, Rm=0, Pg=0
    let encoding: u32 = 0xA400C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_13_c000_a400c01f() {
    // Encoding: 0xA400C01F
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zt=31, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA400C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_14_c000_a401c400() {
    // Encoding: 0xA401C400
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Rm=1, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xA401C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_15_c000_a41fdc00() {
    // Encoding: 0xA41FDC00
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Pg=31, Zt=0, Rn=0, Rm=31
    let encoding: u32 = 0xA41FDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_16_c000_a401c020() {
    // Encoding: 0xA401C020
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rm=1, Rn=1, Zt=0
    let encoding: u32 = 0xA401C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_17_c000_a41fc3e0() {
    // Encoding: 0xA41FC3E0
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Zt=0, Rn=31, Rm=31
    let encoding: u32 = 0xA41FC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_18_c000_a400c420() {
    // Encoding: 0xA400C420
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Zt=0, Rm=0, Pg=1
    let encoding: u32 = 0xA400C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnt1b_z_p_br_contiguous_combo_19_c000_a400dfe0() {
    // Encoding: 0xA400DFE0
    // Test LDNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA400DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a400c3e0() {
    // Encoding: 0xA400C3E0
    // Test LDNT1B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA400C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_0_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_1_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_2_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1b_z_p_br_contiguous_invalid_3_c000_a400c000() {
    // Encoding: 0xA400C000
    // Test LDNT1B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1b_z_p_br_contiguous_reg_write_0_a400c000() {
    // Test LDNT1B_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA400C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1b_z_p_br_contiguous_sp_rn_a400c3e0() {
    // Test LDNT1B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA400C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA400C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FNMLA_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fnmla_z_p_zzz_field_size_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fnmla_z_p_zzz_field_size_1_poweroftwo_4000_65604000() {
    // Encoding: 0x65604000
    // Test FNMLA_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=0, size=1, Zm=0, Pg=0
    let encoding: u32 = 0x65604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fnmla_z_p_zzz_field_size_2_poweroftwo_4000_65a04000() {
    // Encoding: 0x65A04000
    // Test FNMLA_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zda=0, Pg=0, Zm=0, size=2
    let encoding: u32 = 0x65A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fnmla_z_p_zzz_field_size_3_max_4000_65e04000() {
    // Encoding: 0x65E04000
    // Test FNMLA_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zm=0, Zda=0, Zn=0
    let encoding: u32 = 0x65E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmla_z_p_zzz_field_zm_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zm=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmla_z_p_zzz_field_zm_1_poweroftwo_4000_65214000() {
    // Encoding: 0x65214000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zda=0, Zm=1, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x65214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmla_z_p_zzz_field_zm_30_poweroftwominusone_4000_653e4000() {
    // Encoding: 0x653E4000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zda=0, Zn=0, Zm=30, Pg=0
    let encoding: u32 = 0x653E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmla_z_p_zzz_field_zm_31_max_4000_653f4000() {
    // Encoding: 0x653F4000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Zda=0, Zn=0, size=0
    let encoding: u32 = 0x653F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fnmla_z_p_zzz_field_pg_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fnmla_z_p_zzz_field_pg_1_poweroftwo_4000_65204400() {
    // Encoding: 0x65204400
    // Test FNMLA_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zda=0, Pg=1, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmla_z_p_zzz_field_zn_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Zn = 0 (Min)
    // Fields: Zda=0, size=0, Zm=0, Pg=0, Zn=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmla_z_p_zzz_field_zn_1_poweroftwo_4000_65204020() {
    // Encoding: 0x65204020
    // Test FNMLA_Z.P.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=0, Zn=1, Zda=0
    let encoding: u32 = 0x65204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmla_z_p_zzz_field_zn_30_poweroftwominusone_4000_652043c0() {
    // Encoding: 0x652043C0
    // Test FNMLA_Z.P.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Pg=0, Zm=0, size=0, Zn=30
    let encoding: u32 = 0x652043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmla_z_p_zzz_field_zn_31_max_4000_652043e0() {
    // Encoding: 0x652043E0
    // Test FNMLA_Z.P.ZZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Zn=31, size=0, Pg=0, Zda=0
    let encoding: u32 = 0x652043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmla_z_p_zzz_field_zda_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Zda = 0 (Min)
    // Fields: Pg=0, Zda=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmla_z_p_zzz_field_zda_1_poweroftwo_4000_65204001() {
    // Encoding: 0x65204001
    // Test FNMLA_Z.P.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zn=0, Pg=0, Zda=1
    let encoding: u32 = 0x65204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmla_z_p_zzz_field_zda_15_poweroftwominusone_4000_6520400f() {
    // Encoding: 0x6520400F
    // Test FNMLA_Z.P.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zda=15, Zn=0, Pg=0
    let encoding: u32 = 0x6520400F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmla_z_p_zzz_field_zda_31_max_4000_6520401f() {
    // Encoding: 0x6520401F
    // Test FNMLA_Z.P.ZZZ__ field Zda = 31 (Max)
    // Fields: Zm=0, Pg=0, Zn=0, size=0, Zda=31
    let encoding: u32 = 0x6520401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fnmla_z_p_zzz_combo_0_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fnmla_z_p_zzz_combo_1_4000_65604000() {
    // Encoding: 0x65604000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=1, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zda=0, Pg=0, Zm=0, size=1, Zn=0
    let encoding: u32 = 0x65604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fnmla_z_p_zzz_combo_2_4000_65a04000() {
    // Encoding: 0x65A04000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=2, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zm=0, Pg=0, size=2, Zn=0, Zda=0
    let encoding: u32 = 0x65A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fnmla_z_p_zzz_combo_3_4000_65e04000() {
    // Encoding: 0x65E04000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=3, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=3, Zn=0, Zda=0, Pg=0, Zm=0
    let encoding: u32 = 0x65E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_fnmla_z_p_zzz_combo_4_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zn=0, Zm=0, size=0, Zda=0, Pg=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_fnmla_z_p_zzz_combo_5_4000_65214000() {
    // Encoding: 0x65214000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=1, Pg=0, Zn=0, Zda=0
    // Fields: Zn=0, Zda=0, size=0, Zm=1, Pg=0
    let encoding: u32 = 0x65214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_fnmla_z_p_zzz_combo_6_4000_653e4000() {
    // Encoding: 0x653E4000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=30, Pg=0, Zn=0, Zda=0
    // Fields: Zm=30, size=0, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x653E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_fnmla_z_p_zzz_combo_7_4000_653f4000() {
    // Encoding: 0x653F4000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=31, Pg=0, Zn=0, Zda=0
    // Fields: Zda=0, Zn=0, size=0, Zm=31, Pg=0
    let encoding: u32 = 0x653F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fnmla_z_p_zzz_combo_8_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zn=0, Zda=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fnmla_z_p_zzz_combo_9_4000_65204400() {
    // Encoding: 0x65204400
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=1, Zn=0, Zda=0
    // Fields: size=0, Zm=0, Pg=1, Zda=0, Zn=0
    let encoding: u32 = 0x65204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_fnmla_z_p_zzz_combo_10_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=0, Zm=0, Zda=0, Zn=0, Pg=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_fnmla_z_p_zzz_combo_11_4000_65204020() {
    // Encoding: 0x65204020
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=1, Zda=0
    // Fields: Pg=0, Zda=0, size=0, Zn=1, Zm=0
    let encoding: u32 = 0x65204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_fnmla_z_p_zzz_combo_12_4000_652043c0() {
    // Encoding: 0x652043C0
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=30, Zda=0
    // Fields: size=0, Pg=0, Zn=30, Zda=0, Zm=0
    let encoding: u32 = 0x652043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_fnmla_z_p_zzz_combo_13_4000_652043e0() {
    // Encoding: 0x652043E0
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=31, Zda=0
    // Fields: Pg=0, Zm=0, Zda=0, size=0, Zn=31
    let encoding: u32 = 0x652043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=0 (minimum value)
#[test]
fn test_fnmla_z_p_zzz_combo_14_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Pg=0, Zm=0, Zn=0, Zda=0, size=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=1 (value 1)
#[test]
fn test_fnmla_z_p_zzz_combo_15_4000_65204001() {
    // Encoding: 0x65204001
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=1
    // Fields: Zm=0, size=0, Pg=0, Zn=0, Zda=1
    let encoding: u32 = 0x65204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=15 (midpoint (15))
#[test]
fn test_fnmla_z_p_zzz_combo_16_4000_6520400f() {
    // Encoding: 0x6520400F
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=15
    // Fields: Zn=0, Pg=0, size=0, Zm=0, Zda=15
    let encoding: u32 = 0x6520400F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=31 (maximum value (31))
#[test]
fn test_fnmla_z_p_zzz_combo_17_4000_6520401f() {
    // Encoding: 0x6520401F
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=31
    // Fields: Pg=0, size=0, Zn=0, Zda=31, Zm=0
    let encoding: u32 = 0x6520401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fnmla_z_p_zzz_special_size_0_size_variant_0_16384_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zda=0, Pg=0, Zn=0, Zm=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fnmla_z_p_zzz_special_size_1_size_variant_1_16384_65604000() {
    // Encoding: 0x65604000
    // Test FNMLA_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Pg=0, Zda=0, Zn=0
    let encoding: u32 = 0x65604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fnmla_z_p_zzz_special_size_2_size_variant_2_16384_65a04000() {
    // Encoding: 0x65A04000
    // Test FNMLA_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, Zda=0, size=2, Zn=0
    let encoding: u32 = 0x65A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fnmla_z_p_zzz_special_size_3_size_variant_3_16384_65e04000() {
    // Encoding: 0x65E04000
    // Test FNMLA_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zda=0, Pg=0, Zn=0, Zm=0
    let encoding: u32 = 0x65E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_0_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zm=0, Pg=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_1_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zda=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_2_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zn=0, Zm=0, Pg=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_3_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zda=0, Pg=0, Zm=0, Zn=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fnmla_z_p_zzz_reg_write_0_65204000() {
    // Test FNMLA_Z.P.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x65204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// NOR_P.P.PP_Z Tests
// ============================================================================

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nor_p_p_pp_z_field_pm_0_min_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field Pm = 0 (Min)
    // Fields: Pm=0, Pg=0, Pd=0, Pn=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nor_p_p_pp_z_field_pm_1_poweroftwo_4200_25814200() {
    // Encoding: 0x25814200
    // Test NOR_P.P.PP_Z field Pm = 1 (PowerOfTwo)
    // Fields: Pd=0, Pn=0, Pg=0, Pm=1
    let encoding: u32 = 0x25814200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nor_p_p_pp_z_field_pg_0_min_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field Pg = 0 (Min)
    // Fields: Pg=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nor_p_p_pp_z_field_pg_1_poweroftwo_4200_25804600() {
    // Encoding: 0x25804600
    // Test NOR_P.P.PP_Z field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Pn=0, Pd=0, Pm=0
    let encoding: u32 = 0x25804600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nor_p_p_pp_z_field_pn_0_min_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field Pn = 0 (Min)
    // Fields: Pn=0, Pm=0, Pg=0, Pd=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nor_p_p_pp_z_field_pn_1_poweroftwo_4200_25804220() {
    // Encoding: 0x25804220
    // Test NOR_P.P.PP_Z field Pn = 1 (PowerOfTwo)
    // Fields: Pd=0, Pm=0, Pn=1, Pg=0
    let encoding: u32 = 0x25804220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nor_p_p_pp_z_field_pd_0_min_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field Pd = 0 (Min)
    // Fields: Pm=0, Pg=0, Pd=0, Pn=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nor_p_p_pp_z_field_pd_1_poweroftwo_4200_25804201() {
    // Encoding: 0x25804201
    // Test NOR_P.P.PP_Z field Pd = 1 (PowerOfTwo)
    // Fields: Pg=0, Pn=0, Pm=0, Pd=1
    let encoding: u32 = 0x25804201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=0 (register index 0 (first register))
#[test]
fn test_nor_p_p_pp_z_combo_0_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pm=0, Pn=0, Pd=0, Pg=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (register index 1 (second register))
#[test]
fn test_nor_p_p_pp_z_combo_1_4200_25814200() {
    // Encoding: 0x25814200
    // Test NOR_P.P.PP_Z field combination: Pm=1, Pg=0, Pn=0, Pd=0
    // Fields: Pm=1, Pg=0, Pd=0, Pn=0
    let encoding: u32 = 0x25814200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_nor_p_p_pp_z_combo_2_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pm=0, Pd=0, Pn=0, Pg=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_nor_p_p_pp_z_combo_3_4200_25804600() {
    // Encoding: 0x25804600
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=1, Pn=0, Pd=0
    // Fields: Pd=0, Pg=1, Pm=0, Pn=0
    let encoding: u32 = 0x25804600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=0 (register index 0 (first register))
#[test]
fn test_nor_p_p_pp_z_combo_4_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pd=0, Pm=0, Pn=0, Pg=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=1 (register index 1 (second register))
#[test]
fn test_nor_p_p_pp_z_combo_5_4200_25804220() {
    // Encoding: 0x25804220
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=1, Pd=0
    // Fields: Pm=0, Pn=1, Pd=0, Pg=0
    let encoding: u32 = 0x25804220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pd=0 (register index 0 (first register))
#[test]
fn test_nor_p_p_pp_z_combo_6_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pm=0, Pd=0, Pn=0, Pg=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pd=1 (register index 1 (second register))
#[test]
fn test_nor_p_p_pp_z_combo_7_4200_25804201() {
    // Encoding: 0x25804201
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=1
    // Fields: Pd=1, Pm=0, Pn=0, Pg=0
    let encoding: u32 = 0x25804201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_nor_p_p_pp_z_combo_8_4200_25814600() {
    // Encoding: 0x25814600
    // Test NOR_P.P.PP_Z field combination: Pm=1, Pg=1, Pn=0, Pd=0
    // Fields: Pn=0, Pg=1, Pm=1, Pd=0
    let encoding: u32 = 0x25814600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_nor_p_p_pp_z_combo_9_4200_258f7e00() {
    // Encoding: 0x258F7E00
    // Test NOR_P.P.PP_Z field combination: Pm=31, Pg=31, Pn=0, Pd=0
    // Fields: Pd=0, Pn=0, Pm=31, Pg=31
    let encoding: u32 = 0x258F7E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (same register test (reg=1)), Pn=1 (same register test (reg=1))
#[test]
fn test_nor_p_p_pp_z_combo_10_4200_25814220() {
    // Encoding: 0x25814220
    // Test NOR_P.P.PP_Z field combination: Pm=1, Pg=0, Pn=1, Pd=0
    // Fields: Pm=1, Pg=0, Pd=0, Pn=1
    let encoding: u32 = 0x25814220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=31 (same register test (reg=31)), Pn=31 (same register test (reg=31))
#[test]
fn test_nor_p_p_pp_z_combo_11_4200_258f43e0() {
    // Encoding: 0x258F43E0
    // Test NOR_P.P.PP_Z field combination: Pm=31, Pg=0, Pn=31, Pd=0
    // Fields: Pg=0, Pn=31, Pd=0, Pm=31
    let encoding: u32 = 0x258F43E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_nor_p_p_pp_z_combo_12_4200_25814201() {
    // Encoding: 0x25814201
    // Test NOR_P.P.PP_Z field combination: Pm=1, Pg=0, Pn=0, Pd=1
    // Fields: Pn=0, Pg=0, Pm=1, Pd=1
    let encoding: u32 = 0x25814201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_nor_p_p_pp_z_combo_13_4200_258f420f() {
    // Encoding: 0x258F420F
    // Test NOR_P.P.PP_Z field combination: Pm=31, Pg=0, Pn=0, Pd=31
    // Fields: Pg=0, Pm=31, Pd=31, Pn=0
    let encoding: u32 = 0x258F420F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Pn=1 (same register test (reg=1))
#[test]
fn test_nor_p_p_pp_z_combo_14_4200_25804620() {
    // Encoding: 0x25804620
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=1, Pn=1, Pd=0
    // Fields: Pd=0, Pg=1, Pm=0, Pn=1
    let encoding: u32 = 0x25804620;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Pn=31 (same register test (reg=31))
#[test]
fn test_nor_p_p_pp_z_combo_15_4200_25807fe0() {
    // Encoding: 0x25807FE0
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=31, Pn=31, Pd=0
    // Fields: Pm=0, Pn=31, Pd=0, Pg=31
    let encoding: u32 = 0x25807FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_nor_p_p_pp_z_combo_16_4200_25804601() {
    // Encoding: 0x25804601
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=1, Pn=0, Pd=1
    // Fields: Pm=0, Pg=1, Pn=0, Pd=1
    let encoding: u32 = 0x25804601;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_nor_p_p_pp_z_combo_17_4200_25807e0f() {
    // Encoding: 0x25807E0F
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=31, Pn=0, Pd=31
    // Fields: Pm=0, Pg=31, Pd=31, Pn=0
    let encoding: u32 = 0x25807E0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_nor_p_p_pp_z_combo_18_4200_25804221() {
    // Encoding: 0x25804221
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=1, Pd=1
    // Fields: Pg=0, Pm=0, Pd=1, Pn=1
    let encoding: u32 = 0x25804221;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_nor_p_p_pp_z_combo_19_4200_258043ef() {
    // Encoding: 0x258043EF
    // Test NOR_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=31, Pd=31
    // Fields: Pn=31, Pm=0, Pd=31, Pg=0
    let encoding: u32 = 0x258043EF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_nor_p_p_pp_z_invalid_0_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Pn=0, Pm=0, Pd=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_nor_p_p_pp_z_invalid_1_4200_25804200() {
    // Encoding: 0x25804200
    // Test NOR_P.P.PP_Z invalid encoding: Unconditional UNDEFINED
    // Fields: Pn=0, Pm=0, Pd=0, Pg=0
    let encoding: u32 = 0x25804200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nors_p_p_pp_z_field_pm_0_min_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field Pm = 0 (Min)
    // Fields: Pd=0, Pm=0, Pg=0, Pn=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nors_p_p_pp_z_field_pm_1_poweroftwo_4200_25c14200() {
    // Encoding: 0x25C14200
    // Test NORS_P.P.PP_Z field Pm = 1 (PowerOfTwo)
    // Fields: Pg=0, Pm=1, Pd=0, Pn=0
    let encoding: u32 = 0x25C14200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nors_p_p_pp_z_field_pg_0_min_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field Pg = 0 (Min)
    // Fields: Pn=0, Pd=0, Pm=0, Pg=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nors_p_p_pp_z_field_pg_1_poweroftwo_4200_25c04600() {
    // Encoding: 0x25C04600
    // Test NORS_P.P.PP_Z field Pg = 1 (PowerOfTwo)
    // Fields: Pm=0, Pg=1, Pn=0, Pd=0
    let encoding: u32 = 0x25C04600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nors_p_p_pp_z_field_pn_0_min_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field Pn = 0 (Min)
    // Fields: Pd=0, Pm=0, Pn=0, Pg=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nors_p_p_pp_z_field_pn_1_poweroftwo_4200_25c04220() {
    // Encoding: 0x25C04220
    // Test NORS_P.P.PP_Z field Pn = 1 (PowerOfTwo)
    // Fields: Pm=0, Pd=0, Pg=0, Pn=1
    let encoding: u32 = 0x25C04220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_nors_p_p_pp_z_field_pd_0_min_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field Pd = 0 (Min)
    // Fields: Pg=0, Pd=0, Pm=0, Pn=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_nors_p_p_pp_z_field_pd_1_poweroftwo_4200_25c04201() {
    // Encoding: 0x25C04201
    // Test NORS_P.P.PP_Z field Pd = 1 (PowerOfTwo)
    // Fields: Pd=1, Pm=0, Pn=0, Pg=0
    let encoding: u32 = 0x25C04201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=0 (register index 0 (first register))
#[test]
fn test_nors_p_p_pp_z_combo_0_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pn=0, Pm=0, Pd=0, Pg=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (register index 1 (second register))
#[test]
fn test_nors_p_p_pp_z_combo_1_4200_25c14200() {
    // Encoding: 0x25C14200
    // Test NORS_P.P.PP_Z field combination: Pm=1, Pg=0, Pn=0, Pd=0
    // Fields: Pm=1, Pg=0, Pn=0, Pd=0
    let encoding: u32 = 0x25C14200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_nors_p_p_pp_z_combo_2_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pm=0, Pg=0, Pd=0, Pn=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_nors_p_p_pp_z_combo_3_4200_25c04600() {
    // Encoding: 0x25C04600
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=1, Pn=0, Pd=0
    // Fields: Pg=1, Pn=0, Pd=0, Pm=0
    let encoding: u32 = 0x25C04600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=0 (register index 0 (first register))
#[test]
fn test_nors_p_p_pp_z_combo_4_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pd=0, Pn=0, Pm=0, Pg=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=1 (register index 1 (second register))
#[test]
fn test_nors_p_p_pp_z_combo_5_4200_25c04220() {
    // Encoding: 0x25C04220
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=1, Pd=0
    // Fields: Pd=0, Pg=0, Pn=1, Pm=0
    let encoding: u32 = 0x25C04220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pd=0 (register index 0 (first register))
#[test]
fn test_nors_p_p_pp_z_combo_6_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=0
    // Fields: Pm=0, Pn=0, Pg=0, Pd=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pd=1 (register index 1 (second register))
#[test]
fn test_nors_p_p_pp_z_combo_7_4200_25c04201() {
    // Encoding: 0x25C04201
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=0, Pd=1
    // Fields: Pg=0, Pn=0, Pm=0, Pd=1
    let encoding: u32 = 0x25C04201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_nors_p_p_pp_z_combo_8_4200_25c14600() {
    // Encoding: 0x25C14600
    // Test NORS_P.P.PP_Z field combination: Pm=1, Pg=1, Pn=0, Pd=0
    // Fields: Pn=0, Pd=0, Pg=1, Pm=1
    let encoding: u32 = 0x25C14600;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_nors_p_p_pp_z_combo_9_4200_25cf7e00() {
    // Encoding: 0x25CF7E00
    // Test NORS_P.P.PP_Z field combination: Pm=31, Pg=31, Pn=0, Pd=0
    // Fields: Pn=0, Pd=0, Pg=31, Pm=31
    let encoding: u32 = 0x25CF7E00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (same register test (reg=1)), Pn=1 (same register test (reg=1))
#[test]
fn test_nors_p_p_pp_z_combo_10_4200_25c14220() {
    // Encoding: 0x25C14220
    // Test NORS_P.P.PP_Z field combination: Pm=1, Pg=0, Pn=1, Pd=0
    // Fields: Pn=1, Pm=1, Pg=0, Pd=0
    let encoding: u32 = 0x25C14220;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=31 (same register test (reg=31)), Pn=31 (same register test (reg=31))
#[test]
fn test_nors_p_p_pp_z_combo_11_4200_25cf43e0() {
    // Encoding: 0x25CF43E0
    // Test NORS_P.P.PP_Z field combination: Pm=31, Pg=0, Pn=31, Pd=0
    // Fields: Pg=0, Pm=31, Pd=0, Pn=31
    let encoding: u32 = 0x25CF43E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_nors_p_p_pp_z_combo_12_4200_25c14201() {
    // Encoding: 0x25C14201
    // Test NORS_P.P.PP_Z field combination: Pm=1, Pg=0, Pn=0, Pd=1
    // Fields: Pd=1, Pn=0, Pm=1, Pg=0
    let encoding: u32 = 0x25C14201;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pm=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_nors_p_p_pp_z_combo_13_4200_25cf420f() {
    // Encoding: 0x25CF420F
    // Test NORS_P.P.PP_Z field combination: Pm=31, Pg=0, Pn=0, Pd=31
    // Fields: Pm=31, Pd=31, Pg=0, Pn=0
    let encoding: u32 = 0x25CF420F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Pn=1 (same register test (reg=1))
#[test]
fn test_nors_p_p_pp_z_combo_14_4200_25c04620() {
    // Encoding: 0x25C04620
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=1, Pn=1, Pd=0
    // Fields: Pd=0, Pm=0, Pg=1, Pn=1
    let encoding: u32 = 0x25C04620;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Pn=31 (same register test (reg=31))
#[test]
fn test_nors_p_p_pp_z_combo_15_4200_25c07fe0() {
    // Encoding: 0x25C07FE0
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=31, Pn=31, Pd=0
    // Fields: Pg=31, Pm=0, Pn=31, Pd=0
    let encoding: u32 = 0x25C07FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_nors_p_p_pp_z_combo_16_4200_25c04601() {
    // Encoding: 0x25C04601
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=1, Pn=0, Pd=1
    // Fields: Pm=0, Pn=0, Pd=1, Pg=1
    let encoding: u32 = 0x25C04601;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_nors_p_p_pp_z_combo_17_4200_25c07e0f() {
    // Encoding: 0x25C07E0F
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=31, Pn=0, Pd=31
    // Fields: Pn=0, Pg=31, Pm=0, Pd=31
    let encoding: u32 = 0x25C07E0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_nors_p_p_pp_z_combo_18_4200_25c04221() {
    // Encoding: 0x25C04221
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=1, Pd=1
    // Fields: Pg=0, Pn=1, Pm=0, Pd=1
    let encoding: u32 = 0x25C04221;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_nors_p_p_pp_z_combo_19_4200_25c043ef() {
    // Encoding: 0x25C043EF
    // Test NORS_P.P.PP_Z field combination: Pm=0, Pg=0, Pn=31, Pd=31
    // Fields: Pg=0, Pn=31, Pm=0, Pd=31
    let encoding: u32 = 0x25C043EF;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_nors_p_p_pp_z_invalid_0_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pm=0, Pg=0, Pn=0, Pd=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_nors_p_p_pp_z_invalid_1_4200_25c04200() {
    // Encoding: 0x25C04200
    // Test NORS_P.P.PP_Z invalid encoding: Unconditional UNDEFINED
    // Fields: Pm=0, Pn=0, Pd=0, Pg=0
    let encoding: u32 = 0x25C04200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_nor_p_p_pp_z_reg_write_0_25804200() {
    // Test NOR_P.P.PP_Z register write: SimdFromField("Pd")
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_nor_p_p_pp_z_flags_zeroresult_0_25804200() {
    // Test NOR_P.P.PP_Z flag computation: ZeroResult
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x0);
    set_x(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_nor_p_p_pp_z_flags_zeroresult_1_25804200() {
    // Test NOR_P.P.PP_Z flag computation: ZeroResult
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_nor_p_p_pp_z_flags_negativeresult_2_25804200() {
    // Test NOR_P.P.PP_Z flag computation: NegativeResult
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_nor_p_p_pp_z_flags_unsignedoverflow_3_25804200() {
    // Test NOR_P.P.PP_Z flag computation: UnsignedOverflow
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_nor_p_p_pp_z_flags_unsignedoverflow_4_25804200() {
    // Test NOR_P.P.PP_Z flag computation: UnsignedOverflow
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_nor_p_p_pp_z_flags_signedoverflow_5_25804200() {
    // Test NOR_P.P.PP_Z flag computation: SignedOverflow
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x7FFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_nor_p_p_pp_z_flags_signedoverflow_6_25804200() {
    // Test NOR_P.P.PP_Z flag computation: SignedOverflow
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x8000000000000000);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: NOR_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_nor_p_p_pp_z_flags_positiveresult_7_25804200() {
    // Test NOR_P.P.PP_Z flag computation: PositiveResult
    // Encoding: 0x25804200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x32);
    set_x(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x25804200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_nors_p_p_pp_z_reg_write_0_25c04200() {
    // Test NORS_P.P.PP_Z register write: SimdFromField("Pd")
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_nors_p_p_pp_z_flags_zeroresult_0_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: ZeroResult
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x0);
    set_x(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_nors_p_p_pp_z_flags_zeroresult_1_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: ZeroResult
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_nors_p_p_pp_z_flags_negativeresult_2_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: NegativeResult
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_nors_p_p_pp_z_flags_unsignedoverflow_3_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: UnsignedOverflow
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x1);
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_nors_p_p_pp_z_flags_unsignedoverflow_4_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: UnsignedOverflow
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_nors_p_p_pp_z_flags_signedoverflow_5_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: SignedOverflow
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x7FFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_nors_p_p_pp_z_flags_signedoverflow_6_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: SignedOverflow
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: NORS_P.P.PP_Z
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_nors_p_p_pp_z_flags_positiveresult_7_25c04200() {
    // Test NORS_P.P.PP_Z flag computation: PositiveResult
    // Encoding: 0x25C04200
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x64);
    set_x(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x25C04200;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// SQDECW_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecw_z_zs_field_imm4_0_zero_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecw_z_zs_field_imm4_1_poweroftwo_c800_04a1c800() {
    // Encoding: 0x04A1C800
    // Test SQDECW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04A1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecw_z_zs_field_imm4_3_poweroftwominusone_c800_04a3c800() {
    // Encoding: 0x04A3C800
    // Test SQDECW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zdn=0, pattern=0
    let encoding: u32 = 0x04A3C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecw_z_zs_field_imm4_4_poweroftwo_c800_04a4c800() {
    // Encoding: 0x04A4C800
    // Test SQDECW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Zdn=0
    let encoding: u32 = 0x04A4C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecw_z_zs_field_imm4_7_poweroftwominusone_c800_04a7c800() {
    // Encoding: 0x04A7C800
    // Test SQDECW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x04A7C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecw_z_zs_field_imm4_8_poweroftwo_c800_04a8c800() {
    // Encoding: 0x04A8C800
    // Test SQDECW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Zdn=0
    let encoding: u32 = 0x04A8C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecw_z_zs_field_imm4_15_max_c800_04afc800() {
    // Encoding: 0x04AFC800
    // Test SQDECW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x04AFC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_z_zs_field_pattern_0_min_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_z_zs_field_pattern_1_poweroftwo_c800_04a0c820() {
    // Encoding: 0x04A0C820
    // Test SQDECW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04A0C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_z_zs_field_pattern_15_poweroftwominusone_c800_04a0c9e0() {
    // Encoding: 0x04A0C9E0
    // Test SQDECW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04A0C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_z_zs_field_pattern_31_max_c800_04a0cbe0() {
    // Encoding: 0x04A0CBE0
    // Test SQDECW_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_z_zs_field_zdn_0_min_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_z_zs_field_zdn_1_poweroftwo_c800_04a0c801() {
    // Encoding: 0x04A0C801
    // Test SQDECW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x04A0C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_z_zs_field_zdn_15_poweroftwominusone_c800_04a0c80f() {
    // Encoding: 0x04A0C80F
    // Test SQDECW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04A0C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_z_zs_field_zdn_31_max_c800_04a0c81f() {
    // Encoding: 0x04A0C81F
    // Test SQDECW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x04A0C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecw_z_zs_combo_0_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_sqdecw_z_zs_combo_1_c800_04a1c800() {
    // Encoding: 0x04A1C800
    // Test SQDECW_Z.ZS__ field combination: imm4=1, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=1
    let encoding: u32 = 0x04A1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_sqdecw_z_zs_combo_2_c800_04a3c800() {
    // Encoding: 0x04A3C800
    // Test SQDECW_Z.ZS__ field combination: imm4=3, pattern=0, Zdn=0
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x04A3C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_sqdecw_z_zs_combo_3_c800_04a4c800() {
    // Encoding: 0x04A4C800
    // Test SQDECW_Z.ZS__ field combination: imm4=4, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x04A4C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_sqdecw_z_zs_combo_4_c800_04a7c800() {
    // Encoding: 0x04A7C800
    // Test SQDECW_Z.ZS__ field combination: imm4=7, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x04A7C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_sqdecw_z_zs_combo_5_c800_04a8c800() {
    // Encoding: 0x04A8C800
    // Test SQDECW_Z.ZS__ field combination: imm4=8, pattern=0, Zdn=0
    // Fields: imm4=8, pattern=0, Zdn=0
    let encoding: u32 = 0x04A8C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_sqdecw_z_zs_combo_6_c800_04afc800() {
    // Encoding: 0x04AFC800
    // Test SQDECW_Z.ZS__ field combination: imm4=15, pattern=0, Zdn=0
    // Fields: Zdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04AFC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_sqdecw_z_zs_combo_7_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_sqdecw_z_zs_combo_8_c800_04a0c820() {
    // Encoding: 0x04A0C820
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=1, Zdn=0
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x04A0C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_sqdecw_z_zs_combo_9_c800_04a0c9e0() {
    // Encoding: 0x04A0C9E0
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=15, Zdn=0
    // Fields: Zdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04A0C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_sqdecw_z_zs_combo_10_c800_04a0cbe0() {
    // Encoding: 0x04A0CBE0
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=31, Zdn=0
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x04A0CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_sqdecw_z_zs_combo_11_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_sqdecw_z_zs_combo_12_c800_04a0c801() {
    // Encoding: 0x04A0C801
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=1
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x04A0C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_sqdecw_z_zs_combo_13_c800_04a0c80f() {
    // Encoding: 0x04A0C80F
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=15
    // Fields: pattern=0, imm4=0, Zdn=15
    let encoding: u32 = 0x04A0C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_sqdecw_z_zs_combo_14_c800_04a0c81f() {
    // Encoding: 0x04A0C81F
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=31
    // Fields: Zdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04A0C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecw_z_zs_invalid_0_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecw_z_zs_invalid_1_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqdecw_z_zs_reg_write_0_04a0c800() {
    // Test SQDECW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04A0C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// COMPACT_Z.P.Z__ Tests
// ============================================================================

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_compact_z_p_z_field_sz_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field sz = 0 (Min)
    // Fields: Zd=0, Pg=0, sz=0, Zn=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_compact_z_p_z_field_sz_1_max_8000_05e18000() {
    // Encoding: 0x05E18000
    // Test COMPACT_Z.P.Z__ field sz = 1 (Max)
    // Fields: Pg=0, sz=1, Zd=0, Zn=0
    let encoding: u32 = 0x05E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_compact_z_p_z_field_pg_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zd=0, sz=0, Pg=0, Zn=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_compact_z_p_z_field_pg_1_poweroftwo_8000_05a18400() {
    // Encoding: 0x05A18400
    // Test COMPACT_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: sz=0, Pg=1, Zd=0, Zn=0
    let encoding: u32 = 0x05A18400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_compact_z_p_z_field_zn_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field Zn = 0 (Min)
    // Fields: sz=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_compact_z_p_z_field_zn_1_poweroftwo_8000_05a18020() {
    // Encoding: 0x05A18020
    // Test COMPACT_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1, sz=0
    let encoding: u32 = 0x05A18020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_compact_z_p_z_field_zn_30_poweroftwominusone_8000_05a183c0() {
    // Encoding: 0x05A183C0
    // Test COMPACT_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Zn=30, Pg=0, Zd=0
    let encoding: u32 = 0x05A183C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_compact_z_p_z_field_zn_31_max_8000_05a183e0() {
    // Encoding: 0x05A183E0
    // Test COMPACT_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, sz=0, Zd=0, Zn=31
    let encoding: u32 = 0x05A183E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_compact_z_p_z_field_zd_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, sz=0, Pg=0, Zd=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_compact_z_p_z_field_zd_1_poweroftwo_8000_05a18001() {
    // Encoding: 0x05A18001
    // Test COMPACT_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1, sz=0
    let encoding: u32 = 0x05A18001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_compact_z_p_z_field_zd_30_poweroftwominusone_8000_05a1801e() {
    // Encoding: 0x05A1801E
    // Test COMPACT_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, sz=0, Zd=30
    let encoding: u32 = 0x05A1801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_compact_z_p_z_field_zd_31_max_8000_05a1801f() {
    // Encoding: 0x05A1801F
    // Test COMPACT_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, sz=0, Pg=0
    let encoding: u32 = 0x05A1801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_compact_z_p_z_combo_0_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, sz=0, Zn=0, Pg=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_compact_z_p_z_combo_1_8000_05e18000() {
    // Encoding: 0x05E18000
    // Test COMPACT_Z.P.Z__ field combination: sz=1, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0, sz=1
    let encoding: u32 = 0x05E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_compact_z_p_z_combo_2_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=0
    // Fields: sz=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_compact_z_p_z_combo_3_8000_05a18400() {
    // Encoding: 0x05A18400
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=1, Zn=0, Zd=0
    // Fields: sz=0, Zd=0, Zn=0, Pg=1
    let encoding: u32 = 0x05A18400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_compact_z_p_z_combo_4_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=0
    // Fields: sz=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_compact_z_p_z_combo_5_8000_05a18020() {
    // Encoding: 0x05A18020
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=1, Zd=0
    // Fields: Zd=0, Pg=0, Zn=1, sz=0
    let encoding: u32 = 0x05A18020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_compact_z_p_z_combo_6_8000_05a183c0() {
    // Encoding: 0x05A183C0
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=30, Zd=0
    // Fields: Pg=0, sz=0, Zd=0, Zn=30
    let encoding: u32 = 0x05A183C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_compact_z_p_z_combo_7_8000_05a183e0() {
    // Encoding: 0x05A183E0
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=31, Zd=0
    // Fields: Zd=0, Zn=31, Pg=0, sz=0
    let encoding: u32 = 0x05A183E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_compact_z_p_z_combo_8_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=0
    // Fields: sz=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_compact_z_p_z_combo_9_8000_05a18001() {
    // Encoding: 0x05A18001
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=1
    // Fields: sz=0, Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x05A18001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_compact_z_p_z_combo_10_8000_05a1801e() {
    // Encoding: 0x05A1801E
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=30
    // Fields: Pg=0, sz=0, Zn=0, Zd=30
    let encoding: u32 = 0x05A1801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_compact_z_p_z_combo_11_8000_05a1801f() {
    // Encoding: 0x05A1801F
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=31
    // Fields: sz=0, Zd=31, Pg=0, Zn=0
    let encoding: u32 = 0x05A1801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_compact_z_p_z_special_sz_0_size_variant_0_32768_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ special value sz = 0 (Size variant 0)
    // Fields: Zd=0, Pg=0, Zn=0, sz=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_compact_z_p_z_special_sz_1_size_variant_1_32768_05e18000() {
    // Encoding: 0x05E18000
    // Test COMPACT_Z.P.Z__ special value sz = 1 (Size variant 1)
    // Fields: sz=1, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_compact_z_p_z_invalid_0_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0, sz=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_compact_z_p_z_invalid_1_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_compact_z_p_z_reg_write_0_05a18000() {
    // Test COMPACT_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x05A18000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05A18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SW_Z.P.AI_D Tests
// ============================================================================

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_0_zero_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_1_poweroftwo_a000_c521a000() {
    // Encoding: 0xC521A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=1
    let encoding: u32 = 0xC521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_c523a000() {
    // Encoding: 0xC523A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC523A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_4_poweroftwo_a000_c524a000() {
    // Encoding: 0xC524A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=4
    let encoding: u32 = 0xC524A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_c527a000() {
    // Encoding: 0xC527A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=7, Pg=0, Zn=0
    let encoding: u32 = 0xC527A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_8_poweroftwo_a000_c528a000() {
    // Encoding: 0xC528A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=8
    let encoding: u32 = 0xC528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_c52fa000() {
    // Encoding: 0xC52FA000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC52FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_16_poweroftwo_a000_c530a000() {
    // Encoding: 0xC530A000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm5=16, Zn=0
    let encoding: u32 = 0xC530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ldff1sw_z_p_ai_d_field_imm5_31_max_a000_c53fa000() {
    // Encoding: 0xC53FA000
    // Test LDFF1SW_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=31
    let encoding: u32 = 0xC53FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_ai_d_field_pg_0_min_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_ai_d_field_pg_1_poweroftwo_a000_c520a400() {
    // Encoding: 0xC520A400
    // Test LDFF1SW_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Pg=1, Zt=0
    let encoding: u32 = 0xC520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_0_min_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_1_poweroftwo_a000_c520a020() {
    // Encoding: 0xC520A020
    // Test LDFF1SW_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zn=1, Pg=0, imm5=0
    let encoding: u32 = 0xC520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_30_poweroftwominusone_a000_c520a3c0() {
    // Encoding: 0xC520A3C0
    // Test LDFF1SW_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, imm5=0, Zt=0
    let encoding: u32 = 0xC520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_ai_d_field_zn_31_max_a000_c520a3e0() {
    // Encoding: 0xC520A3E0
    // Test LDFF1SW_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=31
    let encoding: u32 = 0xC520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_0_min_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_1_poweroftwo_a000_c520a001() {
    // Encoding: 0xC520A001
    // Test LDFF1SW_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm5=0, Zn=0
    let encoding: u32 = 0xC520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_30_poweroftwominusone_a000_c520a01e() {
    // Encoding: 0xC520A01E
    // Test LDFF1SW_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_ai_d_field_zt_31_max_a000_c520a01f() {
    // Encoding: 0xC520A01F
    // Test LDFF1SW_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zt=31, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xC520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_0_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_1_a000_c521a000() {
    // Encoding: 0xC521A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=1, Pg=0, Zn=0, Zt=0
    // Fields: imm5=1, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_2_a000_c523a000() {
    // Encoding: 0xC523A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=3, Pg=0, Zn=0, Zt=0
    // Fields: imm5=3, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC523A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_3_a000_c524a000() {
    // Encoding: 0xC524A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=4, Pg=0, Zn=0, Zt=0
    // Fields: imm5=4, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xC524A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_4_a000_c527a000() {
    // Encoding: 0xC527A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=7, Pg=0, Zn=0, Zt=0
    // Fields: imm5=7, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xC527A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_5_a000_c528a000() {
    // Encoding: 0xC528A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=8, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, imm5=8, Zt=0
    let encoding: u32 = 0xC528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_6_a000_c52fa000() {
    // Encoding: 0xC52FA000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=15, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, Zt=0, imm5=15
    let encoding: u32 = 0xC52FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_7_a000_c530a000() {
    // Encoding: 0xC530A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=16, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, imm5=16, Zt=0, Pg=0
    let encoding: u32 = 0xC530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_8_a000_c53fa000() {
    // Encoding: 0xC53FA000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=31, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm5=31, Zn=0
    let encoding: u32 = 0xC53FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_9_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldff1sw_z_p_ai_d_combo_10_a000_c520a400() {
    // Encoding: 0xC520A400
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=1, Zn=0, Zt=0
    // Fields: Pg=1, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_11_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_12_a000_c520a020() {
    // Encoding: 0xC520A020
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=1, Zt=0
    // Fields: Zt=0, imm5=0, Zn=1, Pg=0
    let encoding: u32 = 0xC520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_13_a000_c520a3c0() {
    // Encoding: 0xC520A3C0
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=30, Zt=0
    // Fields: imm5=0, Pg=0, Zt=0, Zn=30
    let encoding: u32 = 0xC520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_14_a000_c520a3e0() {
    // Encoding: 0xC520A3E0
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=31, Zt=0
    // Fields: Zn=31, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xC520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_15_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_16_a000_c520a001() {
    // Encoding: 0xC520A001
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=1
    // Fields: Pg=0, Zt=1, imm5=0, Zn=0
    let encoding: u32 = 0xC520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_17_a000_c520a01e() {
    // Encoding: 0xC520A01E
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=30
    // Fields: Pg=0, Zn=0, imm5=0, Zt=30
    let encoding: u32 = 0xC520A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldff1sw_z_p_ai_d_combo_18_a000_c520a01f() {
    // Encoding: 0xC520A01F
    // Test LDFF1SW_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=31
    // Fields: Zn=0, Zt=31, Pg=0, imm5=0
    let encoding: u32 = 0xC520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_ai_d_invalid_0_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_ai_d_invalid_1_a000_c520a000() {
    // Encoding: 0xC520A000
    // Test LDFF1SW_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xC520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1SW_Z.P.AI_D
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_ai_d_reg_write_0_c520a000() {
    // Test LDFF1SW_Z.P.AI_D register write: SimdFromField("t")
    // Encoding: 0xC520A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC520A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1SW_Z.P.BR_S64 Tests
// ============================================================================

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_1_poweroftwo_6000_a4816000() {
    // Encoding: 0xA4816000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=1
    let encoding: u32 = 0xA4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_30_poweroftwominusone_6000_a49e6000() {
    // Encoding: 0xA49E6000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rm_31_max_6000_a49f6000() {
    // Encoding: 0xA49F6000
    // Test LDFF1SW_Z.P.BR_S64 field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Rm=31, Pg=0
    let encoding: u32 = 0xA49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_pg_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_pg_1_poweroftwo_6000_a4806400() {
    // Encoding: 0xA4806400
    // Test LDFF1SW_Z.P.BR_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xA4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_1_poweroftwo_6000_a4806020() {
    // Encoding: 0xA4806020
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=1
    let encoding: u32 = 0xA4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_30_poweroftwominusone_6000_a48063c0() {
    // Encoding: 0xA48063C0
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1sw_z_p_br_s64_field_rn_31_max_6000_a48063e0() {
    // Encoding: 0xA48063E0
    // Test LDFF1SW_Z.P.BR_S64 field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_0_min_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_1_poweroftwo_6000_a4806001() {
    // Encoding: 0xA4806001
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=1, Rn=0
    let encoding: u32 = 0xA4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_30_poweroftwominusone_6000_a480601e() {
    // Encoding: 0xA480601E
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1sw_z_p_br_s64_field_zt_31_max_6000_a480601f() {
    // Encoding: 0xA480601F
    // Test LDFF1SW_Z.P.BR_S64 field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_0_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_1_6000_a4816000() {
    // Encoding: 0xA4816000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=1, Pg=0
    let encoding: u32 = 0xA4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_2_6000_a49e6000() {
    // Encoding: 0xA49E6000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rm=30, Rn=0
    let encoding: u32 = 0xA49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_3_6000_a49f6000() {
    // Encoding: 0xA49F6000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=31, Pg=0, Rn=0
    let encoding: u32 = 0xA49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_4_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_5_6000_a4806400() {
    // Encoding: 0xA4806400
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xA4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_6_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_7_6000_a4806020() {
    // Encoding: 0xA4806020
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Rm=0, Rn=1, Pg=0
    let encoding: u32 = 0xA4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_8_6000_a48063c0() {
    // Encoding: 0xA48063C0
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Rm=0, Pg=0, Rn=30
    let encoding: u32 = 0xA48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_9_6000_a48063e0() {
    // Encoding: 0xA48063E0
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldff1sw_z_p_br_s64_combo_10_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldff1sw_z_p_br_s64_combo_11_6000_a4806001() {
    // Encoding: 0xA4806001
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, Rn=0, Rm=0
    let encoding: u32 = 0xA4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldff1sw_z_p_br_s64_combo_12_6000_a480601e() {
    // Encoding: 0xA480601E
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Zt=30, Pg=0, Rm=0
    let encoding: u32 = 0xA480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldff1sw_z_p_br_s64_combo_13_6000_a480601f() {
    // Encoding: 0xA480601F
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Rm=0, Zt=31, Rn=0
    let encoding: u32 = 0xA480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_14_6000_a4816400() {
    // Encoding: 0xA4816400
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Rm=1, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xA4816400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_15_6000_a49f7c00() {
    // Encoding: 0xA49F7C00
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Rm=31, Pg=31, Rn=0, Zt=0
    let encoding: u32 = 0xA49F7C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_16_6000_a4816020() {
    // Encoding: 0xA4816020
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Pg=0, Zt=0, Rm=1
    let encoding: u32 = 0xA4816020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_17_6000_a49f63e0() {
    // Encoding: 0xA49F63E0
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Rm=31, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA49F63E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_18_6000_a4806420() {
    // Encoding: 0xA4806420
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rm=0, Rn=1, Pg=1, Zt=0
    let encoding: u32 = 0xA4806420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldff1sw_z_p_br_s64_combo_19_6000_a4807fe0() {
    // Encoding: 0xA4807FE0
    // Test LDFF1SW_Z.P.BR_S64 field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Pg=31, Rm=0, Rn=31
    let encoding: u32 = 0xA4807FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1sw_z_p_br_s64_special_rn_31_stack_pointer_sp_may_require_alignment_24576_a48063e0() {
    // Encoding: 0xA48063E0
    // Test LDFF1SW_Z.P.BR_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xA48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_br_s64_invalid_0_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1sw_z_p_br_s64_invalid_1_6000_a4806000() {
    // Encoding: 0xA4806000
    // Test LDFF1SW_Z.P.BR_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1sw_z_p_br_s64_reg_write_0_a4806000() {
    // Test LDFF1SW_Z.P.BR_S64 register write: SimdFromField("t")
    // Encoding: 0xA4806000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4806000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1SW_Z.P.BR_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1sw_z_p_br_s64_sp_rn_a48063e0() {
    // Test LDFF1SW_Z.P.BR_S64 with Rn = SP (31)
    // Encoding: 0xA48063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA48063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1H_Z.P.AI_S Tests
// ============================================================================

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1h_z_p_ai_s_field_imm5_0_zero_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1h_z_p_ai_s_field_imm5_1_poweroftwo_a000_e4e1a000() {
    // Encoding: 0xE4E1A000
    // Test ST1H_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=1, Zn=0
    let encoding: u32 = 0xE4E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1h_z_p_ai_s_field_imm5_3_poweroftwominusone_a000_e4e3a000() {
    // Encoding: 0xE4E3A000
    // Test ST1H_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=3, Zt=0
    let encoding: u32 = 0xE4E3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_4_poweroftwo_a000_e4e4a000() {
    // Encoding: 0xE4E4A000
    // Test ST1H_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xE4E4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1h_z_p_ai_s_field_imm5_7_poweroftwominusone_a000_e4e7a000() {
    // Encoding: 0xE4E7A000
    // Test ST1H_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm5=7, Zn=0
    let encoding: u32 = 0xE4E7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_8_poweroftwo_a000_e4e8a000() {
    // Encoding: 0xE4E8A000
    // Test ST1H_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Zn=0, imm5=8, Pg=0
    let encoding: u32 = 0xE4E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_15_poweroftwominusone_a000_e4efa000() {
    // Encoding: 0xE4EFA000
    // Test ST1H_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, imm5=15, Zt=0
    let encoding: u32 = 0xE4EFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_16_poweroftwo_a000_e4f0a000() {
    // Encoding: 0xE4F0A000
    // Test ST1H_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Pg=0, imm5=16, Zt=0, Zn=0
    let encoding: u32 = 0xE4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_31_max_a000_e4ffa000() {
    // Encoding: 0xE4FFA000
    // Test ST1H_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Pg=0, Zn=0
    let encoding: u32 = 0xE4FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_ai_s_field_pg_0_min_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_ai_s_field_pg_1_poweroftwo_a000_e4e0a400() {
    // Encoding: 0xE4E0A400
    // Test ST1H_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xE4E0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_s_field_zn_0_min_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_s_field_zn_1_poweroftwo_a000_e4e0a020() {
    // Encoding: 0xE4E0A020
    // Test ST1H_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zt=0, imm5=0
    let encoding: u32 = 0xE4E0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_s_field_zn_30_poweroftwominusone_a000_e4e0a3c0() {
    // Encoding: 0xE4E0A3C0
    // Test ST1H_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_s_field_zn_31_max_a000_e4e0a3e0() {
    // Encoding: 0xE4E0A3E0
    // Test ST1H_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zn=31, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_s_field_zt_0_min_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_s_field_zt_1_poweroftwo_a000_e4e0a001() {
    // Encoding: 0xE4E0A001
    // Test ST1H_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Zt=1, Pg=0
    let encoding: u32 = 0xE4E0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_s_field_zt_30_poweroftwominusone_a000_e4e0a01e() {
    // Encoding: 0xE4E0A01E
    // Test ST1H_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zt=30, Pg=0, Zn=0
    let encoding: u32 = 0xE4E0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_s_field_zt_31_max_a000_e4e0a01f() {
    // Encoding: 0xE4E0A01F
    // Test ST1H_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Zn=0, imm5=0
    let encoding: u32 = 0xE4E0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1h_z_p_ai_s_combo_0_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_st1h_z_p_ai_s_combo_1_a000_e4e1a000() {
    // Encoding: 0xE4E1A000
    // Test ST1H_Z.P.AI_S field combination: imm5=1, Pg=0, Zn=0, Zt=0
    // Fields: imm5=1, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_st1h_z_p_ai_s_combo_2_a000_e4e3a000() {
    // Encoding: 0xE4E3A000
    // Test ST1H_Z.P.AI_S field combination: imm5=3, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, imm5=3, Zt=0
    let encoding: u32 = 0xE4E3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_st1h_z_p_ai_s_combo_3_a000_e4e4a000() {
    // Encoding: 0xE4E4A000
    // Test ST1H_Z.P.AI_S field combination: imm5=4, Pg=0, Zn=0, Zt=0
    // Fields: imm5=4, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_st1h_z_p_ai_s_combo_4_a000_e4e7a000() {
    // Encoding: 0xE4E7A000
    // Test ST1H_Z.P.AI_S field combination: imm5=7, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, imm5=7, Zt=0, Pg=0
    let encoding: u32 = 0xE4E7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_st1h_z_p_ai_s_combo_5_a000_e4e8a000() {
    // Encoding: 0xE4E8A000
    // Test ST1H_Z.P.AI_S field combination: imm5=8, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, imm5=8, Zt=0
    let encoding: u32 = 0xE4E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_st1h_z_p_ai_s_combo_6_a000_e4efa000() {
    // Encoding: 0xE4EFA000
    // Test ST1H_Z.P.AI_S field combination: imm5=15, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Zt=0, Pg=0, imm5=15
    let encoding: u32 = 0xE4EFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_st1h_z_p_ai_s_combo_7_a000_e4f0a000() {
    // Encoding: 0xE4F0A000
    // Test ST1H_Z.P.AI_S field combination: imm5=16, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, imm5=16, Zn=0, Pg=0
    let encoding: u32 = 0xE4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_st1h_z_p_ai_s_combo_8_a000_e4ffa000() {
    // Encoding: 0xE4FFA000
    // Test ST1H_Z.P.AI_S field combination: imm5=31, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, imm5=31, Zt=0
    let encoding: u32 = 0xE4FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st1h_z_p_ai_s_combo_9_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st1h_z_p_ai_s_combo_10_a000_e4e0a400() {
    // Encoding: 0xE4E0A400
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=1, Zn=0, Zt=0
    // Fields: Pg=1, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_ai_s_combo_11_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_st1h_z_p_ai_s_combo_12_a000_e4e0a020() {
    // Encoding: 0xE4E0A020
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=1, Zt=0
    // Fields: Zt=0, Zn=1, Pg=0, imm5=0
    let encoding: u32 = 0xE4E0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_st1h_z_p_ai_s_combo_13_a000_e4e0a3c0() {
    // Encoding: 0xE4E0A3C0
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=30, Zt=0
    // Fields: Zt=0, Pg=0, imm5=0, Zn=30
    let encoding: u32 = 0xE4E0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_st1h_z_p_ai_s_combo_14_a000_e4e0a3e0() {
    // Encoding: 0xE4E0A3E0
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=31, Zt=0
    // Fields: imm5=0, Zn=31, Pg=0, Zt=0
    let encoding: u32 = 0xE4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_ai_s_combo_15_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st1h_z_p_ai_s_combo_16_a000_e4e0a001() {
    // Encoding: 0xE4E0A001
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=1
    // Fields: Zn=0, Zt=1, Pg=0, imm5=0
    let encoding: u32 = 0xE4E0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st1h_z_p_ai_s_combo_17_a000_e4e0a01e() {
    // Encoding: 0xE4E0A01E
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=30
    // Fields: Zt=30, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE4E0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st1h_z_p_ai_s_combo_18_a000_e4e0a01f() {
    // Encoding: 0xE4E0A01F
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=31
    // Fields: Pg=0, Zn=0, imm5=0, Zt=31
    let encoding: u32 = 0xE4E0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_s_invalid_0_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_s_invalid_1_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1h_z_p_ai_d_field_imm5_0_zero_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1h_z_p_ai_d_field_imm5_1_poweroftwo_a000_e4c1a000() {
    // Encoding: 0xE4C1A000
    // Test ST1H_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=1, Pg=0
    let encoding: u32 = 0xE4C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1h_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_e4c3a000() {
    // Encoding: 0xE4C3A000
    // Test ST1H_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=3, Pg=0, Zn=0
    let encoding: u32 = 0xE4C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_4_poweroftwo_a000_e4c4a000() {
    // Encoding: 0xE4C4A000
    // Test ST1H_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=4
    let encoding: u32 = 0xE4C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1h_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_e4c7a000() {
    // Encoding: 0xE4C7A000
    // Test ST1H_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=7
    let encoding: u32 = 0xE4C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_8_poweroftwo_a000_e4c8a000() {
    // Encoding: 0xE4C8A000
    // Test ST1H_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm5=8, Zn=0
    let encoding: u32 = 0xE4C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_e4cfa000() {
    // Encoding: 0xE4CFA000
    // Test ST1H_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=15, Zn=0, Zt=0
    let encoding: u32 = 0xE4CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_16_poweroftwo_a000_e4d0a000() {
    // Encoding: 0xE4D0A000
    // Test ST1H_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=16
    let encoding: u32 = 0xE4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_31_max_a000_e4dfa000() {
    // Encoding: 0xE4DFA000
    // Test ST1H_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Zn=0, Pg=0
    let encoding: u32 = 0xE4DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_ai_d_field_pg_0_min_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field Pg = 0 (Min)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_ai_d_field_pg_1_poweroftwo_a000_e4c0a400() {
    // Encoding: 0xE4C0A400
    // Test ST1H_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, Pg=1, Zt=0
    let encoding: u32 = 0xE4C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_d_field_zn_0_min_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_d_field_zn_1_poweroftwo_a000_e4c0a020() {
    // Encoding: 0xE4C0A020
    // Test ST1H_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=1
    let encoding: u32 = 0xE4C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_d_field_zn_30_poweroftwominusone_a000_e4c0a3c0() {
    // Encoding: 0xE4C0A3C0
    // Test ST1H_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_d_field_zn_31_max_a000_e4c0a3e0() {
    // Encoding: 0xE4C0A3E0
    // Test ST1H_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=31
    let encoding: u32 = 0xE4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_d_field_zt_0_min_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_d_field_zt_1_poweroftwo_a000_e4c0a001() {
    // Encoding: 0xE4C0A001
    // Test ST1H_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, Zt=1, Pg=0
    let encoding: u32 = 0xE4C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_d_field_zt_30_poweroftwominusone_a000_e4c0a01e() {
    // Encoding: 0xE4C0A01E
    // Test ST1H_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zt=30, imm5=0
    let encoding: u32 = 0xE4C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_d_field_zt_31_max_a000_e4c0a01f() {
    // Encoding: 0xE4C0A01F
    // Test ST1H_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, Pg=0, Zt=31, imm5=0
    let encoding: u32 = 0xE4C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1h_z_p_ai_d_combo_0_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_st1h_z_p_ai_d_combo_1_a000_e4c1a000() {
    // Encoding: 0xE4C1A000
    // Test ST1H_Z.P.AI_D field combination: imm5=1, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Pg=0, imm5=1, Zt=0
    let encoding: u32 = 0xE4C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_st1h_z_p_ai_d_combo_2_a000_e4c3a000() {
    // Encoding: 0xE4C3A000
    // Test ST1H_Z.P.AI_D field combination: imm5=3, Pg=0, Zn=0, Zt=0
    // Fields: imm5=3, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_st1h_z_p_ai_d_combo_3_a000_e4c4a000() {
    // Encoding: 0xE4C4A000
    // Test ST1H_Z.P.AI_D field combination: imm5=4, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zn=0, imm5=4
    let encoding: u32 = 0xE4C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_st1h_z_p_ai_d_combo_4_a000_e4c7a000() {
    // Encoding: 0xE4C7A000
    // Test ST1H_Z.P.AI_D field combination: imm5=7, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zn=0, imm5=7
    let encoding: u32 = 0xE4C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_st1h_z_p_ai_d_combo_5_a000_e4c8a000() {
    // Encoding: 0xE4C8A000
    // Test ST1H_Z.P.AI_D field combination: imm5=8, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Zt=0, imm5=8, Pg=0
    let encoding: u32 = 0xE4C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_st1h_z_p_ai_d_combo_6_a000_e4cfa000() {
    // Encoding: 0xE4CFA000
    // Test ST1H_Z.P.AI_D field combination: imm5=15, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, imm5=15, Zt=0
    let encoding: u32 = 0xE4CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_st1h_z_p_ai_d_combo_7_a000_e4d0a000() {
    // Encoding: 0xE4D0A000
    // Test ST1H_Z.P.AI_D field combination: imm5=16, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Zt=0, Pg=0, imm5=16
    let encoding: u32 = 0xE4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_st1h_z_p_ai_d_combo_8_a000_e4dfa000() {
    // Encoding: 0xE4DFA000
    // Test ST1H_Z.P.AI_D field combination: imm5=31, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, imm5=31, Zt=0, Zn=0
    let encoding: u32 = 0xE4DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st1h_z_p_ai_d_combo_9_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st1h_z_p_ai_d_combo_10_a000_e4c0a400() {
    // Encoding: 0xE4C0A400
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=1, Zn=0, Zt=0
    // Fields: imm5=0, Pg=1, Zt=0, Zn=0
    let encoding: u32 = 0xE4C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_ai_d_combo_11_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_st1h_z_p_ai_d_combo_12_a000_e4c0a020() {
    // Encoding: 0xE4C0A020
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=1, Zt=0
    // Fields: Zt=0, imm5=0, Pg=0, Zn=1
    let encoding: u32 = 0xE4C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_st1h_z_p_ai_d_combo_13_a000_e4c0a3c0() {
    // Encoding: 0xE4C0A3C0
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=30, Zt=0
    // Fields: Zt=0, imm5=0, Zn=30, Pg=0
    let encoding: u32 = 0xE4C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_st1h_z_p_ai_d_combo_14_a000_e4c0a3e0() {
    // Encoding: 0xE4C0A3E0
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=31, Zt=0
    // Fields: Pg=0, Zt=0, Zn=31, imm5=0
    let encoding: u32 = 0xE4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_ai_d_combo_15_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st1h_z_p_ai_d_combo_16_a000_e4c0a001() {
    // Encoding: 0xE4C0A001
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=1
    // Fields: Pg=0, imm5=0, Zt=1, Zn=0
    let encoding: u32 = 0xE4C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st1h_z_p_ai_d_combo_17_a000_e4c0a01e() {
    // Encoding: 0xE4C0A01E
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=30
    // Fields: Zt=30, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xE4C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st1h_z_p_ai_d_combo_18_a000_e4c0a01f() {
    // Encoding: 0xE4C0A01F
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=31
    // Fields: imm5=0, Zn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE4C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_d_invalid_0_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_d_invalid_1_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_ai_s_store_0_e4e0a000() {
    // Test ST1H_Z.P.AI_S memory store: 8 bytes
    // Encoding: 0xE4E0A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4E0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_ai_d_store_0_e4c0a000() {
    // Test ST1H_Z.P.AI_D memory store: 8 bytes
    // Encoding: 0xE4C0A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1H_Z.P.BR__ Tests
// ============================================================================

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1h_z_p_br_field_size_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1h_z_p_br_field_size_1_poweroftwo_4000_e4a04000() {
    // Encoding: 0xE4A04000
    // Test ST1H_Z.P.BR__ field size = 1 (PowerOfTwo)
    // Fields: Rm=0, size=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1h_z_p_br_field_size_2_poweroftwo_4000_e4c04000() {
    // Encoding: 0xE4C04000
    // Test ST1H_Z.P.BR__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0, size=2
    let encoding: u32 = 0xE4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1h_z_p_br_field_size_3_max_4000_e4e04000() {
    // Encoding: 0xE4E04000
    // Test ST1H_Z.P.BR__ field size = 3 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, size=3, Rm=0
    let encoding: u32 = 0xE4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_br_field_rm_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, size=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_br_field_rm_1_poweroftwo_4000_e4814000() {
    // Encoding: 0xE4814000
    // Test ST1H_Z.P.BR__ field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=1, Rn=0, size=0
    let encoding: u32 = 0xE4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_br_field_rm_30_poweroftwominusone_4000_e49e4000() {
    // Encoding: 0xE49E4000
    // Test ST1H_Z.P.BR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Rn=0, Zt=0, Rm=30
    let encoding: u32 = 0xE49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st1h_z_p_br_field_rm_31_max_4000_e49f4000() {
    // Encoding: 0xE49F4000
    // Test ST1H_Z.P.BR__ field Rm = 31 (Max)
    // Fields: Rn=0, size=0, Pg=0, Zt=0, Rm=31
    let encoding: u32 = 0xE49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_br_field_pg_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_br_field_pg_1_poweroftwo_4000_e4804400() {
    // Encoding: 0xE4804400
    // Test ST1H_Z.P.BR__ field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, size=0, Pg=1, Zt=0
    let encoding: u32 = 0xE4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_br_field_rn_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Rn = 0 (Min)
    // Fields: size=0, Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_br_field_rn_1_poweroftwo_4000_e4804020() {
    // Encoding: 0xE4804020
    // Test ST1H_Z.P.BR__ field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, size=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_br_field_rn_30_poweroftwominusone_4000_e48043c0() {
    // Encoding: 0xE48043C0
    // Test ST1H_Z.P.BR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Rn=30, Rm=0, Zt=0
    let encoding: u32 = 0xE48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_br_field_rn_31_max_4000_e48043e0() {
    // Encoding: 0xE48043E0
    // Test ST1H_Z.P.BR__ field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, size=0, Pg=0, Rn=31
    let encoding: u32 = 0xE48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_br_field_zt_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0, size=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_br_field_zt_1_poweroftwo_4000_e4804001() {
    // Encoding: 0xE4804001
    // Test ST1H_Z.P.BR__ field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=1, size=0
    let encoding: u32 = 0xE4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_br_field_zt_30_poweroftwominusone_4000_e480401e() {
    // Encoding: 0xE480401E
    // Test ST1H_Z.P.BR__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Rm=0, size=0, Pg=0
    let encoding: u32 = 0xE480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_br_field_zt_31_max_4000_e480401f() {
    // Encoding: 0xE480401F
    // Test ST1H_Z.P.BR__ field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Zt=31, Pg=0, size=0
    let encoding: u32 = 0xE480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1h_z_p_br_combo_0_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=0, size=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_st1h_z_p_br_combo_1_4000_e4a04000() {
    // Encoding: 0xE4A04000
    // Test ST1H_Z.P.BR__ field combination: size=1, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, size=1, Rn=0, Rm=0
    let encoding: u32 = 0xE4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_st1h_z_p_br_combo_2_4000_e4c04000() {
    // Encoding: 0xE4C04000
    // Test ST1H_Z.P.BR__ field combination: size=2, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, size=2, Rn=0, Zt=0
    let encoding: u32 = 0xE4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_st1h_z_p_br_combo_3_4000_e4e04000() {
    // Encoding: 0xE4E04000
    // Test ST1H_Z.P.BR__ field combination: size=3, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, size=3, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st1h_z_p_br_combo_4_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, size=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_st1h_z_p_br_combo_5_4000_e4814000() {
    // Encoding: 0xE4814000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, size=0, Rm=1, Rn=0
    let encoding: u32 = 0xE4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_st1h_z_p_br_combo_6_4000_e49e4000() {
    // Encoding: 0xE49E4000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rm=30, size=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_st1h_z_p_br_combo_7_4000_e49f4000() {
    // Encoding: 0xE49F4000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, size=0, Rm=31, Rn=0, Zt=0
    let encoding: u32 = 0xE49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st1h_z_p_br_combo_8_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, size=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st1h_z_p_br_combo_9_4000_e4804400() {
    // Encoding: 0xE4804400
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=1, size=0
    let encoding: u32 = 0xE4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_st1h_z_p_br_combo_10_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_st1h_z_p_br_combo_11_4000_e4804020() {
    // Encoding: 0xE4804020
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Pg=0, Rn=1, Rm=0, size=0
    let encoding: u32 = 0xE4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_st1h_z_p_br_combo_12_4000_e48043c0() {
    // Encoding: 0xE48043C0
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Rn=30, size=0, Rm=0, Pg=0
    let encoding: u32 = 0xE48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_st1h_z_p_br_combo_13_4000_e48043e0() {
    // Encoding: 0xE48043E0
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rm=0, Rn=31, Zt=0, size=0, Pg=0
    let encoding: u32 = 0xE48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_br_combo_14_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st1h_z_p_br_combo_15_4000_e4804001() {
    // Encoding: 0xE4804001
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, Rm=0, Rn=0, size=0
    let encoding: u32 = 0xE4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st1h_z_p_br_combo_16_4000_e480401e() {
    // Encoding: 0xE480401E
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Pg=0, size=0, Rm=0, Rn=0, Zt=30
    let encoding: u32 = 0xE480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st1h_z_p_br_combo_17_4000_e480401f() {
    // Encoding: 0xE480401F
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: size=0, Rn=0, Zt=31, Pg=0, Rm=0
    let encoding: u32 = 0xE480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_st1h_z_p_br_combo_18_4000_e4814400() {
    // Encoding: 0xE4814400
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, size=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xE4814400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_st1h_z_p_br_combo_19_4000_e49f5c00() {
    // Encoding: 0xE49F5C00
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Pg=31, Rm=31, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE49F5C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1h_z_p_br_special_size_0_size_variant_0_16384_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1h_z_p_br_special_size_1_size_variant_1_16384_e4a04000() {
    // Encoding: 0xE4A04000
    // Test ST1H_Z.P.BR__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1h_z_p_br_special_size_2_size_variant_2_16384_e4c04000() {
    // Encoding: 0xE4C04000
    // Test ST1H_Z.P.BR__ special value size = 2 (Size variant 2)
    // Fields: size=2, Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1h_z_p_br_special_size_3_size_variant_3_16384_e4e04000() {
    // Encoding: 0xE4E04000
    // Test ST1H_Z.P.BR__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_br_special_rn_31_stack_pointer_sp_may_require_alignment_16384_e48043e0() {
    // Encoding: 0xE48043E0
    // Test ST1H_Z.P.BR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rm=0, Rn=31, size=0, Pg=0
    let encoding: u32 = 0xE48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_0_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, size=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_1_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, size=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_2_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0, size=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_3_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, size=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_4_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: size=0, Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_5_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_br_sp_rn_e48043e0() {
    // Test ST1H_Z.P.BR__ with Rn = SP (31)
    // Encoding: 0xE48043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE48043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_br_store_0_e4804020() {
    // Test ST1H_Z.P.BR__ memory store: 8 bytes
    // Encoding: 0xE4804020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4804020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRSQRTS_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frsqrts_z_zz_field_size_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frsqrts_z_zz_field_size_1_poweroftwo_1c00_65401c00() {
    // Encoding: 0x65401C00
    // Test FRSQRTS_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, size=1, Zm=0, Zd=0
    let encoding: u32 = 0x65401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frsqrts_z_zz_field_size_2_poweroftwo_1c00_65801c00() {
    // Encoding: 0x65801C00
    // Test FRSQRTS_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x65801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frsqrts_z_zz_field_size_3_max_1c00_65c01c00() {
    // Encoding: 0x65C01C00
    // Test FRSQRTS_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65C01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrts_z_zz_field_zm_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrts_z_zz_field_zm_1_poweroftwo_1c00_65011c00() {
    // Encoding: 0x65011C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Zn=0, Zd=0
    let encoding: u32 = 0x65011C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrts_z_zz_field_zm_30_poweroftwominusone_1c00_651e1c00() {
    // Encoding: 0x651E1C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x651E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrts_z_zz_field_zm_31_max_1c00_651f1c00() {
    // Encoding: 0x651F1C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x651F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrts_z_zz_field_zn_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrts_z_zz_field_zn_1_poweroftwo_1c00_65001c20() {
    // Encoding: 0x65001C20
    // Test FRSQRTS_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x65001C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrts_z_zz_field_zn_30_poweroftwominusone_1c00_65001fc0() {
    // Encoding: 0x65001FC0
    // Test FRSQRTS_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zd=0, Zn=30
    let encoding: u32 = 0x65001FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrts_z_zz_field_zn_31_max_1c00_65001fe0() {
    // Encoding: 0x65001FE0
    // Test FRSQRTS_Z.ZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zm=0, Zn=31, Zd=0
    let encoding: u32 = 0x65001FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrts_z_zz_field_zd_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field Zd = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrts_z_zz_field_zd_1_poweroftwo_1c00_65001c01() {
    // Encoding: 0x65001C01
    // Test FRSQRTS_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zm=0, Zd=1
    let encoding: u32 = 0x65001C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrts_z_zz_field_zd_30_poweroftwominusone_1c00_65001c1e() {
    // Encoding: 0x65001C1E
    // Test FRSQRTS_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65001C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrts_z_zz_field_zd_31_max_1c00_65001c1f() {
    // Encoding: 0x65001C1F
    // Test FRSQRTS_Z.ZZ__ field Zd = 31 (Max)
    // Fields: size=0, Zd=31, Zn=0, Zm=0
    let encoding: u32 = 0x65001C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frsqrts_z_zz_combo_0_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_frsqrts_z_zz_combo_1_1c00_65401c00() {
    // Encoding: 0x65401C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=1, Zm=0, Zn=0, Zd=0
    // Fields: size=1, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_frsqrts_z_zz_combo_2_1c00_65801c00() {
    // Encoding: 0x65801C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=2, Zm=0, Zn=0, Zd=0
    // Fields: size=2, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_frsqrts_z_zz_combo_3_1c00_65c01c00() {
    // Encoding: 0x65C01C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=3, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=3, Zm=0
    let encoding: u32 = 0x65C01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_frsqrts_z_zz_combo_4_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_frsqrts_z_zz_combo_5_1c00_65011c00() {
    // Encoding: 0x65011C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=1, Zn=0, Zd=0
    // Fields: size=0, Zm=1, Zn=0, Zd=0
    let encoding: u32 = 0x65011C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_frsqrts_z_zz_combo_6_1c00_651e1c00() {
    // Encoding: 0x651E1C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=30, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zd=0, Zm=30
    let encoding: u32 = 0x651E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_frsqrts_z_zz_combo_7_1c00_651f1c00() {
    // Encoding: 0x651F1C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=31, Zn=0, Zd=0
    // Fields: size=0, Zm=31, Zd=0, Zn=0
    let encoding: u32 = 0x651F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_frsqrts_z_zz_combo_8_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_frsqrts_z_zz_combo_9_1c00_65001c20() {
    // Encoding: 0x65001C20
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=1, Zd=0
    // Fields: Zn=1, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65001C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_frsqrts_z_zz_combo_10_1c00_65001fc0() {
    // Encoding: 0x65001FC0
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=30, Zd=0
    // Fields: Zm=0, Zd=0, Zn=30, size=0
    let encoding: u32 = 0x65001FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_frsqrts_z_zz_combo_11_1c00_65001fe0() {
    // Encoding: 0x65001FE0
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=31, Zd=0
    // Fields: Zn=31, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x65001FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_frsqrts_z_zz_combo_12_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_frsqrts_z_zz_combo_13_1c00_65001c01() {
    // Encoding: 0x65001C01
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=1
    // Fields: Zd=1, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x65001C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_frsqrts_z_zz_combo_14_1c00_65001c1e() {
    // Encoding: 0x65001C1E
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=30
    // Fields: Zm=0, Zn=0, size=0, Zd=30
    let encoding: u32 = 0x65001C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_frsqrts_z_zz_combo_15_1c00_65001c1f() {
    // Encoding: 0x65001C1F
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=31
    // Fields: Zn=0, size=0, Zm=0, Zd=31
    let encoding: u32 = 0x65001C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frsqrts_z_zz_special_size_0_size_variant_0_7168_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frsqrts_z_zz_special_size_1_size_variant_1_7168_65401c00() {
    // Encoding: 0x65401C00
    // Test FRSQRTS_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zm=0, size=1, Zn=0
    let encoding: u32 = 0x65401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frsqrts_z_zz_special_size_2_size_variant_2_7168_65801c00() {
    // Encoding: 0x65801C00
    // Test FRSQRTS_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x65801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frsqrts_z_zz_special_size_3_size_variant_3_7168_65c01c00() {
    // Encoding: 0x65C01C00
    // Test FRSQRTS_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zn=0, size=3, Zm=0
    let encoding: u32 = 0x65C01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_0_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, Zm=0, size=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_1_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_2_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_3_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frsqrts_z_zz_reg_write_0_65001c00() {
    // Test FRSQRTS_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65001C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65001C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// PRFH_I.P.BR_S Tests
// ============================================================================

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_prfh_i_p_br_s_field_rm_0_min_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, prfop=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_prfh_i_p_br_s_field_rm_1_poweroftwo_c000_8481c000() {
    // Encoding: 0x8481C000
    // Test PRFH_I.P.BR_S field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, prfop=0
    let encoding: u32 = 0x8481C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_prfh_i_p_br_s_field_rm_30_poweroftwominusone_c000_849ec000() {
    // Encoding: 0x849EC000
    // Test PRFH_I.P.BR_S field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, prfop=0, Pg=0
    let encoding: u32 = 0x849EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_prfh_i_p_br_s_field_rm_31_max_c000_849fc000() {
    // Encoding: 0x849FC000
    // Test PRFH_I.P.BR_S field Rm = 31 (Max)
    // Fields: prfop=0, Rm=31, Rn=0, Pg=0
    let encoding: u32 = 0x849FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_prfh_i_p_br_s_field_pg_0_min_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, prfop=0, Rn=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_prfh_i_p_br_s_field_pg_1_poweroftwo_c000_8480c400() {
    // Encoding: 0x8480C400
    // Test PRFH_I.P.BR_S field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, prfop=0
    let encoding: u32 = 0x8480C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_prfh_i_p_br_s_field_rn_0_min_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field Rn = 0 (Min)
    // Fields: Rm=0, prfop=0, Pg=0, Rn=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_prfh_i_p_br_s_field_rn_1_poweroftwo_c000_8480c020() {
    // Encoding: 0x8480C020
    // Test PRFH_I.P.BR_S field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, prfop=0, Rn=1
    let encoding: u32 = 0x8480C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_prfh_i_p_br_s_field_rn_30_poweroftwominusone_c000_8480c3c0() {
    // Encoding: 0x8480C3C0
    // Test PRFH_I.P.BR_S field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, prfop=0
    let encoding: u32 = 0x8480C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_prfh_i_p_br_s_field_rn_31_max_c000_8480c3e0() {
    // Encoding: 0x8480C3E0
    // Test PRFH_I.P.BR_S field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=31, prfop=0
    let encoding: u32 = 0x8480C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_prfh_i_p_br_s_field_prfop_0_min_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field prfop = 0 (Min)
    // Fields: Rm=0, Rn=0, prfop=0, Pg=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_prfh_i_p_br_s_field_prfop_1_poweroftwo_c000_8480c001() {
    // Encoding: 0x8480C001
    // Test PRFH_I.P.BR_S field prfop = 1 (PowerOfTwo)
    // Fields: prfop=1, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0x8480C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_prfh_i_p_br_s_field_prfop_7_poweroftwominusone_c000_8480c007() {
    // Encoding: 0x8480C007
    // Test PRFH_I.P.BR_S field prfop = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, prfop=7, Pg=0
    let encoding: u32 = 0x8480C007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_prfh_i_p_br_s_field_prfop_15_max_c000_8480c00f() {
    // Encoding: 0x8480C00F
    // Test PRFH_I.P.BR_S field prfop = 15 (Max)
    // Fields: Rm=0, Pg=0, prfop=15, Rn=0
    let encoding: u32 = 0x8480C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_prfh_i_p_br_s_combo_0_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=0
    // Fields: Pg=0, prfop=0, Rn=0, Rm=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_prfh_i_p_br_s_combo_1_c000_8481c000() {
    // Encoding: 0x8481C000
    // Test PRFH_I.P.BR_S field combination: Rm=1, Pg=0, Rn=0, prfop=0
    // Fields: prfop=0, Pg=0, Rn=0, Rm=1
    let encoding: u32 = 0x8481C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_prfh_i_p_br_s_combo_2_c000_849ec000() {
    // Encoding: 0x849EC000
    // Test PRFH_I.P.BR_S field combination: Rm=30, Pg=0, Rn=0, prfop=0
    // Fields: Rn=0, Pg=0, prfop=0, Rm=30
    let encoding: u32 = 0x849EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_prfh_i_p_br_s_combo_3_c000_849fc000() {
    // Encoding: 0x849FC000
    // Test PRFH_I.P.BR_S field combination: Rm=31, Pg=0, Rn=0, prfop=0
    // Fields: Rm=31, Rn=0, prfop=0, Pg=0
    let encoding: u32 = 0x849FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_prfh_i_p_br_s_combo_4_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=0
    // Fields: Rm=0, Pg=0, prfop=0, Rn=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_prfh_i_p_br_s_combo_5_c000_8480c400() {
    // Encoding: 0x8480C400
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=1, Rn=0, prfop=0
    // Fields: prfop=0, Rn=0, Pg=1, Rm=0
    let encoding: u32 = 0x8480C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_prfh_i_p_br_s_combo_6_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=0
    // Fields: prfop=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_prfh_i_p_br_s_combo_7_c000_8480c020() {
    // Encoding: 0x8480C020
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=1, prfop=0
    // Fields: Rm=0, Rn=1, Pg=0, prfop=0
    let encoding: u32 = 0x8480C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_prfh_i_p_br_s_combo_8_c000_8480c3c0() {
    // Encoding: 0x8480C3C0
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=30, prfop=0
    // Fields: Rm=0, Pg=0, prfop=0, Rn=30
    let encoding: u32 = 0x8480C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_prfh_i_p_br_s_combo_9_c000_8480c3e0() {
    // Encoding: 0x8480C3E0
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=31, prfop=0
    // Fields: Rm=0, prfop=0, Pg=0, Rn=31
    let encoding: u32 = 0x8480C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=0 (minimum value)
#[test]
fn test_prfh_i_p_br_s_combo_10_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=0
    // Fields: Rm=0, Rn=0, Pg=0, prfop=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=1 (value 1)
#[test]
fn test_prfh_i_p_br_s_combo_11_c000_8480c001() {
    // Encoding: 0x8480C001
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=1
    // Fields: Pg=0, Rm=0, prfop=1, Rn=0
    let encoding: u32 = 0x8480C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=7 (midpoint (7))
#[test]
fn test_prfh_i_p_br_s_combo_12_c000_8480c007() {
    // Encoding: 0x8480C007
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=7
    // Fields: Pg=0, Rn=0, Rm=0, prfop=7
    let encoding: u32 = 0x8480C007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=15 (maximum value (15))
#[test]
fn test_prfh_i_p_br_s_combo_13_c000_8480c00f() {
    // Encoding: 0x8480C00F
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=0, Rn=0, prfop=15
    // Fields: prfop=15, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0x8480C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_prfh_i_p_br_s_combo_14_c000_8481c400() {
    // Encoding: 0x8481C400
    // Test PRFH_I.P.BR_S field combination: Rm=1, Pg=1, Rn=0, prfop=0
    // Fields: Rn=0, Pg=1, Rm=1, prfop=0
    let encoding: u32 = 0x8481C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_prfh_i_p_br_s_combo_15_c000_849fdc00() {
    // Encoding: 0x849FDC00
    // Test PRFH_I.P.BR_S field combination: Rm=31, Pg=31, Rn=0, prfop=0
    // Fields: Rn=0, Pg=31, Rm=31, prfop=0
    let encoding: u32 = 0x849FDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_prfh_i_p_br_s_combo_16_c000_8481c020() {
    // Encoding: 0x8481C020
    // Test PRFH_I.P.BR_S field combination: Rm=1, Pg=0, Rn=1, prfop=0
    // Fields: Rn=1, prfop=0, Pg=0, Rm=1
    let encoding: u32 = 0x8481C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_prfh_i_p_br_s_combo_17_c000_849fc3e0() {
    // Encoding: 0x849FC3E0
    // Test PRFH_I.P.BR_S field combination: Rm=31, Pg=0, Rn=31, prfop=0
    // Fields: Rn=31, prfop=0, Pg=0, Rm=31
    let encoding: u32 = 0x849FC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_prfh_i_p_br_s_combo_18_c000_8480c420() {
    // Encoding: 0x8480C420
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=1, Rn=1, prfop=0
    // Fields: prfop=0, Rm=0, Pg=1, Rn=1
    let encoding: u32 = 0x8480C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_prfh_i_p_br_s_combo_19_c000_8480dfe0() {
    // Encoding: 0x8480DFE0
    // Test PRFH_I.P.BR_S field combination: Rm=0, Pg=31, Rn=31, prfop=0
    // Fields: Rm=0, Rn=31, Pg=31, prfop=0
    let encoding: u32 = 0x8480DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_prfh_i_p_br_s_special_rn_31_stack_pointer_sp_may_require_alignment_49152_8480c3e0() {
    // Encoding: 0x8480C3E0
    // Test PRFH_I.P.BR_S special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: prfop=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0x8480C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_br_s_invalid_0_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: prfop=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_br_s_invalid_1_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, prfop=0, Pg=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_br_s_invalid_2_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, prfop=0, Rm=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_br_s_invalid_3_c000_8480c000() {
    // Encoding: 0x8480C000
    // Test PRFH_I.P.BR_S invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, prfop=0, Rm=0
    let encoding: u32 = 0x8480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.BR_S
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_prfh_i_p_br_s_sp_rn_8480c3e0() {
    // Test PRFH_I.P.BR_S with Rn = SP (31)
    // Encoding: 0x8480C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x8480C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// PRFH_I.P.AI_S Tests
// ============================================================================

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_prfh_i_p_ai_s_field_imm5_0_zero_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field imm5 = 0 (Zero)
    // Fields: imm5=0, prfop=0, Pg=0, Zn=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_prfh_i_p_ai_s_field_imm5_1_poweroftwo_e000_8481e000() {
    // Encoding: 0x8481E000
    // Test PRFH_I.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: prfop=0, Zn=0, imm5=1, Pg=0
    let encoding: u32 = 0x8481E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_prfh_i_p_ai_s_field_imm5_3_poweroftwominusone_e000_8483e000() {
    // Encoding: 0x8483E000
    // Test PRFH_I.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=3, prfop=0
    let encoding: u32 = 0x8483E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_prfh_i_p_ai_s_field_imm5_4_poweroftwo_e000_8484e000() {
    // Encoding: 0x8484E000
    // Test PRFH_I.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, prfop=0, Pg=0, Zn=0
    let encoding: u32 = 0x8484E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_prfh_i_p_ai_s_field_imm5_7_poweroftwominusone_e000_8487e000() {
    // Encoding: 0x8487E000
    // Test PRFH_I.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=7, Zn=0, prfop=0
    let encoding: u32 = 0x8487E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_prfh_i_p_ai_s_field_imm5_8_poweroftwo_e000_8488e000() {
    // Encoding: 0x8488E000
    // Test PRFH_I.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, imm5=8, Pg=0, prfop=0
    let encoding: u32 = 0x8488E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_prfh_i_p_ai_s_field_imm5_15_poweroftwominusone_e000_848fe000() {
    // Encoding: 0x848FE000
    // Test PRFH_I.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, prfop=0, imm5=15
    let encoding: u32 = 0x848FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_prfh_i_p_ai_s_field_imm5_16_poweroftwo_e000_8490e000() {
    // Encoding: 0x8490E000
    // Test PRFH_I.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: prfop=0, Pg=0, Zn=0, imm5=16
    let encoding: u32 = 0x8490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_prfh_i_p_ai_s_field_imm5_31_max_e000_849fe000() {
    // Encoding: 0x849FE000
    // Test PRFH_I.P.AI_S field imm5 = 31 (Max)
    // Fields: Pg=0, prfop=0, imm5=31, Zn=0
    let encoding: u32 = 0x849FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_prfh_i_p_ai_s_field_pg_0_min_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field Pg = 0 (Min)
    // Fields: imm5=0, Pg=0, prfop=0, Zn=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_prfh_i_p_ai_s_field_pg_1_poweroftwo_e000_8480e400() {
    // Encoding: 0x8480E400
    // Test PRFH_I.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: prfop=0, Zn=0, imm5=0, Pg=1
    let encoding: u32 = 0x8480E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_prfh_i_p_ai_s_field_zn_0_min_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field Zn = 0 (Min)
    // Fields: prfop=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_prfh_i_p_ai_s_field_zn_1_poweroftwo_e000_8480e020() {
    // Encoding: 0x8480E020
    // Test PRFH_I.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, prfop=0, Pg=0, Zn=1
    let encoding: u32 = 0x8480E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_prfh_i_p_ai_s_field_zn_30_poweroftwominusone_e000_8480e3c0() {
    // Encoding: 0x8480E3C0
    // Test PRFH_I.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, imm5=0, Pg=0, prfop=0
    let encoding: u32 = 0x8480E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_prfh_i_p_ai_s_field_zn_31_max_e000_8480e3e0() {
    // Encoding: 0x8480E3E0
    // Test PRFH_I.P.AI_S field Zn = 31 (Max)
    // Fields: imm5=0, Pg=0, Zn=31, prfop=0
    let encoding: u32 = 0x8480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_prfh_i_p_ai_s_field_prfop_0_min_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field prfop = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, prfop=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_prfh_i_p_ai_s_field_prfop_1_poweroftwo_e000_8480e001() {
    // Encoding: 0x8480E001
    // Test PRFH_I.P.AI_S field prfop = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=0, prfop=1, Pg=0
    let encoding: u32 = 0x8480E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_prfh_i_p_ai_s_field_prfop_7_poweroftwominusone_e000_8480e007() {
    // Encoding: 0x8480E007
    // Test PRFH_I.P.AI_S field prfop = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, prfop=7, imm5=0
    let encoding: u32 = 0x8480E007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_prfh_i_p_ai_s_field_prfop_15_max_e000_8480e00f() {
    // Encoding: 0x8480E00F
    // Test PRFH_I.P.AI_S field prfop = 15 (Max)
    // Fields: prfop=15, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0x8480E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_prfh_i_p_ai_s_combo_0_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, Pg=0, imm5=0, prfop=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_prfh_i_p_ai_s_combo_1_e000_8481e000() {
    // Encoding: 0x8481E000
    // Test PRFH_I.P.AI_S field combination: imm5=1, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, imm5=1, Zn=0, prfop=0
    let encoding: u32 = 0x8481E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_prfh_i_p_ai_s_combo_2_e000_8483e000() {
    // Encoding: 0x8483E000
    // Test PRFH_I.P.AI_S field combination: imm5=3, Pg=0, Zn=0, prfop=0
    // Fields: prfop=0, Pg=0, imm5=3, Zn=0
    let encoding: u32 = 0x8483E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_prfh_i_p_ai_s_combo_3_e000_8484e000() {
    // Encoding: 0x8484E000
    // Test PRFH_I.P.AI_S field combination: imm5=4, Pg=0, Zn=0, prfop=0
    // Fields: imm5=4, Pg=0, prfop=0, Zn=0
    let encoding: u32 = 0x8484E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_prfh_i_p_ai_s_combo_4_e000_8487e000() {
    // Encoding: 0x8487E000
    // Test PRFH_I.P.AI_S field combination: imm5=7, Pg=0, Zn=0, prfop=0
    // Fields: imm5=7, Zn=0, Pg=0, prfop=0
    let encoding: u32 = 0x8487E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_prfh_i_p_ai_s_combo_5_e000_8488e000() {
    // Encoding: 0x8488E000
    // Test PRFH_I.P.AI_S field combination: imm5=8, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, imm5=8, prfop=0, Pg=0
    let encoding: u32 = 0x8488E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_prfh_i_p_ai_s_combo_6_e000_848fe000() {
    // Encoding: 0x848FE000
    // Test PRFH_I.P.AI_S field combination: imm5=15, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, imm5=15, prfop=0, Zn=0
    let encoding: u32 = 0x848FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_prfh_i_p_ai_s_combo_7_e000_8490e000() {
    // Encoding: 0x8490E000
    // Test PRFH_I.P.AI_S field combination: imm5=16, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, prfop=0, imm5=16, Zn=0
    let encoding: u32 = 0x8490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_prfh_i_p_ai_s_combo_8_e000_849fe000() {
    // Encoding: 0x849FE000
    // Test PRFH_I.P.AI_S field combination: imm5=31, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, imm5=31, Pg=0, prfop=0
    let encoding: u32 = 0x849FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_prfh_i_p_ai_s_combo_9_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: prfop=0, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_prfh_i_p_ai_s_combo_10_e000_8480e400() {
    // Encoding: 0x8480E400
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=1, Zn=0, prfop=0
    // Fields: prfop=0, Pg=1, imm5=0, Zn=0
    let encoding: u32 = 0x8480E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_prfh_i_p_ai_s_combo_11_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, prfop=0, Zn=0, imm5=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_prfh_i_p_ai_s_combo_12_e000_8480e020() {
    // Encoding: 0x8480E020
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=1, prfop=0
    // Fields: imm5=0, Zn=1, Pg=0, prfop=0
    let encoding: u32 = 0x8480E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_prfh_i_p_ai_s_combo_13_e000_8480e3c0() {
    // Encoding: 0x8480E3C0
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=30, prfop=0
    // Fields: imm5=0, Pg=0, Zn=30, prfop=0
    let encoding: u32 = 0x8480E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_prfh_i_p_ai_s_combo_14_e000_8480e3e0() {
    // Encoding: 0x8480E3E0
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=31, prfop=0
    // Fields: prfop=0, imm5=0, Zn=31, Pg=0
    let encoding: u32 = 0x8480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=0 (minimum value)
#[test]
fn test_prfh_i_p_ai_s_combo_15_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: imm5=0, Pg=0, prfop=0, Zn=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=1 (value 1)
#[test]
fn test_prfh_i_p_ai_s_combo_16_e000_8480e001() {
    // Encoding: 0x8480E001
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=1
    // Fields: Pg=0, imm5=0, Zn=0, prfop=1
    let encoding: u32 = 0x8480E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=7 (midpoint (7))
#[test]
fn test_prfh_i_p_ai_s_combo_17_e000_8480e007() {
    // Encoding: 0x8480E007
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=7
    // Fields: imm5=0, Pg=0, prfop=7, Zn=0
    let encoding: u32 = 0x8480E007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=15 (maximum value (15))
#[test]
fn test_prfh_i_p_ai_s_combo_18_e000_8480e00f() {
    // Encoding: 0x8480E00F
    // Test PRFH_I.P.AI_S field combination: imm5=0, Pg=0, Zn=0, prfop=15
    // Fields: Pg=0, prfop=15, Zn=0, imm5=0
    let encoding: u32 = 0x8480E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_ai_s_invalid_0_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, imm5=0, Pg=0, prfop=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_ai_s_invalid_1_e000_8480e000() {
    // Encoding: 0x8480E000
    // Test PRFH_I.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: prfop=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0x8480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_prfh_i_p_ai_d_field_imm5_0_zero_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field imm5 = 0 (Zero)
    // Fields: prfop=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_prfh_i_p_ai_d_field_imm5_1_poweroftwo_e000_c481e000() {
    // Encoding: 0xC481E000
    // Test PRFH_I.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, prfop=0, imm5=1
    let encoding: u32 = 0xC481E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_prfh_i_p_ai_d_field_imm5_3_poweroftwominusone_e000_c483e000() {
    // Encoding: 0xC483E000
    // Test PRFH_I.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: prfop=0, Zn=0, Pg=0, imm5=3
    let encoding: u32 = 0xC483E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_prfh_i_p_ai_d_field_imm5_4_poweroftwo_e000_c484e000() {
    // Encoding: 0xC484E000
    // Test PRFH_I.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, imm5=4, prfop=0
    let encoding: u32 = 0xC484E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_prfh_i_p_ai_d_field_imm5_7_poweroftwominusone_e000_c487e000() {
    // Encoding: 0xC487E000
    // Test PRFH_I.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, prfop=0, Zn=0
    let encoding: u32 = 0xC487E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_prfh_i_p_ai_d_field_imm5_8_poweroftwo_e000_c488e000() {
    // Encoding: 0xC488E000
    // Test PRFH_I.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: prfop=0, Zn=0, Pg=0, imm5=8
    let encoding: u32 = 0xC488E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_prfh_i_p_ai_d_field_imm5_15_poweroftwominusone_e000_c48fe000() {
    // Encoding: 0xC48FE000
    // Test PRFH_I.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Pg=0, prfop=0, Zn=0
    let encoding: u32 = 0xC48FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_prfh_i_p_ai_d_field_imm5_16_poweroftwo_e000_c490e000() {
    // Encoding: 0xC490E000
    // Test PRFH_I.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: prfop=0, imm5=16, Pg=0, Zn=0
    let encoding: u32 = 0xC490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_prfh_i_p_ai_d_field_imm5_31_max_e000_c49fe000() {
    // Encoding: 0xC49FE000
    // Test PRFH_I.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, prfop=0, imm5=31, Zn=0
    let encoding: u32 = 0xC49FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_prfh_i_p_ai_d_field_pg_0_min_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field Pg = 0 (Min)
    // Fields: prfop=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_prfh_i_p_ai_d_field_pg_1_poweroftwo_e000_c480e400() {
    // Encoding: 0xC480E400
    // Test PRFH_I.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: prfop=0, Pg=1, Zn=0, imm5=0
    let encoding: u32 = 0xC480E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_prfh_i_p_ai_d_field_zn_0_min_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, prfop=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_prfh_i_p_ai_d_field_zn_1_poweroftwo_e000_c480e020() {
    // Encoding: 0xC480E020
    // Test PRFH_I.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: prfop=0, Pg=0, Zn=1, imm5=0
    let encoding: u32 = 0xC480E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_prfh_i_p_ai_d_field_zn_30_poweroftwominusone_e000_c480e3c0() {
    // Encoding: 0xC480E3C0
    // Test PRFH_I.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, imm5=0, prfop=0, Pg=0
    let encoding: u32 = 0xC480E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_prfh_i_p_ai_d_field_zn_31_max_e000_c480e3e0() {
    // Encoding: 0xC480E3E0
    // Test PRFH_I.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, imm5=0, prfop=0, Zn=31
    let encoding: u32 = 0xC480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_prfh_i_p_ai_d_field_prfop_0_min_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field prfop = 0 (Min)
    // Fields: imm5=0, Pg=0, prfop=0, Zn=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_prfh_i_p_ai_d_field_prfop_1_poweroftwo_e000_c480e001() {
    // Encoding: 0xC480E001
    // Test PRFH_I.P.AI_D field prfop = 1 (PowerOfTwo)
    // Fields: Zn=0, imm5=0, prfop=1, Pg=0
    let encoding: u32 = 0xC480E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_prfh_i_p_ai_d_field_prfop_7_poweroftwominusone_e000_c480e007() {
    // Encoding: 0xC480E007
    // Test PRFH_I.P.AI_D field prfop = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, prfop=7, Pg=0, imm5=0
    let encoding: u32 = 0xC480E007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field prfop 0 +: 4`
/// Requirement: FieldBoundary { field: "prfop", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_prfh_i_p_ai_d_field_prfop_15_max_e000_c480e00f() {
    // Encoding: 0xC480E00F
    // Test PRFH_I.P.AI_D field prfop = 15 (Max)
    // Fields: imm5=0, Pg=0, Zn=0, prfop=15
    let encoding: u32 = 0xC480E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_prfh_i_p_ai_d_combo_0_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, prfop=0, imm5=0, Pg=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_prfh_i_p_ai_d_combo_1_e000_c481e000() {
    // Encoding: 0xC481E000
    // Test PRFH_I.P.AI_D field combination: imm5=1, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, Zn=0, imm5=1, prfop=0
    let encoding: u32 = 0xC481E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_prfh_i_p_ai_d_combo_2_e000_c483e000() {
    // Encoding: 0xC483E000
    // Test PRFH_I.P.AI_D field combination: imm5=3, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, prfop=0, imm5=3, Zn=0
    let encoding: u32 = 0xC483E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_prfh_i_p_ai_d_combo_3_e000_c484e000() {
    // Encoding: 0xC484E000
    // Test PRFH_I.P.AI_D field combination: imm5=4, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, imm5=4, prfop=0, Pg=0
    let encoding: u32 = 0xC484E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_prfh_i_p_ai_d_combo_4_e000_c487e000() {
    // Encoding: 0xC487E000
    // Test PRFH_I.P.AI_D field combination: imm5=7, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, Pg=0, imm5=7, prfop=0
    let encoding: u32 = 0xC487E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_prfh_i_p_ai_d_combo_5_e000_c488e000() {
    // Encoding: 0xC488E000
    // Test PRFH_I.P.AI_D field combination: imm5=8, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, imm5=8, Pg=0, prfop=0
    let encoding: u32 = 0xC488E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_prfh_i_p_ai_d_combo_6_e000_c48fe000() {
    // Encoding: 0xC48FE000
    // Test PRFH_I.P.AI_D field combination: imm5=15, Pg=0, Zn=0, prfop=0
    // Fields: prfop=0, Zn=0, imm5=15, Pg=0
    let encoding: u32 = 0xC48FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_prfh_i_p_ai_d_combo_7_e000_c490e000() {
    // Encoding: 0xC490E000
    // Test PRFH_I.P.AI_D field combination: imm5=16, Pg=0, Zn=0, prfop=0
    // Fields: prfop=0, Zn=0, imm5=16, Pg=0
    let encoding: u32 = 0xC490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_prfh_i_p_ai_d_combo_8_e000_c49fe000() {
    // Encoding: 0xC49FE000
    // Test PRFH_I.P.AI_D field combination: imm5=31, Pg=0, Zn=0, prfop=0
    // Fields: prfop=0, Pg=0, Zn=0, imm5=31
    let encoding: u32 = 0xC49FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_prfh_i_p_ai_d_combo_9_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: prfop=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_prfh_i_p_ai_d_combo_10_e000_c480e400() {
    // Encoding: 0xC480E400
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=1, Zn=0, prfop=0
    // Fields: imm5=0, Zn=0, Pg=1, prfop=0
    let encoding: u32 = 0xC480E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_prfh_i_p_ai_d_combo_11_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: Zn=0, prfop=0, Pg=0, imm5=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_prfh_i_p_ai_d_combo_12_e000_c480e020() {
    // Encoding: 0xC480E020
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=1, prfop=0
    // Fields: prfop=0, Zn=1, imm5=0, Pg=0
    let encoding: u32 = 0xC480E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_prfh_i_p_ai_d_combo_13_e000_c480e3c0() {
    // Encoding: 0xC480E3C0
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=30, prfop=0
    // Fields: Pg=0, imm5=0, Zn=30, prfop=0
    let encoding: u32 = 0xC480E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_prfh_i_p_ai_d_combo_14_e000_c480e3e0() {
    // Encoding: 0xC480E3E0
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=31, prfop=0
    // Fields: imm5=0, prfop=0, Pg=0, Zn=31
    let encoding: u32 = 0xC480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=0 (minimum value)
#[test]
fn test_prfh_i_p_ai_d_combo_15_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=0
    // Fields: Pg=0, Zn=0, prfop=0, imm5=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=1 (value 1)
#[test]
fn test_prfh_i_p_ai_d_combo_16_e000_c480e001() {
    // Encoding: 0xC480E001
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=1
    // Fields: Zn=0, Pg=0, imm5=0, prfop=1
    let encoding: u32 = 0xC480E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=7 (midpoint (7))
#[test]
fn test_prfh_i_p_ai_d_combo_17_e000_c480e007() {
    // Encoding: 0xC480E007
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=7
    // Fields: Pg=0, prfop=7, Zn=0, imm5=0
    let encoding: u32 = 0xC480E007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// prfop=15 (maximum value (15))
#[test]
fn test_prfh_i_p_ai_d_combo_18_e000_c480e00f() {
    // Encoding: 0xC480E00F
    // Test PRFH_I.P.AI_D field combination: imm5=0, Pg=0, Zn=0, prfop=15
    // Fields: Zn=0, prfop=15, Pg=0, imm5=0
    let encoding: u32 = 0xC480E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_ai_d_invalid_0_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Pg=0, imm5=0, prfop=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PRFH_I.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_prfh_i_p_ai_d_invalid_1_e000_c480e000() {
    // Encoding: 0xC480E000
    // Test PRFH_I.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, prfop=0, imm5=0
    let encoding: u32 = 0xC480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

// ============================================================================
// INDEX_Z.RI__ Tests
// ============================================================================

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_index_z_ri_field_size_0_min_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field size = 0 (Min)
    // Fields: Zd=0, imm5=0, Rn=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_index_z_ri_field_size_1_poweroftwo_4400_04604400() {
    // Encoding: 0x04604400
    // Test INDEX_Z.RI__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Rn=0, imm5=0
    let encoding: u32 = 0x04604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_index_z_ri_field_size_2_poweroftwo_4400_04a04400() {
    // Encoding: 0x04A04400
    // Test INDEX_Z.RI__ field size = 2 (PowerOfTwo)
    // Fields: Rn=0, imm5=0, Zd=0, size=2
    let encoding: u32 = 0x04A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_index_z_ri_field_size_3_max_4400_04e04400() {
    // Encoding: 0x04E04400
    // Test INDEX_Z.RI__ field size = 3 (Max)
    // Fields: Rn=0, imm5=0, Zd=0, size=3
    let encoding: u32 = 0x04E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_index_z_ri_field_imm5_0_zero_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field imm5 = 0 (Zero)
    // Fields: Zd=0, Rn=0, size=0, imm5=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_index_z_ri_field_imm5_1_poweroftwo_4400_04214400() {
    // Encoding: 0x04214400
    // Test INDEX_Z.RI__ field imm5 = 1 (PowerOfTwo)
    // Fields: size=0, Rn=0, imm5=1, Zd=0
    let encoding: u32 = 0x04214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_index_z_ri_field_imm5_3_poweroftwominusone_4400_04234400() {
    // Encoding: 0x04234400
    // Test INDEX_Z.RI__ field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zd=0, imm5=3, size=0
    let encoding: u32 = 0x04234400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_index_z_ri_field_imm5_4_poweroftwo_4400_04244400() {
    // Encoding: 0x04244400
    // Test INDEX_Z.RI__ field imm5 = 4 (PowerOfTwo)
    // Fields: Zd=0, Rn=0, imm5=4, size=0
    let encoding: u32 = 0x04244400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_index_z_ri_field_imm5_7_poweroftwominusone_4400_04274400() {
    // Encoding: 0x04274400
    // Test INDEX_Z.RI__ field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Rn=0, Zd=0, size=0
    let encoding: u32 = 0x04274400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_index_z_ri_field_imm5_8_poweroftwo_4400_04284400() {
    // Encoding: 0x04284400
    // Test INDEX_Z.RI__ field imm5 = 8 (PowerOfTwo)
    // Fields: Rn=0, size=0, Zd=0, imm5=8
    let encoding: u32 = 0x04284400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_index_z_ri_field_imm5_15_poweroftwominusone_4400_042f4400() {
    // Encoding: 0x042F4400
    // Test INDEX_Z.RI__ field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Rn=0, size=0, imm5=15
    let encoding: u32 = 0x042F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_index_z_ri_field_imm5_16_poweroftwo_4400_04304400() {
    // Encoding: 0x04304400
    // Test INDEX_Z.RI__ field imm5 = 16 (PowerOfTwo)
    // Fields: size=0, imm5=16, Zd=0, Rn=0
    let encoding: u32 = 0x04304400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_index_z_ri_field_imm5_31_max_4400_043f4400() {
    // Encoding: 0x043F4400
    // Test INDEX_Z.RI__ field imm5 = 31 (Max)
    // Fields: Rn=0, Zd=0, size=0, imm5=31
    let encoding: u32 = 0x043F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_index_z_ri_field_rn_0_min_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field Rn = 0 (Min)
    // Fields: Zd=0, imm5=0, Rn=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_index_z_ri_field_rn_1_poweroftwo_4400_04204420() {
    // Encoding: 0x04204420
    // Test INDEX_Z.RI__ field Rn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm5=0, Rn=1
    let encoding: u32 = 0x04204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_index_z_ri_field_rn_30_poweroftwominusone_4400_042047c0() {
    // Encoding: 0x042047C0
    // Test INDEX_Z.RI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zd=0, size=0, Rn=30
    let encoding: u32 = 0x042047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_index_z_ri_field_rn_31_max_4400_042047e0() {
    // Encoding: 0x042047E0
    // Test INDEX_Z.RI__ field Rn = 31 (Max)
    // Fields: Rn=31, size=0, Zd=0, imm5=0
    let encoding: u32 = 0x042047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_index_z_ri_field_zd_0_min_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field Zd = 0 (Min)
    // Fields: size=0, Rn=0, imm5=0, Zd=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_index_z_ri_field_zd_1_poweroftwo_4400_04204401() {
    // Encoding: 0x04204401
    // Test INDEX_Z.RI__ field Zd = 1 (PowerOfTwo)
    // Fields: imm5=0, Rn=0, size=0, Zd=1
    let encoding: u32 = 0x04204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_index_z_ri_field_zd_30_poweroftwominusone_4400_0420441e() {
    // Encoding: 0x0420441E
    // Test INDEX_Z.RI__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zd=30, size=0, Rn=0
    let encoding: u32 = 0x0420441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_index_z_ri_field_zd_31_max_4400_0420441f() {
    // Encoding: 0x0420441F
    // Test INDEX_Z.RI__ field Zd = 31 (Max)
    // Fields: Zd=31, Rn=0, imm5=0, size=0
    let encoding: u32 = 0x0420441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_index_z_ri_combo_0_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=0
    // Fields: Zd=0, imm5=0, size=0, Rn=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_index_z_ri_combo_1_4400_04604400() {
    // Encoding: 0x04604400
    // Test INDEX_Z.RI__ field combination: size=1, imm5=0, Rn=0, Zd=0
    // Fields: Rn=0, size=1, imm5=0, Zd=0
    let encoding: u32 = 0x04604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_index_z_ri_combo_2_4400_04a04400() {
    // Encoding: 0x04A04400
    // Test INDEX_Z.RI__ field combination: size=2, imm5=0, Rn=0, Zd=0
    // Fields: Rn=0, size=2, Zd=0, imm5=0
    let encoding: u32 = 0x04A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_index_z_ri_combo_3_4400_04e04400() {
    // Encoding: 0x04E04400
    // Test INDEX_Z.RI__ field combination: size=3, imm5=0, Rn=0, Zd=0
    // Fields: imm5=0, Zd=0, size=3, Rn=0
    let encoding: u32 = 0x04E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_index_z_ri_combo_4_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=0
    // Fields: imm5=0, Zd=0, size=0, Rn=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_index_z_ri_combo_5_4400_04214400() {
    // Encoding: 0x04214400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=1, Rn=0, Zd=0
    // Fields: Zd=0, Rn=0, size=0, imm5=1
    let encoding: u32 = 0x04214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_index_z_ri_combo_6_4400_04234400() {
    // Encoding: 0x04234400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=3, Rn=0, Zd=0
    // Fields: size=0, imm5=3, Rn=0, Zd=0
    let encoding: u32 = 0x04234400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_index_z_ri_combo_7_4400_04244400() {
    // Encoding: 0x04244400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=4, Rn=0, Zd=0
    // Fields: imm5=4, size=0, Zd=0, Rn=0
    let encoding: u32 = 0x04244400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_index_z_ri_combo_8_4400_04274400() {
    // Encoding: 0x04274400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=7, Rn=0, Zd=0
    // Fields: Rn=0, imm5=7, Zd=0, size=0
    let encoding: u32 = 0x04274400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_index_z_ri_combo_9_4400_04284400() {
    // Encoding: 0x04284400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=8, Rn=0, Zd=0
    // Fields: size=0, imm5=8, Rn=0, Zd=0
    let encoding: u32 = 0x04284400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_index_z_ri_combo_10_4400_042f4400() {
    // Encoding: 0x042F4400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=15, Rn=0, Zd=0
    // Fields: size=0, Zd=0, imm5=15, Rn=0
    let encoding: u32 = 0x042F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_index_z_ri_combo_11_4400_04304400() {
    // Encoding: 0x04304400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=16, Rn=0, Zd=0
    // Fields: size=0, imm5=16, Zd=0, Rn=0
    let encoding: u32 = 0x04304400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_index_z_ri_combo_12_4400_043f4400() {
    // Encoding: 0x043F4400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=31, Rn=0, Zd=0
    // Fields: Rn=0, size=0, Zd=0, imm5=31
    let encoding: u32 = 0x043F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_index_z_ri_combo_13_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=0
    // Fields: size=0, imm5=0, Zd=0, Rn=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_index_z_ri_combo_14_4400_04204420() {
    // Encoding: 0x04204420
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=1, Zd=0
    // Fields: size=0, imm5=0, Rn=1, Zd=0
    let encoding: u32 = 0x04204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_index_z_ri_combo_15_4400_042047c0() {
    // Encoding: 0x042047C0
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=30, Zd=0
    // Fields: imm5=0, Zd=0, size=0, Rn=30
    let encoding: u32 = 0x042047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_index_z_ri_combo_16_4400_042047e0() {
    // Encoding: 0x042047E0
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=31, Zd=0
    // Fields: Rn=31, Zd=0, size=0, imm5=0
    let encoding: u32 = 0x042047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_index_z_ri_combo_17_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=0
    // Fields: size=0, Zd=0, imm5=0, Rn=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_index_z_ri_combo_18_4400_04204401() {
    // Encoding: 0x04204401
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=1
    // Fields: Zd=1, size=0, Rn=0, imm5=0
    let encoding: u32 = 0x04204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_index_z_ri_combo_19_4400_0420441e() {
    // Encoding: 0x0420441E
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=30
    // Fields: size=0, Rn=0, Zd=30, imm5=0
    let encoding: u32 = 0x0420441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_index_z_ri_special_size_0_size_variant_0_17408_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ special value size = 0 (Size variant 0)
    // Fields: Rn=0, imm5=0, size=0, Zd=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_index_z_ri_special_size_1_size_variant_1_17408_04604400() {
    // Encoding: 0x04604400
    // Test INDEX_Z.RI__ special value size = 1 (Size variant 1)
    // Fields: Rn=0, imm5=0, Zd=0, size=1
    let encoding: u32 = 0x04604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_index_z_ri_special_size_2_size_variant_2_17408_04a04400() {
    // Encoding: 0x04A04400
    // Test INDEX_Z.RI__ special value size = 2 (Size variant 2)
    // Fields: size=2, Rn=0, Zd=0, imm5=0
    let encoding: u32 = 0x04A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_index_z_ri_special_size_3_size_variant_3_17408_04e04400() {
    // Encoding: 0x04E04400
    // Test INDEX_Z.RI__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, imm5=0, size=3, Rn=0
    let encoding: u32 = 0x04E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_index_z_ri_special_rn_31_stack_pointer_sp_may_require_alignment_17408_042047e0() {
    // Encoding: 0x042047E0
    // Test INDEX_Z.RI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rn=31, Zd=0, imm5=0
    let encoding: u32 = 0x042047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_index_z_ri_invalid_0_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, size=0, Zd=0, imm5=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_index_z_ri_invalid_1_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zd=0, Rn=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INDEX_Z.RI__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_index_z_ri_reg_write_0_04204400() {
    // Test INDEX_Z.RI__ register write: SimdFromField("d")
    // Encoding: 0x04204400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INDEX_Z.RI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_index_z_ri_sp_rn_042047e0() {
    // Test INDEX_Z.RI__ with Rn = SP (31)
    // Encoding: 0x042047E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x042047E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ORV_R.P.Z__ Tests
// ============================================================================

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_orv_r_p_z_field_size_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_orv_r_p_z_field_size_1_poweroftwo_2000_04582000() {
    // Encoding: 0x04582000
    // Test ORV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_orv_r_p_z_field_size_2_poweroftwo_2000_04982000() {
    // Encoding: 0x04982000
    // Test ORV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vd=0, size=2, Pg=0, Zn=0
    let encoding: u32 = 0x04982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_orv_r_p_z_field_size_3_max_2000_04d82000() {
    // Encoding: 0x04D82000
    // Test ORV_R.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_orv_r_p_z_field_pg_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_orv_r_p_z_field_pg_1_poweroftwo_2000_04182400() {
    // Encoding: 0x04182400
    // Test ORV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Vd=0, size=0
    let encoding: u32 = 0x04182400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_orv_r_p_z_field_zn_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Vd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_orv_r_p_z_field_zn_1_poweroftwo_2000_04182020() {
    // Encoding: 0x04182020
    // Test ORV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Vd=0, Zn=1, size=0, Pg=0
    let encoding: u32 = 0x04182020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_orv_r_p_z_field_zn_30_poweroftwominusone_2000_041823c0() {
    // Encoding: 0x041823C0
    // Test ORV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x041823C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_orv_r_p_z_field_zn_31_max_2000_041823e0() {
    // Encoding: 0x041823E0
    // Test ORV_R.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Pg=0, Zn=31, Vd=0
    let encoding: u32 = 0x041823E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_orv_r_p_z_field_vd_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_orv_r_p_z_field_vd_1_poweroftwo_2000_04182001() {
    // Encoding: 0x04182001
    // Test ORV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=0, Vd=1
    let encoding: u32 = 0x04182001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_orv_r_p_z_field_vd_30_poweroftwominusone_2000_0418201e() {
    // Encoding: 0x0418201E
    // Test ORV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Vd=30
    let encoding: u32 = 0x0418201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_orv_r_p_z_field_vd_31_max_2000_0418201f() {
    // Encoding: 0x0418201F
    // Test ORV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Vd=31, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x0418201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_orv_r_p_z_combo_0_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_orv_r_p_z_combo_1_2000_04582000() {
    // Encoding: 0x04582000
    // Test ORV_R.P.Z__ field combination: size=1, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Zn=0, Vd=0, size=1
    let encoding: u32 = 0x04582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_orv_r_p_z_combo_2_2000_04982000() {
    // Encoding: 0x04982000
    // Test ORV_R.P.Z__ field combination: size=2, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Zn=0, Vd=0, size=2
    let encoding: u32 = 0x04982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_orv_r_p_z_combo_3_2000_04d82000() {
    // Encoding: 0x04D82000
    // Test ORV_R.P.Z__ field combination: size=3, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, size=3, Vd=0, Pg=0
    let encoding: u32 = 0x04D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_orv_r_p_z_combo_4_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_orv_r_p_z_combo_5_2000_04182400() {
    // Encoding: 0x04182400
    // Test ORV_R.P.Z__ field combination: size=0, Pg=1, Zn=0, Vd=0
    // Fields: Vd=0, Pg=1, size=0, Zn=0
    let encoding: u32 = 0x04182400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_orv_r_p_z_combo_6_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_orv_r_p_z_combo_7_2000_04182020() {
    // Encoding: 0x04182020
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=1, Vd=0
    // Fields: Vd=0, Zn=1, Pg=0, size=0
    let encoding: u32 = 0x04182020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_orv_r_p_z_combo_8_2000_041823c0() {
    // Encoding: 0x041823C0
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=30, Vd=0
    // Fields: Pg=0, Vd=0, Zn=30, size=0
    let encoding: u32 = 0x041823C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_orv_r_p_z_combo_9_2000_041823e0() {
    // Encoding: 0x041823E0
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=31, Vd=0
    // Fields: Zn=31, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x041823E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_orv_r_p_z_combo_10_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Zn=0, Pg=0, Vd=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_orv_r_p_z_combo_11_2000_04182001() {
    // Encoding: 0x04182001
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=1
    // Fields: Vd=1, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04182001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=30 (SIMD register V30)
#[test]
fn test_orv_r_p_z_combo_12_2000_0418201e() {
    // Encoding: 0x0418201E
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=30
    // Fields: size=0, Pg=0, Zn=0, Vd=30
    let encoding: u32 = 0x0418201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=31 (SIMD register V31)
#[test]
fn test_orv_r_p_z_combo_13_2000_0418201f() {
    // Encoding: 0x0418201F
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=31
    // Fields: Zn=0, Pg=0, size=0, Vd=31
    let encoding: u32 = 0x0418201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_orv_r_p_z_special_size_0_size_variant_0_8192_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_orv_r_p_z_special_size_1_size_variant_1_8192_04582000() {
    // Encoding: 0x04582000
    // Test ORV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Vd=0, Pg=0, Zn=0, size=1
    let encoding: u32 = 0x04582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_orv_r_p_z_special_size_2_size_variant_2_8192_04982000() {
    // Encoding: 0x04982000
    // Test ORV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, size=2, Vd=0
    let encoding: u32 = 0x04982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_orv_r_p_z_special_size_3_size_variant_3_8192_04d82000() {
    // Encoding: 0x04D82000
    // Test ORV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Pg=0, Vd=0, size=3
    let encoding: u32 = 0x04D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_orv_r_p_z_invalid_0_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_orv_r_p_z_invalid_1_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Vd=0, Zn=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ORV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_orv_r_p_z_reg_write_0_04182000() {
    // Test ORV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04182000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04182000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDFF1B_Z.P.BZ_D.x32.unscaled Tests
// ============================================================================

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_xs_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, xs=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_xs_1_max_6000_c4406000() {
    // Encoding: 0xC4406000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_6000_c4016000() {
    // Encoding: 0xC4016000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=1, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_6000_c41e6000() {
    // Encoding: 0xC41E6000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC41E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zm_31_max_6000_c41f6000() {
    // Encoding: 0xC41F6000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Pg=0, xs=0, Zm=31, Zt=0
    let encoding: u32 = 0xC41F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_pg_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_6000_c4006400() {
    // Encoding: 0xC4006400
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0xC4006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_6000_c4006020() {
    // Encoding: 0xC4006020
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_6000_c40063c0() {
    // Encoding: 0xC40063C0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=30
    let encoding: u32 = 0xC40063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_rn_31_max_6000_c40063e0() {
    // Encoding: 0xC40063E0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xC40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_0_min_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_6000_c4006001() {
    // Encoding: 0xC4006001
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Zm=0, Zt=1, Pg=0
    let encoding: u32 = 0xC4006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_6000_c400601e() {
    // Encoding: 0xC400601E
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=30, xs=0
    let encoding: u32 = 0xC400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_field_zt_31_max_6000_c400601f() {
    // Encoding: 0xC400601F
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_0_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_1_6000_c4406000() {
    // Encoding: 0xC4406000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Zt=0, xs=1, Pg=0
    let encoding: u32 = 0xC4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_2_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_3_6000_c4016000() {
    // Encoding: 0xC4016000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zm=1, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xC4016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_4_6000_c41e6000() {
    // Encoding: 0xC41E6000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC41E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_5_6000_c41f6000() {
    // Encoding: 0xC41F6000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Rn=0, Pg=0, Zm=31
    let encoding: u32 = 0xC41F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_6_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_7_6000_c4006400() {
    // Encoding: 0xC4006400
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Rn=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_8_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_9_6000_c4006020() {
    // Encoding: 0xC4006020
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC4006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_10_6000_c40063c0() {
    // Encoding: 0xC40063C0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xC40063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_11_6000_c40063e0() {
    // Encoding: 0xC40063E0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Zm=0, Rn=31, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_12_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_13_6000_c4006001() {
    // Encoding: 0xC4006001
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Rn=0, Zt=1, Zm=0, xs=0
    let encoding: u32 = 0xC4006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_14_6000_c400601e() {
    // Encoding: 0xC400601E
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Zt=30, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_15_6000_c400601f() {
    // Encoding: 0xC400601F
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zm=0, Zt=31, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_16_6000_c4006420() {
    // Encoding: 0xC4006420
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, xs=0, Rn=1, Zm=0, Pg=1
    let encoding: u32 = 0xC4006420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_combo_17_6000_c4007fe0() {
    // Encoding: 0xC4007FE0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, xs=0, Zm=0, Rn=31, Pg=31
    let encoding: u32 = 0xC4007FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_c40063e0() {
    // Encoding: 0xC40063E0
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, xs=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_invalid_0_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_invalid_1_6000_c4006000() {
    // Encoding: 0xC4006000
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_xs_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, xs=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_xs_1_max_6000_84406000() {
    // Encoding: 0x84406000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_6000_84016000() {
    // Encoding: 0x84016000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=1, Zt=0, Rn=0
    let encoding: u32 = 0x84016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_6000_841e6000() {
    // Encoding: 0x841E6000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zm=30, Zt=0, Rn=0
    let encoding: u32 = 0x841E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zm_31_max_6000_841f6000() {
    // Encoding: 0x841F6000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, xs=0, Zt=0, Pg=0, Zm=31
    let encoding: u32 = 0x841F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_pg_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_6000_84006400() {
    // Encoding: 0x84006400
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x84006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_6000_84006020() {
    // Encoding: 0x84006020
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=1
    let encoding: u32 = 0x84006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_6000_840063c0() {
    // Encoding: 0x840063C0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0x840063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_rn_31_max_6000_840063e0() {
    // Encoding: 0x840063E0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0x840063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_0_min_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_6000_84006001() {
    // Encoding: 0x84006001
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zt=1, Pg=0, Zm=0
    let encoding: u32 = 0x84006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_6000_8400601e() {
    // Encoding: 0x8400601E
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=30
    let encoding: u32 = 0x8400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_field_zt_31_max_6000_8400601f() {
    // Encoding: 0x8400601F
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Zt=31, Rn=0, Zm=0
    let encoding: u32 = 0x8400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_0_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_1_6000_84406000() {
    // Encoding: 0x84406000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=1, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0x84406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_2_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_3_6000_84016000() {
    // Encoding: 0x84016000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Rn=0, Zm=1, Zt=0
    let encoding: u32 = 0x84016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_4_6000_841e6000() {
    // Encoding: 0x841E6000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, xs=0, Pg=0, Zm=30
    let encoding: u32 = 0x841E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_5_6000_841f6000() {
    // Encoding: 0x841F6000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zm=31, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x841F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_6_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_7_6000_84006400() {
    // Encoding: 0x84006400
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x84006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_8_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_9_6000_84006020() {
    // Encoding: 0x84006020
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zm=0, Pg=0, xs=0, Rn=1, Zt=0
    let encoding: u32 = 0x84006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_10_6000_840063c0() {
    // Encoding: 0x840063C0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x840063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_11_6000_840063e0() {
    // Encoding: 0x840063E0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, xs=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0x840063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_12_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_13_6000_84006001() {
    // Encoding: 0x84006001
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, Rn=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0x84006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_14_6000_8400601e() {
    // Encoding: 0x8400601E
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Pg=0, Zt=30, Zm=0, xs=0
    let encoding: u32 = 0x8400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_15_6000_8400601f() {
    // Encoding: 0x8400601F
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Zt=31, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x8400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_16_6000_84006420() {
    // Encoding: 0x84006420
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, xs=0, Zt=0, Zm=0, Pg=1
    let encoding: u32 = 0x84006420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_combo_17_6000_84007fe0() {
    // Encoding: 0x84007FE0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Rn=31, Zm=0, xs=0, Pg=31
    let encoding: u32 = 0x84007FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_24576_840063e0() {
    // Encoding: 0x840063E0
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=31
    let encoding: u32 = 0x840063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_invalid_0_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_invalid_1_6000_84006000() {
    // Encoding: 0x84006000
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_e000_c441e000() {
    // Encoding: 0xC441E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zm=1, Rn=0
    let encoding: u32 = 0xC441E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_e000_c45ee000() {
    // Encoding: 0xC45EE000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=30
    let encoding: u32 = 0xC45EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zm_31_max_e000_c45fe000() {
    // Encoding: 0xC45FE000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=31
    let encoding: u32 = 0xC45FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_pg_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_e000_c440e400() {
    // Encoding: 0xC440E400
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Pg=1, Zt=0
    let encoding: u32 = 0xC440E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_e000_c440e020() {
    // Encoding: 0xC440E020
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Rn=1, Pg=0
    let encoding: u32 = 0xC440E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_e000_c440e3c0() {
    // Encoding: 0xC440E3C0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC440E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_rn_31_max_e000_c440e3e0() {
    // Encoding: 0xC440E3E0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_0_min_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_e000_c440e001() {
    // Encoding: 0xC440E001
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xC440E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_e000_c440e01e() {
    // Encoding: 0xC440E01E
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xC440E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_field_zt_31_max_e000_c440e01f() {
    // Encoding: 0xC440E01F
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, Zm=0
    let encoding: u32 = 0xC440E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_0_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_1_e000_c441e000() {
    // Encoding: 0xC441E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC441E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_2_e000_c45ee000() {
    // Encoding: 0xC45EE000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=30, Rn=0
    let encoding: u32 = 0xC45EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_3_e000_c45fe000() {
    // Encoding: 0xC45FE000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Zm=31
    let encoding: u32 = 0xC45FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_4_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_5_e000_c440e400() {
    // Encoding: 0xC440E400
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Pg=1, Rn=0
    let encoding: u32 = 0xC440E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_6_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_7_e000_c440e020() {
    // Encoding: 0xC440E020
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC440E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_8_e000_c440e3c0() {
    // Encoding: 0xC440E3C0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Zm=0, Pg=0, Rn=30
    let encoding: u32 = 0xC440E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_9_e000_c440e3e0() {
    // Encoding: 0xC440E3E0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Zm=0, Zt=0, Rn=31
    let encoding: u32 = 0xC440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_10_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_11_e000_c440e001() {
    // Encoding: 0xC440E001
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, Zm=0, Rn=0
    let encoding: u32 = 0xC440E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_12_e000_c440e01e() {
    // Encoding: 0xC440E01E
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC440E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_13_e000_c440e01f() {
    // Encoding: 0xC440E01F
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Zm=0, Pg=0, Zt=31
    let encoding: u32 = 0xC440E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_14_e000_c440e420() {
    // Encoding: 0xC440E420
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zm=0, Zt=0, Rn=1, Pg=1
    let encoding: u32 = 0xC440E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_combo_15_e000_c440ffe0() {
    // Encoding: 0xC440FFE0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Rn=31, Pg=31, Zm=0
    let encoding: u32 = 0xC440FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_57344_c440e3e0() {
    // Encoding: 0xC440E3E0
    // Test LDFF1B_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC440E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_invalid_0_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_invalid_1_e000_c440e000() {
    // Encoding: 0xC440E000
    // Test LDFF1B_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_reg_write_0_c4006000() {
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_bz_d_x32_unscaled_sp_rn_c40063e0() {
    // Test LDFF1B_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC40063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC40063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_reg_write_0_84006000() {
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84006000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84006000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_bz_s_x32_unscaled_sp_rn_840063e0() {
    // Test LDFF1B_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x840063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x840063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_reg_write_0_c440e000() {
    // Test LDFF1B_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC440E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDFF1B_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldff1b_z_p_bz_d_64_unscaled_sp_rn_c440e3e0() {
    // Test LDFF1B_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC440E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC440E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMUL_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmul_z_zz_field_size_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmul_z_zz_field_size_1_poweroftwo_800_65400800() {
    // Encoding: 0x65400800
    // Test FMUL_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmul_z_zz_field_size_2_poweroftwo_800_65800800() {
    // Encoding: 0x65800800
    // Test FMUL_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Zd=0, Zm=0
    let encoding: u32 = 0x65800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmul_z_zz_field_size_3_max_800_65c00800() {
    // Encoding: 0x65C00800
    // Test FMUL_Z.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Zn=0, size=3, Zd=0
    let encoding: u32 = 0x65C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zz_field_zm_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zz_field_zm_1_poweroftwo_800_65010800() {
    // Encoding: 0x65010800
    // Test FMUL_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zd=0, Zm=1, Zn=0
    let encoding: u32 = 0x65010800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zz_field_zm_30_poweroftwominusone_800_651e0800() {
    // Encoding: 0x651E0800
    // Test FMUL_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zm=30, size=0, Zd=0
    let encoding: u32 = 0x651E0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zz_field_zm_31_max_800_651f0800() {
    // Encoding: 0x651F0800
    // Test FMUL_Z.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zd=0, Zn=0, Zm=31
    let encoding: u32 = 0x651F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zz_field_zn_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zz_field_zn_1_poweroftwo_800_65000820() {
    // Encoding: 0x65000820
    // Test FMUL_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zn=1, Zm=0
    let encoding: u32 = 0x65000820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zz_field_zn_30_poweroftwominusone_800_65000bc0() {
    // Encoding: 0x65000BC0
    // Test FMUL_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zm=0, Zd=0
    let encoding: u32 = 0x65000BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zz_field_zn_31_max_800_65000be0() {
    // Encoding: 0x65000BE0
    // Test FMUL_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, size=0, Zn=31, Zd=0
    let encoding: u32 = 0x65000BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zz_field_zd_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field Zd = 0 (Min)
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zz_field_zd_1_poweroftwo_800_65000801() {
    // Encoding: 0x65000801
    // Test FMUL_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zm=0, Zd=1
    let encoding: u32 = 0x65000801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zz_field_zd_30_poweroftwominusone_800_6500081e() {
    // Encoding: 0x6500081E
    // Test FMUL_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zm=0, Zd=30, size=0
    let encoding: u32 = 0x6500081E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zz_field_zd_31_max_800_6500081f() {
    // Encoding: 0x6500081F
    // Test FMUL_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zn=0, Zd=31, size=0
    let encoding: u32 = 0x6500081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmul_z_zz_combo_0_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fmul_z_zz_combo_1_800_65400800() {
    // Encoding: 0x65400800
    // Test FMUL_Z.ZZ__ field combination: size=1, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Zm=0, size=1
    let encoding: u32 = 0x65400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fmul_z_zz_combo_2_800_65800800() {
    // Encoding: 0x65800800
    // Test FMUL_Z.ZZ__ field combination: size=2, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x65800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fmul_z_zz_combo_3_800_65c00800() {
    // Encoding: 0x65C00800
    // Test FMUL_Z.ZZ__ field combination: size=3, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Zm=0, size=3
    let encoding: u32 = 0x65C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_fmul_z_zz_combo_4_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_fmul_z_zz_combo_5_800_65010800() {
    // Encoding: 0x65010800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=1, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zd=0, Zm=1
    let encoding: u32 = 0x65010800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_fmul_z_zz_combo_6_800_651e0800() {
    // Encoding: 0x651E0800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=30, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, size=0, Zm=30
    let encoding: u32 = 0x651E0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_fmul_z_zz_combo_7_800_651f0800() {
    // Encoding: 0x651F0800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=31, Zn=0, Zd=0
    // Fields: Zd=0, Zm=31, Zn=0, size=0
    let encoding: u32 = 0x651F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_fmul_z_zz_combo_8_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_fmul_z_zz_combo_9_800_65000820() {
    // Encoding: 0x65000820
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=1, Zd=0
    // Fields: Zn=1, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x65000820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_fmul_z_zz_combo_10_800_65000bc0() {
    // Encoding: 0x65000BC0
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=30, Zd=0
    // Fields: Zn=30, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_fmul_z_zz_combo_11_800_65000be0() {
    // Encoding: 0x65000BE0
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=31, Zd=0
    // Fields: Zn=31, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_fmul_z_zz_combo_12_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_fmul_z_zz_combo_13_800_65000801() {
    // Encoding: 0x65000801
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=1
    // Fields: Zn=0, Zm=0, size=0, Zd=1
    let encoding: u32 = 0x65000801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_fmul_z_zz_combo_14_800_6500081e() {
    // Encoding: 0x6500081E
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=30
    // Fields: size=0, Zd=30, Zm=0, Zn=0
    let encoding: u32 = 0x6500081E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_fmul_z_zz_combo_15_800_6500081f() {
    // Encoding: 0x6500081F
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=31
    // Fields: Zn=0, size=0, Zd=31, Zm=0
    let encoding: u32 = 0x6500081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmul_z_zz_special_size_0_size_variant_0_2048_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmul_z_zz_special_size_1_size_variant_1_2048_65400800() {
    // Encoding: 0x65400800
    // Test FMUL_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zm=0, Zn=0, size=1
    let encoding: u32 = 0x65400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmul_z_zz_special_size_2_size_variant_2_2048_65800800() {
    // Encoding: 0x65800800
    // Test FMUL_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Zd=0, Zn=0
    let encoding: u32 = 0x65800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmul_z_zz_special_size_3_size_variant_3_2048_65c00800() {
    // Encoding: 0x65C00800
    // Test FMUL_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, size=3, Zn=0, Zd=0
    let encoding: u32 = 0x65C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_0_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_1_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_2_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_3_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmul_z_zz_reg_write_0_65000800() {
    // Test FMUL_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65000800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECH_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdech_z_zs_field_imm4_0_zero_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdech_z_zs_field_imm4_1_poweroftwo_c800_0461c800() {
    // Encoding: 0x0461C800
    // Test SQDECH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Zdn=0
    let encoding: u32 = 0x0461C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdech_z_zs_field_imm4_3_poweroftwominusone_c800_0463c800() {
    // Encoding: 0x0463C800
    // Test SQDECH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x0463C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdech_z_zs_field_imm4_4_poweroftwo_c800_0464c800() {
    // Encoding: 0x0464C800
    // Test SQDECH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x0464C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdech_z_zs_field_imm4_7_poweroftwominusone_c800_0467c800() {
    // Encoding: 0x0467C800
    // Test SQDECH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x0467C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdech_z_zs_field_imm4_8_poweroftwo_c800_0468c800() {
    // Encoding: 0x0468C800
    // Test SQDECH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x0468C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdech_z_zs_field_imm4_15_max_c800_046fc800() {
    // Encoding: 0x046FC800
    // Test SQDECH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: Zdn=0, pattern=0, imm4=15
    let encoding: u32 = 0x046FC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_z_zs_field_pattern_0_min_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_z_zs_field_pattern_1_poweroftwo_c800_0460c820() {
    // Encoding: 0x0460C820
    // Test SQDECH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x0460C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_z_zs_field_pattern_15_poweroftwominusone_c800_0460c9e0() {
    // Encoding: 0x0460C9E0
    // Test SQDECH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=0, pattern=15
    let encoding: u32 = 0x0460C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_z_zs_field_pattern_31_max_c800_0460cbe0() {
    // Encoding: 0x0460CBE0
    // Test SQDECH_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x0460CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_z_zs_field_zdn_0_min_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_z_zs_field_zdn_1_poweroftwo_c800_0460c801() {
    // Encoding: 0x0460C801
    // Test SQDECH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, pattern=0, imm4=0
    let encoding: u32 = 0x0460C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_z_zs_field_zdn_15_poweroftwominusone_c800_0460c80f() {
    // Encoding: 0x0460C80F
    // Test SQDECH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x0460C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_z_zs_field_zdn_31_max_c800_0460c81f() {
    // Encoding: 0x0460C81F
    // Test SQDECH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x0460C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdech_z_zs_combo_0_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_sqdech_z_zs_combo_1_c800_0461c800() {
    // Encoding: 0x0461C800
    // Test SQDECH_Z.ZS__ field combination: imm4=1, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=1
    let encoding: u32 = 0x0461C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_sqdech_z_zs_combo_2_c800_0463c800() {
    // Encoding: 0x0463C800
    // Test SQDECH_Z.ZS__ field combination: imm4=3, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x0463C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_sqdech_z_zs_combo_3_c800_0464c800() {
    // Encoding: 0x0464C800
    // Test SQDECH_Z.ZS__ field combination: imm4=4, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x0464C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_sqdech_z_zs_combo_4_c800_0467c800() {
    // Encoding: 0x0467C800
    // Test SQDECH_Z.ZS__ field combination: imm4=7, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x0467C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_sqdech_z_zs_combo_5_c800_0468c800() {
    // Encoding: 0x0468C800
    // Test SQDECH_Z.ZS__ field combination: imm4=8, pattern=0, Zdn=0
    // Fields: imm4=8, Zdn=0, pattern=0
    let encoding: u32 = 0x0468C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_sqdech_z_zs_combo_6_c800_046fc800() {
    // Encoding: 0x046FC800
    // Test SQDECH_Z.ZS__ field combination: imm4=15, pattern=0, Zdn=0
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x046FC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_sqdech_z_zs_combo_7_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_sqdech_z_zs_combo_8_c800_0460c820() {
    // Encoding: 0x0460C820
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=1, Zdn=0
    // Fields: pattern=1, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_sqdech_z_zs_combo_9_c800_0460c9e0() {
    // Encoding: 0x0460C9E0
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=15, Zdn=0
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x0460C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_sqdech_z_zs_combo_10_c800_0460cbe0() {
    // Encoding: 0x0460CBE0
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=31, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=31
    let encoding: u32 = 0x0460CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_sqdech_z_zs_combo_11_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_sqdech_z_zs_combo_12_c800_0460c801() {
    // Encoding: 0x0460C801
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=1
    // Fields: pattern=0, Zdn=1, imm4=0
    let encoding: u32 = 0x0460C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_sqdech_z_zs_combo_13_c800_0460c80f() {
    // Encoding: 0x0460C80F
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=15
    // Fields: pattern=0, Zdn=15, imm4=0
    let encoding: u32 = 0x0460C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_sqdech_z_zs_combo_14_c800_0460c81f() {
    // Encoding: 0x0460C81F
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=31
    // Fields: Zdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x0460C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdech_z_zs_invalid_0_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdech_z_zs_invalid_1_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqdech_z_zs_reg_write_0_0460c800() {
    // Test SQDECH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0460C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQW_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_1_poweroftwo_0_a5010000() {
    // Encoding: 0xA5010000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_30_poweroftwominusone_0_a51e0000() {
    // Encoding: 0xA51E0000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA51E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rm_31_max_0_a51f0000() {
    // Encoding: 0xA51F0000
    // Test LD1RQW_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_pg_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_pg_1_poweroftwo_0_a5000400() {
    // Encoding: 0xA5000400
    // Test LD1RQW_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_1_poweroftwo_0_a5000020() {
    // Encoding: 0xA5000020
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_30_poweroftwominusone_0_a50003c0() {
    // Encoding: 0xA50003C0
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA50003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_rn_31_max_0_a50003e0() {
    // Encoding: 0xA50003E0
    // Test LD1RQW_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, Rm=0, Pg=0
    let encoding: u32 = 0xA50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_0_min_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_1_poweroftwo_0_a5000001() {
    // Encoding: 0xA5000001
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA5000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_30_poweroftwominusone_0_a500001e() {
    // Encoding: 0xA500001E
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xA500001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqw_z_p_br_contiguous_field_zt_31_max_0_a500001f() {
    // Encoding: 0xA500001F
    // Test LD1RQW_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Rm=0
    let encoding: u32 = 0xA500001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_0_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_1_0_a5010000() {
    // Encoding: 0xA5010000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=1, Zt=0, Pg=0
    let encoding: u32 = 0xA5010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_2_0_a51e0000() {
    // Encoding: 0xA51E0000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Rm=30
    let encoding: u32 = 0xA51E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_3_0_a51f0000() {
    // Encoding: 0xA51F0000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA51F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_4_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_5_0_a5000400() {
    // Encoding: 0xA5000400
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Pg=1, Rn=0, Rm=0
    let encoding: u32 = 0xA5000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_6_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_7_0_a5000020() {
    // Encoding: 0xA5000020
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Rn=1, Rm=0, Pg=0
    let encoding: u32 = 0xA5000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_8_0_a50003c0() {
    // Encoding: 0xA50003C0
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA50003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_9_0_a50003e0() {
    // Encoding: 0xA50003E0
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xA50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_10_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_11_0_a5000001() {
    // Encoding: 0xA5000001
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Zt=1, Pg=0, Rm=0
    let encoding: u32 = 0xA5000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_12_0_a500001e() {
    // Encoding: 0xA500001E
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA500001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_13_0_a500001f() {
    // Encoding: 0xA500001F
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Pg=0, Zt=31, Rm=0
    let encoding: u32 = 0xA500001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_14_0_a5010400() {
    // Encoding: 0xA5010400
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xA5010400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_15_0_a51f1c00() {
    // Encoding: 0xA51F1C00
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Rm=31, Rn=0, Pg=31, Zt=0
    let encoding: u32 = 0xA51F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_16_0_a5010020() {
    // Encoding: 0xA5010020
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Rm=1, Pg=0, Rn=1
    let encoding: u32 = 0xA5010020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_17_0_a51f03e0() {
    // Encoding: 0xA51F03E0
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Rm=31, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xA51F03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_18_0_a5000420() {
    // Encoding: 0xA5000420
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Rm=0, Pg=1, Zt=0
    let encoding: u32 = 0xA5000420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1rqw_z_p_br_contiguous_combo_19_0_a5001fe0() {
    // Encoding: 0xA5001FE0
    // Test LD1RQW_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Rm=0, Pg=31, Rn=31, Zt=0
    let encoding: u32 = 0xA5001FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqw_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_0_a50003e0() {
    // Encoding: 0xA50003E0
    // Test LD1RQW_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xA50003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_0_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_1_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_2_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqw_z_p_br_contiguous_invalid_3_0_a5000000() {
    // Encoding: 0xA5000000
    // Test LD1RQW_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqw_z_p_br_contiguous_reg_write_0_a5000000() {
    // Test LD1RQW_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA5000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQW_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqw_z_p_br_contiguous_sp_rn_a50003e0() {
    // Test LD1RQW_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA50003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA50003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.ZI__ Tests
// ============================================================================

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_zi_field_tszh_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field tszh = 0 (Min)
    // Fields: imm3=0, Zn=0, Zd=0, tszh=0, tszl=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_zi_field_tszh_1_poweroftwo_9c00_04609c00() {
    // Encoding: 0x04609C00
    // Test LSL_Z.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: imm3=0, Zn=0, Zd=0, tszh=1, tszl=0
    let encoding: u32 = 0x04609C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_zi_field_tszh_3_max_9c00_04e09c00() {
    // Encoding: 0x04E09C00
    // Test LSL_Z.ZI__ field tszh = 3 (Max)
    // Fields: tszl=0, Zn=0, imm3=0, Zd=0, tszh=3
    let encoding: u32 = 0x04E09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_zi_field_tszl_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field tszl = 0 (Min)
    // Fields: tszh=0, tszl=0, Zd=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_zi_field_tszl_1_poweroftwo_9c00_04289c00() {
    // Encoding: 0x04289C00
    // Test LSL_Z.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: imm3=0, tszh=0, tszl=1, Zn=0, Zd=0
    let encoding: u32 = 0x04289C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_zi_field_tszl_3_max_9c00_04389c00() {
    // Encoding: 0x04389C00
    // Test LSL_Z.ZI__ field tszl = 3 (Max)
    // Fields: Zd=0, Zn=0, imm3=0, tszh=0, tszl=3
    let encoding: u32 = 0x04389C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsl_z_zi_field_imm3_0_zero_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field imm3 = 0 (Zero)
    // Fields: imm3=0, tszh=0, tszl=0, Zn=0, Zd=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsl_z_zi_field_imm3_1_poweroftwo_9c00_04219c00() {
    // Encoding: 0x04219C00
    // Test LSL_Z.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszh=0, Zn=0, tszl=0, Zd=0, imm3=1
    let encoding: u32 = 0x04219C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsl_z_zi_field_imm3_3_poweroftwominusone_9c00_04239c00() {
    // Encoding: 0x04239C00
    // Test LSL_Z.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Zd=0, tszh=0, Zn=0, imm3=3
    let encoding: u32 = 0x04239C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsl_z_zi_field_imm3_7_max_9c00_04279c00() {
    // Encoding: 0x04279C00
    // Test LSL_Z.ZI__ field imm3 = 7 (Max)
    // Fields: Zn=0, imm3=7, tszl=0, Zd=0, tszh=0
    let encoding: u32 = 0x04279C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zi_field_zn_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field Zn = 0 (Min)
    // Fields: tszh=0, tszl=0, imm3=0, Zd=0, Zn=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zi_field_zn_1_poweroftwo_9c00_04209c20() {
    // Encoding: 0x04209C20
    // Test LSL_Z.ZI__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, tszl=0, imm3=0, tszh=0, Zn=1
    let encoding: u32 = 0x04209C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zi_field_zn_30_poweroftwominusone_9c00_04209fc0() {
    // Encoding: 0x04209FC0
    // Test LSL_Z.ZI__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Zn=30, tszh=0, imm3=0, Zd=0
    let encoding: u32 = 0x04209FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zi_field_zn_31_max_9c00_04209fe0() {
    // Encoding: 0x04209FE0
    // Test LSL_Z.ZI__ field Zn = 31 (Max)
    // Fields: Zn=31, tszh=0, tszl=0, imm3=0, Zd=0
    let encoding: u32 = 0x04209FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zi_field_zd_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field Zd = 0 (Min)
    // Fields: tszh=0, tszl=0, Zd=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zi_field_zd_1_poweroftwo_9c00_04209c01() {
    // Encoding: 0x04209C01
    // Test LSL_Z.ZI__ field Zd = 1 (PowerOfTwo)
    // Fields: imm3=0, Zn=0, tszh=0, tszl=0, Zd=1
    let encoding: u32 = 0x04209C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zi_field_zd_30_poweroftwominusone_9c00_04209c1e() {
    // Encoding: 0x04209C1E
    // Test LSL_Z.ZI__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: imm3=0, Zn=0, Zd=30, tszl=0, tszh=0
    let encoding: u32 = 0x04209C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zi_field_zd_31_max_9c00_04209c1f() {
    // Encoding: 0x04209C1F
    // Test LSL_Z.ZI__ field Zd = 31 (Max)
    // Fields: imm3=0, Zn=0, tszh=0, tszl=0, Zd=31
    let encoding: u32 = 0x04209C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsl_z_zi_combo_0_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: Zd=0, tszl=0, imm3=0, Zn=0, tszh=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=1 (value 1)
#[test]
fn test_lsl_z_zi_combo_1_9c00_04609c00() {
    // Encoding: 0x04609C00
    // Test LSL_Z.ZI__ field combination: tszh=1, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: tszh=1, imm3=0, tszl=0, Zn=0, Zd=0
    let encoding: u32 = 0x04609C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=3 (maximum value (3))
#[test]
fn test_lsl_z_zi_combo_2_9c00_04e09c00() {
    // Encoding: 0x04E09C00
    // Test LSL_Z.ZI__ field combination: tszh=3, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: tszh=3, imm3=0, Zn=0, tszl=0, Zd=0
    let encoding: u32 = 0x04E09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=0 (minimum value)
#[test]
fn test_lsl_z_zi_combo_3_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: tszh=0, Zn=0, tszl=0, Zd=0, imm3=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=1 (value 1)
#[test]
fn test_lsl_z_zi_combo_4_9c00_04289c00() {
    // Encoding: 0x04289C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=1, imm3=0, Zn=0, Zd=0
    // Fields: Zd=0, tszl=1, tszh=0, imm3=0, Zn=0
    let encoding: u32 = 0x04289C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=3 (maximum value (3))
#[test]
fn test_lsl_z_zi_combo_5_9c00_04389c00() {
    // Encoding: 0x04389C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=3, imm3=0, Zn=0, Zd=0
    // Fields: Zd=0, imm3=0, Zn=0, tszh=0, tszl=3
    let encoding: u32 = 0x04389C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_lsl_z_zi_combo_6_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: imm3=0, tszl=0, Zn=0, tszh=0, Zd=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_lsl_z_zi_combo_7_9c00_04219c00() {
    // Encoding: 0x04219C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=1, Zn=0, Zd=0
    // Fields: tszl=0, imm3=1, Zn=0, tszh=0, Zd=0
    let encoding: u32 = 0x04219C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_lsl_z_zi_combo_8_9c00_04239c00() {
    // Encoding: 0x04239C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=3, Zn=0, Zd=0
    // Fields: imm3=3, Zn=0, Zd=0, tszh=0, tszl=0
    let encoding: u32 = 0x04239C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_lsl_z_zi_combo_9_9c00_04279c00() {
    // Encoding: 0x04279C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=7, Zn=0, Zd=0
    // Fields: Zd=0, tszl=0, imm3=7, Zn=0, tszh=0
    let encoding: u32 = 0x04279C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_lsl_z_zi_combo_10_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: Zd=0, imm3=0, Zn=0, tszh=0, tszl=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_lsl_z_zi_combo_11_9c00_04209c20() {
    // Encoding: 0x04209C20
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=1, Zd=0
    // Fields: tszl=0, tszh=0, Zn=1, Zd=0, imm3=0
    let encoding: u32 = 0x04209C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_lsl_z_zi_combo_12_9c00_04209fc0() {
    // Encoding: 0x04209FC0
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=30, Zd=0
    // Fields: tszl=0, imm3=0, Zn=30, Zd=0, tszh=0
    let encoding: u32 = 0x04209FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_lsl_z_zi_combo_13_9c00_04209fe0() {
    // Encoding: 0x04209FE0
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=31, Zd=0
    // Fields: tszh=0, tszl=0, Zd=0, imm3=0, Zn=31
    let encoding: u32 = 0x04209FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_lsl_z_zi_combo_14_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: tszl=0, imm3=0, Zn=0, Zd=0, tszh=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_lsl_z_zi_combo_15_9c00_04209c01() {
    // Encoding: 0x04209C01
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=1
    // Fields: tszh=0, Zd=1, tszl=0, Zn=0, imm3=0
    let encoding: u32 = 0x04209C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_lsl_z_zi_combo_16_9c00_04209c1e() {
    // Encoding: 0x04209C1E
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=30
    // Fields: Zn=0, imm3=0, tszh=0, Zd=30, tszl=0
    let encoding: u32 = 0x04209C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_lsl_z_zi_combo_17_9c00_04209c1f() {
    // Encoding: 0x04209C1F
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=31
    // Fields: tszl=0, tszh=0, Zd=31, imm3=0, Zn=0
    let encoding: u32 = 0x04209C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_zi_invalid_0_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszl=0, imm3=0, Zn=0, Zd=0, tszh=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_zi_invalid_1_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, tszh=0, Zn=0, tszl=0, imm3=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_zi_invalid_2_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, tszl=0, imm3=0, tszh=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSL_Z.ZI__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lsl_z_zi_reg_write_0_04209c00() {
    // Test LSL_Z.ZI__ register write: SimdFromField("d")
    // Encoding: 0x04209C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04209C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CTERMEQ_RR__ Tests
// ============================================================================

/// Provenance: CTERMEQ_RR__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_ctermeq_rr_field_sz_0_min_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ field sz = 0 (Min)
    // Fields: Rn=0, Rm=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_ctermeq_rr_field_sz_1_max_2000_25e02000() {
    // Encoding: 0x25E02000
    // Test CTERMEQ_RR__ field sz = 1 (Max)
    // Fields: sz=1, Rm=0, Rn=0
    let encoding: u32 = 0x25E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ctermeq_rr_field_rm_0_min_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ field Rm = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ctermeq_rr_field_rm_1_poweroftwo_2000_25a12000() {
    // Encoding: 0x25A12000
    // Test CTERMEQ_RR__ field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, sz=0, Rn=0
    let encoding: u32 = 0x25A12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ctermeq_rr_field_rm_30_poweroftwominusone_2000_25be2000() {
    // Encoding: 0x25BE2000
    // Test CTERMEQ_RR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, sz=0
    let encoding: u32 = 0x25BE2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ctermeq_rr_field_rm_31_max_2000_25bf2000() {
    // Encoding: 0x25BF2000
    // Test CTERMEQ_RR__ field Rm = 31 (Max)
    // Fields: Rn=0, sz=0, Rm=31
    let encoding: u32 = 0x25BF2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ctermeq_rr_field_rn_0_min_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ field Rn = 0 (Min)
    // Fields: Rn=0, Rm=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ctermeq_rr_field_rn_1_poweroftwo_2000_25a02020() {
    // Encoding: 0x25A02020
    // Test CTERMEQ_RR__ field Rn = 1 (PowerOfTwo)
    // Fields: sz=0, Rm=0, Rn=1
    let encoding: u32 = 0x25A02020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ctermeq_rr_field_rn_30_poweroftwominusone_2000_25a023c0() {
    // Encoding: 0x25A023C0
    // Test CTERMEQ_RR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Rm=0, Rn=30
    let encoding: u32 = 0x25A023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ctermeq_rr_field_rn_31_max_2000_25a023e0() {
    // Encoding: 0x25A023E0
    // Test CTERMEQ_RR__ field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, sz=0
    let encoding: u32 = 0x25A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_ctermeq_rr_combo_0_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=0, Rn=0
    // Fields: Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_ctermeq_rr_combo_1_2000_25e02000() {
    // Encoding: 0x25E02000
    // Test CTERMEQ_RR__ field combination: sz=1, Rm=0, Rn=0
    // Fields: sz=1, Rm=0, Rn=0
    let encoding: u32 = 0x25E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ctermeq_rr_combo_2_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=0, Rn=0
    // Fields: Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ctermeq_rr_combo_3_2000_25a12000() {
    // Encoding: 0x25A12000
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=1, Rn=0
    // Fields: Rn=0, sz=0, Rm=1
    let encoding: u32 = 0x25A12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ctermeq_rr_combo_4_2000_25be2000() {
    // Encoding: 0x25BE2000
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=30, Rn=0
    // Fields: Rn=0, sz=0, Rm=30
    let encoding: u32 = 0x25BE2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ctermeq_rr_combo_5_2000_25bf2000() {
    // Encoding: 0x25BF2000
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=31, Rn=0
    // Fields: Rn=0, sz=0, Rm=31
    let encoding: u32 = 0x25BF2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ctermeq_rr_combo_6_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=0, Rn=0
    // Fields: Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ctermeq_rr_combo_7_2000_25a02020() {
    // Encoding: 0x25A02020
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=0, Rn=1
    // Fields: Rn=1, sz=0, Rm=0
    let encoding: u32 = 0x25A02020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ctermeq_rr_combo_8_2000_25a023c0() {
    // Encoding: 0x25A023C0
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=0, Rn=30
    // Fields: Rm=0, Rn=30, sz=0
    let encoding: u32 = 0x25A023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ctermeq_rr_combo_9_2000_25a023e0() {
    // Encoding: 0x25A023E0
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=0, Rn=31
    // Fields: sz=0, Rm=0, Rn=31
    let encoding: u32 = 0x25A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ctermeq_rr_combo_10_2000_25a12020() {
    // Encoding: 0x25A12020
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=1, Rn=1
    // Fields: Rm=1, Rn=1, sz=0
    let encoding: u32 = 0x25A12020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ctermeq_rr_combo_11_2000_25bf23e0() {
    // Encoding: 0x25BF23E0
    // Test CTERMEQ_RR__ field combination: sz=0, Rm=31, Rn=31
    // Fields: Rm=31, Rn=31, sz=0
    let encoding: u32 = 0x25BF23E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_ctermeq_rr_special_sz_0_size_variant_0_8192_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ special value sz = 0 (Size variant 0)
    // Fields: Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_ctermeq_rr_special_sz_1_size_variant_1_8192_25e02000() {
    // Encoding: 0x25E02000
    // Test CTERMEQ_RR__ special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Rm=0, sz=1
    let encoding: u32 = 0x25E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ctermeq_rr_special_rn_31_stack_pointer_sp_may_require_alignment_8192_25a023e0() {
    // Encoding: 0x25A023E0
    // Test CTERMEQ_RR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: sz=0, Rm=0, Rn=31
    let encoding: u32 = 0x25A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ctermeq_rr_invalid_0_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, sz=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ctermeq_rr_invalid_1_2000_25a02000() {
    // Encoding: 0x25A02000
    // Test CTERMEQ_RR__ invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_ctermne_rr_field_sz_0_min_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ field sz = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_ctermne_rr_field_sz_1_max_2010_25e02010() {
    // Encoding: 0x25E02010
    // Test CTERMNE_RR__ field sz = 1 (Max)
    // Fields: Rm=0, Rn=0, sz=1
    let encoding: u32 = 0x25E02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ctermne_rr_field_rm_0_min_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ field Rm = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ctermne_rr_field_rm_1_poweroftwo_2010_25a12010() {
    // Encoding: 0x25A12010
    // Test CTERMNE_RR__ field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, sz=0, Rm=1
    let encoding: u32 = 0x25A12010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ctermne_rr_field_rm_30_poweroftwominusone_2010_25be2010() {
    // Encoding: 0x25BE2010
    // Test CTERMNE_RR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, sz=0, Rm=30
    let encoding: u32 = 0x25BE2010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ctermne_rr_field_rm_31_max_2010_25bf2010() {
    // Encoding: 0x25BF2010
    // Test CTERMNE_RR__ field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, sz=0
    let encoding: u32 = 0x25BF2010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ctermne_rr_field_rn_0_min_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ field Rn = 0 (Min)
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ctermne_rr_field_rn_1_poweroftwo_2010_25a02030() {
    // Encoding: 0x25A02030
    // Test CTERMNE_RR__ field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, sz=0, Rn=1
    let encoding: u32 = 0x25A02030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ctermne_rr_field_rn_30_poweroftwominusone_2010_25a023d0() {
    // Encoding: 0x25A023D0
    // Test CTERMNE_RR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, sz=0, Rm=0
    let encoding: u32 = 0x25A023D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ctermne_rr_field_rn_31_max_2010_25a023f0() {
    // Encoding: 0x25A023F0
    // Test CTERMNE_RR__ field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, sz=0
    let encoding: u32 = 0x25A023F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_ctermne_rr_combo_0_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ field combination: sz=0, Rm=0, Rn=0
    // Fields: sz=0, Rn=0, Rm=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=1 (16-bit / halfword size)
#[test]
fn test_ctermne_rr_combo_1_2010_25e02010() {
    // Encoding: 0x25E02010
    // Test CTERMNE_RR__ field combination: sz=1, Rm=0, Rn=0
    // Fields: Rm=0, Rn=0, sz=1
    let encoding: u32 = 0x25E02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ctermne_rr_combo_2_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ field combination: sz=0, Rm=0, Rn=0
    // Fields: Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ctermne_rr_combo_3_2010_25a12010() {
    // Encoding: 0x25A12010
    // Test CTERMNE_RR__ field combination: sz=0, Rm=1, Rn=0
    // Fields: Rm=1, sz=0, Rn=0
    let encoding: u32 = 0x25A12010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ctermne_rr_combo_4_2010_25be2010() {
    // Encoding: 0x25BE2010
    // Test CTERMNE_RR__ field combination: sz=0, Rm=30, Rn=0
    // Fields: sz=0, Rm=30, Rn=0
    let encoding: u32 = 0x25BE2010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ctermne_rr_combo_5_2010_25bf2010() {
    // Encoding: 0x25BF2010
    // Test CTERMNE_RR__ field combination: sz=0, Rm=31, Rn=0
    // Fields: Rm=31, Rn=0, sz=0
    let encoding: u32 = 0x25BF2010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ctermne_rr_combo_6_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ field combination: sz=0, Rm=0, Rn=0
    // Fields: Rm=0, sz=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ctermne_rr_combo_7_2010_25a02030() {
    // Encoding: 0x25A02030
    // Test CTERMNE_RR__ field combination: sz=0, Rm=0, Rn=1
    // Fields: Rm=0, sz=0, Rn=1
    let encoding: u32 = 0x25A02030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ctermne_rr_combo_8_2010_25a023d0() {
    // Encoding: 0x25A023D0
    // Test CTERMNE_RR__ field combination: sz=0, Rm=0, Rn=30
    // Fields: Rn=30, Rm=0, sz=0
    let encoding: u32 = 0x25A023D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ctermne_rr_combo_9_2010_25a023f0() {
    // Encoding: 0x25A023F0
    // Test CTERMNE_RR__ field combination: sz=0, Rm=0, Rn=31
    // Fields: sz=0, Rn=31, Rm=0
    let encoding: u32 = 0x25A023F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ctermne_rr_combo_10_2010_25a12030() {
    // Encoding: 0x25A12030
    // Test CTERMNE_RR__ field combination: sz=0, Rm=1, Rn=1
    // Fields: sz=0, Rn=1, Rm=1
    let encoding: u32 = 0x25A12030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ctermne_rr_combo_11_2010_25bf23f0() {
    // Encoding: 0x25BF23F0
    // Test CTERMNE_RR__ field combination: sz=0, Rm=31, Rn=31
    // Fields: Rm=31, sz=0, Rn=31
    let encoding: u32 = 0x25BF23F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_ctermne_rr_special_sz_0_size_variant_0_8208_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ special value sz = 0 (Size variant 0)
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_ctermne_rr_special_sz_1_size_variant_1_8208_25e02010() {
    // Encoding: 0x25E02010
    // Test CTERMNE_RR__ special value sz = 1 (Size variant 1)
    // Fields: Rn=0, Rm=0, sz=1
    let encoding: u32 = 0x25E02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ctermne_rr_special_rn_31_stack_pointer_sp_may_require_alignment_8208_25a023f0() {
    // Encoding: 0x25A023F0
    // Test CTERMNE_RR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, sz=0, Rn=31
    let encoding: u32 = 0x25A023F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ctermne_rr_invalid_0_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, sz=0, Rm=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CTERMNE_RR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ctermne_rr_invalid_1_2010_25a02010() {
    // Encoding: 0x25A02010
    // Test CTERMNE_RR__ invalid encoding: Unconditional UNDEFINED
    // Fields: sz=0, Rm=0, Rn=0
    let encoding: u32 = 0x25A02010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CTERMEQ_RR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ctermeq_rr_sp_rn_25a023e0() {
    // Test CTERMEQ_RR__ with Rn = SP (31)
    // Encoding: 0x25A023E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25A023E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_ctermeq_rr_flags_zeroresult_0_25a22020() {
    // Test CTERMEQ_RR__ flag computation: ZeroResult
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x0);
    set_x(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_ctermeq_rr_flags_zeroresult_1_25a22020() {
    // Test CTERMEQ_RR__ flag computation: ZeroResult
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_ctermeq_rr_flags_negativeresult_2_25a22020() {
    // Test CTERMEQ_RR__ flag computation: NegativeResult
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_ctermeq_rr_flags_unsignedoverflow_3_25a22020() {
    // Test CTERMEQ_RR__ flag computation: UnsignedOverflow
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_ctermeq_rr_flags_unsignedoverflow_4_25a22020() {
    // Test CTERMEQ_RR__ flag computation: UnsignedOverflow
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_ctermeq_rr_flags_signedoverflow_5_25a22020() {
    // Test CTERMEQ_RR__ flag computation: SignedOverflow
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x7FFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_ctermeq_rr_flags_signedoverflow_6_25a22020() {
    // Test CTERMEQ_RR__ flag computation: SignedOverflow
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: CTERMEQ_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_ctermeq_rr_flags_positiveresult_7_25a22020() {
    // Test CTERMEQ_RR__ flag computation: PositiveResult
    // Encoding: 0x25A22020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x64);
    set_x(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x25A22020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMNE_RR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ctermne_rr_sp_rn_25a023f0() {
    // Test CTERMNE_RR__ with Rn = SP (31)
    // Encoding: 0x25A023F0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25A023F0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_ctermne_rr_flags_zeroresult_0_25a22030() {
    // Test CTERMNE_RR__ flag computation: ZeroResult
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x0);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_ctermne_rr_flags_zeroresult_1_25a22030() {
    // Test CTERMNE_RR__ flag computation: ZeroResult
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x1);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_ctermne_rr_flags_negativeresult_2_25a22030() {
    // Test CTERMNE_RR__ flag computation: NegativeResult
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_ctermne_rr_flags_unsignedoverflow_3_25a22030() {
    // Test CTERMNE_RR__ flag computation: UnsignedOverflow
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_ctermne_rr_flags_unsignedoverflow_4_25a22030() {
    // Test CTERMNE_RR__ flag computation: UnsignedOverflow
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x2);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_ctermne_rr_flags_signedoverflow_5_25a22030() {
    // Test CTERMNE_RR__ flag computation: SignedOverflow
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x7FFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_ctermne_rr_flags_signedoverflow_6_25a22030() {
    // Test CTERMNE_RR__ flag computation: SignedOverflow
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x8000000000000000);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: CTERMNE_RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_ctermne_rr_flags_positiveresult_7_25a22030() {
    // Test CTERMNE_RR__ flag computation: PositiveResult
    // Encoding: 0x25A22030
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x64);
    set_x(&mut cpu, 2, 0x32);
    let encoding: u32 = 0x25A22030;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// UABD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uabd_z_p_zz_field_size_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uabd_z_p_zz_field_size_1_poweroftwo_0_044d0000() {
    // Encoding: 0x044D0000
    // Test UABD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, size=1
    let encoding: u32 = 0x044D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uabd_z_p_zz_field_size_2_poweroftwo_0_048d0000() {
    // Encoding: 0x048D0000
    // Test UABD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=2, Zm=0
    let encoding: u32 = 0x048D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uabd_z_p_zz_field_size_3_max_0_04cd0000() {
    // Encoding: 0x04CD0000
    // Test UABD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04CD0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uabd_z_p_zz_field_pg_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uabd_z_p_zz_field_pg_1_poweroftwo_0_040d0400() {
    // Encoding: 0x040D0400
    // Test UABD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=1, Zm=0
    let encoding: u32 = 0x040D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uabd_z_p_zz_field_zm_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uabd_z_p_zz_field_zm_1_poweroftwo_0_040d0020() {
    // Encoding: 0x040D0020
    // Test UABD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Zm=1, Pg=0
    let encoding: u32 = 0x040D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uabd_z_p_zz_field_zm_30_poweroftwominusone_0_040d03c0() {
    // Encoding: 0x040D03C0
    // Test UABD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, Pg=0, Zm=30
    let encoding: u32 = 0x040D03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uabd_z_p_zz_field_zm_31_max_0_040d03e0() {
    // Encoding: 0x040D03E0
    // Test UABD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, size=0, Zm=31, Zdn=0
    let encoding: u32 = 0x040D03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uabd_z_p_zz_field_zdn_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uabd_z_p_zz_field_zdn_1_poweroftwo_0_040d0001() {
    // Encoding: 0x040D0001
    // Test UABD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zdn=1, Zm=0
    let encoding: u32 = 0x040D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uabd_z_p_zz_field_zdn_15_poweroftwominusone_0_040d000f() {
    // Encoding: 0x040D000F
    // Test UABD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zdn=15, size=0
    let encoding: u32 = 0x040D000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uabd_z_p_zz_field_zdn_31_max_0_040d001f() {
    // Encoding: 0x040D001F
    // Test UABD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x040D001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uabd_z_p_zz_combo_0_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_uabd_z_p_zz_combo_1_0_044d0000() {
    // Encoding: 0x044D0000
    // Test UABD_Z.P.ZZ__ field combination: size=1, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=1, Zm=0
    let encoding: u32 = 0x044D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_uabd_z_p_zz_combo_2_0_048d0000() {
    // Encoding: 0x048D0000
    // Test UABD_Z.P.ZZ__ field combination: size=2, Pg=0, Zm=0, Zdn=0
    // Fields: size=2, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x048D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_uabd_z_p_zz_combo_3_0_04cd0000() {
    // Encoding: 0x04CD0000
    // Test UABD_Z.P.ZZ__ field combination: size=3, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x04CD0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_uabd_z_p_zz_combo_4_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_uabd_z_p_zz_combo_5_0_040d0400() {
    // Encoding: 0x040D0400
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=1, Zm=0, Zdn=0
    // Fields: Pg=1, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_uabd_z_p_zz_combo_6_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_uabd_z_p_zz_combo_7_0_040d0020() {
    // Encoding: 0x040D0020
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=1, Zdn=0
    // Fields: size=0, Pg=0, Zdn=0, Zm=1
    let encoding: u32 = 0x040D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_uabd_z_p_zz_combo_8_0_040d03c0() {
    // Encoding: 0x040D03C0
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=30, Zdn=0
    // Fields: size=0, Pg=0, Zm=30, Zdn=0
    let encoding: u32 = 0x040D03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_uabd_z_p_zz_combo_9_0_040d03e0() {
    // Encoding: 0x040D03E0
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=31, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=31
    let encoding: u32 = 0x040D03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_uabd_z_p_zz_combo_10_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_uabd_z_p_zz_combo_11_0_040d0001() {
    // Encoding: 0x040D0001
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=1
    // Fields: size=0, Pg=0, Zm=0, Zdn=1
    let encoding: u32 = 0x040D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_uabd_z_p_zz_combo_12_0_040d000f() {
    // Encoding: 0x040D000F
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=15
    // Fields: Pg=0, size=0, Zm=0, Zdn=15
    let encoding: u32 = 0x040D000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_uabd_z_p_zz_combo_13_0_040d001f() {
    // Encoding: 0x040D001F
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=31
    // Fields: size=0, Zm=0, Pg=0, Zdn=31
    let encoding: u32 = 0x040D001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uabd_z_p_zz_special_size_0_size_variant_0_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uabd_z_p_zz_special_size_1_size_variant_1_0_044d0000() {
    // Encoding: 0x044D0000
    // Test UABD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x044D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uabd_z_p_zz_special_size_2_size_variant_2_0_048d0000() {
    // Encoding: 0x048D0000
    // Test UABD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x048D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uabd_z_p_zz_special_size_3_size_variant_3_0_04cd0000() {
    // Encoding: 0x04CD0000
    // Test UABD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04CD0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uabd_z_p_zz_invalid_0_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uabd_z_p_zz_invalid_1_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uabd_z_p_zz_reg_write_0_040d0000() {
    // Test UABD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x040D0000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LASTA_V.P.Z__ Tests
// ============================================================================

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lasta_v_p_z_field_size_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lasta_v_p_z_field_size_1_poweroftwo_8000_05628000() {
    // Encoding: 0x05628000
    // Test LASTA_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Vd=0, size=1
    let encoding: u32 = 0x05628000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lasta_v_p_z_field_size_2_poweroftwo_8000_05a28000() {
    // Encoding: 0x05A28000
    // Test LASTA_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Vd=0, Pg=0, size=2
    let encoding: u32 = 0x05A28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lasta_v_p_z_field_size_3_max_8000_05e28000() {
    // Encoding: 0x05E28000
    // Test LASTA_V.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Pg=0, Vd=0
    let encoding: u32 = 0x05E28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lasta_v_p_z_field_pg_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lasta_v_p_z_field_pg_1_poweroftwo_8000_05228400() {
    // Encoding: 0x05228400
    // Test LASTA_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Vd=0, Pg=1
    let encoding: u32 = 0x05228400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lasta_v_p_z_field_zn_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field Zn = 0 (Min)
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lasta_v_p_z_field_zn_1_poweroftwo_8000_05228020() {
    // Encoding: 0x05228020
    // Test LASTA_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x05228020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lasta_v_p_z_field_zn_30_poweroftwominusone_8000_052283c0() {
    // Encoding: 0x052283C0
    // Test LASTA_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=0, Zn=30, size=0, Pg=0
    let encoding: u32 = 0x052283C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lasta_v_p_z_field_zn_31_max_8000_052283e0() {
    // Encoding: 0x052283E0
    // Test LASTA_V.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, Vd=0, size=0, Zn=31
    let encoding: u32 = 0x052283E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lasta_v_p_z_field_vd_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field Vd = 0 (Min)
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lasta_v_p_z_field_vd_1_poweroftwo_8000_05228001() {
    // Encoding: 0x05228001
    // Test LASTA_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Vd=1, Zn=0
    let encoding: u32 = 0x05228001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lasta_v_p_z_field_vd_30_poweroftwominusone_8000_0522801e() {
    // Encoding: 0x0522801E
    // Test LASTA_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Vd=30, Zn=0
    let encoding: u32 = 0x0522801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lasta_v_p_z_field_vd_31_max_8000_0522801f() {
    // Encoding: 0x0522801F
    // Test LASTA_V.P.Z__ field Vd = 31 (Max)
    // Fields: size=0, Zn=0, Vd=31, Pg=0
    let encoding: u32 = 0x0522801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lasta_v_p_z_combo_0_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_lasta_v_p_z_combo_1_8000_05628000() {
    // Encoding: 0x05628000
    // Test LASTA_V.P.Z__ field combination: size=1, Pg=0, Zn=0, Vd=0
    // Fields: size=1, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05628000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_lasta_v_p_z_combo_2_8000_05a28000() {
    // Encoding: 0x05A28000
    // Test LASTA_V.P.Z__ field combination: size=2, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=2, Pg=0, Zn=0
    let encoding: u32 = 0x05A28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_lasta_v_p_z_combo_3_8000_05e28000() {
    // Encoding: 0x05E28000
    // Test LASTA_V.P.Z__ field combination: size=3, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, Pg=0, size=3
    let encoding: u32 = 0x05E28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_lasta_v_p_z_combo_4_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_lasta_v_p_z_combo_5_8000_05228400() {
    // Encoding: 0x05228400
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=1, Zn=0, Vd=0
    // Fields: Vd=0, Zn=0, size=0, Pg=1
    let encoding: u32 = 0x05228400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_lasta_v_p_z_combo_6_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_lasta_v_p_z_combo_7_8000_05228020() {
    // Encoding: 0x05228020
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=1, Vd=0
    // Fields: size=0, Pg=0, Zn=1, Vd=0
    let encoding: u32 = 0x05228020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_lasta_v_p_z_combo_8_8000_052283c0() {
    // Encoding: 0x052283C0
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=30, Vd=0
    // Fields: Pg=0, Zn=30, Vd=0, size=0
    let encoding: u32 = 0x052283C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_lasta_v_p_z_combo_9_8000_052283e0() {
    // Encoding: 0x052283E0
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=31, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=31
    let encoding: u32 = 0x052283E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_lasta_v_p_z_combo_10_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_lasta_v_p_z_combo_11_8000_05228001() {
    // Encoding: 0x05228001
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=1
    // Fields: Zn=0, size=0, Pg=0, Vd=1
    let encoding: u32 = 0x05228001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=30 (SIMD register V30)
#[test]
fn test_lasta_v_p_z_combo_12_8000_0522801e() {
    // Encoding: 0x0522801E
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=30
    // Fields: size=0, Zn=0, Pg=0, Vd=30
    let encoding: u32 = 0x0522801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=31 (SIMD register V31)
#[test]
fn test_lasta_v_p_z_combo_13_8000_0522801f() {
    // Encoding: 0x0522801F
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=31
    // Fields: Vd=31, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x0522801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lasta_v_p_z_special_size_0_size_variant_0_32768_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lasta_v_p_z_special_size_1_size_variant_1_32768_05628000() {
    // Encoding: 0x05628000
    // Test LASTA_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x05628000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lasta_v_p_z_special_size_2_size_variant_2_32768_05a28000() {
    // Encoding: 0x05A28000
    // Test LASTA_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zn=0, Vd=0
    let encoding: u32 = 0x05A28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lasta_v_p_z_special_size_3_size_variant_3_32768_05e28000() {
    // Encoding: 0x05E28000
    // Test LASTA_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Vd=0, size=3, Zn=0
    let encoding: u32 = 0x05E28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lasta_v_p_z_invalid_0_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lasta_v_p_z_invalid_1_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lasta_v_p_z_reg_write_0_05228000() {
    // Test LASTA_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x05228000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05228000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a521c000() {
    // Encoding: 0xA521C000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Rm=1
    let encoding: u32 = 0xA521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a53ec000() {
    // Encoding: 0xA53EC000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA53EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rm_31_max_c000_a53fc000() {
    // Encoding: 0xA53FC000
    // Test LD2W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Pg=0, Zt=0
    let encoding: u32 = 0xA53FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_pg_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a520c400() {
    // Encoding: 0xA520C400
    // Test LD2W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Pg=1, Zt=0
    let encoding: u32 = 0xA520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a520c020() {
    // Encoding: 0xA520C020
    // Test LD2W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=1
    let encoding: u32 = 0xA520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a520c3c0() {
    // Encoding: 0xA520C3C0
    // Test LD2W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2w_z_p_br_contiguous_field_rn_31_max_c000_a520c3e0() {
    // Encoding: 0xA520C3E0
    // Test LD2W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_0_min_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a520c001() {
    // Encoding: 0xA520C001
    // Test LD2W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, Rm=0
    let encoding: u32 = 0xA520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a520c01e() {
    // Encoding: 0xA520C01E
    // Test LD2W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA520C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2w_z_p_br_contiguous_field_zt_31_max_c000_a520c01f() {
    // Encoding: 0xA520C01F
    // Test LD2W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rm=0, Zt=31, Rn=0
    let encoding: u32 = 0xA520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_0_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_1_c000_a521c000() {
    // Encoding: 0xA521C000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xA521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_2_c000_a53ec000() {
    // Encoding: 0xA53EC000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=30, Pg=0, Rn=0
    let encoding: u32 = 0xA53EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_3_c000_a53fc000() {
    // Encoding: 0xA53FC000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xA53FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_4_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_5_c000_a520c400() {
    // Encoding: 0xA520C400
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Pg=1, Rm=0, Rn=0
    let encoding: u32 = 0xA520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_6_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_7_c000_a520c020() {
    // Encoding: 0xA520C020
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rm=0, Rn=1, Zt=0
    let encoding: u32 = 0xA520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_8_c000_a520c3c0() {
    // Encoding: 0xA520C3C0
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Rn=30, Zt=0, Rm=0
    let encoding: u32 = 0xA520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_9_c000_a520c3e0() {
    // Encoding: 0xA520C3E0
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld2w_z_p_br_contiguous_combo_10_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld2w_z_p_br_contiguous_combo_11_c000_a520c001() {
    // Encoding: 0xA520C001
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Rm=0, Rn=0, Zt=1
    let encoding: u32 = 0xA520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld2w_z_p_br_contiguous_combo_12_c000_a520c01e() {
    // Encoding: 0xA520C01E
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xA520C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld2w_z_p_br_contiguous_combo_13_c000_a520c01f() {
    // Encoding: 0xA520C01F
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Rm=0, Pg=0, Zt=31
    let encoding: u32 = 0xA520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_14_c000_a521c400() {
    // Encoding: 0xA521C400
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=1, Rm=1
    let encoding: u32 = 0xA521C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_15_c000_a53fdc00() {
    // Encoding: 0xA53FDC00
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=31, Rm=31
    let encoding: u32 = 0xA53FDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_16_c000_a521c020() {
    // Encoding: 0xA521C020
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Zt=0, Rm=1, Pg=0
    let encoding: u32 = 0xA521C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_17_c000_a53fc3e0() {
    // Encoding: 0xA53FC3E0
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Rn=31, Rm=31, Zt=0
    let encoding: u32 = 0xA53FC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_18_c000_a520c420() {
    // Encoding: 0xA520C420
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Pg=1, Zt=0, Rm=0, Rn=1
    let encoding: u32 = 0xA520C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld2w_z_p_br_contiguous_combo_19_c000_a520dfe0() {
    // Encoding: 0xA520DFE0
    // Test LD2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Rm=0, Pg=31, Rn=31, Zt=0
    let encoding: u32 = 0xA520DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a520c3e0() {
    // Encoding: 0xA520C3E0
    // Test LD2W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_0_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_1_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_2_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2w_z_p_br_contiguous_invalid_3_c000_a520c000() {
    // Encoding: 0xA520C000
    // Test LD2W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2w_z_p_br_contiguous_sp_rn_a520c3e0() {
    // Test LD2W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA520C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA520C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_0_zero_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e5b1e000() {
    // Encoding: 0xE5B1E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5B1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e5b3e000() {
    // Encoding: 0xE5B3E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=3, Pg=0
    let encoding: u32 = 0xE5B3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e5b4e000() {
    // Encoding: 0xE5B4E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm4=4, Pg=0, Rn=0
    let encoding: u32 = 0xE5B4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e5b7e000() {
    // Encoding: 0xE5B7E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5B7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e5b8e000() {
    // Encoding: 0xE5B8E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=8
    let encoding: u32 = 0xE5B8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_15_max_e000_e5bfe000() {
    // Encoding: 0xE5BFE000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=15
    let encoding: u32 = 0xE5BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_pg_0_min_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e5b0e400() {
    // Encoding: 0xE5B0E400
    // Test ST2D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, Zt=0, imm4=0
    let encoding: u32 = 0xE5B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_0_min_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e5b0e020() {
    // Encoding: 0xE5B0E020
    // Test ST2D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xE5B0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e5b0e3c0() {
    // Encoding: 0xE5B0E3C0
    // Test ST2D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5B0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_31_max_e000_e5b0e3e0() {
    // Encoding: 0xE5B0E3E0
    // Test ST2D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xE5B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_0_min_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e5b0e001() {
    // Encoding: 0xE5B0E001
    // Test ST2D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xE5B0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e5b0e01e() {
    // Encoding: 0xE5B0E01E
    // Test ST2D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xE5B0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_31_max_e000_e5b0e01f() {
    // Encoding: 0xE5B0E01F
    // Test ST2D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE5B0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_0_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_1_e000_e5b1e000() {
    // Encoding: 0xE5B1E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xE5B1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_2_e000_e5b3e000() {
    // Encoding: 0xE5B3E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xE5B3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_3_e000_e5b4e000() {
    // Encoding: 0xE5B4E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: imm4=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5B4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_4_e000_e5b7e000() {
    // Encoding: 0xE5B7E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, imm4=7
    let encoding: u32 = 0xE5B7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_5_e000_e5b8e000() {
    // Encoding: 0xE5B8E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm4=8, Rn=0
    let encoding: u32 = 0xE5B8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_6_e000_e5bfe000() {
    // Encoding: 0xE5BFE000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_7_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_8_e000_e5b0e400() {
    // Encoding: 0xE5B0E400
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_9_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_10_e000_e5b0e020() {
    // Encoding: 0xE5B0E020
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5B0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_11_e000_e5b0e3c0() {
    // Encoding: 0xE5B0E3C0
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xE5B0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_12_e000_e5b0e3e0() {
    // Encoding: 0xE5B0E3E0
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: imm4=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE5B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_13_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_14_e000_e5b0e001() {
    // Encoding: 0xE5B0E001
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, imm4=0, Zt=1, Pg=0
    let encoding: u32 = 0xE5B0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_15_e000_e5b0e01e() {
    // Encoding: 0xE5B0E01E
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: imm4=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xE5B0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_16_e000_e5b0e01f() {
    // Encoding: 0xE5B0E01F
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Zt=31, Rn=0, imm4=0
    let encoding: u32 = 0xE5B0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_17_e000_e5b0e420() {
    // Encoding: 0xE5B0E420
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: imm4=0, Zt=0, Pg=1, Rn=1
    let encoding: u32 = 0xE5B0E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_st2d_z_p_bi_contiguous_combo_18_e000_e5b0ffe0() {
    // Encoding: 0xE5B0FFE0
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, imm4=0, Pg=31, Rn=31
    let encoding: u32 = 0xE5B0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e5b0e3e0() {
    // Encoding: 0xE5B0E3E0
    // Test ST2D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xE5B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_bi_contiguous_invalid_0_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_bi_contiguous_invalid_1_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2d_z_p_bi_contiguous_sp_rn_e5b0e3e0() {
    // Test ST2D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE5B0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5B0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2d_z_p_bi_contiguous_store_0_e5b0e020() {
    // Test ST2D_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE5B0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE5B0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRSQRTE_Z.Z__ Tests
// ============================================================================

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frsqrte_z_z_field_size_0_min_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frsqrte_z_z_field_size_1_poweroftwo_3000_654f3000() {
    // Encoding: 0x654F3000
    // Test FRSQRTE_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=1
    let encoding: u32 = 0x654F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frsqrte_z_z_field_size_2_poweroftwo_3000_658f3000() {
    // Encoding: 0x658F3000
    // Test FRSQRTE_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=2
    let encoding: u32 = 0x658F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frsqrte_z_z_field_size_3_max_3000_65cf3000() {
    // Encoding: 0x65CF3000
    // Test FRSQRTE_Z.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x65CF3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrte_z_z_field_zn_0_min_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrte_z_z_field_zn_1_poweroftwo_3000_650f3020() {
    // Encoding: 0x650F3020
    // Test FRSQRTE_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, size=0
    let encoding: u32 = 0x650F3020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrte_z_z_field_zn_30_poweroftwominusone_3000_650f33c0() {
    // Encoding: 0x650F33C0
    // Test FRSQRTE_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=0, Zn=30
    let encoding: u32 = 0x650F33C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrte_z_z_field_zn_31_max_3000_650f33e0() {
    // Encoding: 0x650F33E0
    // Test FRSQRTE_Z.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Zd=0
    let encoding: u32 = 0x650F33E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrte_z_z_field_zd_0_min_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrte_z_z_field_zd_1_poweroftwo_3000_650f3001() {
    // Encoding: 0x650F3001
    // Test FRSQRTE_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1
    let encoding: u32 = 0x650F3001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrte_z_z_field_zd_30_poweroftwominusone_3000_650f301e() {
    // Encoding: 0x650F301E
    // Test FRSQRTE_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0
    let encoding: u32 = 0x650F301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrte_z_z_field_zd_31_max_3000_650f301f() {
    // Encoding: 0x650F301F
    // Test FRSQRTE_Z.Z__ field Zd = 31 (Max)
    // Fields: size=0, Zn=0, Zd=31
    let encoding: u32 = 0x650F301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frsqrte_z_z_combo_0_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_frsqrte_z_z_combo_1_3000_654f3000() {
    // Encoding: 0x654F3000
    // Test FRSQRTE_Z.Z__ field combination: size=1, Zn=0, Zd=0
    // Fields: Zn=0, size=1, Zd=0
    let encoding: u32 = 0x654F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_frsqrte_z_z_combo_2_3000_658f3000() {
    // Encoding: 0x658F3000
    // Test FRSQRTE_Z.Z__ field combination: size=2, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=2
    let encoding: u32 = 0x658F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_frsqrte_z_z_combo_3_3000_65cf3000() {
    // Encoding: 0x65CF3000
    // Test FRSQRTE_Z.Z__ field combination: size=3, Zn=0, Zd=0
    // Fields: Zn=0, size=3, Zd=0
    let encoding: u32 = 0x65CF3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_frsqrte_z_z_combo_4_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: size=0, Zd=0, Zn=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_frsqrte_z_z_combo_5_3000_650f3020() {
    // Encoding: 0x650F3020
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=1, Zd=0
    // Fields: Zd=0, size=0, Zn=1
    let encoding: u32 = 0x650F3020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_frsqrte_z_z_combo_6_3000_650f33c0() {
    // Encoding: 0x650F33C0
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=30, Zd=0
    // Fields: size=0, Zd=0, Zn=30
    let encoding: u32 = 0x650F33C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_frsqrte_z_z_combo_7_3000_650f33e0() {
    // Encoding: 0x650F33E0
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=31, Zd=0
    // Fields: Zn=31, Zd=0, size=0
    let encoding: u32 = 0x650F33E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_frsqrte_z_z_combo_8_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_frsqrte_z_z_combo_9_3000_650f3001() {
    // Encoding: 0x650F3001
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=1
    // Fields: Zd=1, size=0, Zn=0
    let encoding: u32 = 0x650F3001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_frsqrte_z_z_combo_10_3000_650f301e() {
    // Encoding: 0x650F301E
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=30
    // Fields: size=0, Zn=0, Zd=30
    let encoding: u32 = 0x650F301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_frsqrte_z_z_combo_11_3000_650f301f() {
    // Encoding: 0x650F301F
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=31
    // Fields: size=0, Zd=31, Zn=0
    let encoding: u32 = 0x650F301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frsqrte_z_z_special_size_0_size_variant_0_12288_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frsqrte_z_z_special_size_1_size_variant_1_12288_654f3000() {
    // Encoding: 0x654F3000
    // Test FRSQRTE_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zn=0
    let encoding: u32 = 0x654F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frsqrte_z_z_special_size_2_size_variant_2_12288_658f3000() {
    // Encoding: 0x658F3000
    // Test FRSQRTE_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zd=0
    let encoding: u32 = 0x658F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frsqrte_z_z_special_size_3_size_variant_3_12288_65cf3000() {
    // Encoding: 0x65CF3000
    // Test FRSQRTE_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, size=3, Zn=0
    let encoding: u32 = 0x65CF3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_0_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_1_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_2_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_3_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frsqrte_z_z_reg_write_0_650f3000() {
    // Test FRSQRTE_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x650F3000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650F3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LASTB_R.P.Z__ Tests
// ============================================================================

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lastb_r_p_z_field_size_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Rd=0, Pg=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lastb_r_p_z_field_size_1_poweroftwo_a000_0561a000() {
    // Encoding: 0x0561A000
    // Test LASTB_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rd=0, Zn=0, size=1
    let encoding: u32 = 0x0561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lastb_r_p_z_field_size_2_poweroftwo_a000_05a1a000() {
    // Encoding: 0x05A1A000
    // Test LASTB_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Pg=0, Rd=0
    let encoding: u32 = 0x05A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lastb_r_p_z_field_size_3_max_a000_05e1a000() {
    // Encoding: 0x05E1A000
    // Test LASTB_R.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Pg=0, Rd=0
    let encoding: u32 = 0x05E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lastb_r_p_z_field_pg_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field Pg = 0 (Min)
    // Fields: Rd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lastb_r_p_z_field_pg_1_poweroftwo_a000_0521a400() {
    // Encoding: 0x0521A400
    // Test LASTB_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Rd=0, Zn=0, Pg=1, size=0
    let encoding: u32 = 0x0521A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lastb_r_p_z_field_zn_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field Zn = 0 (Min)
    // Fields: Rd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lastb_r_p_z_field_zn_1_poweroftwo_a000_0521a020() {
    // Encoding: 0x0521A020
    // Test LASTB_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, size=0, Rd=0
    let encoding: u32 = 0x0521A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lastb_r_p_z_field_zn_30_poweroftwominusone_a000_0521a3c0() {
    // Encoding: 0x0521A3C0
    // Test LASTB_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Rd=0
    let encoding: u32 = 0x0521A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lastb_r_p_z_field_zn_31_max_a000_0521a3e0() {
    // Encoding: 0x0521A3E0
    // Test LASTB_R.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Pg=0, Rd=0, Zn=31
    let encoding: u32 = 0x0521A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lastb_r_p_z_field_rd_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field Rd = 0 (Min)
    // Fields: Rd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lastb_r_p_z_field_rd_1_poweroftwo_a000_0521a001() {
    // Encoding: 0x0521A001
    // Test LASTB_R.P.Z__ field Rd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Pg=0, Rd=1
    let encoding: u32 = 0x0521A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_lastb_r_p_z_field_rd_30_poweroftwominusone_a000_0521a01e() {
    // Encoding: 0x0521A01E
    // Test LASTB_R.P.Z__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Rd=30, size=0
    let encoding: u32 = 0x0521A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_lastb_r_p_z_field_rd_31_max_a000_0521a01f() {
    // Encoding: 0x0521A01F
    // Test LASTB_R.P.Z__ field Rd = 31 (Max)
    // Fields: size=0, Zn=0, Rd=31, Pg=0
    let encoding: u32 = 0x0521A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lastb_r_p_z_combo_0_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=0
    // Fields: size=0, Rd=0, Pg=0, Zn=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_lastb_r_p_z_combo_1_a000_0561a000() {
    // Encoding: 0x0561A000
    // Test LASTB_R.P.Z__ field combination: size=1, Pg=0, Zn=0, Rd=0
    // Fields: Zn=0, Pg=0, Rd=0, size=1
    let encoding: u32 = 0x0561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_lastb_r_p_z_combo_2_a000_05a1a000() {
    // Encoding: 0x05A1A000
    // Test LASTB_R.P.Z__ field combination: size=2, Pg=0, Zn=0, Rd=0
    // Fields: size=2, Pg=0, Zn=0, Rd=0
    let encoding: u32 = 0x05A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_lastb_r_p_z_combo_3_a000_05e1a000() {
    // Encoding: 0x05E1A000
    // Test LASTB_R.P.Z__ field combination: size=3, Pg=0, Zn=0, Rd=0
    // Fields: size=3, Zn=0, Rd=0, Pg=0
    let encoding: u32 = 0x05E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_lastb_r_p_z_combo_4_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=0
    // Fields: Rd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_lastb_r_p_z_combo_5_a000_0521a400() {
    // Encoding: 0x0521A400
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=1, Zn=0, Rd=0
    // Fields: Rd=0, size=0, Zn=0, Pg=1
    let encoding: u32 = 0x0521A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_lastb_r_p_z_combo_6_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=0
    // Fields: Pg=0, Rd=0, Zn=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_lastb_r_p_z_combo_7_a000_0521a020() {
    // Encoding: 0x0521A020
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=1, Rd=0
    // Fields: Zn=1, Pg=0, Rd=0, size=0
    let encoding: u32 = 0x0521A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_lastb_r_p_z_combo_8_a000_0521a3c0() {
    // Encoding: 0x0521A3C0
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=30, Rd=0
    // Fields: size=0, Pg=0, Rd=0, Zn=30
    let encoding: u32 = 0x0521A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_lastb_r_p_z_combo_9_a000_0521a3e0() {
    // Encoding: 0x0521A3E0
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=31, Rd=0
    // Fields: size=0, Rd=0, Pg=0, Zn=31
    let encoding: u32 = 0x0521A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=0 (register index 0 (first register))
#[test]
fn test_lastb_r_p_z_combo_10_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=0
    // Fields: Zn=0, Rd=0, size=0, Pg=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=1 (register index 1 (second register))
#[test]
fn test_lastb_r_p_z_combo_11_a000_0521a001() {
    // Encoding: 0x0521A001
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=1
    // Fields: size=0, Pg=0, Zn=0, Rd=1
    let encoding: u32 = 0x0521A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=30 (register index 30 (LR in some contexts))
#[test]
fn test_lastb_r_p_z_combo_12_a000_0521a01e() {
    // Encoding: 0x0521A01E
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=30
    // Fields: Pg=0, size=0, Zn=0, Rd=30
    let encoding: u32 = 0x0521A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rd=31 (register index 31 (ZR - zero register))
#[test]
fn test_lastb_r_p_z_combo_13_a000_0521a01f() {
    // Encoding: 0x0521A01F
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=31
    // Fields: Rd=31, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x0521A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rd=1 (same register test (reg=1))
#[test]
fn test_lastb_r_p_z_combo_14_a000_0521a401() {
    // Encoding: 0x0521A401
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=1, Zn=0, Rd=1
    // Fields: Rd=1, Zn=0, size=0, Pg=1
    let encoding: u32 = 0x0521A401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rd=31 (same register test (reg=31))
#[test]
fn test_lastb_r_p_z_combo_15_a000_0521bc1f() {
    // Encoding: 0x0521BC1F
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=31, Zn=0, Rd=31
    // Fields: size=0, Pg=31, Zn=0, Rd=31
    let encoding: u32 = 0x0521BC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lastb_r_p_z_special_size_0_size_variant_0_40960_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zn=0, size=0, Rd=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lastb_r_p_z_special_size_1_size_variant_1_40960_0561a000() {
    // Encoding: 0x0561A000
    // Test LASTB_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Rd=0, Pg=0
    let encoding: u32 = 0x0561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lastb_r_p_z_special_size_2_size_variant_2_40960_05a1a000() {
    // Encoding: 0x05A1A000
    // Test LASTB_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zn=0, Rd=0
    let encoding: u32 = 0x05A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lastb_r_p_z_special_size_3_size_variant_3_40960_05e1a000() {
    // Encoding: 0x05E1A000
    // Test LASTB_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Rd=0, Pg=0, size=3
    let encoding: u32 = 0x05E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_lastb_r_p_z_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_40960_0521a01f() {
    // Encoding: 0x0521A01F
    // Test LASTB_R.P.Z__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Rd=31, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x0521A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lastb_r_p_z_invalid_0_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Rd=0, Pg=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lastb_r_p_z_invalid_1_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Rd=0, Zn=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_lastb_r_p_z_reg_write_0_0521a000() {
    // Test LASTB_R.P.Z__ register write: GpFromField("d")
    // Encoding: 0x0521A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0521A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_lastb_r_p_z_zr_rd_0521a01f() {
    // Test LASTB_R.P.Z__ with Rd = ZR (31)
    // Encoding: 0x0521A01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0521A01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// EOR_Z.ZI__ Tests
// ============================================================================

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_eor_z_zi_field_imm13_0_zero_0_05400000() {
    // Encoding: 0x05400000
    // Test EOR_Z.ZI__ field imm13 = 0 (Zero)
    // Fields: imm13=0, Zdn=0
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_eor_z_zi_field_imm13_1_poweroftwo_0_05400020() {
    // Encoding: 0x05400020
    // Test EOR_Z.ZI__ field imm13 = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm13=1
    let encoding: u32 = 0x05400020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_eor_z_zi_field_imm13_3_poweroftwominusone_0_05400060() {
    // Encoding: 0x05400060
    // Test EOR_Z.ZI__ field imm13 = 3 (PowerOfTwoMinusOne)
    // Fields: imm13=3, Zdn=0
    let encoding: u32 = 0x05400060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_eor_z_zi_field_imm13_4_poweroftwo_0_05400080() {
    // Encoding: 0x05400080
    // Test EOR_Z.ZI__ field imm13 = 4 (PowerOfTwo)
    // Fields: Zdn=0, imm13=4
    let encoding: u32 = 0x05400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_eor_z_zi_field_imm13_7_poweroftwominusone_0_054000e0() {
    // Encoding: 0x054000E0
    // Test EOR_Z.ZI__ field imm13 = 7 (PowerOfTwoMinusOne)
    // Fields: imm13=7, Zdn=0
    let encoding: u32 = 0x054000E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_eor_z_zi_field_imm13_8_poweroftwo_0_05400100() {
    // Encoding: 0x05400100
    // Test EOR_Z.ZI__ field imm13 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm13=8
    let encoding: u32 = 0x05400100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_eor_z_zi_field_imm13_15_poweroftwominusone_0_054001e0() {
    // Encoding: 0x054001E0
    // Test EOR_Z.ZI__ field imm13 = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm13=15
    let encoding: u32 = 0x054001E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_eor_z_zi_field_imm13_16_poweroftwo_0_05400200() {
    // Encoding: 0x05400200
    // Test EOR_Z.ZI__ field imm13 = 16 (PowerOfTwo)
    // Fields: Zdn=0, imm13=16
    let encoding: u32 = 0x05400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_eor_z_zi_field_imm13_31_poweroftwominusone_0_054003e0() {
    // Encoding: 0x054003E0
    // Test EOR_Z.ZI__ field imm13 = 31 (PowerOfTwoMinusOne)
    // Fields: imm13=31, Zdn=0
    let encoding: u32 = 0x054003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_eor_z_zi_field_imm13_32_poweroftwo_0_05400400() {
    // Encoding: 0x05400400
    // Test EOR_Z.ZI__ field imm13 = 32 (PowerOfTwo)
    // Fields: imm13=32, Zdn=0
    let encoding: u32 = 0x05400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_eor_z_zi_field_imm13_63_poweroftwominusone_0_054007e0() {
    // Encoding: 0x054007E0
    // Test EOR_Z.ZI__ field imm13 = 63 (PowerOfTwoMinusOne)
    // Fields: imm13=63, Zdn=0
    let encoding: u32 = 0x054007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_eor_z_zi_field_imm13_64_poweroftwo_0_05400800() {
    // Encoding: 0x05400800
    // Test EOR_Z.ZI__ field imm13 = 64 (PowerOfTwo)
    // Fields: Zdn=0, imm13=64
    let encoding: u32 = 0x05400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_eor_z_zi_field_imm13_127_poweroftwominusone_0_05400fe0() {
    // Encoding: 0x05400FE0
    // Test EOR_Z.ZI__ field imm13 = 127 (PowerOfTwoMinusOne)
    // Fields: imm13=127, Zdn=0
    let encoding: u32 = 0x05400FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_eor_z_zi_field_imm13_128_poweroftwo_0_05401000() {
    // Encoding: 0x05401000
    // Test EOR_Z.ZI__ field imm13 = 128 (PowerOfTwo)
    // Fields: imm13=128, Zdn=0
    let encoding: u32 = 0x05401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_eor_z_zi_field_imm13_255_poweroftwominusone_0_05401fe0() {
    // Encoding: 0x05401FE0
    // Test EOR_Z.ZI__ field imm13 = 255 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm13=255
    let encoding: u32 = 0x05401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_eor_z_zi_field_imm13_256_poweroftwo_0_05402000() {
    // Encoding: 0x05402000
    // Test EOR_Z.ZI__ field imm13 = 256 (PowerOfTwo)
    // Fields: Zdn=0, imm13=256
    let encoding: u32 = 0x05402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_eor_z_zi_field_imm13_511_poweroftwominusone_0_05403fe0() {
    // Encoding: 0x05403FE0
    // Test EOR_Z.ZI__ field imm13 = 511 (PowerOfTwoMinusOne)
    // Fields: imm13=511, Zdn=0
    let encoding: u32 = 0x05403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_eor_z_zi_field_imm13_512_poweroftwo_0_05404000() {
    // Encoding: 0x05404000
    // Test EOR_Z.ZI__ field imm13 = 512 (PowerOfTwo)
    // Fields: Zdn=0, imm13=512
    let encoding: u32 = 0x05404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_eor_z_zi_field_imm13_1023_poweroftwominusone_0_05407fe0() {
    // Encoding: 0x05407FE0
    // Test EOR_Z.ZI__ field imm13 = 1023 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm13=1023
    let encoding: u32 = 0x05407FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_eor_z_zi_field_imm13_1024_poweroftwo_0_05408000() {
    // Encoding: 0x05408000
    // Test EOR_Z.ZI__ field imm13 = 1024 (PowerOfTwo)
    // Fields: Zdn=0, imm13=1024
    let encoding: u32 = 0x05408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 2047, boundary: PowerOfTwoMinusOne }
/// 2^11 - 1 = 2047
#[test]
fn test_eor_z_zi_field_imm13_2047_poweroftwominusone_0_0540ffe0() {
    // Encoding: 0x0540FFE0
    // Test EOR_Z.ZI__ field imm13 = 2047 (PowerOfTwoMinusOne)
    // Fields: imm13=2047, Zdn=0
    let encoding: u32 = 0x0540FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_eor_z_zi_field_imm13_2048_poweroftwo_0_05410000() {
    // Encoding: 0x05410000
    // Test EOR_Z.ZI__ field imm13 = 2048 (PowerOfTwo)
    // Fields: imm13=2048, Zdn=0
    let encoding: u32 = 0x05410000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 4095, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (4095)
#[test]
fn test_eor_z_zi_field_imm13_4095_poweroftwominusone_0_0541ffe0() {
    // Encoding: 0x0541FFE0
    // Test EOR_Z.ZI__ field imm13 = 4095 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm13=4095
    let encoding: u32 = 0x0541FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 4096, boundary: PowerOfTwo }
/// power of 2 (2^12 = 4096)
#[test]
fn test_eor_z_zi_field_imm13_4096_poweroftwo_0_05420000() {
    // Encoding: 0x05420000
    // Test EOR_Z.ZI__ field imm13 = 4096 (PowerOfTwo)
    // Fields: Zdn=0, imm13=4096
    let encoding: u32 = 0x05420000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 8191, boundary: Max }
/// maximum immediate (8191)
#[test]
fn test_eor_z_zi_field_imm13_8191_max_0_0543ffe0() {
    // Encoding: 0x0543FFE0
    // Test EOR_Z.ZI__ field imm13 = 8191 (Max)
    // Fields: Zdn=0, imm13=8191
    let encoding: u32 = 0x0543FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_eor_z_zi_field_zdn_0_min_0_05400000() {
    // Encoding: 0x05400000
    // Test EOR_Z.ZI__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm13=0
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_eor_z_zi_field_zdn_1_poweroftwo_0_05400001() {
    // Encoding: 0x05400001
    // Test EOR_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, imm13=0
    let encoding: u32 = 0x05400001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_eor_z_zi_field_zdn_15_poweroftwominusone_0_0540000f() {
    // Encoding: 0x0540000F
    // Test EOR_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm13=0, Zdn=15
    let encoding: u32 = 0x0540000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_eor_z_zi_field_zdn_31_max_0_0540001f() {
    // Encoding: 0x0540001F
    // Test EOR_Z.ZI__ field Zdn = 31 (Max)
    // Fields: imm13=0, Zdn=31
    let encoding: u32 = 0x0540001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=0 (immediate value 0)
#[test]
fn test_eor_z_zi_combo_0_0_05400000() {
    // Encoding: 0x05400000
    // Test EOR_Z.ZI__ field combination: imm13=0, Zdn=0
    // Fields: Zdn=0, imm13=0
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=1 (immediate value 1)
#[test]
fn test_eor_z_zi_combo_1_0_05400020() {
    // Encoding: 0x05400020
    // Test EOR_Z.ZI__ field combination: imm13=1, Zdn=0
    // Fields: imm13=1, Zdn=0
    let encoding: u32 = 0x05400020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=3 (2^2 - 1 = 3)
#[test]
fn test_eor_z_zi_combo_2_0_05400060() {
    // Encoding: 0x05400060
    // Test EOR_Z.ZI__ field combination: imm13=3, Zdn=0
    // Fields: Zdn=0, imm13=3
    let encoding: u32 = 0x05400060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=4 (power of 2 (2^2 = 4))
#[test]
fn test_eor_z_zi_combo_3_0_05400080() {
    // Encoding: 0x05400080
    // Test EOR_Z.ZI__ field combination: imm13=4, Zdn=0
    // Fields: imm13=4, Zdn=0
    let encoding: u32 = 0x05400080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=7 (2^3 - 1 = 7)
#[test]
fn test_eor_z_zi_combo_4_0_054000e0() {
    // Encoding: 0x054000E0
    // Test EOR_Z.ZI__ field combination: imm13=7, Zdn=0
    // Fields: imm13=7, Zdn=0
    let encoding: u32 = 0x054000E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=8 (power of 2 (2^3 = 8))
#[test]
fn test_eor_z_zi_combo_5_0_05400100() {
    // Encoding: 0x05400100
    // Test EOR_Z.ZI__ field combination: imm13=8, Zdn=0
    // Fields: Zdn=0, imm13=8
    let encoding: u32 = 0x05400100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=15 (2^4 - 1 = 15)
#[test]
fn test_eor_z_zi_combo_6_0_054001e0() {
    // Encoding: 0x054001E0
    // Test EOR_Z.ZI__ field combination: imm13=15, Zdn=0
    // Fields: Zdn=0, imm13=15
    let encoding: u32 = 0x054001E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=16 (power of 2 (2^4 = 16))
#[test]
fn test_eor_z_zi_combo_7_0_05400200() {
    // Encoding: 0x05400200
    // Test EOR_Z.ZI__ field combination: imm13=16, Zdn=0
    // Fields: Zdn=0, imm13=16
    let encoding: u32 = 0x05400200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=31 (2^5 - 1 = 31)
#[test]
fn test_eor_z_zi_combo_8_0_054003e0() {
    // Encoding: 0x054003E0
    // Test EOR_Z.ZI__ field combination: imm13=31, Zdn=0
    // Fields: Zdn=0, imm13=31
    let encoding: u32 = 0x054003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=32 (power of 2 (2^5 = 32))
#[test]
fn test_eor_z_zi_combo_9_0_05400400() {
    // Encoding: 0x05400400
    // Test EOR_Z.ZI__ field combination: imm13=32, Zdn=0
    // Fields: imm13=32, Zdn=0
    let encoding: u32 = 0x05400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=63 (2^6 - 1 = 63)
#[test]
fn test_eor_z_zi_combo_10_0_054007e0() {
    // Encoding: 0x054007E0
    // Test EOR_Z.ZI__ field combination: imm13=63, Zdn=0
    // Fields: imm13=63, Zdn=0
    let encoding: u32 = 0x054007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=64 (power of 2 (2^6 = 64))
#[test]
fn test_eor_z_zi_combo_11_0_05400800() {
    // Encoding: 0x05400800
    // Test EOR_Z.ZI__ field combination: imm13=64, Zdn=0
    // Fields: Zdn=0, imm13=64
    let encoding: u32 = 0x05400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=127 (2^7 - 1 = 127)
#[test]
fn test_eor_z_zi_combo_12_0_05400fe0() {
    // Encoding: 0x05400FE0
    // Test EOR_Z.ZI__ field combination: imm13=127, Zdn=0
    // Fields: Zdn=0, imm13=127
    let encoding: u32 = 0x05400FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=128 (power of 2 (2^7 = 128))
#[test]
fn test_eor_z_zi_combo_13_0_05401000() {
    // Encoding: 0x05401000
    // Test EOR_Z.ZI__ field combination: imm13=128, Zdn=0
    // Fields: imm13=128, Zdn=0
    let encoding: u32 = 0x05401000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=255 (2^8 - 1 = 255)
#[test]
fn test_eor_z_zi_combo_14_0_05401fe0() {
    // Encoding: 0x05401FE0
    // Test EOR_Z.ZI__ field combination: imm13=255, Zdn=0
    // Fields: imm13=255, Zdn=0
    let encoding: u32 = 0x05401FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=256 (power of 2 (2^8 = 256))
#[test]
fn test_eor_z_zi_combo_15_0_05402000() {
    // Encoding: 0x05402000
    // Test EOR_Z.ZI__ field combination: imm13=256, Zdn=0
    // Fields: imm13=256, Zdn=0
    let encoding: u32 = 0x05402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=511 (2^9 - 1 = 511)
#[test]
fn test_eor_z_zi_combo_16_0_05403fe0() {
    // Encoding: 0x05403FE0
    // Test EOR_Z.ZI__ field combination: imm13=511, Zdn=0
    // Fields: Zdn=0, imm13=511
    let encoding: u32 = 0x05403FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=512 (power of 2 (2^9 = 512))
#[test]
fn test_eor_z_zi_combo_17_0_05404000() {
    // Encoding: 0x05404000
    // Test EOR_Z.ZI__ field combination: imm13=512, Zdn=0
    // Fields: imm13=512, Zdn=0
    let encoding: u32 = 0x05404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=1023 (2^10 - 1 = 1023)
#[test]
fn test_eor_z_zi_combo_18_0_05407fe0() {
    // Encoding: 0x05407FE0
    // Test EOR_Z.ZI__ field combination: imm13=1023, Zdn=0
    // Fields: imm13=1023, Zdn=0
    let encoding: u32 = 0x05407FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=1024 (power of 2 (2^10 = 1024))
#[test]
fn test_eor_z_zi_combo_19_0_05408000() {
    // Encoding: 0x05408000
    // Test EOR_Z.ZI__ field combination: imm13=1024, Zdn=0
    // Fields: Zdn=0, imm13=1024
    let encoding: u32 = 0x05408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_eor_z_zi_invalid_0_0_05400000() {
    // Encoding: 0x05400000
    // Test EOR_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm13=0
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_eor_z_zi_invalid_1_0_05400000() {
    // Encoding: 0x05400000
    // Test EOR_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, imm13=0
    let encoding: u32 = 0x05400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: EOR_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_eor_z_zi_reg_write_0_05400000() {
    // Test EOR_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x05400000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05400000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNF1SB_Z.P.BI_S16 Tests
// ============================================================================

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_0_zero_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_1_poweroftwo_a000_a5d1a000() {
    // Encoding: 0xA5D1A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xA5D1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_3_poweroftwominusone_a000_a5d3a000() {
    // Encoding: 0xA5D3A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5D3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_4_poweroftwo_a000_a5d4a000() {
    // Encoding: 0xA5D4A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5D4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_7_poweroftwominusone_a000_a5d7a000() {
    // Encoding: 0xA5D7A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0
    let encoding: u32 = 0xA5D7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_8_poweroftwo_a000_a5d8a000() {
    // Encoding: 0xA5D8A000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, imm4=8, Pg=0, Zt=0
    let encoding: u32 = 0xA5D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_imm4_15_max_a000_a5dfa000() {
    // Encoding: 0xA5DFA000
    // Test LDNF1SB_Z.P.BI_S16 field imm4 = 15 (Max)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=15
    let encoding: u32 = 0xA5DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_pg_0_min_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_pg_1_poweroftwo_a000_a5d0a400() {
    // Encoding: 0xA5D0A400
    // Test LDNF1SB_Z.P.BI_S16 field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=1
    let encoding: u32 = 0xA5D0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_0_min_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_1_poweroftwo_a000_a5d0a020() {
    // Encoding: 0xA5D0A020
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xA5D0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_30_poweroftwominusone_a000_a5d0a3c0() {
    // Encoding: 0xA5D0A3C0
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, imm4=0
    let encoding: u32 = 0xA5D0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_rn_31_max_a000_a5d0a3e0() {
    // Encoding: 0xA5D0A3E0
    // Test LDNF1SB_Z.P.BI_S16 field Rn = 31 (Max)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=31
    let encoding: u32 = 0xA5D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_0_min_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_1_poweroftwo_a000_a5d0a001() {
    // Encoding: 0xA5D0A001
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xA5D0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_30_poweroftwominusone_a000_a5d0a01e() {
    // Encoding: 0xA5D0A01E
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA5D0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sb_z_p_bi_s16_field_zt_31_max_a000_a5d0a01f() {
    // Encoding: 0xA5D0A01F
    // Test LDNF1SB_Z.P.BI_S16 field Zt = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=31
    let encoding: u32 = 0xA5D0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_0_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_1_a000_a5d1a000() {
    // Encoding: 0xA5D1A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: imm4=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5D1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_2_a000_a5d3a000() {
    // Encoding: 0xA5D3A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, imm4=3, Pg=0
    let encoding: u32 = 0xA5D3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_3_a000_a5d4a000() {
    // Encoding: 0xA5D4A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=4, Pg=0, Rn=0
    let encoding: u32 = 0xA5D4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_4_a000_a5d7a000() {
    // Encoding: 0xA5D7A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=7, Zt=0, Pg=0
    let encoding: u32 = 0xA5D7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_5_a000_a5d8a000() {
    // Encoding: 0xA5D8A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: imm4=8, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_6_a000_a5dfa000() {
    // Encoding: 0xA5DFA000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: imm4=15, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_7_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_8_a000_a5d0a400() {
    // Encoding: 0xA5D0A400
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xA5D0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_9_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_10_a000_a5d0a020() {
    // Encoding: 0xA5D0A020
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Pg=0, imm4=0, Rn=1
    let encoding: u32 = 0xA5D0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_11_a000_a5d0a3c0() {
    // Encoding: 0xA5D0A3C0
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: imm4=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xA5D0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_12_a000_a5d0a3e0() {
    // Encoding: 0xA5D0A3E0
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA5D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_13_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_14_a000_a5d0a001() {
    // Encoding: 0xA5D0A001
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5D0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_15_a000_a5d0a01e() {
    // Encoding: 0xA5D0A01E
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xA5D0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_16_a000_a5d0a01f() {
    // Encoding: 0xA5D0A01F
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA5D0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_17_a000_a5d0a420() {
    // Encoding: 0xA5D0A420
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: imm4=0, Pg=1, Rn=1, Zt=0
    let encoding: u32 = 0xA5D0A420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnf1sb_z_p_bi_s16_combo_18_a000_a5d0bfe0() {
    // Encoding: 0xA5D0BFE0
    // Test LDNF1SB_Z.P.BI_S16 field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xA5D0BFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sb_z_p_bi_s16_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5d0a3e0() {
    // Encoding: 0xA5D0A3E0
    // Test LDNF1SB_Z.P.BI_S16 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xA5D0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s16_invalid_0_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s16_invalid_1_a000_a5d0a000() {
    // Encoding: 0xA5D0A000
    // Test LDNF1SB_Z.P.BI_S16 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_0_zero_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_1_poweroftwo_a000_a5b1a000() {
    // Encoding: 0xA5B1A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA5B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_3_poweroftwominusone_a000_a5b3a000() {
    // Encoding: 0xA5B3A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=3, Rn=0
    let encoding: u32 = 0xA5B3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_4_poweroftwo_a000_a5b4a000() {
    // Encoding: 0xA5B4A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, imm4=4, Zt=0, Pg=0
    let encoding: u32 = 0xA5B4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_7_poweroftwominusone_a000_a5b7a000() {
    // Encoding: 0xA5B7A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=7, Rn=0
    let encoding: u32 = 0xA5B7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_8_poweroftwo_a000_a5b8a000() {
    // Encoding: 0xA5B8A000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA5B8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_imm4_15_max_a000_a5bfa000() {
    // Encoding: 0xA5BFA000
    // Test LDNF1SB_Z.P.BI_S32 field imm4 = 15 (Max)
    // Fields: Pg=0, imm4=15, Rn=0, Zt=0
    let encoding: u32 = 0xA5BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_pg_0_min_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_pg_1_poweroftwo_a000_a5b0a400() {
    // Encoding: 0xA5B0A400
    // Test LDNF1SB_Z.P.BI_S32 field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA5B0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_0_min_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_1_poweroftwo_a000_a5b0a020() {
    // Encoding: 0xA5B0A020
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, imm4=0
    let encoding: u32 = 0xA5B0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_30_poweroftwominusone_a000_a5b0a3c0() {
    // Encoding: 0xA5B0A3C0
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xA5B0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_rn_31_max_a000_a5b0a3e0() {
    // Encoding: 0xA5B0A3E0
    // Test LDNF1SB_Z.P.BI_S32 field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_0_min_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_1_poweroftwo_a000_a5b0a001() {
    // Encoding: 0xA5B0A001
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, imm4=0, Rn=0
    let encoding: u32 = 0xA5B0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_30_poweroftwominusone_a000_a5b0a01e() {
    // Encoding: 0xA5B0A01E
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA5B0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sb_z_p_bi_s32_field_zt_31_max_a000_a5b0a01f() {
    // Encoding: 0xA5B0A01F
    // Test LDNF1SB_Z.P.BI_S32 field Zt = 31 (Max)
    // Fields: Zt=31, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5B0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_0_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_1_a000_a5b1a000() {
    // Encoding: 0xA5B1A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: imm4=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_2_a000_a5b3a000() {
    // Encoding: 0xA5B3A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5B3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_3_a000_a5b4a000() {
    // Encoding: 0xA5B4A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5B4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_4_a000_a5b7a000() {
    // Encoding: 0xA5B7A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: imm4=7, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5B7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_5_a000_a5b8a000() {
    // Encoding: 0xA5B8A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm4=8, Rn=0
    let encoding: u32 = 0xA5B8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_6_a000_a5bfa000() {
    // Encoding: 0xA5BFA000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, imm4=15
    let encoding: u32 = 0xA5BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_7_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_8_a000_a5b0a400() {
    // Encoding: 0xA5B0A400
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Pg=1, imm4=0, Zt=0
    let encoding: u32 = 0xA5B0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_9_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_10_a000_a5b0a020() {
    // Encoding: 0xA5B0A020
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xA5B0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_11_a000_a5b0a3c0() {
    // Encoding: 0xA5B0A3C0
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, imm4=0, Zt=0, Rn=30
    let encoding: u32 = 0xA5B0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_12_a000_a5b0a3e0() {
    // Encoding: 0xA5B0A3E0
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, imm4=0, Rn=31, Pg=0
    let encoding: u32 = 0xA5B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_13_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_14_a000_a5b0a001() {
    // Encoding: 0xA5B0A001
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Pg=0, imm4=0, Zt=1
    let encoding: u32 = 0xA5B0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_15_a000_a5b0a01e() {
    // Encoding: 0xA5B0A01E
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, imm4=0, Pg=0, Zt=30
    let encoding: u32 = 0xA5B0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_16_a000_a5b0a01f() {
    // Encoding: 0xA5B0A01F
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Zt=31, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xA5B0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_17_a000_a5b0a420() {
    // Encoding: 0xA5B0A420
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Pg=1, Zt=0, imm4=0
    let encoding: u32 = 0xA5B0A420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnf1sb_z_p_bi_s32_combo_18_a000_a5b0bfe0() {
    // Encoding: 0xA5B0BFE0
    // Test LDNF1SB_Z.P.BI_S32 field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: imm4=0, Rn=31, Pg=31, Zt=0
    let encoding: u32 = 0xA5B0BFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sb_z_p_bi_s32_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a5b0a3e0() {
    // Encoding: 0xA5B0A3E0
    // Test LDNF1SB_Z.P.BI_S32 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=31
    let encoding: u32 = 0xA5B0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s32_invalid_0_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s32_invalid_1_a000_a5b0a000() {
    // Encoding: 0xA5B0A000
    // Test LDNF1SB_Z.P.BI_S32 invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_0_zero_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_1_poweroftwo_a000_a591a000() {
    // Encoding: 0xA591A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=1, Rn=0
    let encoding: u32 = 0xA591A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_3_poweroftwominusone_a000_a593a000() {
    // Encoding: 0xA593A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xA593A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_4_poweroftwo_a000_a594a000() {
    // Encoding: 0xA594A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA594A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_7_poweroftwominusone_a000_a597a000() {
    // Encoding: 0xA597A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xA597A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_8_poweroftwo_a000_a598a000() {
    // Encoding: 0xA598A000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=8
    let encoding: u32 = 0xA598A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_imm4_15_max_a000_a59fa000() {
    // Encoding: 0xA59FA000
    // Test LDNF1SB_Z.P.BI_S64 field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA59FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_pg_0_min_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_pg_1_poweroftwo_a000_a590a400() {
    // Encoding: 0xA590A400
    // Test LDNF1SB_Z.P.BI_S64 field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA590A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_0_min_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_1_poweroftwo_a000_a590a020() {
    // Encoding: 0xA590A020
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xA590A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_30_poweroftwominusone_a000_a590a3c0() {
    // Encoding: 0xA590A3C0
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xA590A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_rn_31_max_a000_a590a3e0() {
    // Encoding: 0xA590A3E0
    // Test LDNF1SB_Z.P.BI_S64 field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA590A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_0_min_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_1_poweroftwo_a000_a590a001() {
    // Encoding: 0xA590A001
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA590A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_30_poweroftwominusone_a000_a590a01e() {
    // Encoding: 0xA590A01E
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=30
    let encoding: u32 = 0xA590A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnf1sb_z_p_bi_s64_field_zt_31_max_a000_a590a01f() {
    // Encoding: 0xA590A01F
    // Test LDNF1SB_Z.P.BI_S64 field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, imm4=0
    let encoding: u32 = 0xA590A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_0_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_1_a000_a591a000() {
    // Encoding: 0xA591A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=1
    let encoding: u32 = 0xA591A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_2_a000_a593a000() {
    // Encoding: 0xA593A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: imm4=3, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA593A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_3_a000_a594a000() {
    // Encoding: 0xA594A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=4, Zt=0
    let encoding: u32 = 0xA594A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_4_a000_a597a000() {
    // Encoding: 0xA597A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=7, Zt=0
    let encoding: u32 = 0xA597A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_5_a000_a598a000() {
    // Encoding: 0xA598A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=8
    let encoding: u32 = 0xA598A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_6_a000_a59fa000() {
    // Encoding: 0xA59FA000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, imm4=15, Pg=0
    let encoding: u32 = 0xA59FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_7_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_8_a000_a590a400() {
    // Encoding: 0xA590A400
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=1, imm4=0
    let encoding: u32 = 0xA590A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_9_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_10_a000_a590a020() {
    // Encoding: 0xA590A020
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Zt=0, Rn=1, imm4=0
    let encoding: u32 = 0xA590A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_11_a000_a590a3c0() {
    // Encoding: 0xA590A3C0
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Pg=0, Rn=30, imm4=0
    let encoding: u32 = 0xA590A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_12_a000_a590a3e0() {
    // Encoding: 0xA590A3E0
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xA590A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_13_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_14_a000_a590a001() {
    // Encoding: 0xA590A001
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, imm4=0, Rn=0
    let encoding: u32 = 0xA590A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_15_a000_a590a01e() {
    // Encoding: 0xA590A01E
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Pg=0, imm4=0, Zt=30
    let encoding: u32 = 0xA590A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_16_a000_a590a01f() {
    // Encoding: 0xA590A01F
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, imm4=0, Zt=31, Rn=0
    let encoding: u32 = 0xA590A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_17_a000_a590a420() {
    // Encoding: 0xA590A420
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: Pg=1, imm4=0, Zt=0, Rn=1
    let encoding: u32 = 0xA590A420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnf1sb_z_p_bi_s64_combo_18_a000_a590bfe0() {
    // Encoding: 0xA590BFE0
    // Test LDNF1SB_Z.P.BI_S64 field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Pg=31, Rn=31, imm4=0
    let encoding: u32 = 0xA590BFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnf1sb_z_p_bi_s64_special_rn_31_stack_pointer_sp_may_require_alignment_40960_a590a3e0() {
    // Encoding: 0xA590A3E0
    // Test LDNF1SB_Z.P.BI_S64 special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA590A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s64_invalid_0_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnf1sb_z_p_bi_s64_invalid_1_a000_a590a000() {
    // Encoding: 0xA590A000
    // Test LDNF1SB_Z.P.BI_S64 invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA590A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sb_z_p_bi_s16_reg_write_0_a5d0a000() {
    // Test LDNF1SB_Z.P.BI_S16 register write: SimdFromField("t")
    // Encoding: 0xA5D0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5D0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S16
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sb_z_p_bi_s16_sp_rn_a5d0a3e0() {
    // Test LDNF1SB_Z.P.BI_S16 with Rn = SP (31)
    // Encoding: 0xA5D0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5D0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sb_z_p_bi_s32_reg_write_0_a5b0a000() {
    // Test LDNF1SB_Z.P.BI_S32 register write: SimdFromField("t")
    // Encoding: 0xA5B0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5B0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S32
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sb_z_p_bi_s32_sp_rn_a5b0a3e0() {
    // Test LDNF1SB_Z.P.BI_S32 with Rn = SP (31)
    // Encoding: 0xA5B0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5B0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnf1sb_z_p_bi_s64_reg_write_0_a590a000() {
    // Test LDNF1SB_Z.P.BI_S64 register write: SimdFromField("t")
    // Encoding: 0xA590A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA590A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNF1SB_Z.P.BI_S64
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnf1sb_z_p_bi_s64_sp_rn_a590a3e0() {
    // Test LDNF1SB_Z.P.BI_S64 with Rn = SP (31)
    // Encoding: 0xA590A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA590A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECW_R.RS_UW Tests
// ============================================================================

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_0_zero_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_1_poweroftwo_fc00_04a1fc00() {
    // Encoding: 0x04A1FC00
    // Test UQDECW_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x04A1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_3_poweroftwominusone_fc00_04a3fc00() {
    // Encoding: 0x04A3FC00
    // Test UQDECW_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04A3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_4_poweroftwo_fc00_04a4fc00() {
    // Encoding: 0x04A4FC00
    // Test UQDECW_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x04A4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_7_poweroftwominusone_fc00_04a7fc00() {
    // Encoding: 0x04A7FC00
    // Test UQDECW_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04A7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_8_poweroftwo_fc00_04a8fc00() {
    // Encoding: 0x04A8FC00
    // Test UQDECW_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x04A8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_15_max_fc00_04affc00() {
    // Encoding: 0x04AFFC00
    // Test UQDECW_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04AFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_0_min_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_1_poweroftwo_fc00_04a0fc20() {
    // Encoding: 0x04A0FC20
    // Test UQDECW_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_15_poweroftwominusone_fc00_04a0fde0() {
    // Encoding: 0x04A0FDE0
    // Test UQDECW_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=0, pattern=15
    let encoding: u32 = 0x04A0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_31_max_fc00_04a0ffe0() {
    // Encoding: 0x04A0FFE0
    // Test UQDECW_R.RS_UW field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04A0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_0_min_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_1_poweroftwo_fc00_04a0fc01() {
    // Encoding: 0x04A0FC01
    // Test UQDECW_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04A0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_15_poweroftwominusone_fc00_04a0fc0f() {
    // Encoding: 0x04A0FC0F
    // Test UQDECW_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04A0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_31_max_fc00_04a0fc1f() {
    // Encoding: 0x04A0FC1F
    // Test UQDECW_R.RS_UW field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04A0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecw_r_rs_uw_combo_0_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_uqdecw_r_rs_uw_combo_1_fc00_04a1fc00() {
    // Encoding: 0x04A1FC00
    // Test UQDECW_R.RS_UW field combination: imm4=1, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04A1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_uqdecw_r_rs_uw_combo_2_fc00_04a3fc00() {
    // Encoding: 0x04A3FC00
    // Test UQDECW_R.RS_UW field combination: imm4=3, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x04A3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_uqdecw_r_rs_uw_combo_3_fc00_04a4fc00() {
    // Encoding: 0x04A4FC00
    // Test UQDECW_R.RS_UW field combination: imm4=4, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x04A4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_uqdecw_r_rs_uw_combo_4_fc00_04a7fc00() {
    // Encoding: 0x04A7FC00
    // Test UQDECW_R.RS_UW field combination: imm4=7, pattern=0, Rdn=0
    // Fields: imm4=7, Rdn=0, pattern=0
    let encoding: u32 = 0x04A7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_uqdecw_r_rs_uw_combo_5_fc00_04a8fc00() {
    // Encoding: 0x04A8FC00
    // Test UQDECW_R.RS_UW field combination: imm4=8, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=8
    let encoding: u32 = 0x04A8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_uqdecw_r_rs_uw_combo_6_fc00_04affc00() {
    // Encoding: 0x04AFFC00
    // Test UQDECW_R.RS_UW field combination: imm4=15, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=15
    let encoding: u32 = 0x04AFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_uqdecw_r_rs_uw_combo_7_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_uqdecw_r_rs_uw_combo_8_fc00_04a0fc20() {
    // Encoding: 0x04A0FC20
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=1, Rdn=0
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x04A0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_uqdecw_r_rs_uw_combo_9_fc00_04a0fde0() {
    // Encoding: 0x04A0FDE0
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=15, Rdn=0
    // Fields: Rdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x04A0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_uqdecw_r_rs_uw_combo_10_fc00_04a0ffe0() {
    // Encoding: 0x04A0FFE0
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=31, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x04A0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_uqdecw_r_rs_uw_combo_11_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=1 (value 1)
#[test]
fn test_uqdecw_r_rs_uw_combo_12_fc00_04a0fc01() {
    // Encoding: 0x04A0FC01
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=1
    // Fields: imm4=0, Rdn=1, pattern=0
    let encoding: u32 = 0x04A0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=15 (midpoint (15))
#[test]
fn test_uqdecw_r_rs_uw_combo_13_fc00_04a0fc0f() {
    // Encoding: 0x04A0FC0F
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=15
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04A0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=31 (maximum value (31))
#[test]
fn test_uqdecw_r_rs_uw_combo_14_fc00_04a0fc1f() {
    // Encoding: 0x04A0FC1F
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=31
    // Fields: pattern=0, imm4=0, Rdn=31
    let encoding: u32 = 0x04A0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_uw_invalid_0_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_uw_invalid_1_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecw_r_rs_x_field_imm4_0_zero_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecw_r_rs_x_field_imm4_1_poweroftwo_fc00_04b1fc00() {
    // Encoding: 0x04B1FC00
    // Test UQDECW_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rdn=0, pattern=0
    let encoding: u32 = 0x04B1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecw_r_rs_x_field_imm4_3_poweroftwominusone_fc00_04b3fc00() {
    // Encoding: 0x04B3FC00
    // Test UQDECW_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x04B3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_4_poweroftwo_fc00_04b4fc00() {
    // Encoding: 0x04B4FC00
    // Test UQDECW_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x04B4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_7_poweroftwominusone_fc00_04b7fc00() {
    // Encoding: 0x04B7FC00
    // Test UQDECW_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04B7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_8_poweroftwo_fc00_04b8fc00() {
    // Encoding: 0x04B8FC00
    // Test UQDECW_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04B8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_15_max_fc00_04bffc00() {
    // Encoding: 0x04BFFC00
    // Test UQDECW_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04BFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_x_field_pattern_0_min_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_x_field_pattern_1_poweroftwo_fc00_04b0fc20() {
    // Encoding: 0x04B0FC20
    // Test UQDECW_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x04B0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_x_field_pattern_15_poweroftwominusone_fc00_04b0fde0() {
    // Encoding: 0x04B0FDE0
    // Test UQDECW_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x04B0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_x_field_pattern_31_max_fc00_04b0ffe0() {
    // Encoding: 0x04B0FFE0
    // Test UQDECW_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04B0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_x_field_rdn_0_min_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_x_field_rdn_1_poweroftwo_fc00_04b0fc01() {
    // Encoding: 0x04B0FC01
    // Test UQDECW_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Rdn=1
    let encoding: u32 = 0x04B0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_x_field_rdn_15_poweroftwominusone_fc00_04b0fc0f() {
    // Encoding: 0x04B0FC0F
    // Test UQDECW_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x04B0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_x_field_rdn_31_max_fc00_04b0fc1f() {
    // Encoding: 0x04B0FC1F
    // Test UQDECW_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x04B0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecw_r_rs_x_combo_0_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_uqdecw_r_rs_x_combo_1_fc00_04b1fc00() {
    // Encoding: 0x04B1FC00
    // Test UQDECW_R.RS_X field combination: imm4=1, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04B1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_uqdecw_r_rs_x_combo_2_fc00_04b3fc00() {
    // Encoding: 0x04B3FC00
    // Test UQDECW_R.RS_X field combination: imm4=3, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x04B3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_uqdecw_r_rs_x_combo_3_fc00_04b4fc00() {
    // Encoding: 0x04B4FC00
    // Test UQDECW_R.RS_X field combination: imm4=4, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x04B4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_uqdecw_r_rs_x_combo_4_fc00_04b7fc00() {
    // Encoding: 0x04B7FC00
    // Test UQDECW_R.RS_X field combination: imm4=7, pattern=0, Rdn=0
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04B7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_uqdecw_r_rs_x_combo_5_fc00_04b8fc00() {
    // Encoding: 0x04B8FC00
    // Test UQDECW_R.RS_X field combination: imm4=8, pattern=0, Rdn=0
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04B8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_uqdecw_r_rs_x_combo_6_fc00_04bffc00() {
    // Encoding: 0x04BFFC00
    // Test UQDECW_R.RS_X field combination: imm4=15, pattern=0, Rdn=0
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04BFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_uqdecw_r_rs_x_combo_7_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_uqdecw_r_rs_x_combo_8_fc00_04b0fc20() {
    // Encoding: 0x04B0FC20
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=1, Rdn=0
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04B0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_uqdecw_r_rs_x_combo_9_fc00_04b0fde0() {
    // Encoding: 0x04B0FDE0
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=15, Rdn=0
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x04B0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_uqdecw_r_rs_x_combo_10_fc00_04b0ffe0() {
    // Encoding: 0x04B0FFE0
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=31, Rdn=0
    // Fields: pattern=31, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_uqdecw_r_rs_x_combo_11_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=1 (value 1)
#[test]
fn test_uqdecw_r_rs_x_combo_12_fc00_04b0fc01() {
    // Encoding: 0x04B0FC01
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=1
    // Fields: pattern=0, imm4=0, Rdn=1
    let encoding: u32 = 0x04B0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=15 (midpoint (15))
#[test]
fn test_uqdecw_r_rs_x_combo_13_fc00_04b0fc0f() {
    // Encoding: 0x04B0FC0F
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=15
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x04B0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=31 (maximum value (31))
#[test]
fn test_uqdecw_r_rs_x_combo_14_fc00_04b0fc1f() {
    // Encoding: 0x04B0FC1F
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=31
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04B0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_x_invalid_0_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_x_invalid_1_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecw_r_rs_uw_reg_write_0_04a0fc00() {
    // Test UQDECW_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x04A0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecw_r_rs_x_reg_write_0_04b0fc00() {
    // Test UQDECW_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04B0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMLA_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmla_z_p_zzz_field_size_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmla_z_p_zzz_field_size_1_poweroftwo_0_65600000() {
    // Encoding: 0x65600000
    // Test FMLA_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zda=0, Zm=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x65600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmla_z_p_zzz_field_size_2_poweroftwo_0_65a00000() {
    // Encoding: 0x65A00000
    // Test FMLA_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zda=0, Zm=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x65A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmla_z_p_zzz_field_size_3_max_0_65e00000() {
    // Encoding: 0x65E00000
    // Test FMLA_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Zn=0, Pg=0, Zda=0, Zm=0, size=3
    let encoding: u32 = 0x65E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_p_zzz_field_zm_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zn=0, Zda=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_p_zzz_field_zm_1_poweroftwo_0_65210000() {
    // Encoding: 0x65210000
    // Test FMLA_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zda=0, Zm=1, Pg=0
    let encoding: u32 = 0x65210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_p_zzz_field_zm_30_poweroftwominusone_0_653e0000() {
    // Encoding: 0x653E0000
    // Test FMLA_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Zm=30, Zda=0
    let encoding: u32 = 0x653E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_p_zzz_field_zm_31_max_0_653f0000() {
    // Encoding: 0x653F0000
    // Test FMLA_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Zm=31, Zda=0
    let encoding: u32 = 0x653F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmla_z_p_zzz_field_pg_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zda=0, Zn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmla_z_p_zzz_field_pg_1_poweroftwo_0_65200400() {
    // Encoding: 0x65200400
    // Test FMLA_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zda=0, Zm=0, size=0
    let encoding: u32 = 0x65200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_p_zzz_field_zn_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Zn = 0 (Min)
    // Fields: Pg=0, Zda=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_p_zzz_field_zn_1_poweroftwo_0_65200020() {
    // Encoding: 0x65200020
    // Test FMLA_Z.P.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=1, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_p_zzz_field_zn_30_poweroftwominusone_0_652003c0() {
    // Encoding: 0x652003C0
    // Test FMLA_Z.P.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, size=0, Pg=0, Zm=0, Zn=30
    let encoding: u32 = 0x652003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_p_zzz_field_zn_31_max_0_652003e0() {
    // Encoding: 0x652003E0
    // Test FMLA_Z.P.ZZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Zda=0, size=0, Pg=0, Zn=31
    let encoding: u32 = 0x652003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_p_zzz_field_zda_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Zda = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zm=0, Zda=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_p_zzz_field_zda_1_poweroftwo_0_65200001() {
    // Encoding: 0x65200001
    // Test FMLA_Z.P.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: Zm=0, Zda=1, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x65200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmla_z_p_zzz_field_zda_15_poweroftwominusone_0_6520000f() {
    // Encoding: 0x6520000F
    // Test FMLA_Z.P.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, Pg=0, size=0, Zda=15
    let encoding: u32 = 0x6520000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmla_z_p_zzz_field_zda_31_max_0_6520001f() {
    // Encoding: 0x6520001F
    // Test FMLA_Z.P.ZZZ__ field Zda = 31 (Max)
    // Fields: Zn=0, Zda=31, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x6520001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmla_z_p_zzz_combo_0_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zm=0, size=0, Zda=0, Pg=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fmla_z_p_zzz_combo_1_0_65600000() {
    // Encoding: 0x65600000
    // Test FMLA_Z.P.ZZZ__ field combination: size=1, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zda=0, Zn=0, size=1, Zm=0, Pg=0
    let encoding: u32 = 0x65600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fmla_z_p_zzz_combo_2_0_65a00000() {
    // Encoding: 0x65A00000
    // Test FMLA_Z.P.ZZZ__ field combination: size=2, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=2, Zm=0, Pg=0, Zda=0, Zn=0
    let encoding: u32 = 0x65A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fmla_z_p_zzz_combo_3_0_65e00000() {
    // Encoding: 0x65E00000
    // Test FMLA_Z.P.ZZZ__ field combination: size=3, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=3, Zm=0, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x65E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_fmla_z_p_zzz_combo_4_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zm=0, size=0, Pg=0, Zda=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_fmla_z_p_zzz_combo_5_0_65210000() {
    // Encoding: 0x65210000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=1, Pg=0, Zn=0, Zda=0
    // Fields: Pg=0, Zm=1, size=0, Zn=0, Zda=0
    let encoding: u32 = 0x65210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_fmla_z_p_zzz_combo_6_0_653e0000() {
    // Encoding: 0x653E0000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=30, Pg=0, Zn=0, Zda=0
    // Fields: Zn=0, Zda=0, Zm=30, size=0, Pg=0
    let encoding: u32 = 0x653E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_fmla_z_p_zzz_combo_7_0_653f0000() {
    // Encoding: 0x653F0000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=31, Pg=0, Zn=0, Zda=0
    // Fields: Zm=31, Zda=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x653F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fmla_z_p_zzz_combo_8_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zn=0, Zm=0, size=0, Zda=0, Pg=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fmla_z_p_zzz_combo_9_0_65200400() {
    // Encoding: 0x65200400
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=1, Zn=0, Zda=0
    // Fields: size=0, Zda=0, Zm=0, Pg=1, Zn=0
    let encoding: u32 = 0x65200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_fmla_z_p_zzz_combo_10_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=0, Zn=0, Pg=0, Zm=0, Zda=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_fmla_z_p_zzz_combo_11_0_65200020() {
    // Encoding: 0x65200020
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=1, Zda=0
    // Fields: size=0, Zda=0, Zm=0, Zn=1, Pg=0
    let encoding: u32 = 0x65200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_fmla_z_p_zzz_combo_12_0_652003c0() {
    // Encoding: 0x652003C0
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=30, Zda=0
    // Fields: Zm=0, Pg=0, size=0, Zn=30, Zda=0
    let encoding: u32 = 0x652003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_fmla_z_p_zzz_combo_13_0_652003e0() {
    // Encoding: 0x652003E0
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=31, Zda=0
    // Fields: Zda=0, Zm=0, Zn=31, Pg=0, size=0
    let encoding: u32 = 0x652003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=0 (minimum value)
#[test]
fn test_fmla_z_p_zzz_combo_14_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Pg=0, Zn=0, size=0, Zm=0, Zda=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=1 (value 1)
#[test]
fn test_fmla_z_p_zzz_combo_15_0_65200001() {
    // Encoding: 0x65200001
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=1
    // Fields: size=0, Pg=0, Zda=1, Zn=0, Zm=0
    let encoding: u32 = 0x65200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=15 (midpoint (15))
#[test]
fn test_fmla_z_p_zzz_combo_16_0_6520000f() {
    // Encoding: 0x6520000F
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=15
    // Fields: Zn=0, Zda=15, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x6520000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zda=31 (maximum value (31))
#[test]
fn test_fmla_z_p_zzz_combo_17_0_6520001f() {
    // Encoding: 0x6520001F
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=31
    // Fields: size=0, Zm=0, Zn=0, Zda=31, Pg=0
    let encoding: u32 = 0x6520001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmla_z_p_zzz_special_size_0_size_variant_0_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zn=0, Zda=0, size=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmla_z_p_zzz_special_size_1_size_variant_1_0_65600000() {
    // Encoding: 0x65600000
    // Test FMLA_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x65600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmla_z_p_zzz_special_size_2_size_variant_2_0_65a00000() {
    // Encoding: 0x65A00000
    // Test FMLA_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zda=0, Pg=0, Zn=0, Zm=0
    let encoding: u32 = 0x65A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmla_z_p_zzz_special_size_3_size_variant_3_0_65e00000() {
    // Encoding: 0x65E00000
    // Test FMLA_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x65E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_0_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zda=0, Pg=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_1_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zn=0, Zda=0, Pg=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_2_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Pg=0, Zda=0, Zn=0, size=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_3_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zn=0, Zda=0, size=0, Pg=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmla_z_p_zzz_reg_write_0_65200000() {
    // Test FMLA_Z.P.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x65200000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMINV_V.P.Z__ Tests
// ============================================================================

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fminv_v_p_z_field_size_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fminv_v_p_z_field_size_1_poweroftwo_2000_65472000() {
    // Encoding: 0x65472000
    // Test FMINV_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65472000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fminv_v_p_z_field_size_2_poweroftwo_2000_65872000() {
    // Encoding: 0x65872000
    // Test FMINV_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vd=0, Zn=0, size=2, Pg=0
    let encoding: u32 = 0x65872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fminv_v_p_z_field_size_3_max_2000_65c72000() {
    // Encoding: 0x65C72000
    // Test FMINV_V.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zn=0, Vd=0, size=3
    let encoding: u32 = 0x65C72000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fminv_v_p_z_field_pg_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field Pg = 0 (Min)
    // Fields: Vd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fminv_v_p_z_field_pg_1_poweroftwo_2000_65072400() {
    // Encoding: 0x65072400
    // Test FMINV_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zn=0, Vd=0
    let encoding: u32 = 0x65072400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminv_v_p_z_field_zn_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminv_v_p_z_field_zn_1_poweroftwo_2000_65072020() {
    // Encoding: 0x65072020
    // Test FMINV_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Vd=0, Pg=0
    let encoding: u32 = 0x65072020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminv_v_p_z_field_zn_30_poweroftwominusone_2000_650723c0() {
    // Encoding: 0x650723C0
    // Test FMINV_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=0, Zn=30, Pg=0, size=0
    let encoding: u32 = 0x650723C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminv_v_p_z_field_zn_31_max_2000_650723e0() {
    // Encoding: 0x650723E0
    // Test FMINV_V.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x650723E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminv_v_p_z_field_vd_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field Vd = 0 (Min)
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminv_v_p_z_field_vd_1_poweroftwo_2000_65072001() {
    // Encoding: 0x65072001
    // Test FMINV_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Vd=1, Pg=0
    let encoding: u32 = 0x65072001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminv_v_p_z_field_vd_30_poweroftwominusone_2000_6507201e() {
    // Encoding: 0x6507201E
    // Test FMINV_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=0, Vd=30
    let encoding: u32 = 0x6507201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminv_v_p_z_field_vd_31_max_2000_6507201f() {
    // Encoding: 0x6507201F
    // Test FMINV_V.P.Z__ field Vd = 31 (Max)
    // Fields: Pg=0, Zn=0, size=0, Vd=31
    let encoding: u32 = 0x6507201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fminv_v_p_z_combo_0_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fminv_v_p_z_combo_1_2000_65472000() {
    // Encoding: 0x65472000
    // Test FMINV_V.P.Z__ field combination: size=1, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Vd=0, size=1, Zn=0
    let encoding: u32 = 0x65472000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fminv_v_p_z_combo_2_2000_65872000() {
    // Encoding: 0x65872000
    // Test FMINV_V.P.Z__ field combination: size=2, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=2, Zn=0, Pg=0
    let encoding: u32 = 0x65872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fminv_v_p_z_combo_3_2000_65c72000() {
    // Encoding: 0x65C72000
    // Test FMINV_V.P.Z__ field combination: size=3, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x65C72000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fminv_v_p_z_combo_4_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fminv_v_p_z_combo_5_2000_65072400() {
    // Encoding: 0x65072400
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=1, Zn=0, Vd=0
    // Fields: Zn=0, Pg=1, Vd=0, size=0
    let encoding: u32 = 0x65072400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_fminv_v_p_z_combo_6_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Vd=0, size=0, Zn=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_fminv_v_p_z_combo_7_2000_65072020() {
    // Encoding: 0x65072020
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=1, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=1
    let encoding: u32 = 0x65072020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_fminv_v_p_z_combo_8_2000_650723c0() {
    // Encoding: 0x650723C0
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=30, Vd=0
    // Fields: size=0, Vd=0, Zn=30, Pg=0
    let encoding: u32 = 0x650723C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_fminv_v_p_z_combo_9_2000_650723e0() {
    // Encoding: 0x650723E0
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=31, Vd=0
    // Fields: Zn=31, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x650723E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_fminv_v_p_z_combo_10_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_fminv_v_p_z_combo_11_2000_65072001() {
    // Encoding: 0x65072001
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=1
    // Fields: Zn=0, size=0, Pg=0, Vd=1
    let encoding: u32 = 0x65072001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=30 (SIMD register V30)
#[test]
fn test_fminv_v_p_z_combo_12_2000_6507201e() {
    // Encoding: 0x6507201E
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=30
    // Fields: Vd=30, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6507201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=31 (SIMD register V31)
#[test]
fn test_fminv_v_p_z_combo_13_2000_6507201f() {
    // Encoding: 0x6507201F
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=31
    // Fields: Vd=31, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6507201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fminv_v_p_z_special_size_0_size_variant_0_8192_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Vd=0, Zn=0, size=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fminv_v_p_z_special_size_1_size_variant_1_8192_65472000() {
    // Encoding: 0x65472000
    // Test FMINV_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65472000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fminv_v_p_z_special_size_2_size_variant_2_8192_65872000() {
    // Encoding: 0x65872000
    // Test FMINV_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Vd=0, Pg=0
    let encoding: u32 = 0x65872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fminv_v_p_z_special_size_3_size_variant_3_8192_65c72000() {
    // Encoding: 0x65C72000
    // Test FMINV_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x65C72000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_0_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_1_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_2_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Vd=0, Zn=0, size=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_3_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fminv_v_p_z_reg_write_0_65072000() {
    // Test FMINV_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x65072000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65072000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LDNT1W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_0_zero_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a501e000() {
    // Encoding: 0xA501E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA501E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a503e000() {
    // Encoding: 0xA503E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA503E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a504e000() {
    // Encoding: 0xA504E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xA504E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a507e000() {
    // Encoding: 0xA507E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=7, Rn=0
    let encoding: u32 = 0xA507E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a508e000() {
    // Encoding: 0xA508E000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=8, Zt=0
    let encoding: u32 = 0xA508E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_imm4_15_max_e000_a50fe000() {
    // Encoding: 0xA50FE000
    // Test LDNT1W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA50FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_pg_0_min_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a500e400() {
    // Encoding: 0xA500E400
    // Test LDNT1W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, imm4=0, Rn=0
    let encoding: u32 = 0xA500E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_0_min_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a500e020() {
    // Encoding: 0xA500E020
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, imm4=0, Zt=0
    let encoding: u32 = 0xA500E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a500e3c0() {
    // Encoding: 0xA500E3C0
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA500E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_rn_31_max_e000_a500e3e0() {
    // Encoding: 0xA500E3E0
    // Test LDNT1W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_0_min_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a500e001() {
    // Encoding: 0xA500E001
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA500E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a500e01e() {
    // Encoding: 0xA500E01E
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=30
    let encoding: u32 = 0xA500E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1w_z_p_bi_contiguous_field_zt_31_max_e000_a500e01f() {
    // Encoding: 0xA500E01F
    // Test LDNT1W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xA500E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_0_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_1_e000_a501e000() {
    // Encoding: 0xA501E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA501E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_2_e000_a503e000() {
    // Encoding: 0xA503E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=3, Zt=0
    let encoding: u32 = 0xA503E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_3_e000_a504e000() {
    // Encoding: 0xA504E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=4, Rn=0, Pg=0
    let encoding: u32 = 0xA504E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_4_e000_a507e000() {
    // Encoding: 0xA507E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: imm4=7, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA507E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_5_e000_a508e000() {
    // Encoding: 0xA508E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=8, Pg=0, Zt=0
    let encoding: u32 = 0xA508E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_6_e000_a50fe000() {
    // Encoding: 0xA50FE000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=15, Rn=0, Pg=0
    let encoding: u32 = 0xA50FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_7_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_8_e000_a500e400() {
    // Encoding: 0xA500E400
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xA500E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_9_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_10_e000_a500e020() {
    // Encoding: 0xA500E020
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Pg=0, imm4=0, Rn=1
    let encoding: u32 = 0xA500E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_11_e000_a500e3c0() {
    // Encoding: 0xA500E3C0
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Rn=30, imm4=0, Zt=0
    let encoding: u32 = 0xA500E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_12_e000_a500e3e0() {
    // Encoding: 0xA500E3E0
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xA500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_13_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_14_e000_a500e001() {
    // Encoding: 0xA500E001
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: imm4=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xA500E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_15_e000_a500e01e() {
    // Encoding: 0xA500E01E
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Pg=0, Zt=30, imm4=0
    let encoding: u32 = 0xA500E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_16_e000_a500e01f() {
    // Encoding: 0xA500E01F
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Zt=31, Pg=0, imm4=0
    let encoding: u32 = 0xA500E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_17_e000_a500e420() {
    // Encoding: 0xA500E420
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: imm4=0, Rn=1, Zt=0, Pg=1
    let encoding: u32 = 0xA500E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnt1w_z_p_bi_contiguous_combo_18_e000_a500ffe0() {
    // Encoding: 0xA500FFE0
    // Test LDNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xA500FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a500e3e0() {
    // Encoding: 0xA500E3E0
    // Test LDNT1W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xA500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_bi_contiguous_invalid_0_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1w_z_p_bi_contiguous_invalid_1_e000_a500e000() {
    // Encoding: 0xA500E000
    // Test LDNT1W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1w_z_p_bi_contiguous_reg_write_0_a500e000() {
    // Test LDNT1W_Z.P.BI_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA500E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1w_z_p_bi_contiguous_sp_rn_a500e3e0() {
    // Test LDNT1W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA500E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA500E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4e16000() {
    // Encoding: 0xE4E16000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=1
    let encoding: u32 = 0xE4E16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e4fe6000() {
    // Encoding: 0xE4FE6000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Zt=0, Pg=0
    let encoding: u32 = 0xE4FE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_31_max_6000_e4ff6000() {
    // Encoding: 0xE4FF6000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Pg=0, Zt=0
    let encoding: u32 = 0xE4FF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_br_contiguous_field_pg_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4e06400() {
    // Encoding: 0xE4E06400
    // Test ST4H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xE4E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4e06020() {
    // Encoding: 0xE4E06020
    // Test ST4H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e4e063c0() {
    // Encoding: 0xE4E063C0
    // Test ST4H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=30
    let encoding: u32 = 0xE4E063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_31_max_6000_e4e063e0() {
    // Encoding: 0xE4E063E0
    // Test ST4H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xE4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4e06001() {
    // Encoding: 0xE4E06001
    // Test ST4H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, Rm=0
    let encoding: u32 = 0xE4E06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e4e0601e() {
    // Encoding: 0xE4E0601E
    // Test ST4H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4E0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_31_max_6000_e4e0601f() {
    // Encoding: 0xE4E0601F
    // Test ST4H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4E0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_0_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_1_6000_e4e16000() {
    // Encoding: 0xE4E16000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=1, Zt=0
    let encoding: u32 = 0xE4E16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_st4h_z_p_br_contiguous_combo_2_6000_e4fe6000() {
    // Encoding: 0xE4FE6000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=30, Pg=0
    let encoding: u32 = 0xE4FE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_st4h_z_p_br_contiguous_combo_3_6000_e4ff6000() {
    // Encoding: 0xE4FF6000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xE4FF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_4_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_5_6000_e4e06400() {
    // Encoding: 0xE4E06400
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xE4E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_6_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_7_6000_e4e06020() {
    // Encoding: 0xE4E06020
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xE4E06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_st4h_z_p_br_contiguous_combo_8_6000_e4e063c0() {
    // Encoding: 0xE4E063C0
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30
    let encoding: u32 = 0xE4E063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_st4h_z_p_br_contiguous_combo_9_6000_e4e063e0() {
    // Encoding: 0xE4E063E0
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=31
    let encoding: u32 = 0xE4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st4h_z_p_br_contiguous_combo_10_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st4h_z_p_br_contiguous_combo_11_6000_e4e06001() {
    // Encoding: 0xE4E06001
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Rm=0, Zt=1, Pg=0
    let encoding: u32 = 0xE4E06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st4h_z_p_br_contiguous_combo_12_6000_e4e0601e() {
    // Encoding: 0xE4E0601E
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rm=0, Zt=30, Rn=0, Pg=0
    let encoding: u32 = 0xE4E0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st4h_z_p_br_contiguous_combo_13_6000_e4e0601f() {
    // Encoding: 0xE4E0601F
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rm=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xE4E0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_st4h_z_p_br_contiguous_combo_14_6000_e4e16400() {
    // Encoding: 0xE4E16400
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Rm=1, Rn=0, Zt=0
    let encoding: u32 = 0xE4E16400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_st4h_z_p_br_contiguous_combo_15_6000_e4ff7c00() {
    // Encoding: 0xE4FF7C00
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Rm=31, Zt=0, Pg=31, Rn=0
    let encoding: u32 = 0xE4FF7C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_st4h_z_p_br_contiguous_combo_16_6000_e4e16020() {
    // Encoding: 0xE4E16020
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Rm=1, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xE4E16020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_st4h_z_p_br_contiguous_combo_17_6000_e4ff63e0() {
    // Encoding: 0xE4FF63E0
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Zt=0, Rm=31, Pg=0
    let encoding: u32 = 0xE4FF63E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_st4h_z_p_br_contiguous_combo_18_6000_e4e06420() {
    // Encoding: 0xE4E06420
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rm=0, Rn=1, Zt=0, Pg=1
    let encoding: u32 = 0xE4E06420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_st4h_z_p_br_contiguous_combo_19_6000_e4e07fe0() {
    // Encoding: 0xE4E07FE0
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Rm=0, Rn=31, Pg=31, Zt=0
    let encoding: u32 = 0xE4E07FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e4e063e0() {
    // Encoding: 0xE4E063E0
    // Test ST4H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_0_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_1_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_2_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_3_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4h_z_p_br_contiguous_sp_rn_e4e063e0() {
    // Test ST4H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE4E063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4E063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4h_z_p_br_contiguous_store_0_e4e06020() {
    // Test ST4H_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4E06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4E06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUBR_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsubr_z_p_zs_field_size_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field size = 0 (Min)
    // Fields: size=0, i1=0, Zdn=0, Pg=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsubr_z_p_zs_field_size_1_poweroftwo_8000_655b8000() {
    // Encoding: 0x655B8000
    // Test FSUBR_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x655B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsubr_z_p_zs_field_size_2_poweroftwo_8000_659b8000() {
    // Encoding: 0x659B8000
    // Test FSUBR_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zdn=0, i1=0
    let encoding: u32 = 0x659B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsubr_z_p_zs_field_size_3_max_8000_65db8000() {
    // Encoding: 0x65DB8000
    // Test FSUBR_Z.P.ZS__ field size = 3 (Max)
    // Fields: Pg=0, size=3, i1=0, Zdn=0
    let encoding: u32 = 0x65DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsubr_z_p_zs_field_pg_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: size=0, i1=0, Zdn=0, Pg=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsubr_z_p_zs_field_pg_1_poweroftwo_8000_651b8400() {
    // Encoding: 0x651B8400
    // Test FSUBR_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, i1=0, Pg=1
    let encoding: u32 = 0x651B8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsubr_z_p_zs_field_i1_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: Pg=0, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fsubr_z_p_zs_field_i1_1_max_8000_651b8020() {
    // Encoding: 0x651B8020
    // Test FSUBR_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: size=0, Zdn=0, i1=1, Pg=0
    let encoding: u32 = 0x651B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsubr_z_p_zs_field_zdn_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, Pg=0, i1=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fsubr_z_p_zs_field_zdn_1_poweroftwo_8000_651b8001() {
    // Encoding: 0x651B8001
    // Test FSUBR_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: i1=0, Zdn=1, Pg=0, size=0
    let encoding: u32 = 0x651B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fsubr_z_p_zs_field_zdn_15_poweroftwominusone_8000_651b800f() {
    // Encoding: 0x651B800F
    // Test FSUBR_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=15, i1=0, size=0
    let encoding: u32 = 0x651B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fsubr_z_p_zs_field_zdn_31_max_8000_651b801f() {
    // Encoding: 0x651B801F
    // Test FSUBR_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, i1=0, Pg=0
    let encoding: u32 = 0x651B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsubr_z_p_zs_combo_0_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Zdn=0, i1=0, Pg=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fsubr_z_p_zs_combo_1_8000_655b8000() {
    // Encoding: 0x655B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=1, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=1, i1=0
    let encoding: u32 = 0x655B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fsubr_z_p_zs_combo_2_8000_659b8000() {
    // Encoding: 0x659B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=2, Pg=0, i1=0, Zdn=0
    // Fields: Zdn=0, Pg=0, i1=0, size=2
    let encoding: u32 = 0x659B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fsubr_z_p_zs_combo_3_8000_65db8000() {
    // Encoding: 0x65DB8000
    // Test FSUBR_Z.P.ZS__ field combination: size=3, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, Zdn=0, i1=0, size=3
    let encoding: u32 = 0x65DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fsubr_z_p_zs_combo_4_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, i1=0, Zdn=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fsubr_z_p_zs_combo_5_8000_651b8400() {
    // Encoding: 0x651B8400
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=1, i1=0, Zdn=0
    // Fields: i1=0, size=0, Zdn=0, Pg=1
    let encoding: u32 = 0x651B8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_fsubr_z_p_zs_combo_6_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Zdn=0, Pg=0, i1=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=1 (maximum value (1))
#[test]
fn test_fsubr_z_p_zs_combo_7_8000_651b8020() {
    // Encoding: 0x651B8020
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=1, Zdn=0
    // Fields: size=0, Zdn=0, Pg=0, i1=1
    let encoding: u32 = 0x651B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_fsubr_z_p_zs_combo_8_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: i1=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_fsubr_z_p_zs_combo_9_8000_651b8001() {
    // Encoding: 0x651B8001
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=1
    // Fields: Zdn=1, Pg=0, size=0, i1=0
    let encoding: u32 = 0x651B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_fsubr_z_p_zs_combo_10_8000_651b800f() {
    // Encoding: 0x651B800F
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=15
    // Fields: size=0, i1=0, Pg=0, Zdn=15
    let encoding: u32 = 0x651B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_fsubr_z_p_zs_combo_11_8000_651b801f() {
    // Encoding: 0x651B801F
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=31
    // Fields: i1=0, size=0, Pg=0, Zdn=31
    let encoding: u32 = 0x651B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsubr_z_p_zs_special_size_0_size_variant_0_32768_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsubr_z_p_zs_special_size_1_size_variant_1_32768_655b8000() {
    // Encoding: 0x655B8000
    // Test FSUBR_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: i1=0, size=1, Zdn=0, Pg=0
    let encoding: u32 = 0x655B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsubr_z_p_zs_special_size_2_size_variant_2_32768_659b8000() {
    // Encoding: 0x659B8000
    // Test FSUBR_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: i1=0, Pg=0, Zdn=0, size=2
    let encoding: u32 = 0x659B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsubr_z_p_zs_special_size_3_size_variant_3_32768_65db8000() {
    // Encoding: 0x65DB8000
    // Test FSUBR_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x65DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_0_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, i1=0, size=0, Pg=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_1_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_2_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: i1=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_3_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, i1=0, Zdn=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fsubr_z_p_zs_reg_write_0_651b8000() {
    // Test FSUBR_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651B8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651B8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ADD_Z.ZZ__ Tests
// ============================================================================

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_add_z_zz_field_size_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_add_z_zz_field_size_1_poweroftwo_0_04600000() {
    // Encoding: 0x04600000
    // Test ADD_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Zn=0, Zm=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_add_z_zz_field_size_2_poweroftwo_0_04a00000() {
    // Encoding: 0x04A00000
    // Test ADD_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x04A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_add_z_zz_field_size_3_max_0_04e00000() {
    // Encoding: 0x04E00000
    // Test ADD_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_add_z_zz_field_zm_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_add_z_zz_field_zm_1_poweroftwo_0_04210000() {
    // Encoding: 0x04210000
    // Test ADD_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=1, Zd=0
    let encoding: u32 = 0x04210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_add_z_zz_field_zm_30_poweroftwominusone_0_043e0000() {
    // Encoding: 0x043E0000
    // Test ADD_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Zd=0, Zn=0
    let encoding: u32 = 0x043E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_add_z_zz_field_zm_31_max_0_043f0000() {
    // Encoding: 0x043F0000
    // Test ADD_Z.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zn=0, Zd=0, Zm=31
    let encoding: u32 = 0x043F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_add_z_zz_field_zn_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_add_z_zz_field_zn_1_poweroftwo_0_04200020() {
    // Encoding: 0x04200020
    // Test ADD_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zn=1, Zd=0
    let encoding: u32 = 0x04200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_add_z_zz_field_zn_30_poweroftwominusone_0_042003c0() {
    // Encoding: 0x042003C0
    // Test ADD_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x042003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_add_z_zz_field_zn_31_max_0_042003e0() {
    // Encoding: 0x042003E0
    // Test ADD_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zd=0, Zm=0, Zn=31, size=0
    let encoding: u32 = 0x042003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_add_z_zz_field_zd_0_min_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field Zd = 0 (Min)
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_add_z_zz_field_zd_1_poweroftwo_0_04200001() {
    // Encoding: 0x04200001
    // Test ADD_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zd=1, Zm=0
    let encoding: u32 = 0x04200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_add_z_zz_field_zd_30_poweroftwominusone_0_0420001e() {
    // Encoding: 0x0420001E
    // Test ADD_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Zm=0, size=0
    let encoding: u32 = 0x0420001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_add_z_zz_field_zd_31_max_0_0420001f() {
    // Encoding: 0x0420001F
    // Test ADD_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, Zm=0, size=0, Zd=31
    let encoding: u32 = 0x0420001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_add_z_zz_combo_0_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_add_z_zz_combo_1_0_04600000() {
    // Encoding: 0x04600000
    // Test ADD_Z.ZZ__ field combination: size=1, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, size=1, Zn=0, Zd=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_add_z_zz_combo_2_0_04a00000() {
    // Encoding: 0x04A00000
    // Test ADD_Z.ZZ__ field combination: size=2, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=2, Zm=0
    let encoding: u32 = 0x04A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_add_z_zz_combo_3_0_04e00000() {
    // Encoding: 0x04E00000
    // Test ADD_Z.ZZ__ field combination: size=3, Zm=0, Zn=0, Zd=0
    // Fields: size=3, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x04E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_add_z_zz_combo_4_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_add_z_zz_combo_5_0_04210000() {
    // Encoding: 0x04210000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=1, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, Zm=1, size=0
    let encoding: u32 = 0x04210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_add_z_zz_combo_6_0_043e0000() {
    // Encoding: 0x043E0000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=30, Zn=0, Zd=0
    // Fields: Zn=0, Zm=30, size=0, Zd=0
    let encoding: u32 = 0x043E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_add_z_zz_combo_7_0_043f0000() {
    // Encoding: 0x043F0000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=31, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zm=31, Zd=0
    let encoding: u32 = 0x043F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_add_z_zz_combo_8_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_add_z_zz_combo_9_0_04200020() {
    // Encoding: 0x04200020
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=1, Zd=0
    // Fields: Zn=1, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x04200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_add_z_zz_combo_10_0_042003c0() {
    // Encoding: 0x042003C0
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=30, Zd=0
    // Fields: Zm=0, Zn=30, Zd=0, size=0
    let encoding: u32 = 0x042003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_add_z_zz_combo_11_0_042003e0() {
    // Encoding: 0x042003E0
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=31, Zd=0
    // Fields: Zm=0, Zd=0, size=0, Zn=31
    let encoding: u32 = 0x042003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_add_z_zz_combo_12_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_add_z_zz_combo_13_0_04200001() {
    // Encoding: 0x04200001
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=1
    // Fields: Zd=1, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x04200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_add_z_zz_combo_14_0_0420001e() {
    // Encoding: 0x0420001E
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=30
    // Fields: Zm=0, Zn=0, Zd=30, size=0
    let encoding: u32 = 0x0420001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_add_z_zz_combo_15_0_0420001f() {
    // Encoding: 0x0420001F
    // Test ADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=31
    // Fields: size=0, Zd=31, Zn=0, Zm=0
    let encoding: u32 = 0x0420001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_add_z_zz_special_size_0_size_variant_0_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_add_z_zz_special_size_1_size_variant_1_0_04600000() {
    // Encoding: 0x04600000
    // Test ADD_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Zm=0, Zd=0
    let encoding: u32 = 0x04600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_add_z_zz_special_size_2_size_variant_2_0_04a00000() {
    // Encoding: 0x04A00000
    // Test ADD_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, size=2, Zm=0, Zn=0
    let encoding: u32 = 0x04A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_add_z_zz_special_size_3_size_variant_3_0_04e00000() {
    // Encoding: 0x04E00000
    // Test ADD_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, size=3, Zm=0, Zn=0
    let encoding: u32 = 0x04E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_add_z_zz_invalid_0_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_add_z_zz_invalid_1_0_04200000() {
    // Encoding: 0x04200000
    // Test ADD_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x04200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ADD_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_add_z_zz_reg_write_0_04200000() {
    // Test ADD_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x04200000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_0_zero_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e4d1e000() {
    // Encoding: 0xE4D1E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=1, Zt=0
    let encoding: u32 = 0xE4D1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e4d3e000() {
    // Encoding: 0xE4D3E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=3, Rn=0
    let encoding: u32 = 0xE4D3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e4d4e000() {
    // Encoding: 0xE4D4E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xE4D4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e4d7e000() {
    // Encoding: 0xE4D7E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4D7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e4d8e000() {
    // Encoding: 0xE4D8E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4D8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_15_max_e000_e4dfe000() {
    // Encoding: 0xE4DFE000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_pg_0_min_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e4d0e400() {
    // Encoding: 0xE4D0E400
    // Test ST3H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE4D0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_0_min_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e4d0e020() {
    // Encoding: 0xE4D0E020
    // Test ST3H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xE4D0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e4d0e3c0() {
    // Encoding: 0xE4D0E3C0
    // Test ST3H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, imm4=0
    let encoding: u32 = 0xE4D0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_31_max_e000_e4d0e3e0() {
    // Encoding: 0xE4D0E3E0
    // Test ST3H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE4D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_0_min_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e4d0e001() {
    // Encoding: 0xE4D0E001
    // Test ST3H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xE4D0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e4d0e01e() {
    // Encoding: 0xE4D0E01E
    // Test ST3H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=30
    let encoding: u32 = 0xE4D0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_31_max_e000_e4d0e01f() {
    // Encoding: 0xE4D0E01F
    // Test ST3H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=31
    let encoding: u32 = 0xE4D0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_0_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_1_e000_e4d1e000() {
    // Encoding: 0xE4D1E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: imm4=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4D1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_2_e000_e4d3e000() {
    // Encoding: 0xE4D3E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, imm4=3, Pg=0
    let encoding: u32 = 0xE4D3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_3_e000_e4d4e000() {
    // Encoding: 0xE4D4E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=4, Zt=0, Pg=0
    let encoding: u32 = 0xE4D4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_4_e000_e4d7e000() {
    // Encoding: 0xE4D7E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=7
    let encoding: u32 = 0xE4D7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_5_e000_e4d8e000() {
    // Encoding: 0xE4D8E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4D8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_6_e000_e4dfe000() {
    // Encoding: 0xE4DFE000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=15, Zt=0, Pg=0
    let encoding: u32 = 0xE4DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_7_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_8_e000_e4d0e400() {
    // Encoding: 0xE4D0E400
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=1, imm4=0
    let encoding: u32 = 0xE4D0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_9_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_10_e000_e4d0e020() {
    // Encoding: 0xE4D0E020
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: imm4=0, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xE4D0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_11_e000_e4d0e3c0() {
    // Encoding: 0xE4D0E3C0
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE4D0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_12_e000_e4d0e3e0() {
    // Encoding: 0xE4D0E3E0
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xE4D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_13_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_14_e000_e4d0e001() {
    // Encoding: 0xE4D0E001
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, imm4=0, Rn=0, Zt=1
    let encoding: u32 = 0xE4D0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_15_e000_e4d0e01e() {
    // Encoding: 0xE4D0E01E
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE4D0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_16_e000_e4d0e01f() {
    // Encoding: 0xE4D0E01F
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Zt=31, imm4=0, Rn=0
    let encoding: u32 = 0xE4D0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_17_e000_e4d0e420() {
    // Encoding: 0xE4D0E420
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: imm4=0, Pg=1, Zt=0, Rn=1
    let encoding: u32 = 0xE4D0E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_st3h_z_p_bi_contiguous_combo_18_e000_e4d0ffe0() {
    // Encoding: 0xE4D0FFE0
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: imm4=0, Zt=0, Pg=31, Rn=31
    let encoding: u32 = 0xE4D0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e4d0e3e0() {
    // Encoding: 0xE4D0E3E0
    // Test ST3H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, Rn=31, imm4=0
    let encoding: u32 = 0xE4D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_bi_contiguous_invalid_0_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_bi_contiguous_invalid_1_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3h_z_p_bi_contiguous_sp_rn_e4d0e3e0() {
    // Test ST3H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE4D0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4D0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3h_z_p_bi_contiguous_store_0_e4d0e020() {
    // Test ST3H_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE4D0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4D0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMINV_R.P.Z__ Tests
// ============================================================================

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uminv_r_p_z_field_size_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uminv_r_p_z_field_size_1_poweroftwo_2000_044b2000() {
    // Encoding: 0x044B2000
    // Test UMINV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Vd=0, Zn=0, Pg=0, size=1
    let encoding: u32 = 0x044B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uminv_r_p_z_field_size_2_poweroftwo_2000_048b2000() {
    // Encoding: 0x048B2000
    // Test UMINV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x048B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uminv_r_p_z_field_size_3_max_2000_04cb2000() {
    // Encoding: 0x04CB2000
    // Test UMINV_R.P.Z__ field size = 3 (Max)
    // Fields: Vd=0, Pg=0, size=3, Zn=0
    let encoding: u32 = 0x04CB2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uminv_r_p_z_field_pg_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uminv_r_p_z_field_pg_1_poweroftwo_2000_040b2400() {
    // Encoding: 0x040B2400
    // Test UMINV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Vd=0, Pg=1, size=0, Zn=0
    let encoding: u32 = 0x040B2400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uminv_r_p_z_field_zn_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uminv_r_p_z_field_zn_1_poweroftwo_2000_040b2020() {
    // Encoding: 0x040B2020
    // Test UMINV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x040B2020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uminv_r_p_z_field_zn_30_poweroftwominusone_2000_040b23c0() {
    // Encoding: 0x040B23C0
    // Test UMINV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x040B23C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uminv_r_p_z_field_zn_31_max_2000_040b23e0() {
    // Encoding: 0x040B23E0
    // Test UMINV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Vd=0, Zn=31, size=0, Pg=0
    let encoding: u32 = 0x040B23E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uminv_r_p_z_field_vd_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uminv_r_p_z_field_vd_1_poweroftwo_2000_040b2001() {
    // Encoding: 0x040B2001
    // Test UMINV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, size=0, Vd=1
    let encoding: u32 = 0x040B2001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uminv_r_p_z_field_vd_30_poweroftwominusone_2000_040b201e() {
    // Encoding: 0x040B201E
    // Test UMINV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Vd=30, Zn=0
    let encoding: u32 = 0x040B201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uminv_r_p_z_field_vd_31_max_2000_040b201f() {
    // Encoding: 0x040B201F
    // Test UMINV_R.P.Z__ field Vd = 31 (Max)
    // Fields: size=0, Vd=31, Zn=0, Pg=0
    let encoding: u32 = 0x040B201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uminv_r_p_z_combo_0_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_uminv_r_p_z_combo_1_2000_044b2000() {
    // Encoding: 0x044B2000
    // Test UMINV_R.P.Z__ field combination: size=1, Pg=0, Zn=0, Vd=0
    // Fields: size=1, Zn=0, Pg=0, Vd=0
    let encoding: u32 = 0x044B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_uminv_r_p_z_combo_2_2000_048b2000() {
    // Encoding: 0x048B2000
    // Test UMINV_R.P.Z__ field combination: size=2, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, size=2, Vd=0, Pg=0
    let encoding: u32 = 0x048B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_uminv_r_p_z_combo_3_2000_04cb2000() {
    // Encoding: 0x04CB2000
    // Test UMINV_R.P.Z__ field combination: size=3, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Pg=0, size=3, Vd=0
    let encoding: u32 = 0x04CB2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_uminv_r_p_z_combo_4_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Vd=0, size=0, Zn=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_uminv_r_p_z_combo_5_2000_040b2400() {
    // Encoding: 0x040B2400
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=1, Zn=0, Vd=0
    // Fields: Pg=1, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x040B2400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_uminv_r_p_z_combo_6_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_uminv_r_p_z_combo_7_2000_040b2020() {
    // Encoding: 0x040B2020
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=1, Vd=0
    // Fields: Zn=1, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x040B2020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_uminv_r_p_z_combo_8_2000_040b23c0() {
    // Encoding: 0x040B23C0
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=30, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=30
    let encoding: u32 = 0x040B23C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_uminv_r_p_z_combo_9_2000_040b23e0() {
    // Encoding: 0x040B23E0
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=31, Vd=0
    // Fields: Pg=0, Zn=31, Vd=0, size=0
    let encoding: u32 = 0x040B23E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_uminv_r_p_z_combo_10_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_uminv_r_p_z_combo_11_2000_040b2001() {
    // Encoding: 0x040B2001
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=1
    // Fields: Pg=0, Zn=0, Vd=1, size=0
    let encoding: u32 = 0x040B2001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=30 (SIMD register V30)
#[test]
fn test_uminv_r_p_z_combo_12_2000_040b201e() {
    // Encoding: 0x040B201E
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=30
    // Fields: Vd=30, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x040B201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=31 (SIMD register V31)
#[test]
fn test_uminv_r_p_z_combo_13_2000_040b201f() {
    // Encoding: 0x040B201F
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=31
    // Fields: size=0, Pg=0, Zn=0, Vd=31
    let encoding: u32 = 0x040B201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uminv_r_p_z_special_size_0_size_variant_0_8192_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Vd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uminv_r_p_z_special_size_1_size_variant_1_8192_044b2000() {
    // Encoding: 0x044B2000
    // Test UMINV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zn=0, Vd=0
    let encoding: u32 = 0x044B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uminv_r_p_z_special_size_2_size_variant_2_8192_048b2000() {
    // Encoding: 0x048B2000
    // Test UMINV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, size=2, Vd=0
    let encoding: u32 = 0x048B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uminv_r_p_z_special_size_3_size_variant_3_8192_04cb2000() {
    // Encoding: 0x04CB2000
    // Test UMINV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Vd=0, size=3, Pg=0
    let encoding: u32 = 0x04CB2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uminv_r_p_z_invalid_0_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uminv_r_p_z_invalid_1_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uminv_r_p_z_reg_write_0_040b2000() {
    // Test UMINV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x040B2000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040B2000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// EORV_R.P.Z__ Tests
// ============================================================================

/// Provenance: EORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_eorv_r_p_z_field_size_0_min_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_eorv_r_p_z_field_size_1_poweroftwo_2000_04592000() {
    // Encoding: 0x04592000
    // Test EORV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04592000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_eorv_r_p_z_field_size_2_poweroftwo_2000_04992000() {
    // Encoding: 0x04992000
    // Test EORV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=2, Vd=0
    let encoding: u32 = 0x04992000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_eorv_r_p_z_field_size_3_max_2000_04d92000() {
    // Encoding: 0x04D92000
    // Test EORV_R.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, Vd=0, Pg=0, size=3
    let encoding: u32 = 0x04D92000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_eorv_r_p_z_field_pg_0_min_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_eorv_r_p_z_field_pg_1_poweroftwo_2000_04192400() {
    // Encoding: 0x04192400
    // Test EORV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x04192400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_eorv_r_p_z_field_zn_0_min_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_eorv_r_p_z_field_zn_1_poweroftwo_2000_04192020() {
    // Encoding: 0x04192020
    // Test EORV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Vd=0, Zn=1
    let encoding: u32 = 0x04192020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_eorv_r_p_z_field_zn_30_poweroftwominusone_2000_041923c0() {
    // Encoding: 0x041923C0
    // Test EORV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x041923C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_eorv_r_p_z_field_zn_31_max_2000_041923e0() {
    // Encoding: 0x041923E0
    // Test EORV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x041923E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_eorv_r_p_z_field_vd_0_min_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_eorv_r_p_z_field_vd_1_poweroftwo_2000_04192001() {
    // Encoding: 0x04192001
    // Test EORV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Vd=1, Zn=0
    let encoding: u32 = 0x04192001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_eorv_r_p_z_field_vd_30_poweroftwominusone_2000_0419201e() {
    // Encoding: 0x0419201E
    // Test EORV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Vd=30
    let encoding: u32 = 0x0419201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_eorv_r_p_z_field_vd_31_max_2000_0419201f() {
    // Encoding: 0x0419201F
    // Test EORV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Vd=31, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0419201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_eorv_r_p_z_combo_0_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_eorv_r_p_z_combo_1_2000_04592000() {
    // Encoding: 0x04592000
    // Test EORV_R.P.Z__ field combination: size=1, Pg=0, Zn=0, Vd=0
    // Fields: size=1, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04592000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_eorv_r_p_z_combo_2_2000_04992000() {
    // Encoding: 0x04992000
    // Test EORV_R.P.Z__ field combination: size=2, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Vd=0, size=2, Zn=0
    let encoding: u32 = 0x04992000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_eorv_r_p_z_combo_3_2000_04d92000() {
    // Encoding: 0x04D92000
    // Test EORV_R.P.Z__ field combination: size=3, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, size=3, Vd=0, Pg=0
    let encoding: u32 = 0x04D92000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_eorv_r_p_z_combo_4_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_eorv_r_p_z_combo_5_2000_04192400() {
    // Encoding: 0x04192400
    // Test EORV_R.P.Z__ field combination: size=0, Pg=1, Zn=0, Vd=0
    // Fields: Pg=1, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x04192400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_eorv_r_p_z_combo_6_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_eorv_r_p_z_combo_7_2000_04192020() {
    // Encoding: 0x04192020
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=1, Vd=0
    // Fields: Pg=0, Zn=1, Vd=0, size=0
    let encoding: u32 = 0x04192020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_eorv_r_p_z_combo_8_2000_041923c0() {
    // Encoding: 0x041923C0
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=30, Vd=0
    // Fields: size=0, Vd=0, Zn=30, Pg=0
    let encoding: u32 = 0x041923C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_eorv_r_p_z_combo_9_2000_041923e0() {
    // Encoding: 0x041923E0
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=31, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=31
    let encoding: u32 = 0x041923E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=0 (SIMD register V0)
#[test]
fn test_eorv_r_p_z_combo_10_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=1 (SIMD register V1)
#[test]
fn test_eorv_r_p_z_combo_11_2000_04192001() {
    // Encoding: 0x04192001
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=1
    // Fields: Vd=1, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04192001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=30 (SIMD register V30)
#[test]
fn test_eorv_r_p_z_combo_12_2000_0419201e() {
    // Encoding: 0x0419201E
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=30
    // Fields: Pg=0, Vd=30, Zn=0, size=0
    let encoding: u32 = 0x0419201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vd=31 (SIMD register V31)
#[test]
fn test_eorv_r_p_z_combo_13_2000_0419201f() {
    // Encoding: 0x0419201F
    // Test EORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=31
    // Fields: Zn=0, size=0, Pg=0, Vd=31
    let encoding: u32 = 0x0419201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_eorv_r_p_z_special_size_0_size_variant_0_8192_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_eorv_r_p_z_special_size_1_size_variant_1_8192_04592000() {
    // Encoding: 0x04592000
    // Test EORV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04592000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_eorv_r_p_z_special_size_2_size_variant_2_8192_04992000() {
    // Encoding: 0x04992000
    // Test EORV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, size=2, Vd=0
    let encoding: u32 = 0x04992000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_eorv_r_p_z_special_size_3_size_variant_3_8192_04d92000() {
    // Encoding: 0x04D92000
    // Test EORV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04D92000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_eorv_r_p_z_invalid_0_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_eorv_r_p_z_invalid_1_2000_04192000() {
    // Encoding: 0x04192000
    // Test EORV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Vd=0, Zn=0, size=0
    let encoding: u32 = 0x04192000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: EORV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_eorv_r_p_z_reg_write_0_04192000() {
    // Test EORV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04192000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04192000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FDIVR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fdivr_z_p_zz_field_size_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fdivr_z_p_zz_field_size_1_poweroftwo_8000_654c8000() {
    // Encoding: 0x654C8000
    // Test FDIVR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x654C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fdivr_z_p_zz_field_size_2_poweroftwo_8000_658c8000() {
    // Encoding: 0x658C8000
    // Test FDIVR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, size=2
    let encoding: u32 = 0x658C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fdivr_z_p_zz_field_size_3_max_8000_65cc8000() {
    // Encoding: 0x65CC8000
    // Test FDIVR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x65CC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fdivr_z_p_zz_field_pg_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fdivr_z_p_zz_field_pg_1_poweroftwo_8000_650c8400() {
    // Encoding: 0x650C8400
    // Test FDIVR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Zdn=0, size=0
    let encoding: u32 = 0x650C8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fdivr_z_p_zz_field_zm_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fdivr_z_p_zz_field_zm_1_poweroftwo_8000_650c8020() {
    // Encoding: 0x650C8020
    // Test FDIVR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x650C8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fdivr_z_p_zz_field_zm_30_poweroftwominusone_8000_650c83c0() {
    // Encoding: 0x650C83C0
    // Test FDIVR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Zm=30, size=0, Pg=0
    let encoding: u32 = 0x650C83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fdivr_z_p_zz_field_zm_31_max_8000_650c83e0() {
    // Encoding: 0x650C83E0
    // Test FDIVR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, Zm=31, size=0, Pg=0
    let encoding: u32 = 0x650C83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fdivr_z_p_zz_field_zdn_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fdivr_z_p_zz_field_zdn_1_poweroftwo_8000_650c8001() {
    // Encoding: 0x650C8001
    // Test FDIVR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=1, Pg=0, size=0
    let encoding: u32 = 0x650C8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fdivr_z_p_zz_field_zdn_15_poweroftwominusone_8000_650c800f() {
    // Encoding: 0x650C800F
    // Test FDIVR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=15, Zm=0, size=0
    let encoding: u32 = 0x650C800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fdivr_z_p_zz_field_zdn_31_max_8000_650c801f() {
    // Encoding: 0x650C801F
    // Test FDIVR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Zdn=31, size=0, Pg=0
    let encoding: u32 = 0x650C801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fdivr_z_p_zz_combo_0_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fdivr_z_p_zz_combo_1_8000_654c8000() {
    // Encoding: 0x654C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=1, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=1, Zm=0
    let encoding: u32 = 0x654C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fdivr_z_p_zz_combo_2_8000_658c8000() {
    // Encoding: 0x658C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=2, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Zm=0, Pg=0, size=2
    let encoding: u32 = 0x658C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fdivr_z_p_zz_combo_3_8000_65cc8000() {
    // Encoding: 0x65CC8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=3, Pg=0, Zm=0, Zdn=0
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65CC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fdivr_z_p_zz_combo_4_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fdivr_z_p_zz_combo_5_8000_650c8400() {
    // Encoding: 0x650C8400
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=1, Zm=0, Zdn=0
    // Fields: Pg=1, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650C8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_fdivr_z_p_zz_combo_6_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_fdivr_z_p_zz_combo_7_8000_650c8020() {
    // Encoding: 0x650C8020
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=1, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=1
    let encoding: u32 = 0x650C8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_fdivr_z_p_zz_combo_8_8000_650c83c0() {
    // Encoding: 0x650C83C0
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=30, Zdn=0
    // Fields: Pg=0, size=0, Zm=30, Zdn=0
    let encoding: u32 = 0x650C83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_fdivr_z_p_zz_combo_9_8000_650c83e0() {
    // Encoding: 0x650C83E0
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=31, Zdn=0
    // Fields: Zm=31, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x650C83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_fdivr_z_p_zz_combo_10_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_fdivr_z_p_zz_combo_11_8000_650c8001() {
    // Encoding: 0x650C8001
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=1
    // Fields: Zdn=1, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x650C8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_fdivr_z_p_zz_combo_12_8000_650c800f() {
    // Encoding: 0x650C800F
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=15
    // Fields: Zm=0, Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x650C800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_fdivr_z_p_zz_combo_13_8000_650c801f() {
    // Encoding: 0x650C801F
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=31
    // Fields: Pg=0, size=0, Zm=0, Zdn=31
    let encoding: u32 = 0x650C801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fdivr_z_p_zz_special_size_0_size_variant_0_32768_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fdivr_z_p_zz_special_size_1_size_variant_1_32768_654c8000() {
    // Encoding: 0x654C8000
    // Test FDIVR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x654C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fdivr_z_p_zz_special_size_2_size_variant_2_32768_658c8000() {
    // Encoding: 0x658C8000
    // Test FDIVR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x658C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fdivr_z_p_zz_special_size_3_size_variant_3_32768_65cc8000() {
    // Encoding: 0x65CC8000
    // Test FDIVR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x65CC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_0_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_1_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_2_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_3_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fdivr_z_p_zz_reg_write_0_650c8000() {
    // Test FDIVR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x650C8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650C8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// PNEXT_P.P.P__ Tests
// ============================================================================

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_pnext_p_p_p_field_size_0_min_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ field size = 0 (Min)
    // Fields: Pg=0, Pdn=0, size=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_pnext_p_p_p_field_size_1_poweroftwo_c400_2559c400() {
    // Encoding: 0x2559C400
    // Test PNEXT_P.P.P__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Pdn=0, size=1
    let encoding: u32 = 0x2559C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_pnext_p_p_p_field_size_2_poweroftwo_c400_2599c400() {
    // Encoding: 0x2599C400
    // Test PNEXT_P.P.P__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Pdn=0
    let encoding: u32 = 0x2599C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_pnext_p_p_p_field_size_3_max_c400_25d9c400() {
    // Encoding: 0x25D9C400
    // Test PNEXT_P.P.P__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Pdn=0
    let encoding: u32 = 0x25D9C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_pnext_p_p_p_field_pg_0_min_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ field Pg = 0 (Min)
    // Fields: Pdn=0, size=0, Pg=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_pnext_p_p_p_field_pg_1_poweroftwo_c400_2519c420() {
    // Encoding: 0x2519C420
    // Test PNEXT_P.P.P__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pdn=0, Pg=1
    let encoding: u32 = 0x2519C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field Pdn 0 +: 4`
/// Requirement: FieldBoundary { field: "Pdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_pnext_p_p_p_field_pdn_0_min_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ field Pdn = 0 (Min)
    // Fields: size=0, Pg=0, Pdn=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field Pdn 0 +: 4`
/// Requirement: FieldBoundary { field: "Pdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_pnext_p_p_p_field_pdn_1_poweroftwo_c400_2519c401() {
    // Encoding: 0x2519C401
    // Test PNEXT_P.P.P__ field Pdn = 1 (PowerOfTwo)
    // Fields: Pdn=1, Pg=0, size=0
    let encoding: u32 = 0x2519C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field Pdn 0 +: 4`
/// Requirement: FieldBoundary { field: "Pdn", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_pnext_p_p_p_field_pdn_7_poweroftwominusone_c400_2519c407() {
    // Encoding: 0x2519C407
    // Test PNEXT_P.P.P__ field Pdn = 7 (PowerOfTwoMinusOne)
    // Fields: Pdn=7, Pg=0, size=0
    let encoding: u32 = 0x2519C407;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field Pdn 0 +: 4`
/// Requirement: FieldBoundary { field: "Pdn", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_pnext_p_p_p_field_pdn_15_max_c400_2519c40f() {
    // Encoding: 0x2519C40F
    // Test PNEXT_P.P.P__ field Pdn = 15 (Max)
    // Fields: Pg=0, Pdn=15, size=0
    let encoding: u32 = 0x2519C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_pnext_p_p_p_combo_0_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=0, Pdn=0
    // Fields: size=0, Pg=0, Pdn=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_pnext_p_p_p_combo_1_c400_2559c400() {
    // Encoding: 0x2559C400
    // Test PNEXT_P.P.P__ field combination: size=1, Pg=0, Pdn=0
    // Fields: Pdn=0, size=1, Pg=0
    let encoding: u32 = 0x2559C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_pnext_p_p_p_combo_2_c400_2599c400() {
    // Encoding: 0x2599C400
    // Test PNEXT_P.P.P__ field combination: size=2, Pg=0, Pdn=0
    // Fields: Pg=0, size=2, Pdn=0
    let encoding: u32 = 0x2599C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_pnext_p_p_p_combo_3_c400_25d9c400() {
    // Encoding: 0x25D9C400
    // Test PNEXT_P.P.P__ field combination: size=3, Pg=0, Pdn=0
    // Fields: Pdn=0, Pg=0, size=3
    let encoding: u32 = 0x25D9C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_pnext_p_p_p_combo_4_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=0, Pdn=0
    // Fields: size=0, Pg=0, Pdn=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_pnext_p_p_p_combo_5_c400_2519c420() {
    // Encoding: 0x2519C420
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=1, Pdn=0
    // Fields: size=0, Pg=1, Pdn=0
    let encoding: u32 = 0x2519C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pdn=0 (minimum value)
#[test]
fn test_pnext_p_p_p_combo_6_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=0, Pdn=0
    // Fields: Pg=0, size=0, Pdn=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pdn=1 (value 1)
#[test]
fn test_pnext_p_p_p_combo_7_c400_2519c401() {
    // Encoding: 0x2519C401
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=0, Pdn=1
    // Fields: Pg=0, Pdn=1, size=0
    let encoding: u32 = 0x2519C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pdn=7 (midpoint (7))
#[test]
fn test_pnext_p_p_p_combo_8_c400_2519c407() {
    // Encoding: 0x2519C407
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=0, Pdn=7
    // Fields: size=0, Pg=0, Pdn=7
    let encoding: u32 = 0x2519C407;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pdn=15 (maximum value (15))
#[test]
fn test_pnext_p_p_p_combo_9_c400_2519c40f() {
    // Encoding: 0x2519C40F
    // Test PNEXT_P.P.P__ field combination: size=0, Pg=0, Pdn=15
    // Fields: size=0, Pg=0, Pdn=15
    let encoding: u32 = 0x2519C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_pnext_p_p_p_special_size_0_size_variant_0_50176_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Pdn=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_pnext_p_p_p_special_size_1_size_variant_1_50176_2559c400() {
    // Encoding: 0x2559C400
    // Test PNEXT_P.P.P__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pdn=0, Pg=0
    let encoding: u32 = 0x2559C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_pnext_p_p_p_special_size_2_size_variant_2_50176_2599c400() {
    // Encoding: 0x2599C400
    // Test PNEXT_P.P.P__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Pdn=0
    let encoding: u32 = 0x2599C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_pnext_p_p_p_special_size_3_size_variant_3_50176_25d9c400() {
    // Encoding: 0x25D9C400
    // Test PNEXT_P.P.P__ special value size = 3 (Size variant 3)
    // Fields: Pdn=0, size=3, Pg=0
    let encoding: u32 = 0x25D9C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_pnext_p_p_p_invalid_0_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pdn=0, size=0, Pg=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_pnext_p_p_p_invalid_1_c400_2519c400() {
    // Encoding: 0x2519C400
    // Test PNEXT_P.P.P__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pdn=0, size=0, Pg=0
    let encoding: u32 = 0x2519C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `SimdFromField("Pdn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pdn")
#[test]
fn test_pnext_p_p_p_reg_write_0_2519c400() {
    // Test PNEXT_P.P.P__ register write: SimdFromField("Pdn")
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_pnext_p_p_p_flags_zeroresult_0_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: ZeroResult
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x0);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_pnext_p_p_p_flags_zeroresult_1_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: ZeroResult
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x1);
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_pnext_p_p_p_flags_negativeresult_2_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: NegativeResult
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x0);
    set_x(&mut cpu, 1, 0x8000000000000000);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_pnext_p_p_p_flags_unsignedoverflow_3_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: UnsignedOverflow
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_pnext_p_p_p_flags_unsignedoverflow_4_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: UnsignedOverflow
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x2);
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_pnext_p_p_p_flags_signedoverflow_5_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: SignedOverflow
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x1);
    set_x(&mut cpu, 1, 0x7FFFFFFFFFFFFFFF);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_pnext_p_p_p_flags_signedoverflow_6_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: SignedOverflow
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: PNEXT_P.P.P__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_pnext_p_p_p_flags_positiveresult_7_2519c400() {
    // Test PNEXT_P.P.P__ flag computation: PositiveResult
    // Encoding: 0x2519C400
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x32);
    set_x(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x2519C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// LDNT1D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_0_zero_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a581e000() {
    // Encoding: 0xA581E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xA581E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a583e000() {
    // Encoding: 0xA583E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, Rn=0, Zt=0
    let encoding: u32 = 0xA583E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a584e000() {
    // Encoding: 0xA584E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA584E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a587e000() {
    // Encoding: 0xA587E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=7
    let encoding: u32 = 0xA587E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a588e000() {
    // Encoding: 0xA588E000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xA588E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_imm4_15_max_e000_a58fe000() {
    // Encoding: 0xA58FE000
    // Test LDNT1D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=15
    let encoding: u32 = 0xA58FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_pg_0_min_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a580e400() {
    // Encoding: 0xA580E400
    // Test LDNT1D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xA580E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_0_min_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a580e020() {
    // Encoding: 0xA580E020
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA580E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a580e3c0() {
    // Encoding: 0xA580E3C0
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=30
    let encoding: u32 = 0xA580E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_rn_31_max_e000_a580e3e0() {
    // Encoding: 0xA580E3E0
    // Test LDNT1D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=31
    let encoding: u32 = 0xA580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_0_min_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a580e001() {
    // Encoding: 0xA580E001
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xA580E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a580e01e() {
    // Encoding: 0xA580E01E
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xA580E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ldnt1d_z_p_bi_contiguous_field_zt_31_max_e000_a580e01f() {
    // Encoding: 0xA580E01F
    // Test LDNT1D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xA580E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_0_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_1_e000_a581e000() {
    // Encoding: 0xA581E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, imm4=1, Zt=0, Rn=0
    let encoding: u32 = 0xA581E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_2_e000_a583e000() {
    // Encoding: 0xA583E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xA583E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_3_e000_a584e000() {
    // Encoding: 0xA584E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=4
    let encoding: u32 = 0xA584E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_4_e000_a587e000() {
    // Encoding: 0xA587E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: imm4=7, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA587E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_5_e000_a588e000() {
    // Encoding: 0xA588E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: imm4=8, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA588E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_6_e000_a58fe000() {
    // Encoding: 0xA58FE000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=15, Pg=0
    let encoding: u32 = 0xA58FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_7_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_8_e000_a580e400() {
    // Encoding: 0xA580E400
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xA580E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_9_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_10_e000_a580e020() {
    // Encoding: 0xA580E020
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, imm4=0, Rn=1, Zt=0
    let encoding: u32 = 0xA580E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_11_e000_a580e3c0() {
    // Encoding: 0xA580E3C0
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xA580E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_12_e000_a580e3e0() {
    // Encoding: 0xA580E3E0
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, imm4=0, Rn=31, Pg=0
    let encoding: u32 = 0xA580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_13_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_14_e000_a580e001() {
    // Encoding: 0xA580E001
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, imm4=0, Rn=0, Zt=1
    let encoding: u32 = 0xA580E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_15_e000_a580e01e() {
    // Encoding: 0xA580E01E
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Pg=0, Rn=0, Zt=30, imm4=0
    let encoding: u32 = 0xA580E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_16_e000_a580e01f() {
    // Encoding: 0xA580E01F
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: imm4=0, Pg=0, Zt=31, Rn=0
    let encoding: u32 = 0xA580E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_17_e000_a580e420() {
    // Encoding: 0xA580E420
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, imm4=0, Rn=1, Pg=1
    let encoding: u32 = 0xA580E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ldnt1d_z_p_bi_contiguous_combo_18_e000_a580ffe0() {
    // Encoding: 0xA580FFE0
    // Test LDNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: imm4=0, Pg=31, Zt=0, Rn=31
    let encoding: u32 = 0xA580FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ldnt1d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a580e3e0() {
    // Encoding: 0xA580E3E0
    // Test LDNT1D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=31
    let encoding: u32 = 0xA580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_bi_contiguous_invalid_0_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ldnt1d_z_p_bi_contiguous_invalid_1_e000_a580e000() {
    // Encoding: 0xA580E000
    // Test LDNT1D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ldnt1d_z_p_bi_contiguous_reg_write_0_a580e000() {
    // Test LDNT1D_Z.P.BI_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA580E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LDNT1D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ldnt1d_z_p_bi_contiguous_sp_rn_a580e3e0() {
    // Test LDNT1D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA580E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA580E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// MSB_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_msb_z_p_zzz_field_size_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Zdn=0, Zm=0, Pg=0, Za=0, size=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_msb_z_p_zzz_field_size_1_poweroftwo_e000_0440e000() {
    // Encoding: 0x0440E000
    // Test MSB_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=1, Za=0, Zdn=0
    let encoding: u32 = 0x0440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_msb_z_p_zzz_field_size_2_poweroftwo_e000_0480e000() {
    // Encoding: 0x0480E000
    // Test MSB_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, Za=0, size=2, Zm=0
    let encoding: u32 = 0x0480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_msb_z_p_zzz_field_size_3_max_e000_04c0e000() {
    // Encoding: 0x04C0E000
    // Test MSB_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Zm=0, Za=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x04C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_msb_z_p_zzz_field_zm_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, Zm=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_msb_z_p_zzz_field_zm_1_poweroftwo_e000_0401e000() {
    // Encoding: 0x0401E000
    // Test MSB_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, Za=0, Zm=1, size=0
    let encoding: u32 = 0x0401E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_msb_z_p_zzz_field_zm_30_poweroftwominusone_e000_041ee000() {
    // Encoding: 0x041EE000
    // Test MSB_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, Zm=30, Za=0, Pg=0
    let encoding: u32 = 0x041EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_msb_z_p_zzz_field_zm_31_max_e000_041fe000() {
    // Encoding: 0x041FE000
    // Test MSB_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zdn=0, size=0, Za=0, Zm=31
    let encoding: u32 = 0x041FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_msb_z_p_zzz_field_pg_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Za=0, size=0, Zdn=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_msb_z_p_zzz_field_pg_1_poweroftwo_e000_0400e400() {
    // Encoding: 0x0400E400
    // Test MSB_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, Pg=1, Za=0, size=0
    let encoding: u32 = 0x0400E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_msb_z_p_zzz_field_za_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: size=0, Za=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_msb_z_p_zzz_field_za_1_poweroftwo_e000_0400e020() {
    // Encoding: 0x0400E020
    // Test MSB_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zdn=0, Za=1, Pg=0
    let encoding: u32 = 0x0400E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_msb_z_p_zzz_field_za_15_poweroftwominusone_e000_0400e1e0() {
    // Encoding: 0x0400E1E0
    // Test MSB_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=0, Zm=0, Za=15
    let encoding: u32 = 0x0400E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_msb_z_p_zzz_field_za_31_max_e000_0400e3e0() {
    // Encoding: 0x0400E3E0
    // Test MSB_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: Pg=0, size=0, Zm=0, Za=31, Zdn=0
    let encoding: u32 = 0x0400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_msb_z_p_zzz_field_zdn_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_msb_z_p_zzz_field_zdn_1_poweroftwo_e000_0400e001() {
    // Encoding: 0x0400E001
    // Test MSB_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Za=0, Zdn=1, size=0
    let encoding: u32 = 0x0400E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_msb_z_p_zzz_field_zdn_15_poweroftwominusone_e000_0400e00f() {
    // Encoding: 0x0400E00F
    // Test MSB_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, Zm=0, Pg=0, Za=0, size=0
    let encoding: u32 = 0x0400E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_msb_z_p_zzz_field_zdn_31_max_e000_0400e01f() {
    // Encoding: 0x0400E01F
    // Test MSB_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Zm=0, Za=0, Pg=0
    let encoding: u32 = 0x0400E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_msb_z_p_zzz_combo_0_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Za=0, Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_msb_z_p_zzz_combo_1_e000_0440e000() {
    // Encoding: 0x0440E000
    // Test MSB_Z.P.ZZZ__ field combination: size=1, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Zm=0, size=1, Za=0, Zdn=0, Pg=0
    let encoding: u32 = 0x0440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_msb_z_p_zzz_combo_2_e000_0480e000() {
    // Encoding: 0x0480E000
    // Test MSB_Z.P.ZZZ__ field combination: size=2, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Zm=0, Zdn=0, Za=0, Pg=0, size=2
    let encoding: u32 = 0x0480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_msb_z_p_zzz_combo_3_e000_04c0e000() {
    // Encoding: 0x04C0E000
    // Test MSB_Z.P.ZZZ__ field combination: size=3, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Za=0, Zdn=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x04C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_msb_z_p_zzz_combo_4_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Za=0, size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_msb_z_p_zzz_combo_5_e000_0401e000() {
    // Encoding: 0x0401E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=1, Pg=0, Za=0, Zdn=0
    // Fields: Zdn=0, size=0, Zm=1, Za=0, Pg=0
    let encoding: u32 = 0x0401E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_msb_z_p_zzz_combo_6_e000_041ee000() {
    // Encoding: 0x041EE000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=30, Pg=0, Za=0, Zdn=0
    // Fields: Zdn=0, Pg=0, size=0, Za=0, Zm=30
    let encoding: u32 = 0x041EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_msb_z_p_zzz_combo_7_e000_041fe000() {
    // Encoding: 0x041FE000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=31, Pg=0, Za=0, Zdn=0
    // Fields: size=0, Zdn=0, Pg=0, Zm=31, Za=0
    let encoding: u32 = 0x041FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_msb_z_p_zzz_combo_8_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Za=0, Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_msb_z_p_zzz_combo_9_e000_0400e400() {
    // Encoding: 0x0400E400
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=1, Za=0, Zdn=0
    // Fields: Zm=0, Za=0, Pg=1, size=0, Zdn=0
    let encoding: u32 = 0x0400E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Za=0 (minimum value)
#[test]
fn test_msb_z_p_zzz_combo_10_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Pg=0, Za=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Za=1 (value 1)
#[test]
fn test_msb_z_p_zzz_combo_11_e000_0400e020() {
    // Encoding: 0x0400E020
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=1, Zdn=0
    // Fields: Zm=0, Za=1, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x0400E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Za=15 (midpoint (15))
#[test]
fn test_msb_z_p_zzz_combo_12_e000_0400e1e0() {
    // Encoding: 0x0400E1E0
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=15, Zdn=0
    // Fields: Za=15, size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x0400E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Za=31 (maximum value (31))
#[test]
fn test_msb_z_p_zzz_combo_13_e000_0400e3e0() {
    // Encoding: 0x0400E3E0
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=31, Zdn=0
    // Fields: Zm=0, Zdn=0, Za=31, size=0, Pg=0
    let encoding: u32 = 0x0400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_msb_z_p_zzz_combo_14_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Zm=0, Za=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_msb_z_p_zzz_combo_15_e000_0400e001() {
    // Encoding: 0x0400E001
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=1
    // Fields: Zdn=1, Pg=0, Zm=0, size=0, Za=0
    let encoding: u32 = 0x0400E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_msb_z_p_zzz_combo_16_e000_0400e00f() {
    // Encoding: 0x0400E00F
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=15
    // Fields: size=0, Pg=0, Zm=0, Za=0, Zdn=15
    let encoding: u32 = 0x0400E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_msb_z_p_zzz_combo_17_e000_0400e01f() {
    // Encoding: 0x0400E01F
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=31
    // Fields: Pg=0, Zdn=31, Zm=0, Za=0, size=0
    let encoding: u32 = 0x0400E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_msb_z_p_zzz_special_size_0_size_variant_0_57344_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Za=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_msb_z_p_zzz_special_size_1_size_variant_1_57344_0440e000() {
    // Encoding: 0x0440E000
    // Test MSB_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Za=0, Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x0440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_msb_z_p_zzz_special_size_2_size_variant_2_57344_0480e000() {
    // Encoding: 0x0480E000
    // Test MSB_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Za=0, Zm=0, Zdn=0, Pg=0, size=2
    let encoding: u32 = 0x0480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_msb_z_p_zzz_special_size_3_size_variant_3_57344_04c0e000() {
    // Encoding: 0x04C0E000
    // Test MSB_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, Zdn=0, Za=0, size=3
    let encoding: u32 = 0x04C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_msb_z_p_zzz_invalid_0_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zdn=0, Pg=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_msb_z_p_zzz_invalid_1_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Za=0, Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_msb_z_p_zzz_reg_write_0_0400e000() {
    // Test MSB_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x0400E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0400E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTB_R.P.Z__ Tests
// ============================================================================

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clastb_r_p_z_field_size_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Rdn=0, size=0, Zm=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clastb_r_p_z_field_size_1_poweroftwo_a000_0571a000() {
    // Encoding: 0x0571A000
    // Test CLASTB_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Rdn=0, Zm=0
    let encoding: u32 = 0x0571A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clastb_r_p_z_field_size_2_poweroftwo_a000_05b1a000() {
    // Encoding: 0x05B1A000
    // Test CLASTB_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, Zm=0, Pg=0, size=2
    let encoding: u32 = 0x05B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clastb_r_p_z_field_size_3_max_a000_05f1a000() {
    // Encoding: 0x05F1A000
    // Test CLASTB_R.P.Z__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Rdn=0, Pg=0
    let encoding: u32 = 0x05F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clastb_r_p_z_field_pg_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Rdn=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clastb_r_p_z_field_pg_1_poweroftwo_a000_0531a400() {
    // Encoding: 0x0531A400
    // Test CLASTB_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Rdn=0, size=0
    let encoding: u32 = 0x0531A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clastb_r_p_z_field_zm_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field Zm = 0 (Min)
    // Fields: Zm=0, Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clastb_r_p_z_field_zm_1_poweroftwo_a000_0531a020() {
    // Encoding: 0x0531A020
    // Test CLASTB_R.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Rdn=0, Pg=0
    let encoding: u32 = 0x0531A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clastb_r_p_z_field_zm_30_poweroftwominusone_a000_0531a3c0() {
    // Encoding: 0x0531A3C0
    // Test CLASTB_R.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=30, Rdn=0
    let encoding: u32 = 0x0531A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clastb_r_p_z_field_zm_31_max_a000_0531a3e0() {
    // Encoding: 0x0531A3E0
    // Test CLASTB_R.P.Z__ field Zm = 31 (Max)
    // Fields: Zm=31, Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x0531A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clastb_r_p_z_field_rdn_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field Rdn = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Rdn=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clastb_r_p_z_field_rdn_1_poweroftwo_a000_0531a001() {
    // Encoding: 0x0531A001
    // Test CLASTB_R.P.Z__ field Rdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Rdn=1, Zm=0
    let encoding: u32 = 0x0531A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clastb_r_p_z_field_rdn_15_poweroftwominusone_a000_0531a00f() {
    // Encoding: 0x0531A00F
    // Test CLASTB_R.P.Z__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Rdn=15, Zm=0, Pg=0
    let encoding: u32 = 0x0531A00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clastb_r_p_z_field_rdn_31_max_a000_0531a01f() {
    // Encoding: 0x0531A01F
    // Test CLASTB_R.P.Z__ field Rdn = 31 (Max)
    // Fields: Pg=0, Zm=0, size=0, Rdn=31
    let encoding: u32 = 0x0531A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clastb_r_p_z_combo_0_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=0
    // Fields: size=0, Zm=0, Rdn=0, Pg=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_clastb_r_p_z_combo_1_a000_0571a000() {
    // Encoding: 0x0571A000
    // Test CLASTB_R.P.Z__ field combination: size=1, Pg=0, Zm=0, Rdn=0
    // Fields: Zm=0, Rdn=0, size=1, Pg=0
    let encoding: u32 = 0x0571A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_clastb_r_p_z_combo_2_a000_05b1a000() {
    // Encoding: 0x05B1A000
    // Test CLASTB_R.P.Z__ field combination: size=2, Pg=0, Zm=0, Rdn=0
    // Fields: size=2, Rdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x05B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_clastb_r_p_z_combo_3_a000_05f1a000() {
    // Encoding: 0x05F1A000
    // Test CLASTB_R.P.Z__ field combination: size=3, Pg=0, Zm=0, Rdn=0
    // Fields: Zm=0, Rdn=0, Pg=0, size=3
    let encoding: u32 = 0x05F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_clastb_r_p_z_combo_4_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=0
    // Fields: size=0, Zm=0, Pg=0, Rdn=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_clastb_r_p_z_combo_5_a000_0531a400() {
    // Encoding: 0x0531A400
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=1, Zm=0, Rdn=0
    // Fields: size=0, Pg=1, Rdn=0, Zm=0
    let encoding: u32 = 0x0531A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_clastb_r_p_z_combo_6_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=0
    // Fields: size=0, Rdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_clastb_r_p_z_combo_7_a000_0531a020() {
    // Encoding: 0x0531A020
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=1, Rdn=0
    // Fields: size=0, Pg=0, Zm=1, Rdn=0
    let encoding: u32 = 0x0531A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_clastb_r_p_z_combo_8_a000_0531a3c0() {
    // Encoding: 0x0531A3C0
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=30, Rdn=0
    // Fields: size=0, Zm=30, Rdn=0, Pg=0
    let encoding: u32 = 0x0531A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_clastb_r_p_z_combo_9_a000_0531a3e0() {
    // Encoding: 0x0531A3E0
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=31, Rdn=0
    // Fields: Zm=31, size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x0531A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_clastb_r_p_z_combo_10_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=0
    // Fields: size=0, Zm=0, Rdn=0, Pg=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=1 (value 1)
#[test]
fn test_clastb_r_p_z_combo_11_a000_0531a001() {
    // Encoding: 0x0531A001
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=1
    // Fields: size=0, Pg=0, Rdn=1, Zm=0
    let encoding: u32 = 0x0531A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=15 (midpoint (15))
#[test]
fn test_clastb_r_p_z_combo_12_a000_0531a00f() {
    // Encoding: 0x0531A00F
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=15
    // Fields: Zm=0, Pg=0, Rdn=15, size=0
    let encoding: u32 = 0x0531A00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=31 (maximum value (31))
#[test]
fn test_clastb_r_p_z_combo_13_a000_0531a01f() {
    // Encoding: 0x0531A01F
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=31
    // Fields: Rdn=31, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x0531A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clastb_r_p_z_special_size_0_size_variant_0_40960_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Rdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clastb_r_p_z_special_size_1_size_variant_1_40960_0571a000() {
    // Encoding: 0x0571A000
    // Test CLASTB_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Rdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x0571A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clastb_r_p_z_special_size_2_size_variant_2_40960_05b1a000() {
    // Encoding: 0x05B1A000
    // Test CLASTB_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Pg=0, Rdn=0
    let encoding: u32 = 0x05B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clastb_r_p_z_special_size_3_size_variant_3_40960_05f1a000() {
    // Encoding: 0x05F1A000
    // Test CLASTB_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Pg=0, Rdn=0
    let encoding: u32 = 0x05F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clastb_r_p_z_invalid_0_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rdn=0, size=0, Zm=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clastb_r_p_z_invalid_1_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zm=0, Rdn=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_clastb_r_p_z_reg_write_0_0531a000() {
    // Test CLASTB_R.P.Z__ register write: GpFromField("dn")
    // Encoding: 0x0531A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0531A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FCADD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fcadd_z_p_zz_field_size_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, rot=0, Pg=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fcadd_z_p_zz_field_size_1_poweroftwo_8000_64408000() {
    // Encoding: 0x64408000
    // Test FCADD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, rot=0, Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x64408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fcadd_z_p_zz_field_size_2_poweroftwo_8000_64808000() {
    // Encoding: 0x64808000
    // Test FCADD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0, rot=0
    let encoding: u32 = 0x64808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fcadd_z_p_zz_field_size_3_max_8000_64c08000() {
    // Encoding: 0x64C08000
    // Test FCADD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Pg=0, rot=0, Zdn=0
    let encoding: u32 = 0x64C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field rot 16 +: 1`
/// Requirement: FieldBoundary { field: "rot", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fcadd_z_p_zz_field_rot_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field rot = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, rot=0, size=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field rot 16 +: 1`
/// Requirement: FieldBoundary { field: "rot", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fcadd_z_p_zz_field_rot_1_max_8000_64018000() {
    // Encoding: 0x64018000
    // Test FCADD_Z.P.ZZ__ field rot = 1 (Max)
    // Fields: Pg=0, rot=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x64018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcadd_z_p_zz_field_pg_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0, Zm=0, rot=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcadd_z_p_zz_field_pg_1_poweroftwo_8000_64008400() {
    // Encoding: 0x64008400
    // Test FCADD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, rot=0, size=0, Zdn=0
    let encoding: u32 = 0x64008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcadd_z_p_zz_field_zm_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0, rot=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcadd_z_p_zz_field_zm_1_poweroftwo_8000_64008020() {
    // Encoding: 0x64008020
    // Test FCADD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, rot=0, Pg=0, Zm=1
    let encoding: u32 = 0x64008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcadd_z_p_zz_field_zm_30_poweroftwominusone_8000_640083c0() {
    // Encoding: 0x640083C0
    // Test FCADD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, rot=0, Pg=0, Zm=30
    let encoding: u32 = 0x640083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcadd_z_p_zz_field_zm_31_max_8000_640083e0() {
    // Encoding: 0x640083E0
    // Test FCADD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zdn=0, Pg=0, Zm=31, rot=0
    let encoding: u32 = 0x640083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fcadd_z_p_zz_field_zdn_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, rot=0, Pg=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fcadd_z_p_zz_field_zdn_1_poweroftwo_8000_64008001() {
    // Encoding: 0x64008001
    // Test FCADD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: rot=0, Zm=0, size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x64008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fcadd_z_p_zz_field_zdn_15_poweroftwominusone_8000_6400800f() {
    // Encoding: 0x6400800F
    // Test FCADD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, rot=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x6400800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fcadd_z_p_zz_field_zdn_31_max_8000_6400801f() {
    // Encoding: 0x6400801F
    // Test FCADD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zdn=31, Zm=0, rot=0, size=0
    let encoding: u32 = 0x6400801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fcadd_z_p_zz_combo_0_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, rot=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fcadd_z_p_zz_combo_1_8000_64408000() {
    // Encoding: 0x64408000
    // Test FCADD_Z.P.ZZ__ field combination: size=1, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: rot=0, Zm=0, size=1, Zdn=0, Pg=0
    let encoding: u32 = 0x64408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fcadd_z_p_zz_combo_2_8000_64808000() {
    // Encoding: 0x64808000
    // Test FCADD_Z.P.ZZ__ field combination: size=2, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, rot=0, Zm=0, size=2, Zdn=0
    let encoding: u32 = 0x64808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fcadd_z_p_zz_combo_3_8000_64c08000() {
    // Encoding: 0x64C08000
    // Test FCADD_Z.P.ZZ__ field combination: size=3, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: rot=0, size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x64C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// rot=0 (minimum value)
#[test]
fn test_fcadd_z_p_zz_combo_4_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zm=0, Zdn=0, rot=0, Pg=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// rot=1 (maximum value (1))
#[test]
fn test_fcadd_z_p_zz_combo_5_8000_64018000() {
    // Encoding: 0x64018000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=1, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zm=0, Pg=0, rot=1, Zdn=0
    let encoding: u32 = 0x64018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcadd_z_p_zz_combo_6_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zm=0, size=0, rot=0, Zdn=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fcadd_z_p_zz_combo_7_8000_64008400() {
    // Encoding: 0x64008400
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=1, Zm=0, Zdn=0
    // Fields: rot=0, Pg=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x64008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_fcadd_z_p_zz_combo_8_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: rot=0, Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_fcadd_z_p_zz_combo_9_8000_64008020() {
    // Encoding: 0x64008020
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=1, Zdn=0
    // Fields: Zdn=0, Pg=0, rot=0, size=0, Zm=1
    let encoding: u32 = 0x64008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_fcadd_z_p_zz_combo_10_8000_640083c0() {
    // Encoding: 0x640083C0
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=30, Zdn=0
    // Fields: Zm=30, rot=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x640083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_fcadd_z_p_zz_combo_11_8000_640083e0() {
    // Encoding: 0x640083E0
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=31, Zdn=0
    // Fields: rot=0, Pg=0, Zdn=0, size=0, Zm=31
    let encoding: u32 = 0x640083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_fcadd_z_p_zz_combo_12_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, rot=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_fcadd_z_p_zz_combo_13_8000_64008001() {
    // Encoding: 0x64008001
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=1
    // Fields: Zm=0, Pg=0, rot=0, Zdn=1, size=0
    let encoding: u32 = 0x64008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_fcadd_z_p_zz_combo_14_8000_6400800f() {
    // Encoding: 0x6400800F
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=15
    // Fields: rot=0, size=0, Zm=0, Zdn=15, Pg=0
    let encoding: u32 = 0x6400800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_fcadd_z_p_zz_combo_15_8000_6400801f() {
    // Encoding: 0x6400801F
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=31
    // Fields: Zm=0, Pg=0, Zdn=31, rot=0, size=0
    let encoding: u32 = 0x6400801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fcadd_z_p_zz_special_size_0_size_variant_0_32768_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: rot=0, Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fcadd_z_p_zz_special_size_1_size_variant_1_32768_64408000() {
    // Encoding: 0x64408000
    // Test FCADD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zdn=0, size=1, Zm=0, rot=0
    let encoding: u32 = 0x64408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fcadd_z_p_zz_special_size_2_size_variant_2_32768_64808000() {
    // Encoding: 0x64808000
    // Test FCADD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zdn=0, size=2, rot=0, Pg=0
    let encoding: u32 = 0x64808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fcadd_z_p_zz_special_size_3_size_variant_3_32768_64c08000() {
    // Encoding: 0x64C08000
    // Test FCADD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Pg=0, rot=0, Zm=0
    let encoding: u32 = 0x64C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_0_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zdn=0, Pg=0, rot=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_1_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: rot=0, Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_2_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Zm=0, size=0, rot=0, Pg=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_3_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Pg=0, Zdn=0, rot=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fcadd_z_p_zz_reg_write_0_64008000() {
    // Test FCADD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x64008000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// WHILELO_P.P.RR__ Tests
// ============================================================================

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_whilelo_p_p_rr_field_size_0_min_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field size = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, Pd=0, sf=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_whilelo_p_p_rr_field_size_1_poweroftwo_c00_25600c00() {
    // Encoding: 0x25600C00
    // Test WHILELO_P.P.RR__ field size = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, size=1, Pd=0, sf=0
    let encoding: u32 = 0x25600C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_whilelo_p_p_rr_field_size_2_poweroftwo_c00_25a00c00() {
    // Encoding: 0x25A00C00
    // Test WHILELO_P.P.RR__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Rn=0, Pd=0, sf=0, Rm=0
    let encoding: u32 = 0x25A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_whilelo_p_p_rr_field_size_3_max_c00_25e00c00() {
    // Encoding: 0x25E00C00
    // Test WHILELO_P.P.RR__ field size = 3 (Max)
    // Fields: size=3, Pd=0, sf=0, Rn=0, Rm=0
    let encoding: u32 = 0x25E00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_whilelo_p_p_rr_field_rm_0_min_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field Rm = 0 (Min)
    // Fields: Rn=0, Pd=0, size=0, sf=0, Rm=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_whilelo_p_p_rr_field_rm_1_poweroftwo_c00_25210c00() {
    // Encoding: 0x25210C00
    // Test WHILELO_P.P.RR__ field Rm = 1 (PowerOfTwo)
    // Fields: size=0, sf=0, Rn=0, Pd=0, Rm=1
    let encoding: u32 = 0x25210C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_whilelo_p_p_rr_field_rm_30_poweroftwominusone_c00_253e0c00() {
    // Encoding: 0x253E0C00
    // Test WHILELO_P.P.RR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: sf=0, Rm=30, Rn=0, Pd=0, size=0
    let encoding: u32 = 0x253E0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_whilelo_p_p_rr_field_rm_31_max_c00_253f0c00() {
    // Encoding: 0x253F0C00
    // Test WHILELO_P.P.RR__ field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Pd=0, sf=0, size=0
    let encoding: u32 = 0x253F0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field sf 12 +: 1`
/// Requirement: FieldBoundary { field: "sf", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_whilelo_p_p_rr_field_sf_0_min_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field sf = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, sf=0, Pd=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field sf 12 +: 1`
/// Requirement: FieldBoundary { field: "sf", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_whilelo_p_p_rr_field_sf_1_max_c00_25201c00() {
    // Encoding: 0x25201C00
    // Test WHILELO_P.P.RR__ field sf = 1 (Max)
    // Fields: Pd=0, Rn=0, sf=1, size=0, Rm=0
    let encoding: u32 = 0x25201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_whilelo_p_p_rr_field_rn_0_min_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field Rn = 0 (Min)
    // Fields: size=0, Rn=0, Rm=0, sf=0, Pd=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_whilelo_p_p_rr_field_rn_1_poweroftwo_c00_25200c20() {
    // Encoding: 0x25200C20
    // Test WHILELO_P.P.RR__ field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Rn=1, sf=0, Pd=0, Rm=0
    let encoding: u32 = 0x25200C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_whilelo_p_p_rr_field_rn_30_poweroftwominusone_c00_25200fc0() {
    // Encoding: 0x25200FC0
    // Test WHILELO_P.P.RR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=30, Pd=0, sf=0, Rm=0
    let encoding: u32 = 0x25200FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_whilelo_p_p_rr_field_rn_31_max_c00_25200fe0() {
    // Encoding: 0x25200FE0
    // Test WHILELO_P.P.RR__ field Rn = 31 (Max)
    // Fields: size=0, sf=0, Rm=0, Rn=31, Pd=0
    let encoding: u32 = 0x25200FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_whilelo_p_p_rr_field_pd_0_min_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field Pd = 0 (Min)
    // Fields: sf=0, size=0, Rn=0, Rm=0, Pd=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_whilelo_p_p_rr_field_pd_1_poweroftwo_c00_25200c01() {
    // Encoding: 0x25200C01
    // Test WHILELO_P.P.RR__ field Pd = 1 (PowerOfTwo)
    // Fields: Rm=0, sf=0, size=0, Pd=1, Rn=0
    let encoding: u32 = 0x25200C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_whilelo_p_p_rr_combo_0_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: size=0, Rm=0, Rn=0, Pd=0, sf=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_whilelo_p_p_rr_combo_1_c00_25600c00() {
    // Encoding: 0x25600C00
    // Test WHILELO_P.P.RR__ field combination: size=1, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: Rm=0, Rn=0, Pd=0, size=1, sf=0
    let encoding: u32 = 0x25600C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_whilelo_p_p_rr_combo_2_c00_25a00c00() {
    // Encoding: 0x25A00C00
    // Test WHILELO_P.P.RR__ field combination: size=2, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: Rm=0, Pd=0, sf=0, size=2, Rn=0
    let encoding: u32 = 0x25A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_whilelo_p_p_rr_combo_3_c00_25e00c00() {
    // Encoding: 0x25E00C00
    // Test WHILELO_P.P.RR__ field combination: size=3, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: Pd=0, Rn=0, Rm=0, size=3, sf=0
    let encoding: u32 = 0x25E00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_whilelo_p_p_rr_combo_4_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: sf=0, Rm=0, Pd=0, Rn=0, size=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_whilelo_p_p_rr_combo_5_c00_25210c00() {
    // Encoding: 0x25210C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=1, sf=0, Rn=0, Pd=0
    // Fields: Rm=1, sf=0, size=0, Rn=0, Pd=0
    let encoding: u32 = 0x25210C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_whilelo_p_p_rr_combo_6_c00_253e0c00() {
    // Encoding: 0x253E0C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=30, sf=0, Rn=0, Pd=0
    // Fields: Rn=0, size=0, Pd=0, Rm=30, sf=0
    let encoding: u32 = 0x253E0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_whilelo_p_p_rr_combo_7_c00_253f0c00() {
    // Encoding: 0x253F0C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=31, sf=0, Rn=0, Pd=0
    // Fields: Rm=31, size=0, sf=0, Pd=0, Rn=0
    let encoding: u32 = 0x253F0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sf=0 (8-bit / byte size)
#[test]
fn test_whilelo_p_p_rr_combo_8_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: size=0, Rn=0, Rm=0, sf=0, Pd=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sf=1 (16-bit / halfword size)
#[test]
fn test_whilelo_p_p_rr_combo_9_c00_25201c00() {
    // Encoding: 0x25201C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=1, Rn=0, Pd=0
    // Fields: size=0, sf=1, Rn=0, Rm=0, Pd=0
    let encoding: u32 = 0x25201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_whilelo_p_p_rr_combo_10_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: Pd=0, Rm=0, size=0, sf=0, Rn=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_whilelo_p_p_rr_combo_11_c00_25200c20() {
    // Encoding: 0x25200C20
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=1, Pd=0
    // Fields: Pd=0, Rm=0, size=0, Rn=1, sf=0
    let encoding: u32 = 0x25200C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_whilelo_p_p_rr_combo_12_c00_25200fc0() {
    // Encoding: 0x25200FC0
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=30, Pd=0
    // Fields: size=0, Rm=0, sf=0, Rn=30, Pd=0
    let encoding: u32 = 0x25200FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_whilelo_p_p_rr_combo_13_c00_25200fe0() {
    // Encoding: 0x25200FE0
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=31, Pd=0
    // Fields: size=0, Rm=0, sf=0, Rn=31, Pd=0
    let encoding: u32 = 0x25200FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pd=0 (register index 0 (first register))
#[test]
fn test_whilelo_p_p_rr_combo_14_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=0, Pd=0
    // Fields: Rm=0, size=0, Rn=0, sf=0, Pd=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pd=1 (register index 1 (second register))
#[test]
fn test_whilelo_p_p_rr_combo_15_c00_25200c01() {
    // Encoding: 0x25200C01
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=0, sf=0, Rn=0, Pd=1
    // Fields: Rn=0, size=0, Rm=0, sf=0, Pd=1
    let encoding: u32 = 0x25200C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_whilelo_p_p_rr_combo_16_c00_25210c20() {
    // Encoding: 0x25210C20
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=1, sf=0, Rn=1, Pd=0
    // Fields: Rn=1, size=0, Rm=1, sf=0, Pd=0
    let encoding: u32 = 0x25210C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_whilelo_p_p_rr_combo_17_c00_253f0fe0() {
    // Encoding: 0x253F0FE0
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=31, sf=0, Rn=31, Pd=0
    // Fields: Rn=31, Rm=31, sf=0, Pd=0, size=0
    let encoding: u32 = 0x253F0FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pd=1 (same register test (reg=1))
#[test]
fn test_whilelo_p_p_rr_combo_18_c00_25210c01() {
    // Encoding: 0x25210C01
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=1, sf=0, Rn=0, Pd=1
    // Fields: sf=0, Rn=0, Rm=1, Pd=1, size=0
    let encoding: u32 = 0x25210C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pd=31 (same register test (reg=31))
#[test]
fn test_whilelo_p_p_rr_combo_19_c00_253f0c0f() {
    // Encoding: 0x253F0C0F
    // Test WHILELO_P.P.RR__ field combination: size=0, Rm=31, sf=0, Rn=0, Pd=31
    // Fields: size=0, Rm=31, Rn=0, Pd=31, sf=0
    let encoding: u32 = 0x253F0C0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_whilelo_p_p_rr_special_size_0_size_variant_0_3072_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ special value size = 0 (Size variant 0)
    // Fields: Rn=0, Rm=0, Pd=0, size=0, sf=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_whilelo_p_p_rr_special_size_1_size_variant_1_3072_25600c00() {
    // Encoding: 0x25600C00
    // Test WHILELO_P.P.RR__ special value size = 1 (Size variant 1)
    // Fields: Pd=0, size=1, Rn=0, Rm=0, sf=0
    let encoding: u32 = 0x25600C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_whilelo_p_p_rr_special_size_2_size_variant_2_3072_25a00c00() {
    // Encoding: 0x25A00C00
    // Test WHILELO_P.P.RR__ special value size = 2 (Size variant 2)
    // Fields: sf=0, Rm=0, Rn=0, Pd=0, size=2
    let encoding: u32 = 0x25A00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_whilelo_p_p_rr_special_size_3_size_variant_3_3072_25e00c00() {
    // Encoding: 0x25E00C00
    // Test WHILELO_P.P.RR__ special value size = 3 (Size variant 3)
    // Fields: Pd=0, Rm=0, sf=0, Rn=0, size=3
    let encoding: u32 = 0x25E00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field sf = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sf", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_whilelo_p_p_rr_special_sf_0_size_variant_0_3072_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ special value sf = 0 (Size variant 0)
    // Fields: size=0, Rn=0, Pd=0, sf=0, Rm=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field sf = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sf", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_whilelo_p_p_rr_special_sf_1_size_variant_1_3072_25201c00() {
    // Encoding: 0x25201C00
    // Test WHILELO_P.P.RR__ special value sf = 1 (Size variant 1)
    // Fields: Rn=0, sf=1, size=0, Rm=0, Pd=0
    let encoding: u32 = 0x25201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_whilelo_p_p_rr_special_rn_31_stack_pointer_sp_may_require_alignment_3072_25200fe0() {
    // Encoding: 0x25200FE0
    // Test WHILELO_P.P.RR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pd=0, Rm=0, sf=0, size=0, Rn=31
    let encoding: u32 = 0x25200FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_whilelo_p_p_rr_invalid_0_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, sf=0, Rm=0, size=0, Pd=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_whilelo_p_p_rr_invalid_1_c00_25200c00() {
    // Encoding: 0x25200C00
    // Test WHILELO_P.P.RR__ invalid encoding: Unconditional UNDEFINED
    // Fields: sf=0, Pd=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0x25200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_whilelo_p_p_rr_reg_write_0_25200c00() {
    // Test WHILELO_P.P.RR__ register write: SimdFromField("Pd")
    // Encoding: 0x25200C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25200C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_whilelo_p_p_rr_sp_rn_25200fe0() {
    // Test WHILELO_P.P.RR__ with Rn = SP (31)
    // Encoding: 0x25200FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25200FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 0 + 0 = 0 (Z=1)
#[test]
fn test_whilelo_p_p_rr_flags_zeroresult_0_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: ZeroResult
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x0);
    set_x(&mut cpu, 1, 0x0);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: ZeroResult }
/// 1 + (-1) = 0 (Z=1, C=1)
#[test]
fn test_whilelo_p_p_rr_flags_zeroresult_1_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: ZeroResult
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x1);
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: NegativeResult }
/// negative value (N=1)
#[test]
fn test_whilelo_p_p_rr_flags_negativeresult_2_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: NegativeResult
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x8000000000000000);
    set_x(&mut cpu, 2, 0x0);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 1 = 0 (C=1, Z=1)
#[test]
fn test_whilelo_p_p_rr_flags_unsignedoverflow_3_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: UnsignedOverflow
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, true, "Z should be true");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: UnsignedOverflow }
/// max + 2 = 1 (C=1)
#[test]
fn test_whilelo_p_p_rr_flags_unsignedoverflow_4_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: UnsignedOverflow
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x2);
    set_x(&mut cpu, 1, 0xFFFFFFFFFFFFFFFF);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// max_signed + 1 = min_signed (V=1, N=1)
#[test]
fn test_whilelo_p_p_rr_flags_signedoverflow_5_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: SignedOverflow
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x7FFFFFFFFFFFFFFF);
    set_x(&mut cpu, 2, 0x1);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, true, "N should be true");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: SignedOverflow }
/// min_signed + (-1) = max_signed (V=1)
#[test]
fn test_whilelo_p_p_rr_flags_signedoverflow_6_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: SignedOverflow
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0xFFFFFFFFFFFFFFFF);
    set_x(&mut cpu, 1, 0x8000000000000000);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, true, "C should be true");
    assert_eq!(cpu.get_pstate().v, true, "V should be true");
}

/// Provenance: WHILELO_P.P.RR__
/// ASL: `if setflags then PSTATE.<N,Z,C,V> = nzcv`
/// Requirement: FlagComputation { flag: N, scenario: PositiveResult }
/// 100 + 50 = 150 (no flags)
#[test]
fn test_whilelo_p_p_rr_flags_positiveresult_7_25220c20() {
    // Test WHILELO_P.P.RR__ flag computation: PositiveResult
    // Encoding: 0x25220C20
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 2, 0x32);
    set_x(&mut cpu, 1, 0x64);
    let encoding: u32 = 0x25220C20;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(cpu.get_pstate().n, false, "N should be false");
    assert_eq!(cpu.get_pstate().z, false, "Z should be false");
    assert_eq!(cpu.get_pstate().c, false, "C should be false");
    assert_eq!(cpu.get_pstate().v, false, "V should be false");
}

// ============================================================================
// LSR_Z.P.ZI__ Tests
// ============================================================================

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zi_field_tszh_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field tszh = 0 (Min)
    // Fields: tszh=0, Zdn=0, imm3=0, Pg=0, tszl=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zi_field_tszh_1_poweroftwo_8000_04418000() {
    // Encoding: 0x04418000
    // Test LSR_Z.P.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: imm3=0, tszl=0, Pg=0, tszh=1, Zdn=0
    let encoding: u32 = 0x04418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsr_z_p_zi_field_tszh_3_max_8000_04c18000() {
    // Encoding: 0x04C18000
    // Test LSR_Z.P.ZI__ field tszh = 3 (Max)
    // Fields: Zdn=0, imm3=0, tszh=3, Pg=0, tszl=0
    let encoding: u32 = 0x04C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsr_z_p_zi_field_pg_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, tszl=0, tszh=0, imm3=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsr_z_p_zi_field_pg_1_poweroftwo_8000_04018400() {
    // Encoding: 0x04018400
    // Test LSR_Z.P.ZI__ field Pg = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, Zdn=0, Pg=1, imm3=0
    let encoding: u32 = 0x04018400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zi_field_tszl_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field tszl = 0 (Min)
    // Fields: Pg=0, imm3=0, tszl=0, Zdn=0, tszh=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zi_field_tszl_1_poweroftwo_8000_04018100() {
    // Encoding: 0x04018100
    // Test LSR_Z.P.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: tszh=0, Zdn=0, imm3=0, tszl=1, Pg=0
    let encoding: u32 = 0x04018100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsr_z_p_zi_field_tszl_3_max_8000_04018300() {
    // Encoding: 0x04018300
    // Test LSR_Z.P.ZI__ field tszl = 3 (Max)
    // Fields: tszh=0, tszl=3, Pg=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04018300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsr_z_p_zi_field_imm3_0_zero_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field imm3 = 0 (Zero)
    // Fields: tszl=0, tszh=0, Pg=0, Zdn=0, imm3=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsr_z_p_zi_field_imm3_1_poweroftwo_8000_04018020() {
    // Encoding: 0x04018020
    // Test LSR_Z.P.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, Pg=0, imm3=1, Zdn=0
    let encoding: u32 = 0x04018020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsr_z_p_zi_field_imm3_3_poweroftwominusone_8000_04018060() {
    // Encoding: 0x04018060
    // Test LSR_Z.P.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Zdn=0, tszh=0, Pg=0, imm3=3
    let encoding: u32 = 0x04018060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsr_z_p_zi_field_imm3_7_max_8000_040180e0() {
    // Encoding: 0x040180E0
    // Test LSR_Z.P.ZI__ field imm3 = 7 (Max)
    // Fields: tszl=0, imm3=7, Pg=0, Zdn=0, tszh=0
    let encoding: u32 = 0x040180E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zi_field_zdn_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field Zdn = 0 (Min)
    // Fields: tszl=0, imm3=0, tszh=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zi_field_zdn_1_poweroftwo_8000_04018001() {
    // Encoding: 0x04018001
    // Test LSR_Z.P.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: tszh=0, imm3=0, tszl=0, Pg=0, Zdn=1
    let encoding: u32 = 0x04018001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsr_z_p_zi_field_zdn_15_poweroftwominusone_8000_0401800f() {
    // Encoding: 0x0401800F
    // Test LSR_Z.P.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, tszl=0, tszh=0, imm3=0, Pg=0
    let encoding: u32 = 0x0401800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsr_z_p_zi_field_zdn_31_max_8000_0401801f() {
    // Encoding: 0x0401801F
    // Test LSR_Z.P.ZI__ field Zdn = 31 (Max)
    // Fields: imm3=0, tszh=0, Zdn=31, Pg=0, tszl=0
    let encoding: u32 = 0x0401801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsr_z_p_zi_combo_0_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=0, imm3=0, Zdn=0, tszl=0, Pg=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=1 (value 1)
#[test]
fn test_lsr_z_p_zi_combo_1_8000_04418000() {
    // Encoding: 0x04418000
    // Test LSR_Z.P.ZI__ field combination: tszh=1, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Pg=0, imm3=0, Zdn=0, tszh=1, tszl=0
    let encoding: u32 = 0x04418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=3 (maximum value (3))
#[test]
fn test_lsr_z_p_zi_combo_2_8000_04c18000() {
    // Encoding: 0x04C18000
    // Test LSR_Z.P.ZI__ field combination: tszh=3, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Zdn=0, tszh=3, imm3=0, Pg=0, tszl=0
    let encoding: u32 = 0x04C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_lsr_z_p_zi_combo_3_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Pg=0, imm3=0, tszh=0, tszl=0, Zdn=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_lsr_z_p_zi_combo_4_8000_04018400() {
    // Encoding: 0x04018400
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=1, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=0, tszl=0, imm3=0, Pg=1, Zdn=0
    let encoding: u32 = 0x04018400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=0 (minimum value)
#[test]
fn test_lsr_z_p_zi_combo_5_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=0, tszl=0, Pg=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=1 (value 1)
#[test]
fn test_lsr_z_p_zi_combo_6_8000_04018100() {
    // Encoding: 0x04018100
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=1, imm3=0, Zdn=0
    // Fields: tszh=0, Pg=0, tszl=1, Zdn=0, imm3=0
    let encoding: u32 = 0x04018100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=3 (maximum value (3))
#[test]
fn test_lsr_z_p_zi_combo_7_8000_04018300() {
    // Encoding: 0x04018300
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=3, imm3=0, Zdn=0
    // Fields: Zdn=0, tszh=0, imm3=0, tszl=3, Pg=0
    let encoding: u32 = 0x04018300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_lsr_z_p_zi_combo_8_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: imm3=0, tszh=0, Zdn=0, tszl=0, Pg=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_lsr_z_p_zi_combo_9_8000_04018020() {
    // Encoding: 0x04018020
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=1, Zdn=0
    // Fields: tszl=0, Zdn=0, tszh=0, Pg=0, imm3=1
    let encoding: u32 = 0x04018020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_lsr_z_p_zi_combo_10_8000_04018060() {
    // Encoding: 0x04018060
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=3, Zdn=0
    // Fields: Pg=0, tszh=0, Zdn=0, tszl=0, imm3=3
    let encoding: u32 = 0x04018060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_lsr_z_p_zi_combo_11_8000_040180e0() {
    // Encoding: 0x040180E0
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=7, Zdn=0
    // Fields: tszl=0, Pg=0, tszh=0, Zdn=0, imm3=7
    let encoding: u32 = 0x040180E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_lsr_z_p_zi_combo_12_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Pg=0, tszl=0, imm3=0, tszh=0, Zdn=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_lsr_z_p_zi_combo_13_8000_04018001() {
    // Encoding: 0x04018001
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=1
    // Fields: tszh=0, tszl=0, imm3=0, Zdn=1, Pg=0
    let encoding: u32 = 0x04018001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_lsr_z_p_zi_combo_14_8000_0401800f() {
    // Encoding: 0x0401800F
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=15
    // Fields: Pg=0, imm3=0, tszh=0, tszl=0, Zdn=15
    let encoding: u32 = 0x0401800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_lsr_z_p_zi_combo_15_8000_0401801f() {
    // Encoding: 0x0401801F
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=31
    // Fields: Pg=0, tszh=0, tszl=0, imm3=0, Zdn=31
    let encoding: u32 = 0x0401801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zi_invalid_0_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zi_invalid_1_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszh=0, Zdn=0, Pg=0, tszl=0, imm3=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zi_invalid_2_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszh=0, tszl=0, Pg=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsr_z_p_zi_reg_write_0_04018000() {
    // Test LSR_Z.P.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x04018000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04018000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSLR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lslr_z_p_zz_field_size_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lslr_z_p_zz_field_size_1_poweroftwo_8000_04578000() {
    // Encoding: 0x04578000
    // Test LSLR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04578000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lslr_z_p_zz_field_size_2_poweroftwo_8000_04978000() {
    // Encoding: 0x04978000
    // Test LSLR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, Pg=0, size=2
    let encoding: u32 = 0x04978000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lslr_z_p_zz_field_size_3_max_8000_04d78000() {
    // Encoding: 0x04D78000
    // Test LSLR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x04D78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lslr_z_p_zz_field_pg_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lslr_z_p_zz_field_pg_1_poweroftwo_8000_04178400() {
    // Encoding: 0x04178400
    // Test LSLR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, Pg=1, size=0
    let encoding: u32 = 0x04178400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lslr_z_p_zz_field_zm_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lslr_z_p_zz_field_zm_1_poweroftwo_8000_04178020() {
    // Encoding: 0x04178020
    // Test LSLR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, size=0, Pg=0
    let encoding: u32 = 0x04178020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lslr_z_p_zz_field_zm_30_poweroftwominusone_8000_041783c0() {
    // Encoding: 0x041783C0
    // Test LSLR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, Zm=30, Pg=0
    let encoding: u32 = 0x041783C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lslr_z_p_zz_field_zm_31_max_8000_041783e0() {
    // Encoding: 0x041783E0
    // Test LSLR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zdn=0, Pg=0
    let encoding: u32 = 0x041783E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lslr_z_p_zz_field_zdn_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lslr_z_p_zz_field_zdn_1_poweroftwo_8000_04178001() {
    // Encoding: 0x04178001
    // Test LSLR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=1, size=0, Pg=0
    let encoding: u32 = 0x04178001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lslr_z_p_zz_field_zdn_15_poweroftwominusone_8000_0417800f() {
    // Encoding: 0x0417800F
    // Test LSLR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x0417800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lslr_z_p_zz_field_zdn_31_max_8000_0417801f() {
    // Encoding: 0x0417801F
    // Test LSLR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x0417801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lslr_z_p_zz_combo_0_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_lslr_z_p_zz_combo_1_8000_04578000() {
    // Encoding: 0x04578000
    // Test LSLR_Z.P.ZZ__ field combination: size=1, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x04578000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_lslr_z_p_zz_combo_2_8000_04978000() {
    // Encoding: 0x04978000
    // Test LSLR_Z.P.ZZ__ field combination: size=2, Pg=0, Zm=0, Zdn=0
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04978000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_lslr_z_p_zz_combo_3_8000_04d78000() {
    // Encoding: 0x04D78000
    // Test LSLR_Z.P.ZZ__ field combination: size=3, Pg=0, Zm=0, Zdn=0
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04D78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_lslr_z_p_zz_combo_4_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_lslr_z_p_zz_combo_5_8000_04178400() {
    // Encoding: 0x04178400
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=1, Zm=0, Zdn=0
    // Fields: Pg=1, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04178400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_lslr_z_p_zz_combo_6_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_lslr_z_p_zz_combo_7_8000_04178020() {
    // Encoding: 0x04178020
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=1, Zdn=0
    // Fields: size=0, Zdn=0, Zm=1, Pg=0
    let encoding: u32 = 0x04178020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_lslr_z_p_zz_combo_8_8000_041783c0() {
    // Encoding: 0x041783C0
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=30, Zdn=0
    // Fields: Zm=30, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x041783C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_lslr_z_p_zz_combo_9_8000_041783e0() {
    // Encoding: 0x041783E0
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=31, Zdn=0
    // Fields: Pg=0, Zm=31, Zdn=0, size=0
    let encoding: u32 = 0x041783E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_lslr_z_p_zz_combo_10_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_lslr_z_p_zz_combo_11_8000_04178001() {
    // Encoding: 0x04178001
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=1
    // Fields: Zm=0, Pg=0, Zdn=1, size=0
    let encoding: u32 = 0x04178001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_lslr_z_p_zz_combo_12_8000_0417800f() {
    // Encoding: 0x0417800F
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=15
    // Fields: Pg=0, Zm=0, size=0, Zdn=15
    let encoding: u32 = 0x0417800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_lslr_z_p_zz_combo_13_8000_0417801f() {
    // Encoding: 0x0417801F
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=31
    // Fields: size=0, Zm=0, Pg=0, Zdn=31
    let encoding: u32 = 0x0417801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lslr_z_p_zz_special_size_0_size_variant_0_32768_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lslr_z_p_zz_special_size_1_size_variant_1_32768_04578000() {
    // Encoding: 0x04578000
    // Test LSLR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x04578000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lslr_z_p_zz_special_size_2_size_variant_2_32768_04978000() {
    // Encoding: 0x04978000
    // Test LSLR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zm=0, Zdn=0
    let encoding: u32 = 0x04978000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lslr_z_p_zz_special_size_3_size_variant_3_32768_04d78000() {
    // Encoding: 0x04D78000
    // Test LSLR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x04D78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lslr_z_p_zz_invalid_0_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lslr_z_p_zz_invalid_1_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lslr_z_p_zz_reg_write_0_04178000() {
    // Test LSLR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04178000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04178000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INCD_Z.ZS__ Tests
// ============================================================================

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incd_z_zs_field_imm4_0_zero_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incd_z_zs_field_imm4_1_poweroftwo_c000_04f1c000() {
    // Encoding: 0x04F1C000
    // Test INCD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04F1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incd_z_zs_field_imm4_3_poweroftwominusone_c000_04f3c000() {
    // Encoding: 0x04F3C000
    // Test INCD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x04F3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incd_z_zs_field_imm4_4_poweroftwo_c000_04f4c000() {
    // Encoding: 0x04F4C000
    // Test INCD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Zdn=0
    let encoding: u32 = 0x04F4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incd_z_zs_field_imm4_7_poweroftwominusone_c000_04f7c000() {
    // Encoding: 0x04F7C000
    // Test INCD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x04F7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incd_z_zs_field_imm4_8_poweroftwo_c000_04f8c000() {
    // Encoding: 0x04F8C000
    // Test INCD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04F8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incd_z_zs_field_imm4_15_max_c000_04ffc000() {
    // Encoding: 0x04FFC000
    // Test INCD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, Zdn=0, imm4=15
    let encoding: u32 = 0x04FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incd_z_zs_field_pattern_0_min_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incd_z_zs_field_pattern_1_poweroftwo_c000_04f0c020() {
    // Encoding: 0x04F0C020
    // Test INCD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04F0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incd_z_zs_field_pattern_15_poweroftwominusone_c000_04f0c1e0() {
    // Encoding: 0x04F0C1E0
    // Test INCD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x04F0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incd_z_zs_field_pattern_31_max_c000_04f0c3e0() {
    // Encoding: 0x04F0C3E0
    // Test INCD_Z.ZS__ field pattern = 31 (Max)
    // Fields: Zdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x04F0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incd_z_zs_field_zdn_0_min_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incd_z_zs_field_zdn_1_poweroftwo_c000_04f0c001() {
    // Encoding: 0x04F0C001
    // Test INCD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=1, imm4=0
    let encoding: u32 = 0x04F0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incd_z_zs_field_zdn_15_poweroftwominusone_c000_04f0c00f() {
    // Encoding: 0x04F0C00F
    // Test INCD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=15, pattern=0
    let encoding: u32 = 0x04F0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incd_z_zs_field_zdn_31_max_c000_04f0c01f() {
    // Encoding: 0x04F0C01F
    // Test INCD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x04F0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incd_z_zs_combo_0_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_incd_z_zs_combo_1_c000_04f1c000() {
    // Encoding: 0x04F1C000
    // Test INCD_Z.ZS__ field combination: imm4=1, pattern=0, Zdn=0
    // Fields: Zdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04F1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_incd_z_zs_combo_2_c000_04f3c000() {
    // Encoding: 0x04F3C000
    // Test INCD_Z.ZS__ field combination: imm4=3, pattern=0, Zdn=0
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x04F3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_incd_z_zs_combo_3_c000_04f4c000() {
    // Encoding: 0x04F4C000
    // Test INCD_Z.ZS__ field combination: imm4=4, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x04F4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_incd_z_zs_combo_4_c000_04f7c000() {
    // Encoding: 0x04F7C000
    // Test INCD_Z.ZS__ field combination: imm4=7, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x04F7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_incd_z_zs_combo_5_c000_04f8c000() {
    // Encoding: 0x04F8C000
    // Test INCD_Z.ZS__ field combination: imm4=8, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=8
    let encoding: u32 = 0x04F8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_incd_z_zs_combo_6_c000_04ffc000() {
    // Encoding: 0x04FFC000
    // Test INCD_Z.ZS__ field combination: imm4=15, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=15, Zdn=0
    let encoding: u32 = 0x04FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_incd_z_zs_combo_7_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_incd_z_zs_combo_8_c000_04f0c020() {
    // Encoding: 0x04F0C020
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=1, Zdn=0
    // Fields: pattern=1, imm4=0, Zdn=0
    let encoding: u32 = 0x04F0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_incd_z_zs_combo_9_c000_04f0c1e0() {
    // Encoding: 0x04F0C1E0
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=15, Zdn=0
    // Fields: Zdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x04F0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_incd_z_zs_combo_10_c000_04f0c3e0() {
    // Encoding: 0x04F0C3E0
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=31, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=31
    let encoding: u32 = 0x04F0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_incd_z_zs_combo_11_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_incd_z_zs_combo_12_c000_04f0c001() {
    // Encoding: 0x04F0C001
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=1
    // Fields: imm4=0, Zdn=1, pattern=0
    let encoding: u32 = 0x04F0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_incd_z_zs_combo_13_c000_04f0c00f() {
    // Encoding: 0x04F0C00F
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=15
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04F0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_incd_z_zs_combo_14_c000_04f0c01f() {
    // Encoding: 0x04F0C01F
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=31
    // Fields: imm4=0, Zdn=31, pattern=0
    let encoding: u32 = 0x04F0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incd_z_zs_invalid_0_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incd_z_zs_invalid_1_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_inch_z_zs_field_imm4_0_zero_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_inch_z_zs_field_imm4_1_poweroftwo_c000_0471c000() {
    // Encoding: 0x0471C000
    // Test INCH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Zdn=0
    let encoding: u32 = 0x0471C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_inch_z_zs_field_imm4_3_poweroftwominusone_c000_0473c000() {
    // Encoding: 0x0473C000
    // Test INCH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x0473C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_inch_z_zs_field_imm4_4_poweroftwo_c000_0474c000() {
    // Encoding: 0x0474C000
    // Test INCH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x0474C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_inch_z_zs_field_imm4_7_poweroftwominusone_c000_0477c000() {
    // Encoding: 0x0477C000
    // Test INCH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x0477C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_inch_z_zs_field_imm4_8_poweroftwo_c000_0478c000() {
    // Encoding: 0x0478C000
    // Test INCH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zdn=0, pattern=0
    let encoding: u32 = 0x0478C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_inch_z_zs_field_imm4_15_max_c000_047fc000() {
    // Encoding: 0x047FC000
    // Test INCH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Zdn=0
    let encoding: u32 = 0x047FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_inch_z_zs_field_pattern_0_min_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_inch_z_zs_field_pattern_1_poweroftwo_c000_0470c020() {
    // Encoding: 0x0470C020
    // Test INCH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x0470C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_inch_z_zs_field_pattern_15_poweroftwominusone_c000_0470c1e0() {
    // Encoding: 0x0470C1E0
    // Test INCH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Zdn=0, imm4=0
    let encoding: u32 = 0x0470C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_inch_z_zs_field_pattern_31_max_c000_0470c3e0() {
    // Encoding: 0x0470C3E0
    // Test INCH_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, Zdn=0, imm4=0
    let encoding: u32 = 0x0470C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_inch_z_zs_field_zdn_0_min_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_inch_z_zs_field_zdn_1_poweroftwo_c000_0470c001() {
    // Encoding: 0x0470C001
    // Test INCH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x0470C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_inch_z_zs_field_zdn_15_poweroftwominusone_c000_0470c00f() {
    // Encoding: 0x0470C00F
    // Test INCH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x0470C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_inch_z_zs_field_zdn_31_max_c000_0470c01f() {
    // Encoding: 0x0470C01F
    // Test INCH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x0470C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_inch_z_zs_combo_0_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_inch_z_zs_combo_1_c000_0471c000() {
    // Encoding: 0x0471C000
    // Test INCH_Z.ZS__ field combination: imm4=1, pattern=0, Zdn=0
    // Fields: imm4=1, pattern=0, Zdn=0
    let encoding: u32 = 0x0471C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_inch_z_zs_combo_2_c000_0473c000() {
    // Encoding: 0x0473C000
    // Test INCH_Z.ZS__ field combination: imm4=3, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=3, Zdn=0
    let encoding: u32 = 0x0473C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_inch_z_zs_combo_3_c000_0474c000() {
    // Encoding: 0x0474C000
    // Test INCH_Z.ZS__ field combination: imm4=4, pattern=0, Zdn=0
    // Fields: imm4=4, Zdn=0, pattern=0
    let encoding: u32 = 0x0474C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_inch_z_zs_combo_4_c000_0477c000() {
    // Encoding: 0x0477C000
    // Test INCH_Z.ZS__ field combination: imm4=7, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x0477C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_inch_z_zs_combo_5_c000_0478c000() {
    // Encoding: 0x0478C000
    // Test INCH_Z.ZS__ field combination: imm4=8, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=8
    let encoding: u32 = 0x0478C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_inch_z_zs_combo_6_c000_047fc000() {
    // Encoding: 0x047FC000
    // Test INCH_Z.ZS__ field combination: imm4=15, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=15
    let encoding: u32 = 0x047FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_inch_z_zs_combo_7_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_inch_z_zs_combo_8_c000_0470c020() {
    // Encoding: 0x0470C020
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=1, Zdn=0
    // Fields: Zdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x0470C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_inch_z_zs_combo_9_c000_0470c1e0() {
    // Encoding: 0x0470C1E0
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=15, Zdn=0
    // Fields: Zdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0470C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_inch_z_zs_combo_10_c000_0470c3e0() {
    // Encoding: 0x0470C3E0
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=31, Zdn=0
    // Fields: Zdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x0470C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_inch_z_zs_combo_11_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_inch_z_zs_combo_12_c000_0470c001() {
    // Encoding: 0x0470C001
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=1
    // Fields: Zdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x0470C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_inch_z_zs_combo_13_c000_0470c00f() {
    // Encoding: 0x0470C00F
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=15
    // Fields: Zdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x0470C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_inch_z_zs_combo_14_c000_0470c01f() {
    // Encoding: 0x0470C01F
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=31
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x0470C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_inch_z_zs_invalid_0_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INCH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_inch_z_zs_invalid_1_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incw_z_zs_field_imm4_0_zero_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incw_z_zs_field_imm4_1_poweroftwo_c000_04b1c000() {
    // Encoding: 0x04B1C000
    // Test INCW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Zdn=0
    let encoding: u32 = 0x04B1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incw_z_zs_field_imm4_3_poweroftwominusone_c000_04b3c000() {
    // Encoding: 0x04B3C000
    // Test INCW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x04B3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incw_z_zs_field_imm4_4_poweroftwo_c000_04b4c000() {
    // Encoding: 0x04B4C000
    // Test INCW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Zdn=0
    let encoding: u32 = 0x04B4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incw_z_zs_field_imm4_7_poweroftwominusone_c000_04b7c000() {
    // Encoding: 0x04B7C000
    // Test INCW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x04B7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incw_z_zs_field_imm4_8_poweroftwo_c000_04b8c000() {
    // Encoding: 0x04B8C000
    // Test INCW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=8
    let encoding: u32 = 0x04B8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incw_z_zs_field_imm4_15_max_c000_04bfc000() {
    // Encoding: 0x04BFC000
    // Test INCW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Zdn=0
    let encoding: u32 = 0x04BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incw_z_zs_field_pattern_0_min_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incw_z_zs_field_pattern_1_poweroftwo_c000_04b0c020() {
    // Encoding: 0x04B0C020
    // Test INCW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, Zdn=0, pattern=1
    let encoding: u32 = 0x04B0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incw_z_zs_field_pattern_15_poweroftwominusone_c000_04b0c1e0() {
    // Encoding: 0x04B0C1E0
    // Test INCW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incw_z_zs_field_pattern_31_max_c000_04b0c3e0() {
    // Encoding: 0x04B0C3E0
    // Test INCW_Z.ZS__ field pattern = 31 (Max)
    // Fields: Zdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x04B0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incw_z_zs_field_zdn_0_min_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incw_z_zs_field_zdn_1_poweroftwo_c000_04b0c001() {
    // Encoding: 0x04B0C001
    // Test INCW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x04B0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incw_z_zs_field_zdn_15_poweroftwominusone_c000_04b0c00f() {
    // Encoding: 0x04B0C00F
    // Test INCW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04B0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incw_z_zs_field_zdn_31_max_c000_04b0c01f() {
    // Encoding: 0x04B0C01F
    // Test INCW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Zdn=31
    let encoding: u32 = 0x04B0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incw_z_zs_combo_0_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_incw_z_zs_combo_1_c000_04b1c000() {
    // Encoding: 0x04B1C000
    // Test INCW_Z.ZS__ field combination: imm4=1, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04B1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_incw_z_zs_combo_2_c000_04b3c000() {
    // Encoding: 0x04B3C000
    // Test INCW_Z.ZS__ field combination: imm4=3, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04B3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_incw_z_zs_combo_3_c000_04b4c000() {
    // Encoding: 0x04B4C000
    // Test INCW_Z.ZS__ field combination: imm4=4, pattern=0, Zdn=0
    // Fields: imm4=4, pattern=0, Zdn=0
    let encoding: u32 = 0x04B4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_incw_z_zs_combo_4_c000_04b7c000() {
    // Encoding: 0x04B7C000
    // Test INCW_Z.ZS__ field combination: imm4=7, pattern=0, Zdn=0
    // Fields: Zdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04B7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_incw_z_zs_combo_5_c000_04b8c000() {
    // Encoding: 0x04B8C000
    // Test INCW_Z.ZS__ field combination: imm4=8, pattern=0, Zdn=0
    // Fields: Zdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04B8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_incw_z_zs_combo_6_c000_04bfc000() {
    // Encoding: 0x04BFC000
    // Test INCW_Z.ZS__ field combination: imm4=15, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=15, Zdn=0
    let encoding: u32 = 0x04BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_incw_z_zs_combo_7_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_incw_z_zs_combo_8_c000_04b0c020() {
    // Encoding: 0x04B0C020
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=1, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=1
    let encoding: u32 = 0x04B0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_incw_z_zs_combo_9_c000_04b0c1e0() {
    // Encoding: 0x04B0C1E0
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=15, Zdn=0
    // Fields: pattern=15, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_incw_z_zs_combo_10_c000_04b0c3e0() {
    // Encoding: 0x04B0C3E0
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=31, Zdn=0
    // Fields: pattern=31, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_incw_z_zs_combo_11_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_incw_z_zs_combo_12_c000_04b0c001() {
    // Encoding: 0x04B0C001
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=1
    // Fields: pattern=0, Zdn=1, imm4=0
    let encoding: u32 = 0x04B0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_incw_z_zs_combo_13_c000_04b0c00f() {
    // Encoding: 0x04B0C00F
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=15
    // Fields: imm4=0, Zdn=15, pattern=0
    let encoding: u32 = 0x04B0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_incw_z_zs_combo_14_c000_04b0c01f() {
    // Encoding: 0x04B0C01F
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=31
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x04B0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incw_z_zs_invalid_0_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INCW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incw_z_zs_invalid_1_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INCD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_incd_z_zs_reg_write_0_04f0c000() {
    // Test INCD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04F0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_inch_z_zs_reg_write_0_0470c000() {
    // Test INCH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0470C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_incw_z_zs_reg_write_0_04b0c000() {
    // Test INCW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04B0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DECP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_decp_z_p_z_field_size_0_min_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_decp_z_p_z_field_size_1_poweroftwo_8000_256d8000() {
    // Encoding: 0x256D8000
    // Test DECP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_decp_z_p_z_field_size_2_poweroftwo_8000_25ad8000() {
    // Encoding: 0x25AD8000
    // Test DECP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_decp_z_p_z_field_size_3_max_8000_25ed8000() {
    // Encoding: 0x25ED8000
    // Test DECP_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x25ED8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_decp_z_p_z_field_pg_0_min_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_decp_z_p_z_field_pg_1_poweroftwo_8000_252d8020() {
    // Encoding: 0x252D8020
    // Test DECP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=1
    let encoding: u32 = 0x252D8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decp_z_p_z_field_zdn_0_min_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decp_z_p_z_field_zdn_1_poweroftwo_8000_252d8001() {
    // Encoding: 0x252D8001
    // Test DECP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, Pg=0
    let encoding: u32 = 0x252D8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decp_z_p_z_field_zdn_15_poweroftwominusone_8000_252d800f() {
    // Encoding: 0x252D800F
    // Test DECP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x252D800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decp_z_p_z_field_zdn_31_max_8000_252d801f() {
    // Encoding: 0x252D801F
    // Test DECP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zdn=31, size=0
    let encoding: u32 = 0x252D801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_decp_z_p_z_combo_0_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_decp_z_p_z_combo_1_8000_256d8000() {
    // Encoding: 0x256D8000
    // Test DECP_Z.P.Z__ field combination: size=1, Pg=0, Zdn=0
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_decp_z_p_z_combo_2_8000_25ad8000() {
    // Encoding: 0x25AD8000
    // Test DECP_Z.P.Z__ field combination: size=2, Pg=0, Zdn=0
    // Fields: size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x25AD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_decp_z_p_z_combo_3_8000_25ed8000() {
    // Encoding: 0x25ED8000
    // Test DECP_Z.P.Z__ field combination: size=3, Pg=0, Zdn=0
    // Fields: Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x25ED8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_decp_z_p_z_combo_4_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_decp_z_p_z_combo_5_8000_252d8020() {
    // Encoding: 0x252D8020
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=1, Zdn=0
    // Fields: Zdn=0, Pg=1, size=0
    let encoding: u32 = 0x252D8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_decp_z_p_z_combo_6_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_decp_z_p_z_combo_7_8000_252d8001() {
    // Encoding: 0x252D8001
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=1
    // Fields: size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x252D8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_decp_z_p_z_combo_8_8000_252d800f() {
    // Encoding: 0x252D800F
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=15
    // Fields: Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x252D800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_decp_z_p_z_combo_9_8000_252d801f() {
    // Encoding: 0x252D801F
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=31
    // Fields: Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x252D801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_decp_z_p_z_special_size_0_size_variant_0_32768_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_decp_z_p_z_special_size_1_size_variant_1_32768_256d8000() {
    // Encoding: 0x256D8000
    // Test DECP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Pg=0, size=1
    let encoding: u32 = 0x256D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_decp_z_p_z_special_size_2_size_variant_2_32768_25ad8000() {
    // Encoding: 0x25AD8000
    // Test DECP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x25AD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_decp_z_p_z_special_size_3_size_variant_3_32768_25ed8000() {
    // Encoding: 0x25ED8000
    // Test DECP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x25ED8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_0_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_1_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_2_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_3_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_decp_z_p_z_reg_write_0_252d8000() {
    // Test DECP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x252D8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252D8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD4H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_0_zero_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_a4e1e000() {
    // Encoding: 0xA4E1E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_a4e3e000() {
    // Encoding: 0xA4E3E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_a4e4e000() {
    // Encoding: 0xA4E4E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_a4e7e000() {
    // Encoding: 0xA4E7E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xA4E7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_a4e8e000() {
    // Encoding: 0xA4E8E000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4E8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_imm4_15_max_e000_a4efe000() {
    // Encoding: 0xA4EFE000
    // Test LD4H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4EFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_pg_0_min_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_a4e0e400() {
    // Encoding: 0xA4E0E400
    // Test LD4H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, imm4=0, Rn=0
    let encoding: u32 = 0xA4E0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_0_min_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_a4e0e020() {
    // Encoding: 0xA4E0E020
    // Test LD4H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA4E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_a4e0e3c0() {
    // Encoding: 0xA4E0E3C0
    // Test LD4H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, imm4=0
    let encoding: u32 = 0xA4E0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld4h_z_p_bi_contiguous_field_rn_31_max_e000_a4e0e3e0() {
    // Encoding: 0xA4E0E3E0
    // Test LD4H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xA4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_0_min_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_a4e0e001() {
    // Encoding: 0xA4E0E001
    // Test LD4H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xA4E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_a4e0e01e() {
    // Encoding: 0xA4E0E01E
    // Test LD4H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xA4E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld4h_z_p_bi_contiguous_field_zt_31_max_e000_a4e0e01f() {
    // Encoding: 0xA4E0E01F
    // Test LD4H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, imm4=0
    let encoding: u32 = 0xA4E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_0_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_1_e000_a4e1e000() {
    // Encoding: 0xA4E1E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_2_e000_a4e3e000() {
    // Encoding: 0xA4E3E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=3, Pg=0
    let encoding: u32 = 0xA4E3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_3_e000_a4e4e000() {
    // Encoding: 0xA4E4E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=4, Zt=0
    let encoding: u32 = 0xA4E4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_4_e000_a4e7e000() {
    // Encoding: 0xA4E7E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, imm4=7
    let encoding: u32 = 0xA4E7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_5_e000_a4e8e000() {
    // Encoding: 0xA4E8E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, imm4=8
    let encoding: u32 = 0xA4E8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_6_e000_a4efe000() {
    // Encoding: 0xA4EFE000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=15, Pg=0, Rn=0
    let encoding: u32 = 0xA4EFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_7_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_8_e000_a4e0e400() {
    // Encoding: 0xA4E0E400
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xA4E0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_9_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_10_e000_a4e0e020() {
    // Encoding: 0xA4E0E020
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rn=1, imm4=0, Zt=0
    let encoding: u32 = 0xA4E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_11_e000_a4e0e3c0() {
    // Encoding: 0xA4E0E3C0
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xA4E0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_12_e000_a4e0e3e0() {
    // Encoding: 0xA4E0E3E0
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: imm4=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_13_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_14_e000_a4e0e001() {
    // Encoding: 0xA4E0E001
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, imm4=0, Rn=0
    let encoding: u32 = 0xA4E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_15_e000_a4e0e01e() {
    // Encoding: 0xA4E0E01E
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_16_e000_a4e0e01f() {
    // Encoding: 0xA4E0E01F
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Zt=31, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xA4E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_17_e000_a4e0e420() {
    // Encoding: 0xA4E0E420
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xA4E0E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld4h_z_p_bi_contiguous_combo_18_e000_a4e0ffe0() {
    // Encoding: 0xA4E0FFE0
    // Test LD4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: Rn=31, imm4=0, Zt=0, Pg=31
    let encoding: u32 = 0xA4E0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld4h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_a4e0e3e0() {
    // Encoding: 0xA4E0E3E0
    // Test LD4H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=31
    let encoding: u32 = 0xA4E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_bi_contiguous_invalid_0_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld4h_z_p_bi_contiguous_invalid_1_e000_a4e0e000() {
    // Encoding: 0xA4E0E000
    // Test LD4H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD4H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld4h_z_p_bi_contiguous_sp_rn_a4e0e3e0() {
    // Test LD4H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xA4E0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4E0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCD_R.RS_UW Tests
// ============================================================================

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincd_r_rs_uw_field_imm4_0_zero_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincd_r_rs_uw_field_imm4_1_poweroftwo_f400_04e1f400() {
    // Encoding: 0x04E1F400
    // Test UQINCD_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04E1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincd_r_rs_uw_field_imm4_3_poweroftwominusone_f400_04e3f400() {
    // Encoding: 0x04E3F400
    // Test UQINCD_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04E3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_4_poweroftwo_f400_04e4f400() {
    // Encoding: 0x04E4F400
    // Test UQINCD_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x04E4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_7_poweroftwominusone_f400_04e7f400() {
    // Encoding: 0x04E7F400
    // Test UQINCD_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=7
    let encoding: u32 = 0x04E7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_8_poweroftwo_f400_04e8f400() {
    // Encoding: 0x04E8F400
    // Test UQINCD_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x04E8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_15_max_f400_04eff400() {
    // Encoding: 0x04EFF400
    // Test UQINCD_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04EFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_uw_field_pattern_0_min_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_uw_field_pattern_1_poweroftwo_f400_04e0f420() {
    // Encoding: 0x04E0F420
    // Test UQINCD_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x04E0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_uw_field_pattern_15_poweroftwominusone_f400_04e0f5e0() {
    // Encoding: 0x04E0F5E0
    // Test UQINCD_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04E0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_uw_field_pattern_31_max_f400_04e0f7e0() {
    // Encoding: 0x04E0F7E0
    // Test UQINCD_R.RS_UW field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04E0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_uw_field_rdn_0_min_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field Rdn = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_uw_field_rdn_1_poweroftwo_f400_04e0f401() {
    // Encoding: 0x04E0F401
    // Test UQINCD_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x04E0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_uw_field_rdn_15_poweroftwominusone_f400_04e0f40f() {
    // Encoding: 0x04E0F40F
    // Test UQINCD_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=15, pattern=0
    let encoding: u32 = 0x04E0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_uw_field_rdn_31_max_f400_04e0f41f() {
    // Encoding: 0x04E0F41F
    // Test UQINCD_R.RS_UW field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincd_r_rs_uw_combo_0_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_uqincd_r_rs_uw_combo_1_f400_04e1f400() {
    // Encoding: 0x04E1F400
    // Test UQINCD_R.RS_UW field combination: imm4=1, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=1, Rdn=0
    let encoding: u32 = 0x04E1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_uqincd_r_rs_uw_combo_2_f400_04e3f400() {
    // Encoding: 0x04E3F400
    // Test UQINCD_R.RS_UW field combination: imm4=3, pattern=0, Rdn=0
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04E3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_uqincd_r_rs_uw_combo_3_f400_04e4f400() {
    // Encoding: 0x04E4F400
    // Test UQINCD_R.RS_UW field combination: imm4=4, pattern=0, Rdn=0
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x04E4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_uqincd_r_rs_uw_combo_4_f400_04e7f400() {
    // Encoding: 0x04E7F400
    // Test UQINCD_R.RS_UW field combination: imm4=7, pattern=0, Rdn=0
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04E7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_uqincd_r_rs_uw_combo_5_f400_04e8f400() {
    // Encoding: 0x04E8F400
    // Test UQINCD_R.RS_UW field combination: imm4=8, pattern=0, Rdn=0
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04E8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_uqincd_r_rs_uw_combo_6_f400_04eff400() {
    // Encoding: 0x04EFF400
    // Test UQINCD_R.RS_UW field combination: imm4=15, pattern=0, Rdn=0
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04EFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_uqincd_r_rs_uw_combo_7_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_uqincd_r_rs_uw_combo_8_f400_04e0f420() {
    // Encoding: 0x04E0F420
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=1, Rdn=0
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04E0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_uqincd_r_rs_uw_combo_9_f400_04e0f5e0() {
    // Encoding: 0x04E0F5E0
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=15, Rdn=0
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x04E0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_uqincd_r_rs_uw_combo_10_f400_04e0f7e0() {
    // Encoding: 0x04E0F7E0
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=31, Rdn=0
    // Fields: pattern=31, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_uqincd_r_rs_uw_combo_11_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=1 (value 1)
#[test]
fn test_uqincd_r_rs_uw_combo_12_f400_04e0f401() {
    // Encoding: 0x04E0F401
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=1
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04E0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=15 (midpoint (15))
#[test]
fn test_uqincd_r_rs_uw_combo_13_f400_04e0f40f() {
    // Encoding: 0x04E0F40F
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=15
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x04E0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=31 (maximum value (31))
#[test]
fn test_uqincd_r_rs_uw_combo_14_f400_04e0f41f() {
    // Encoding: 0x04E0F41F
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=31
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_uw_invalid_0_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_uw_invalid_1_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincd_r_rs_x_field_imm4_0_zero_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincd_r_rs_x_field_imm4_1_poweroftwo_f400_04f1f400() {
    // Encoding: 0x04F1F400
    // Test UQINCD_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04F1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincd_r_rs_x_field_imm4_3_poweroftwominusone_f400_04f3f400() {
    // Encoding: 0x04F3F400
    // Test UQINCD_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x04F3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincd_r_rs_x_field_imm4_4_poweroftwo_f400_04f4f400() {
    // Encoding: 0x04F4F400
    // Test UQINCD_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04F4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincd_r_rs_x_field_imm4_7_poweroftwominusone_f400_04f7f400() {
    // Encoding: 0x04F7F400
    // Test UQINCD_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04F7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincd_r_rs_x_field_imm4_8_poweroftwo_f400_04f8f400() {
    // Encoding: 0x04F8F400
    // Test UQINCD_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x04F8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincd_r_rs_x_field_imm4_15_max_f400_04fff400() {
    // Encoding: 0x04FFF400
    // Test UQINCD_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04FFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_x_field_pattern_0_min_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_x_field_pattern_1_poweroftwo_f400_04f0f420() {
    // Encoding: 0x04F0F420
    // Test UQINCD_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04F0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_x_field_pattern_15_poweroftwominusone_f400_04f0f5e0() {
    // Encoding: 0x04F0F5E0
    // Test UQINCD_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_x_field_pattern_31_max_f400_04f0f7e0() {
    // Encoding: 0x04F0F7E0
    // Test UQINCD_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04F0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_x_field_rdn_0_min_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_x_field_rdn_1_poweroftwo_f400_04f0f401() {
    // Encoding: 0x04F0F401
    // Test UQINCD_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_x_field_rdn_15_poweroftwominusone_f400_04f0f40f() {
    // Encoding: 0x04F0F40F
    // Test UQINCD_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04F0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_x_field_rdn_31_max_f400_04f0f41f() {
    // Encoding: 0x04F0F41F
    // Test UQINCD_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x04F0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincd_r_rs_x_combo_0_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_uqincd_r_rs_x_combo_1_f400_04f1f400() {
    // Encoding: 0x04F1F400
    // Test UQINCD_R.RS_X field combination: imm4=1, pattern=0, Rdn=0
    // Fields: imm4=1, Rdn=0, pattern=0
    let encoding: u32 = 0x04F1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_uqincd_r_rs_x_combo_2_f400_04f3f400() {
    // Encoding: 0x04F3F400
    // Test UQINCD_R.RS_X field combination: imm4=3, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x04F3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_uqincd_r_rs_x_combo_3_f400_04f4f400() {
    // Encoding: 0x04F4F400
    // Test UQINCD_R.RS_X field combination: imm4=4, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04F4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_uqincd_r_rs_x_combo_4_f400_04f7f400() {
    // Encoding: 0x04F7F400
    // Test UQINCD_R.RS_X field combination: imm4=7, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=7, Rdn=0
    let encoding: u32 = 0x04F7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_uqincd_r_rs_x_combo_5_f400_04f8f400() {
    // Encoding: 0x04F8F400
    // Test UQINCD_R.RS_X field combination: imm4=8, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04F8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_uqincd_r_rs_x_combo_6_f400_04fff400() {
    // Encoding: 0x04FFF400
    // Test UQINCD_R.RS_X field combination: imm4=15, pattern=0, Rdn=0
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04FFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=0 (minimum value)
#[test]
fn test_uqincd_r_rs_x_combo_7_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=1 (value 1)
#[test]
fn test_uqincd_r_rs_x_combo_8_f400_04f0f420() {
    // Encoding: 0x04F0F420
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=1, Rdn=0
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=15 (midpoint (15))
#[test]
fn test_uqincd_r_rs_x_combo_9_f400_04f0f5e0() {
    // Encoding: 0x04F0F5E0
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=15, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04F0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// pattern=31 (maximum value (31))
#[test]
fn test_uqincd_r_rs_x_combo_10_f400_04f0f7e0() {
    // Encoding: 0x04F0F7E0
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=31, Rdn=0
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04F0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=0 (minimum value)
#[test]
fn test_uqincd_r_rs_x_combo_11_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=1 (value 1)
#[test]
fn test_uqincd_r_rs_x_combo_12_f400_04f0f401() {
    // Encoding: 0x04F0F401
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=1
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=15 (midpoint (15))
#[test]
fn test_uqincd_r_rs_x_combo_13_f400_04f0f40f() {
    // Encoding: 0x04F0F40F
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=15
    // Fields: imm4=0, Rdn=15, pattern=0
    let encoding: u32 = 0x04F0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rdn=31 (maximum value (31))
#[test]
fn test_uqincd_r_rs_x_combo_14_f400_04f0f41f() {
    // Encoding: 0x04F0F41F
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=31
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_x_invalid_0_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_x_invalid_1_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincd_r_rs_uw_reg_write_0_04e0f400() {
    // Test UQINCD_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x04E0F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincd_r_rs_x_reg_write_0_04f0f400() {
    // Test UQINCD_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04F0F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FABS_Z.P.Z__ Tests
// ============================================================================

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fabs_z_p_z_field_size_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fabs_z_p_z_field_size_1_poweroftwo_a000_045ca000() {
    // Encoding: 0x045CA000
    // Test FABS_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=0, size=1
    let encoding: u32 = 0x045CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fabs_z_p_z_field_size_2_poweroftwo_a000_049ca000() {
    // Encoding: 0x049CA000
    // Test FABS_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x049CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fabs_z_p_z_field_size_3_max_a000_04dca000() {
    // Encoding: 0x04DCA000
    // Test FABS_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x04DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fabs_z_p_z_field_pg_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fabs_z_p_z_field_pg_1_poweroftwo_a000_041ca400() {
    // Encoding: 0x041CA400
    // Test FABS_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0, size=0
    let encoding: u32 = 0x041CA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fabs_z_p_z_field_zn_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fabs_z_p_z_field_zn_1_poweroftwo_a000_041ca020() {
    // Encoding: 0x041CA020
    // Test FABS_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Pg=0, Zn=1
    let encoding: u32 = 0x041CA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fabs_z_p_z_field_zn_30_poweroftwominusone_a000_041ca3c0() {
    // Encoding: 0x041CA3C0
    // Test FABS_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, size=0, Zn=30
    let encoding: u32 = 0x041CA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fabs_z_p_z_field_zn_31_max_a000_041ca3e0() {
    // Encoding: 0x041CA3E0
    // Test FABS_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Zd=0, Pg=0
    let encoding: u32 = 0x041CA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fabs_z_p_z_field_zd_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fabs_z_p_z_field_zd_1_poweroftwo_a000_041ca001() {
    // Encoding: 0x041CA001
    // Test FABS_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1, Pg=0
    let encoding: u32 = 0x041CA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fabs_z_p_z_field_zd_30_poweroftwominusone_a000_041ca01e() {
    // Encoding: 0x041CA01E
    // Test FABS_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, size=0, Zd=30
    let encoding: u32 = 0x041CA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fabs_z_p_z_field_zd_31_max_a000_041ca01f() {
    // Encoding: 0x041CA01F
    // Test FABS_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x041CA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fabs_z_p_z_combo_0_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fabs_z_p_z_combo_1_a000_045ca000() {
    // Encoding: 0x045CA000
    // Test FABS_Z.P.Z__ field combination: size=1, Pg=0, Zn=0, Zd=0
    // Fields: size=1, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x045CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fabs_z_p_z_combo_2_a000_049ca000() {
    // Encoding: 0x049CA000
    // Test FABS_Z.P.Z__ field combination: size=2, Pg=0, Zn=0, Zd=0
    // Fields: size=2, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x049CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fabs_z_p_z_combo_3_a000_04dca000() {
    // Encoding: 0x04DCA000
    // Test FABS_Z.P.Z__ field combination: size=3, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=3, Zn=0
    let encoding: u32 = 0x04DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fabs_z_p_z_combo_4_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fabs_z_p_z_combo_5_a000_041ca400() {
    // Encoding: 0x041CA400
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=1, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Pg=1, Zd=0
    let encoding: u32 = 0x041CA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_fabs_z_p_z_combo_6_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=1 (SIMD register V1)
#[test]
fn test_fabs_z_p_z_combo_7_a000_041ca020() {
    // Encoding: 0x041CA020
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=1, Zd=0
    // Fields: Pg=0, Zd=0, size=0, Zn=1
    let encoding: u32 = 0x041CA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=30 (SIMD register V30)
#[test]
fn test_fabs_z_p_z_combo_8_a000_041ca3c0() {
    // Encoding: 0x041CA3C0
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=30, Zd=0
    // Fields: size=0, Zd=0, Zn=30, Pg=0
    let encoding: u32 = 0x041CA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=31 (SIMD register V31)
#[test]
fn test_fabs_z_p_z_combo_9_a000_041ca3e0() {
    // Encoding: 0x041CA3E0
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=31, Zd=0
    // Fields: Zn=31, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x041CA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_fabs_z_p_z_combo_10_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_fabs_z_p_z_combo_11_a000_041ca001() {
    // Encoding: 0x041CA001
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=1
    // Fields: Zn=0, size=0, Pg=0, Zd=1
    let encoding: u32 = 0x041CA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_fabs_z_p_z_combo_12_a000_041ca01e() {
    // Encoding: 0x041CA01E
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=30
    // Fields: Zn=0, size=0, Pg=0, Zd=30
    let encoding: u32 = 0x041CA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_fabs_z_p_z_combo_13_a000_041ca01f() {
    // Encoding: 0x041CA01F
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=31
    // Fields: Zd=31, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x041CA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fabs_z_p_z_special_size_0_size_variant_0_40960_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fabs_z_p_z_special_size_1_size_variant_1_40960_045ca000() {
    // Encoding: 0x045CA000
    // Test FABS_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x045CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fabs_z_p_z_special_size_2_size_variant_2_40960_049ca000() {
    // Encoding: 0x049CA000
    // Test FABS_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x049CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fabs_z_p_z_special_size_3_size_variant_3_40960_04dca000() {
    // Encoding: 0x04DCA000
    // Test FABS_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x04DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_0_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_1_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_2_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_3_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fabs_z_p_z_reg_write_0_041ca000() {
    // Test FABS_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x041CA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041CA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD3H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a4c1c000() {
    // Encoding: 0xA4C1C000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xA4C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a4dec000() {
    // Encoding: 0xA4DEC000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=30
    let encoding: u32 = 0xA4DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rm_31_max_c000_a4dfc000() {
    // Encoding: 0xA4DFC000
    // Test LD3H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rm=31, Rn=0
    let encoding: u32 = 0xA4DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_pg_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a4c0c400() {
    // Encoding: 0xA4C0C400
    // Test LD3H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Rm=0, Rn=0
    let encoding: u32 = 0xA4C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a4c0c020() {
    // Encoding: 0xA4C0C020
    // Test LD3H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=1
    let encoding: u32 = 0xA4C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a4c0c3c0() {
    // Encoding: 0xA4C0C3C0
    // Test LD3H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=30
    let encoding: u32 = 0xA4C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld3h_z_p_br_contiguous_field_rn_31_max_c000_a4c0c3e0() {
    // Encoding: 0xA4C0C3E0
    // Test LD3H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_0_min_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a4c0c001() {
    // Encoding: 0xA4C0C001
    // Test LD3H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rm=0, Rn=0
    let encoding: u32 = 0xA4C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a4c0c01e() {
    // Encoding: 0xA4C0C01E
    // Test LD3H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xA4C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld3h_z_p_br_contiguous_field_zt_31_max_c000_a4c0c01f() {
    // Encoding: 0xA4C0C01F
    // Test LD3H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, Rm=0
    let encoding: u32 = 0xA4C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_0_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_1_c000_a4c1c000() {
    // Encoding: 0xA4C1C000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=1, Zt=0, Rn=0
    let encoding: u32 = 0xA4C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_2_c000_a4dec000() {
    // Encoding: 0xA4DEC000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, Rm=30
    let encoding: u32 = 0xA4DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_3_c000_a4dfc000() {
    // Encoding: 0xA4DFC000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=31, Pg=0
    let encoding: u32 = 0xA4DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_4_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_5_c000_a4c0c400() {
    // Encoding: 0xA4C0C400
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Pg=1, Rn=0
    let encoding: u32 = 0xA4C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_6_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_7_c000_a4c0c020() {
    // Encoding: 0xA4C0C020
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rm=0, Rn=1, Zt=0
    let encoding: u32 = 0xA4C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_8_c000_a4c0c3c0() {
    // Encoding: 0xA4C0C3C0
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_9_c000_a4c0c3e0() {
    // Encoding: 0xA4C0C3E0
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld3h_z_p_br_contiguous_combo_10_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld3h_z_p_br_contiguous_combo_11_c000_a4c0c001() {
    // Encoding: 0xA4C0C001
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Zt=1, Rm=0, Pg=0
    let encoding: u32 = 0xA4C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld3h_z_p_br_contiguous_combo_12_c000_a4c0c01e() {
    // Encoding: 0xA4C0C01E
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld3h_z_p_br_contiguous_combo_13_c000_a4c0c01f() {
    // Encoding: 0xA4C0C01F
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zt=31, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_14_c000_a4c1c400() {
    // Encoding: 0xA4C1C400
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Rn=0, Rm=1, Zt=0
    let encoding: u32 = 0xA4C1C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_15_c000_a4dfdc00() {
    // Encoding: 0xA4DFDC00
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Pg=31, Rn=0, Zt=0, Rm=31
    let encoding: u32 = 0xA4DFDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_16_c000_a4c1c020() {
    // Encoding: 0xA4C1C020
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rm=1, Zt=0, Rn=1
    let encoding: u32 = 0xA4C1C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_17_c000_a4dfc3e0() {
    // Encoding: 0xA4DFC3E0
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Rm=31, Rn=31, Zt=0
    let encoding: u32 = 0xA4DFC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_18_c000_a4c0c420() {
    // Encoding: 0xA4C0C420
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Pg=1, Rn=1, Zt=0, Rm=0
    let encoding: u32 = 0xA4C0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld3h_z_p_br_contiguous_combo_19_c000_a4c0dfe0() {
    // Encoding: 0xA4C0DFE0
    // Test LD3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xA4C0DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld3h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a4c0c3e0() {
    // Encoding: 0xA4C0C3E0
    // Test LD3H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xA4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_0_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_1_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_2_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld3h_z_p_br_contiguous_invalid_3_c000_a4c0c000() {
    // Encoding: 0xA4C0C000
    // Test LD3H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD3H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld3h_z_p_br_contiguous_sp_rn_a4c0c3e0() {
    // Test LD3H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA4C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA4C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTA_V.P.Z__ Tests
// ============================================================================

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clasta_v_p_z_field_size_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field size = 0 (Min)
    // Fields: Vdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clasta_v_p_z_field_size_1_poweroftwo_8000_056a8000() {
    // Encoding: 0x056A8000
    // Test CLASTA_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Vdn=0, size=1
    let encoding: u32 = 0x056A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clasta_v_p_z_field_size_2_poweroftwo_8000_05aa8000() {
    // Encoding: 0x05AA8000
    // Test CLASTA_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vdn=0, Pg=0, size=2, Zm=0
    let encoding: u32 = 0x05AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clasta_v_p_z_field_size_3_max_8000_05ea8000() {
    // Encoding: 0x05EA8000
    // Test CLASTA_V.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zm=0, size=3, Vdn=0
    let encoding: u32 = 0x05EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clasta_v_p_z_field_pg_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field Pg = 0 (Min)
    // Fields: Zm=0, Vdn=0, Pg=0, size=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clasta_v_p_z_field_pg_1_poweroftwo_8000_052a8400() {
    // Encoding: 0x052A8400
    // Test CLASTA_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Vdn=0, size=0, Pg=1
    let encoding: u32 = 0x052A8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clasta_v_p_z_field_zm_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field Zm = 0 (Min)
    // Fields: Vdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clasta_v_p_z_field_zm_1_poweroftwo_8000_052a8020() {
    // Encoding: 0x052A8020
    // Test CLASTA_V.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Vdn=0, Pg=0
    let encoding: u32 = 0x052A8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clasta_v_p_z_field_zm_30_poweroftwominusone_8000_052a83c0() {
    // Encoding: 0x052A83C0
    // Test CLASTA_V.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Pg=0, Vdn=0
    let encoding: u32 = 0x052A83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clasta_v_p_z_field_zm_31_max_8000_052a83e0() {
    // Encoding: 0x052A83E0
    // Test CLASTA_V.P.Z__ field Zm = 31 (Max)
    // Fields: Pg=0, size=0, Zm=31, Vdn=0
    let encoding: u32 = 0x052A83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clasta_v_p_z_field_vdn_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field Vdn = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Vdn=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clasta_v_p_z_field_vdn_1_poweroftwo_8000_052a8001() {
    // Encoding: 0x052A8001
    // Test CLASTA_V.P.Z__ field Vdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Vdn=1, Zm=0
    let encoding: u32 = 0x052A8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clasta_v_p_z_field_vdn_15_poweroftwominusone_8000_052a800f() {
    // Encoding: 0x052A800F
    // Test CLASTA_V.P.Z__ field Vdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Pg=0, Vdn=15
    let encoding: u32 = 0x052A800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clasta_v_p_z_field_vdn_31_max_8000_052a801f() {
    // Encoding: 0x052A801F
    // Test CLASTA_V.P.Z__ field Vdn = 31 (Max)
    // Fields: Zm=0, size=0, Pg=0, Vdn=31
    let encoding: u32 = 0x052A801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clasta_v_p_z_combo_0_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: Zm=0, size=0, Pg=0, Vdn=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_clasta_v_p_z_combo_1_8000_056a8000() {
    // Encoding: 0x056A8000
    // Test CLASTA_V.P.Z__ field combination: size=1, Pg=0, Zm=0, Vdn=0
    // Fields: Vdn=0, Zm=0, Pg=0, size=1
    let encoding: u32 = 0x056A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_clasta_v_p_z_combo_2_8000_05aa8000() {
    // Encoding: 0x05AA8000
    // Test CLASTA_V.P.Z__ field combination: size=2, Pg=0, Zm=0, Vdn=0
    // Fields: size=2, Zm=0, Vdn=0, Pg=0
    let encoding: u32 = 0x05AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_clasta_v_p_z_combo_3_8000_05ea8000() {
    // Encoding: 0x05EA8000
    // Test CLASTA_V.P.Z__ field combination: size=3, Pg=0, Zm=0, Vdn=0
    // Fields: Pg=0, Vdn=0, size=3, Zm=0
    let encoding: u32 = 0x05EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_clasta_v_p_z_combo_4_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: size=0, Zm=0, Vdn=0, Pg=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_clasta_v_p_z_combo_5_8000_052a8400() {
    // Encoding: 0x052A8400
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=1, Zm=0, Vdn=0
    // Fields: Vdn=0, size=0, Pg=1, Zm=0
    let encoding: u32 = 0x052A8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_clasta_v_p_z_combo_6_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: Vdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_clasta_v_p_z_combo_7_8000_052a8020() {
    // Encoding: 0x052A8020
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=1, Vdn=0
    // Fields: Pg=0, Zm=1, size=0, Vdn=0
    let encoding: u32 = 0x052A8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_clasta_v_p_z_combo_8_8000_052a83c0() {
    // Encoding: 0x052A83C0
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=30, Vdn=0
    // Fields: Pg=0, Zm=30, size=0, Vdn=0
    let encoding: u32 = 0x052A83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_clasta_v_p_z_combo_9_8000_052a83e0() {
    // Encoding: 0x052A83E0
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=31, Vdn=0
    // Fields: size=0, Pg=0, Zm=31, Vdn=0
    let encoding: u32 = 0x052A83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vdn=0 (minimum value)
#[test]
fn test_clasta_v_p_z_combo_10_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: Zm=0, Pg=0, size=0, Vdn=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vdn=1 (value 1)
#[test]
fn test_clasta_v_p_z_combo_11_8000_052a8001() {
    // Encoding: 0x052A8001
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=1
    // Fields: size=0, Zm=0, Vdn=1, Pg=0
    let encoding: u32 = 0x052A8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vdn=15 (midpoint (15))
#[test]
fn test_clasta_v_p_z_combo_12_8000_052a800f() {
    // Encoding: 0x052A800F
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=15
    // Fields: size=0, Zm=0, Pg=0, Vdn=15
    let encoding: u32 = 0x052A800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vdn=31 (maximum value (31))
#[test]
fn test_clasta_v_p_z_combo_13_8000_052a801f() {
    // Encoding: 0x052A801F
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=31
    // Fields: Zm=0, Pg=0, size=0, Vdn=31
    let encoding: u32 = 0x052A801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clasta_v_p_z_special_size_0_size_variant_0_32768_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, size=0, Vdn=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clasta_v_p_z_special_size_1_size_variant_1_32768_056a8000() {
    // Encoding: 0x056A8000
    // Test CLASTA_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Pg=0, Vdn=0, size=1
    let encoding: u32 = 0x056A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clasta_v_p_z_special_size_2_size_variant_2_32768_05aa8000() {
    // Encoding: 0x05AA8000
    // Test CLASTA_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Vdn=0, size=2, Pg=0
    let encoding: u32 = 0x05AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clasta_v_p_z_special_size_3_size_variant_3_32768_05ea8000() {
    // Encoding: 0x05EA8000
    // Test CLASTA_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Vdn=0, Zm=0
    let encoding: u32 = 0x05EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clasta_v_p_z_invalid_0_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Vdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clasta_v_p_z_invalid_1_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Vdn=0, size=0, Zm=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_clasta_v_p_z_reg_write_0_052a8000() {
    // Test CLASTA_V.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x052A8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x052A8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1SH_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_xs_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_xs_1_max_0_84e00000() {
    // Encoding: 0x84E00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, xs=1, Zm=0
    let encoding: u32 = 0x84E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_0_84a10000() {
    // Encoding: 0x84A10000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Rn=0, Zm=1, Zt=0
    let encoding: u32 = 0x84A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_0_84be0000() {
    // Encoding: 0x84BE0000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Zm=30, xs=0, Pg=0
    let encoding: u32 = 0x84BE0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zm_31_max_0_84bf0000() {
    // Encoding: 0x84BF0000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x84BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_pg_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: xs=0, Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_0_84a00400() {
    // Encoding: 0x84A00400
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=1
    let encoding: u32 = 0x84A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_0_84a00020() {
    // Encoding: 0x84A00020
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0x84A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_0_84a003c0() {
    // Encoding: 0x84A003C0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=30, xs=0
    let encoding: u32 = 0x84A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_rn_31_max_0_84a003e0() {
    // Encoding: 0x84A003E0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, xs=0, Rn=31, Pg=0
    let encoding: u32 = 0x84A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_0_min_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_0_84a00001() {
    // Encoding: 0x84A00001
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0x84A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_0_84a0001e() {
    // Encoding: 0x84A0001E
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0x84A0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_field_zt_31_max_0_84a0001f() {
    // Encoding: 0x84A0001F
    // Test LD1SH_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zm=0, xs=0, Zt=31
    let encoding: u32 = 0x84A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_0_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_1_0_84e00000() {
    // Encoding: 0x84E00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=1, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_2_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_3_0_84a10000() {
    // Encoding: 0x84A10000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Zm=1, Rn=0, Zt=0
    let encoding: u32 = 0x84A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_4_0_84be0000() {
    // Encoding: 0x84BE0000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, xs=0, Zm=30
    let encoding: u32 = 0x84BE0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_5_0_84bf0000() {
    // Encoding: 0x84BF0000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zm=31, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_6_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_7_0_84a00400() {
    // Encoding: 0x84A00400
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Zm=0, Pg=1, Rn=0
    let encoding: u32 = 0x84A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_8_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_9_0_84a00020() {
    // Encoding: 0x84A00020
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0x84A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_10_0_84a003c0() {
    // Encoding: 0x84A003C0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0x84A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_11_0_84a003e0() {
    // Encoding: 0x84A003E0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x84A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_12_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_13_0_84a00001() {
    // Encoding: 0x84A00001
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, Pg=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x84A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_14_0_84a0001e() {
    // Encoding: 0x84A0001E
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_15_0_84a0001f() {
    // Encoding: 0x84A0001F
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Zt=31, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x84A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_16_0_84a00420() {
    // Encoding: 0x84A00420
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, Zm=0, xs=0, Pg=1, Rn=1
    let encoding: u32 = 0x84A00420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_combo_17_0_84a01fe0() {
    // Encoding: 0x84A01FE0
    // Test LD1SH_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Rn=31, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x84A01FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_84a003e0() {
    // Encoding: 0x84A003E0
    // Test LD1SH_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x84A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_invalid_0_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_invalid_1_0_84a00000() {
    // Encoding: 0x84A00000
    // Test LD1SH_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, xs=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_xs_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_xs_1_max_0_c4e00000() {
    // Encoding: 0xC4E00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Rn=0, Zm=0, xs=1, Pg=0, Zt=0
    let encoding: u32 = 0xC4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_0_c4a10000() {
    // Encoding: 0xC4A10000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_0_c4be0000() {
    // Encoding: 0xC4BE0000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4BE0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zm_31_max_0_c4bf0000() {
    // Encoding: 0xC4BF0000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: xs=0, Zt=0, Zm=31, Pg=0, Rn=0
    let encoding: u32 = 0xC4BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_pg_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_0_c4a00400() {
    // Encoding: 0xC4A00400
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xC4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_0_c4a00020() {
    // Encoding: 0xC4A00020
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zt=0, xs=0, Rn=1
    let encoding: u32 = 0xC4A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_0_c4a003c0() {
    // Encoding: 0xC4A003C0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=0, Rn=30, xs=0, Pg=0
    let encoding: u32 = 0xC4A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_rn_31_max_0_c4a003e0() {
    // Encoding: 0xC4A003E0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xC4A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_0_min_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_0_c4a00001() {
    // Encoding: 0xC4A00001
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zt=1, xs=0, Rn=0
    let encoding: u32 = 0xC4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_0_c4a0001e() {
    // Encoding: 0xC4A0001E
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xC4A0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_field_zt_31_max_0_c4a0001f() {
    // Encoding: 0xC4A0001F
    // Test LD1SH_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31, xs=0
    let encoding: u32 = 0xC4A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_0_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_1_0_c4e00000() {
    // Encoding: 0xC4E00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_2_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_3_0_c4a10000() {
    // Encoding: 0xC4A10000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Zt=0, Zm=1, Pg=0
    let encoding: u32 = 0xC4A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_4_0_c4be0000() {
    // Encoding: 0xC4BE0000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zm=30, Zt=0, xs=0
    let encoding: u32 = 0xC4BE0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_5_0_c4bf0000() {
    // Encoding: 0xC4BF0000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Zt=0, Pg=0, Zm=31
    let encoding: u32 = 0xC4BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_6_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_7_0_c4a00400() {
    // Encoding: 0xC4A00400
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Zm=0, Pg=1, Rn=0
    let encoding: u32 = 0xC4A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_8_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_9_0_c4a00020() {
    // Encoding: 0xC4A00020
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xC4A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_10_0_c4a003c0() {
    // Encoding: 0xC4A003C0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Pg=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0xC4A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_11_0_c4a003e0() {
    // Encoding: 0xC4A003E0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=31
    let encoding: u32 = 0xC4A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_12_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_13_0_c4a00001() {
    // Encoding: 0xC4A00001
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_14_0_c4a0001e() {
    // Encoding: 0xC4A0001E
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: xs=0, Zm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xC4A0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_15_0_c4a0001f() {
    // Encoding: 0xC4A0001F
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: xs=0, Zm=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xC4A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_16_0_c4a00420() {
    // Encoding: 0xC4A00420
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zm=0, Pg=1, xs=0, Rn=1, Zt=0
    let encoding: u32 = 0xC4A00420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_combo_17_0_c4a01fe0() {
    // Encoding: 0xC4A01FE0
    // Test LD1SH_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: xs=0, Zt=0, Rn=31, Zm=0, Pg=31
    let encoding: u32 = 0xC4A01FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c4a003e0() {
    // Encoding: 0xC4A003E0
    // Test LD1SH_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Rn=31, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_invalid_0_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_invalid_1_0_c4a00000() {
    // Encoding: 0xC4A00000
    // Test LD1SH_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0, xs=0
    let encoding: u32 = 0xC4A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_xs_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_xs_1_max_0_c4c00000() {
    // Encoding: 0xC4C00000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, xs=1, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, xs=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_0_c4810000() {
    // Encoding: 0xC4810000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, xs=0, Zm=1, Zt=0
    let encoding: u32 = 0xC4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_0_c49e0000() {
    // Encoding: 0xC49E0000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC49E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zm_31_max_0_c49f0000() {
    // Encoding: 0xC49F0000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xC49F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_pg_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_0_c4800400() {
    // Encoding: 0xC4800400
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zm=0, Zt=0, Pg=1
    let encoding: u32 = 0xC4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_0_c4800020() {
    // Encoding: 0xC4800020
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xC4800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_0_c48003c0() {
    // Encoding: 0xC48003C0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zt=0, Pg=0, Zm=0, Rn=30
    let encoding: u32 = 0xC48003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_rn_31_max_0_c48003e0() {
    // Encoding: 0xC48003E0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=31
    let encoding: u32 = 0xC48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_0_min_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_0_c4800001() {
    // Encoding: 0xC4800001
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=1
    let encoding: u32 = 0xC4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_0_c480001e() {
    // Encoding: 0xC480001E
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, xs=0, Zm=0
    let encoding: u32 = 0xC480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_field_zt_31_max_0_c480001f() {
    // Encoding: 0xC480001F
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=31, xs=0
    let encoding: u32 = 0xC480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_0_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_1_0_c4c00000() {
    // Encoding: 0xC4C00000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=1, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_2_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_3_0_c4810000() {
    // Encoding: 0xC4810000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_4_0_c49e0000() {
    // Encoding: 0xC49E0000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=30, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC49E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_5_0_c49f0000() {
    // Encoding: 0xC49F0000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zm=31, Pg=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC49F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_6_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_7_0_c4800400() {
    // Encoding: 0xC4800400
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zm=0, xs=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xC4800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_8_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_9_0_c4800020() {
    // Encoding: 0xC4800020
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=1
    let encoding: u32 = 0xC4800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_10_0_c48003c0() {
    // Encoding: 0xC48003C0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, xs=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC48003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_11_0_c48003e0() {
    // Encoding: 0xC48003E0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: xs=0, Pg=0, Rn=31, Zt=0, Zm=0
    let encoding: u32 = 0xC48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_12_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_13_0_c4800001() {
    // Encoding: 0xC4800001
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, xs=0, Zt=1, Rn=0, Zm=0
    let encoding: u32 = 0xC4800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_14_0_c480001e() {
    // Encoding: 0xC480001E
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: xs=0, Rn=0, Pg=0, Zt=30, Zm=0
    let encoding: u32 = 0xC480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_15_0_c480001f() {
    // Encoding: 0xC480001F
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0xC480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_16_0_c4800420() {
    // Encoding: 0xC4800420
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, Pg=1, xs=0, Zm=0, Rn=1
    let encoding: u32 = 0xC4800420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_combo_17_0_c4801fe0() {
    // Encoding: 0xC4801FE0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Pg=31, Zm=0, xs=0, Rn=31
    let encoding: u32 = 0xC4801FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_c48003e0() {
    // Encoding: 0xC48003E0
    // Test LD1SH_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC48003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_invalid_0_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_invalid_1_0_c4800000() {
    // Encoding: 0xC4800000
    // Test LD1SH_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_xs_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_xs_1_max_0_84c00000() {
    // Encoding: 0x84C00000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0, xs=1
    let encoding: u32 = 0x84C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_0_84810000() {
    // Encoding: 0x84810000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=1
    let encoding: u32 = 0x84810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_0_849e0000() {
    // Encoding: 0x849E0000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Zm=30, Pg=0, xs=0
    let encoding: u32 = 0x849E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zm_31_max_0_849f0000() {
    // Encoding: 0x849F0000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0x849F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_pg_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_0_84800400() {
    // Encoding: 0x84800400
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0x84800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_0_84800020() {
    // Encoding: 0x84800020
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=0, Zt=0, Rn=1
    let encoding: u32 = 0x84800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_0_848003c0() {
    // Encoding: 0x848003C0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=30, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0x848003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_rn_31_max_0_848003e0() {
    // Encoding: 0x848003E0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Rn=31, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0x848003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_0_min_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_0_84800001() {
    // Encoding: 0x84800001
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0x84800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_0_8480001e() {
    // Encoding: 0x8480001E
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x8480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_field_zt_31_max_0_8480001f() {
    // Encoding: 0x8480001F
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Rn=0, Zm=0, Zt=31, Pg=0
    let encoding: u32 = 0x8480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_0_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_1_0_84c00000() {
    // Encoding: 0x84C00000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=1, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0x84C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_2_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_3_0_84810000() {
    // Encoding: 0x84810000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zm=1, Rn=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x84810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_4_0_849e0000() {
    // Encoding: 0x849E0000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=30, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0x849E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_5_0_849f0000() {
    // Encoding: 0x849F0000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0x849F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_6_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_7_0_84800400() {
    // Encoding: 0x84800400
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, xs=0, Rn=0, Pg=1
    let encoding: u32 = 0x84800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_8_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_9_0_84800020() {
    // Encoding: 0x84800020
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zm=0, Rn=1, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0x84800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_10_0_848003c0() {
    // Encoding: 0x848003C0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0x848003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_11_0_848003e0() {
    // Encoding: 0x848003E0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0x848003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_12_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_13_0_84800001() {
    // Encoding: 0x84800001
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0x84800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_14_0_8480001e() {
    // Encoding: 0x8480001E
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Zm=0, xs=0, Zt=30, Pg=0
    let encoding: u32 = 0x8480001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_15_0_8480001f() {
    // Encoding: 0x8480001F
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zm=0, Rn=0, Zt=31, Pg=0, xs=0
    let encoding: u32 = 0x8480001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_16_0_84800420() {
    // Encoding: 0x84800420
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Pg=1, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0x84800420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_combo_17_0_84801fe0() {
    // Encoding: 0x84801FE0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Rn=31, Zm=0, Pg=31, xs=0, Zt=0
    let encoding: u32 = 0x84801FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_0_848003e0() {
    // Encoding: 0x848003E0
    // Test LD1SH_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0x848003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_invalid_0_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_invalid_1_0_84800000() {
    // Encoding: 0x84800000
    // Test LD1SH_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x84800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_8000_c4e18000() {
    // Encoding: 0xC4E18000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=1
    let encoding: u32 = 0xC4E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_8000_c4fe8000() {
    // Encoding: 0xC4FE8000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4FE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zm_31_max_8000_c4ff8000() {
    // Encoding: 0xC4FF8000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=31
    let encoding: u32 = 0xC4FF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_pg_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_8000_c4e08400() {
    // Encoding: 0xC4E08400
    // Test LD1SH_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, Zm=0, Rn=0
    let encoding: u32 = 0xC4E08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_8000_c4e08020() {
    // Encoding: 0xC4E08020
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4E08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_8000_c4e083c0() {
    // Encoding: 0xC4E083C0
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xC4E083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_rn_31_max_8000_c4e083e0() {
    // Encoding: 0xC4E083E0
    // Test LD1SH_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xC4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_0_min_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_8000_c4e08001() {
    // Encoding: 0xC4E08001
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Zm=0, Rn=0
    let encoding: u32 = 0xC4E08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_8000_c4e0801e() {
    // Encoding: 0xC4E0801E
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_field_zt_31_max_8000_c4e0801f() {
    // Encoding: 0xC4E0801F
    // Test LD1SH_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, Zm=0
    let encoding: u32 = 0xC4E0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_0_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_1_8000_c4e18000() {
    // Encoding: 0xC4E18000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=1, Rn=0
    let encoding: u32 = 0xC4E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_2_8000_c4fe8000() {
    // Encoding: 0xC4FE8000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=30, Zt=0, Rn=0
    let encoding: u32 = 0xC4FE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_3_8000_c4ff8000() {
    // Encoding: 0xC4FF8000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=31, Zt=0, Rn=0
    let encoding: u32 = 0xC4FF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_4_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_5_8000_c4e08400() {
    // Encoding: 0xC4E08400
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4E08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_6_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_7_8000_c4e08020() {
    // Encoding: 0xC4E08020
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Rn=1, Pg=0, Zm=0
    let encoding: u32 = 0xC4E08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_8_8000_c4e083c0() {
    // Encoding: 0xC4E083C0
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Zm=0, Rn=30, Pg=0
    let encoding: u32 = 0xC4E083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_9_8000_c4e083e0() {
    // Encoding: 0xC4E083E0
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_10_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_11_8000_c4e08001() {
    // Encoding: 0xC4E08001
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Zt=1, Rn=0, Zm=0
    let encoding: u32 = 0xC4E08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_12_8000_c4e0801e() {
    // Encoding: 0xC4E0801E
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_13_8000_c4e0801f() {
    // Encoding: 0xC4E0801F
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Rn=0, Zt=31, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_14_8000_c4e08420() {
    // Encoding: 0xC4E08420
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, Rn=1, Zm=0, Pg=1
    let encoding: u32 = 0xC4E08420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_combo_15_8000_c4e09fe0() {
    // Encoding: 0xC4E09FE0
    // Test LD1SH_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0xC4E09FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c4e083e0() {
    // Encoding: 0xC4E083E0
    // Test LD1SH_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_invalid_0_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_invalid_1_8000_c4e08000() {
    // Encoding: 0xC4E08000
    // Test LD1SH_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_8000_c4c18000() {
    // Encoding: 0xC4C18000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_8000_c4de8000() {
    // Encoding: 0xC4DE8000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4DE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zm_31_max_8000_c4df8000() {
    // Encoding: 0xC4DF8000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, Zm=31, Rn=0
    let encoding: u32 = 0xC4DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_pg_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_8000_c4c08400() {
    // Encoding: 0xC4C08400
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xC4C08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_8000_c4c08020() {
    // Encoding: 0xC4C08020
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, Zm=0
    let encoding: u32 = 0xC4C08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_8000_c4c083c0() {
    // Encoding: 0xC4C083C0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_rn_31_max_8000_c4c083e0() {
    // Encoding: 0xC4C083E0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0xC4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_0_min_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_8000_c4c08001() {
    // Encoding: 0xC4C08001
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xC4C08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_8000_c4c0801e() {
    // Encoding: 0xC4C0801E
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xC4C0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_field_zt_31_max_8000_c4c0801f() {
    // Encoding: 0xC4C0801F
    // Test LD1SH_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xC4C0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_0_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_1_8000_c4c18000() {
    // Encoding: 0xC4C18000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zm=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_2_8000_c4de8000() {
    // Encoding: 0xC4DE8000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=30, Zt=0, Pg=0
    let encoding: u32 = 0xC4DE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_3_8000_c4df8000() {
    // Encoding: 0xC4DF8000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, Zm=31
    let encoding: u32 = 0xC4DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_4_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_5_8000_c4c08400() {
    // Encoding: 0xC4C08400
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Pg=1, Zm=0, Zt=0
    let encoding: u32 = 0xC4C08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_6_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_7_8000_c4c08020() {
    // Encoding: 0xC4C08020
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xC4C08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_8_8000_c4c083c0() {
    // Encoding: 0xC4C083C0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=30
    let encoding: u32 = 0xC4C083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_9_8000_c4c083e0() {
    // Encoding: 0xC4C083E0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, Rn=31, Pg=0, Zm=0
    let encoding: u32 = 0xC4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_10_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_11_8000_c4c08001() {
    // Encoding: 0xC4C08001
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xC4C08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_12_8000_c4c0801e() {
    // Encoding: 0xC4C0801E
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xC4C0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_13_8000_c4c0801f() {
    // Encoding: 0xC4C0801F
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Zt=31, Rn=0, Zm=0
    let encoding: u32 = 0xC4C0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_14_8000_c4c08420() {
    // Encoding: 0xC4C08420
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, Zm=0, Pg=1, Rn=1
    let encoding: u32 = 0xC4C08420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_combo_15_8000_c4c09fe0() {
    // Encoding: 0xC4C09FE0
    // Test LD1SH_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Rn=31, Zm=0, Pg=31
    let encoding: u32 = 0xC4C09FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_c4c083e0() {
    // Encoding: 0xC4C083E0
    // Test LD1SH_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0
    let encoding: u32 = 0xC4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_invalid_0_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_invalid_1_8000_c4c08000() {
    // Encoding: 0xC4C08000
    // Test LD1SH_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_reg_write_0_84a00000() {
    // Test LD1SH_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x84A00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_scaled_sp_rn_84a003e0() {
    // Test LD1SH_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x84A003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_reg_write_0_c4a00000() {
    // Test LD1SH_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC4A00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_scaled_sp_rn_c4a003e0() {
    // Test LD1SH_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC4A003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_reg_write_0_c4800000() {
    // Test LD1SH_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_x32_unscaled_sp_rn_c48003e0() {
    // Test LD1SH_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC48003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC48003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_reg_write_0_84800000() {
    // Test LD1SH_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_s_x32_unscaled_sp_rn_848003e0() {
    // Test LD1SH_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x848003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x848003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_reg_write_0_c4e08000() {
    // Test LD1SH_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC4E08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_64_scaled_sp_rn_c4e083e0() {
    // Test LD1SH_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC4E083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_reg_write_0_c4c08000() {
    // Test LD1SH_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4C08000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C08000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1SH_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1sh_z_p_bz_d_64_unscaled_sp_rn_c4c083e0() {
    // Test LD1SH_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC4C083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUB_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsub_z_p_zs_field_size_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsub_z_p_zs_field_size_1_poweroftwo_8000_65598000() {
    // Encoding: 0x65598000
    // Test FSUB_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, i1=0, Pg=0, size=1
    let encoding: u32 = 0x65598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsub_z_p_zs_field_size_2_poweroftwo_8000_65998000() {
    // Encoding: 0x65998000
    // Test FSUB_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, i1=0, size=2, Zdn=0
    let encoding: u32 = 0x65998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsub_z_p_zs_field_size_3_max_8000_65d98000() {
    // Encoding: 0x65D98000
    // Test FSUB_Z.P.ZS__ field size = 3 (Max)
    // Fields: i1=0, Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x65D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsub_z_p_zs_field_pg_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsub_z_p_zs_field_pg_1_poweroftwo_8000_65198400() {
    // Encoding: 0x65198400
    // Test FSUB_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, i1=0, Pg=1, Zdn=0
    let encoding: u32 = 0x65198400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsub_z_p_zs_field_i1_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: i1=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fsub_z_p_zs_field_i1_1_max_8000_65198020() {
    // Encoding: 0x65198020
    // Test FSUB_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: size=0, i1=1, Pg=0, Zdn=0
    let encoding: u32 = 0x65198020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsub_z_p_zs_field_zdn_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fsub_z_p_zs_field_zdn_1_poweroftwo_8000_65198001() {
    // Encoding: 0x65198001
    // Test FSUB_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, i1=0, Zdn=1
    let encoding: u32 = 0x65198001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fsub_z_p_zs_field_zdn_15_poweroftwominusone_8000_6519800f() {
    // Encoding: 0x6519800F
    // Test FSUB_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, i1=0, Zdn=15
    let encoding: u32 = 0x6519800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fsub_z_p_zs_field_zdn_31_max_8000_6519801f() {
    // Encoding: 0x6519801F
    // Test FSUB_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31, i1=0
    let encoding: u32 = 0x6519801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsub_z_p_zs_combo_0_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, size=0, i1=0, Zdn=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fsub_z_p_zs_combo_1_8000_65598000() {
    // Encoding: 0x65598000
    // Test FSUB_Z.P.ZS__ field combination: size=1, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, i1=0, size=1, Zdn=0
    let encoding: u32 = 0x65598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fsub_z_p_zs_combo_2_8000_65998000() {
    // Encoding: 0x65998000
    // Test FSUB_Z.P.ZS__ field combination: size=2, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, Zdn=0, i1=0, size=2
    let encoding: u32 = 0x65998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fsub_z_p_zs_combo_3_8000_65d98000() {
    // Encoding: 0x65D98000
    // Test FSUB_Z.P.ZS__ field combination: size=3, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, size=3, i1=0, Zdn=0
    let encoding: u32 = 0x65D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fsub_z_p_zs_combo_4_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Zdn=0, i1=0, size=0, Pg=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fsub_z_p_zs_combo_5_8000_65198400() {
    // Encoding: 0x65198400
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=1, i1=0, Zdn=0
    // Fields: size=0, Zdn=0, i1=0, Pg=1
    let encoding: u32 = 0x65198400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_fsub_z_p_zs_combo_6_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=1 (maximum value (1))
#[test]
fn test_fsub_z_p_zs_combo_7_8000_65198020() {
    // Encoding: 0x65198020
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=1, Zdn=0
    // Fields: i1=1, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65198020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_fsub_z_p_zs_combo_8_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_fsub_z_p_zs_combo_9_8000_65198001() {
    // Encoding: 0x65198001
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=1
    // Fields: Pg=0, size=0, i1=0, Zdn=1
    let encoding: u32 = 0x65198001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_fsub_z_p_zs_combo_10_8000_6519800f() {
    // Encoding: 0x6519800F
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=15
    // Fields: Pg=0, Zdn=15, size=0, i1=0
    let encoding: u32 = 0x6519800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_fsub_z_p_zs_combo_11_8000_6519801f() {
    // Encoding: 0x6519801F
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=31
    // Fields: size=0, Zdn=31, Pg=0, i1=0
    let encoding: u32 = 0x6519801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsub_z_p_zs_special_size_0_size_variant_0_32768_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, i1=0, Zdn=0, size=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsub_z_p_zs_special_size_1_size_variant_1_32768_65598000() {
    // Encoding: 0x65598000
    // Test FSUB_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zdn=0, i1=0, Pg=0
    let encoding: u32 = 0x65598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsub_z_p_zs_special_size_2_size_variant_2_32768_65998000() {
    // Encoding: 0x65998000
    // Test FSUB_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: i1=0, size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x65998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsub_z_p_zs_special_size_3_size_variant_3_32768_65d98000() {
    // Encoding: 0x65D98000
    // Test FSUB_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, i1=0, size=3, Zdn=0
    let encoding: u32 = 0x65D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_0_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i1=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_1_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Pg=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_2_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_3_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fsub_z_p_zs_reg_write_0_65198000() {
    // Test FSUB_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x65198000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65198000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1RQD_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_1_poweroftwo_0_a5810000() {
    // Encoding: 0xA5810000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Rm=1, Zt=0
    let encoding: u32 = 0xA5810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_30_poweroftwominusone_0_a59e0000() {
    // Encoding: 0xA59E0000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=30
    let encoding: u32 = 0xA59E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rm_31_max_0_a59f0000() {
    // Encoding: 0xA59F0000
    // Test LD1RQD_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=31
    let encoding: u32 = 0xA59F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_pg_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_pg_1_poweroftwo_0_a5800400() {
    // Encoding: 0xA5800400
    // Test LD1RQD_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_1_poweroftwo_0_a5800020() {
    // Encoding: 0xA5800020
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Rm=0, Zt=0
    let encoding: u32 = 0xA5800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_30_poweroftwominusone_0_a58003c0() {
    // Encoding: 0xA58003C0
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xA58003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_rn_31_max_0_a58003e0() {
    // Encoding: 0xA58003E0
    // Test LD1RQD_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xA58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_0_min_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_1_poweroftwo_0_a5800001() {
    // Encoding: 0xA5800001
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, Rm=0
    let encoding: u32 = 0xA5800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_30_poweroftwominusone_0_a580001e() {
    // Encoding: 0xA580001E
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=0, Zt=30, Pg=0
    let encoding: u32 = 0xA580001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1rqd_z_p_br_contiguous_field_zt_31_max_0_a580001f() {
    // Encoding: 0xA580001F
    // Test LD1RQD_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xA580001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_0_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_1_0_a5810000() {
    // Encoding: 0xA5810000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Rm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_2_0_a59e0000() {
    // Encoding: 0xA59E0000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=30, Zt=0, Rn=0
    let encoding: u32 = 0xA59E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_3_0_a59f0000() {
    // Encoding: 0xA59F0000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=31, Zt=0
    let encoding: u32 = 0xA59F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_4_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_5_0_a5800400() {
    // Encoding: 0xA5800400
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Pg=1, Rn=0
    let encoding: u32 = 0xA5800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_6_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_7_0_a5800020() {
    // Encoding: 0xA5800020
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Zt=0, Rn=1, Rm=0
    let encoding: u32 = 0xA5800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_8_0_a58003c0() {
    // Encoding: 0xA58003C0
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Rn=30, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xA58003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_9_0_a58003e0() {
    // Encoding: 0xA58003E0
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=31
    let encoding: u32 = 0xA58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_10_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_11_0_a5800001() {
    // Encoding: 0xA5800001
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xA5800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_12_0_a580001e() {
    // Encoding: 0xA580001E
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xA580001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_13_0_a580001f() {
    // Encoding: 0xA580001F
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zt=31, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA580001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_14_0_a5810400() {
    // Encoding: 0xA5810400
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Pg=1, Rn=0, Rm=1
    let encoding: u32 = 0xA5810400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_15_0_a59f1c00() {
    // Encoding: 0xA59F1C00
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Rn=0, Rm=31, Zt=0, Pg=31
    let encoding: u32 = 0xA59F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_16_0_a5810020() {
    // Encoding: 0xA5810020
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rn=1, Zt=0, Rm=1
    let encoding: u32 = 0xA5810020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_17_0_a59f03e0() {
    // Encoding: 0xA59F03E0
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Rm=31, Zt=0, Pg=0
    let encoding: u32 = 0xA59F03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_18_0_a5800420() {
    // Encoding: 0xA5800420
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Rm=0, Zt=0, Pg=1
    let encoding: u32 = 0xA5800420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1rqd_z_p_br_contiguous_combo_19_0_a5801fe0() {
    // Encoding: 0xA5801FE0
    // Test LD1RQD_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Rm=0, Rn=31, Pg=31
    let encoding: u32 = 0xA5801FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1rqd_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_0_a58003e0() {
    // Encoding: 0xA58003E0
    // Test LD1RQD_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_0_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_1_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_2_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1rqd_z_p_br_contiguous_invalid_3_0_a5800000() {
    // Encoding: 0xA5800000
    // Test LD1RQD_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1rqd_z_p_br_contiguous_reg_write_0_a5800000() {
    // Test LD1RQD_Z.P.BR_Contiguous register write: SimdFromField("t")
    // Encoding: 0xA5800000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5800000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1RQD_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1rqd_z_p_br_contiguous_sp_rn_a58003e0() {
    // Test LD1RQD_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA58003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA58003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMIN_Z.ZI__ Tests
// ============================================================================

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umin_z_zi_field_size_0_min_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umin_z_zi_field_size_1_poweroftwo_c000_256bc000() {
    // Encoding: 0x256BC000
    // Test UMIN_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: imm8=0, Zdn=0, size=1
    let encoding: u32 = 0x256BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umin_z_zi_field_size_2_poweroftwo_c000_25abc000() {
    // Encoding: 0x25ABC000
    // Test UMIN_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: imm8=0, size=2, Zdn=0
    let encoding: u32 = 0x25ABC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umin_z_zi_field_size_3_max_c000_25ebc000() {
    // Encoding: 0x25EBC000
    // Test UMIN_Z.ZI__ field size = 3 (Max)
    // Fields: size=3, imm8=0, Zdn=0
    let encoding: u32 = 0x25EBC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_umin_z_zi_field_imm8_0_zero_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_umin_z_zi_field_imm8_1_poweroftwo_c000_252bc020() {
    // Encoding: 0x252BC020
    // Test UMIN_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm8=1, size=0
    let encoding: u32 = 0x252BC020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_umin_z_zi_field_imm8_3_poweroftwominusone_c000_252bc060() {
    // Encoding: 0x252BC060
    // Test UMIN_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: imm8=3, Zdn=0, size=0
    let encoding: u32 = 0x252BC060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_umin_z_zi_field_imm8_4_poweroftwo_c000_252bc080() {
    // Encoding: 0x252BC080
    // Test UMIN_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, Zdn=0, imm8=4
    let encoding: u32 = 0x252BC080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_umin_z_zi_field_imm8_7_poweroftwominusone_c000_252bc0e0() {
    // Encoding: 0x252BC0E0
    // Test UMIN_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, imm8=7
    let encoding: u32 = 0x252BC0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_umin_z_zi_field_imm8_8_poweroftwo_c000_252bc100() {
    // Encoding: 0x252BC100
    // Test UMIN_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: size=0, imm8=8, Zdn=0
    let encoding: u32 = 0x252BC100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_umin_z_zi_field_imm8_15_poweroftwominusone_c000_252bc1e0() {
    // Encoding: 0x252BC1E0
    // Test UMIN_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, imm8=15
    let encoding: u32 = 0x252BC1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_umin_z_zi_field_imm8_16_poweroftwo_c000_252bc200() {
    // Encoding: 0x252BC200
    // Test UMIN_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: imm8=16, size=0, Zdn=0
    let encoding: u32 = 0x252BC200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_umin_z_zi_field_imm8_31_poweroftwominusone_c000_252bc3e0() {
    // Encoding: 0x252BC3E0
    // Test UMIN_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: imm8=31, size=0, Zdn=0
    let encoding: u32 = 0x252BC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_umin_z_zi_field_imm8_32_poweroftwo_c000_252bc400() {
    // Encoding: 0x252BC400
    // Test UMIN_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: imm8=32, size=0, Zdn=0
    let encoding: u32 = 0x252BC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_umin_z_zi_field_imm8_63_poweroftwominusone_c000_252bc7e0() {
    // Encoding: 0x252BC7E0
    // Test UMIN_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=63, size=0
    let encoding: u32 = 0x252BC7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_umin_z_zi_field_imm8_64_poweroftwo_c000_252bc800() {
    // Encoding: 0x252BC800
    // Test UMIN_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: imm8=64, Zdn=0, size=0
    let encoding: u32 = 0x252BC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_umin_z_zi_field_imm8_127_poweroftwominusone_c000_252bcfe0() {
    // Encoding: 0x252BCFE0
    // Test UMIN_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, imm8=127
    let encoding: u32 = 0x252BCFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_umin_z_zi_field_imm8_128_poweroftwo_c000_252bd000() {
    // Encoding: 0x252BD000
    // Test UMIN_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: Zdn=0, imm8=128, size=0
    let encoding: u32 = 0x252BD000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_umin_z_zi_field_imm8_255_max_c000_252bdfe0() {
    // Encoding: 0x252BDFE0
    // Test UMIN_Z.ZI__ field imm8 = 255 (Max)
    // Fields: Zdn=0, size=0, imm8=255
    let encoding: u32 = 0x252BDFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_umin_z_zi_field_zdn_0_min_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_umin_z_zi_field_zdn_1_poweroftwo_c000_252bc001() {
    // Encoding: 0x252BC001
    // Test UMIN_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, imm8=0
    let encoding: u32 = 0x252BC001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_umin_z_zi_field_zdn_15_poweroftwominusone_c000_252bc00f() {
    // Encoding: 0x252BC00F
    // Test UMIN_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, imm8=0, size=0
    let encoding: u32 = 0x252BC00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_umin_z_zi_field_zdn_31_max_c000_252bc01f() {
    // Encoding: 0x252BC01F
    // Test UMIN_Z.ZI__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, imm8=0
    let encoding: u32 = 0x252BC01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umin_z_zi_combo_0_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_umin_z_zi_combo_1_c000_256bc000() {
    // Encoding: 0x256BC000
    // Test UMIN_Z.ZI__ field combination: size=1, imm8=0, Zdn=0
    // Fields: Zdn=0, imm8=0, size=1
    let encoding: u32 = 0x256BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_umin_z_zi_combo_2_c000_25abc000() {
    // Encoding: 0x25ABC000
    // Test UMIN_Z.ZI__ field combination: size=2, imm8=0, Zdn=0
    // Fields: size=2, imm8=0, Zdn=0
    let encoding: u32 = 0x25ABC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_umin_z_zi_combo_3_c000_25ebc000() {
    // Encoding: 0x25EBC000
    // Test UMIN_Z.ZI__ field combination: size=3, imm8=0, Zdn=0
    // Fields: Zdn=0, size=3, imm8=0
    let encoding: u32 = 0x25EBC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=0 (immediate value 0)
#[test]
fn test_umin_z_zi_combo_4_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=1 (immediate value 1)
#[test]
fn test_umin_z_zi_combo_5_c000_252bc020() {
    // Encoding: 0x252BC020
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=1, Zdn=0
    // Fields: imm8=1, size=0, Zdn=0
    let encoding: u32 = 0x252BC020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=3 (2^2 - 1 = 3)
#[test]
fn test_umin_z_zi_combo_6_c000_252bc060() {
    // Encoding: 0x252BC060
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=3, Zdn=0
    // Fields: size=0, imm8=3, Zdn=0
    let encoding: u32 = 0x252BC060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=4 (power of 2 (2^2 = 4))
#[test]
fn test_umin_z_zi_combo_7_c000_252bc080() {
    // Encoding: 0x252BC080
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=4, Zdn=0
    // Fields: Zdn=0, size=0, imm8=4
    let encoding: u32 = 0x252BC080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=7 (2^3 - 1 = 7)
#[test]
fn test_umin_z_zi_combo_8_c000_252bc0e0() {
    // Encoding: 0x252BC0E0
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=7, Zdn=0
    // Fields: size=0, Zdn=0, imm8=7
    let encoding: u32 = 0x252BC0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=8 (power of 2 (2^3 = 8))
#[test]
fn test_umin_z_zi_combo_9_c000_252bc100() {
    // Encoding: 0x252BC100
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=8, Zdn=0
    // Fields: Zdn=0, size=0, imm8=8
    let encoding: u32 = 0x252BC100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=15 (2^4 - 1 = 15)
#[test]
fn test_umin_z_zi_combo_10_c000_252bc1e0() {
    // Encoding: 0x252BC1E0
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=15, Zdn=0
    // Fields: Zdn=0, size=0, imm8=15
    let encoding: u32 = 0x252BC1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=16 (power of 2 (2^4 = 16))
#[test]
fn test_umin_z_zi_combo_11_c000_252bc200() {
    // Encoding: 0x252BC200
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=16, Zdn=0
    // Fields: Zdn=0, imm8=16, size=0
    let encoding: u32 = 0x252BC200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=31 (2^5 - 1 = 31)
#[test]
fn test_umin_z_zi_combo_12_c000_252bc3e0() {
    // Encoding: 0x252BC3E0
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=31, Zdn=0
    // Fields: size=0, imm8=31, Zdn=0
    let encoding: u32 = 0x252BC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=32 (power of 2 (2^5 = 32))
#[test]
fn test_umin_z_zi_combo_13_c000_252bc400() {
    // Encoding: 0x252BC400
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=32, Zdn=0
    // Fields: Zdn=0, size=0, imm8=32
    let encoding: u32 = 0x252BC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=63 (2^6 - 1 = 63)
#[test]
fn test_umin_z_zi_combo_14_c000_252bc7e0() {
    // Encoding: 0x252BC7E0
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=63, Zdn=0
    // Fields: size=0, imm8=63, Zdn=0
    let encoding: u32 = 0x252BC7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=64 (power of 2 (2^6 = 64))
#[test]
fn test_umin_z_zi_combo_15_c000_252bc800() {
    // Encoding: 0x252BC800
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=64, Zdn=0
    // Fields: imm8=64, Zdn=0, size=0
    let encoding: u32 = 0x252BC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=127 (immediate midpoint (127))
#[test]
fn test_umin_z_zi_combo_16_c000_252bcfe0() {
    // Encoding: 0x252BCFE0
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=127, Zdn=0
    // Fields: Zdn=0, size=0, imm8=127
    let encoding: u32 = 0x252BCFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=128 (power of 2 (2^7 = 128))
#[test]
fn test_umin_z_zi_combo_17_c000_252bd000() {
    // Encoding: 0x252BD000
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=128, Zdn=0
    // Fields: size=0, Zdn=0, imm8=128
    let encoding: u32 = 0x252BD000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8=255 (maximum immediate (255))
#[test]
fn test_umin_z_zi_combo_18_c000_252bdfe0() {
    // Encoding: 0x252BDFE0
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=255, Zdn=0
    // Fields: imm8=255, Zdn=0, size=0
    let encoding: u32 = 0x252BDFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_umin_z_zi_combo_19_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umin_z_zi_special_size_0_size_variant_0_49152_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umin_z_zi_special_size_1_size_variant_1_49152_256bc000() {
    // Encoding: 0x256BC000
    // Test UMIN_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: imm8=0, size=1, Zdn=0
    let encoding: u32 = 0x256BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umin_z_zi_special_size_2_size_variant_2_49152_25abc000() {
    // Encoding: 0x25ABC000
    // Test UMIN_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, imm8=0, size=2
    let encoding: u32 = 0x25ABC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umin_z_zi_special_size_3_size_variant_3_49152_25ebc000() {
    // Encoding: 0x25EBC000
    // Test UMIN_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: imm8=0, size=3, Zdn=0
    let encoding: u32 = 0x25EBC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umin_z_zi_invalid_0_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umin_z_zi_invalid_1_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_umin_z_zi_reg_write_0_252bc000() {
    // Test UMIN_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x252BC000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252BC000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMUL_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmul_z_p_zz_field_size_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmul_z_p_zz_field_size_1_poweroftwo_8000_65428000() {
    // Encoding: 0x65428000
    // Test FMUL_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, size=1
    let encoding: u32 = 0x65428000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmul_z_p_zz_field_size_2_poweroftwo_8000_65828000() {
    // Encoding: 0x65828000
    // Test FMUL_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x65828000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmul_z_p_zz_field_size_3_max_8000_65c28000() {
    // Encoding: 0x65C28000
    // Test FMUL_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Pg=0, Zm=0, size=3, Zdn=0
    let encoding: u32 = 0x65C28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmul_z_p_zz_field_pg_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmul_z_p_zz_field_pg_1_poweroftwo_8000_65028400() {
    // Encoding: 0x65028400
    // Test FMUL_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Zdn=0, size=0
    let encoding: u32 = 0x65028400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_p_zz_field_zm_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_p_zz_field_zm_1_poweroftwo_8000_65028020() {
    // Encoding: 0x65028020
    // Test FMUL_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=0, Zm=1
    let encoding: u32 = 0x65028020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_p_zz_field_zm_30_poweroftwominusone_8000_650283c0() {
    // Encoding: 0x650283C0
    // Test FMUL_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x650283C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_p_zz_field_zm_31_max_8000_650283e0() {
    // Encoding: 0x650283E0
    // Test FMUL_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, size=0, Pg=0, Zm=31
    let encoding: u32 = 0x650283E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_p_zz_field_zdn_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmul_z_p_zz_field_zdn_1_poweroftwo_8000_65028001() {
    // Encoding: 0x65028001
    // Test FMUL_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=0, Zdn=1
    let encoding: u32 = 0x65028001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmul_z_p_zz_field_zdn_15_poweroftwominusone_8000_6502800f() {
    // Encoding: 0x6502800F
    // Test FMUL_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=15, Pg=0, Zm=0
    let encoding: u32 = 0x6502800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmul_z_p_zz_field_zdn_31_max_8000_6502801f() {
    // Encoding: 0x6502801F
    // Test FMUL_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, size=0, Zm=0, Zdn=31
    let encoding: u32 = 0x6502801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmul_z_p_zz_combo_0_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_fmul_z_p_zz_combo_1_8000_65428000() {
    // Encoding: 0x65428000
    // Test FMUL_Z.P.ZZ__ field combination: size=1, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, size=1, Pg=0, Zm=0
    let encoding: u32 = 0x65428000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_fmul_z_p_zz_combo_2_8000_65828000() {
    // Encoding: 0x65828000
    // Test FMUL_Z.P.ZZ__ field combination: size=2, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, size=2, Zm=0, Pg=0
    let encoding: u32 = 0x65828000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_fmul_z_p_zz_combo_3_8000_65c28000() {
    // Encoding: 0x65C28000
    // Test FMUL_Z.P.ZZ__ field combination: size=3, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x65C28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fmul_z_p_zz_combo_4_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_fmul_z_p_zz_combo_5_8000_65028400() {
    // Encoding: 0x65028400
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=1, Zm=0, Zdn=0
    // Fields: Zdn=0, size=0, Zm=0, Pg=1
    let encoding: u32 = 0x65028400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_fmul_z_p_zz_combo_6_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_fmul_z_p_zz_combo_7_8000_65028020() {
    // Encoding: 0x65028020
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=1, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=1
    let encoding: u32 = 0x65028020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_fmul_z_p_zz_combo_8_8000_650283c0() {
    // Encoding: 0x650283C0
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=30, Zdn=0
    // Fields: Zm=30, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650283C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_fmul_z_p_zz_combo_9_8000_650283e0() {
    // Encoding: 0x650283E0
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=31, Zdn=0
    // Fields: Pg=0, Zm=31, Zdn=0, size=0
    let encoding: u32 = 0x650283E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_fmul_z_p_zz_combo_10_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_fmul_z_p_zz_combo_11_8000_65028001() {
    // Encoding: 0x65028001
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=1
    // Fields: Pg=0, Zdn=1, Zm=0, size=0
    let encoding: u32 = 0x65028001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_fmul_z_p_zz_combo_12_8000_6502800f() {
    // Encoding: 0x6502800F
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=15
    // Fields: Pg=0, size=0, Zdn=15, Zm=0
    let encoding: u32 = 0x6502800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_fmul_z_p_zz_combo_13_8000_6502801f() {
    // Encoding: 0x6502801F
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=31
    // Fields: size=0, Pg=0, Zm=0, Zdn=31
    let encoding: u32 = 0x6502801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmul_z_p_zz_special_size_0_size_variant_0_32768_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmul_z_p_zz_special_size_1_size_variant_1_32768_65428000() {
    // Encoding: 0x65428000
    // Test FMUL_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65428000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmul_z_p_zz_special_size_2_size_variant_2_32768_65828000() {
    // Encoding: 0x65828000
    // Test FMUL_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, Zdn=0, size=2
    let encoding: u32 = 0x65828000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmul_z_p_zz_special_size_3_size_variant_3_32768_65c28000() {
    // Encoding: 0x65C28000
    // Test FMUL_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zdn=0, Zm=0, size=3
    let encoding: u32 = 0x65C28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_0_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_1_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_2_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_3_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmul_z_p_zz_reg_write_0_65028000() {
    // Test FMUL_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65028000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65028000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD2D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_1_poweroftwo_c000_a5a1c000() {
    // Encoding: 0xA5A1C000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_30_poweroftwominusone_c000_a5bec000() {
    // Encoding: 0xA5BEC000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xA5BEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rm_31_max_c000_a5bfc000() {
    // Encoding: 0xA5BFC000
    // Test LD2D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Rm=31, Pg=0
    let encoding: u32 = 0xA5BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_pg_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_pg_1_poweroftwo_c000_a5a0c400() {
    // Encoding: 0xA5A0C400
    // Test LD2D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xA5A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_1_poweroftwo_c000_a5a0c020() {
    // Encoding: 0xA5A0C020
    // Test LD2D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xA5A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_30_poweroftwominusone_c000_a5a0c3c0() {
    // Encoding: 0xA5A0C3C0
    // Test LD2D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Rm=0
    let encoding: u32 = 0xA5A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld2d_z_p_br_contiguous_field_rn_31_max_c000_a5a0c3e0() {
    // Encoding: 0xA5A0C3E0
    // Test LD2D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xA5A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_0_min_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_1_poweroftwo_c000_a5a0c001() {
    // Encoding: 0xA5A0C001
    // Test LD2D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rm=0, Rn=0
    let encoding: u32 = 0xA5A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_30_poweroftwominusone_c000_a5a0c01e() {
    // Encoding: 0xA5A0C01E
    // Test LD2D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA5A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld2d_z_p_br_contiguous_field_zt_31_max_c000_a5a0c01f() {
    // Encoding: 0xA5A0C01F
    // Test LD2D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xA5A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_0_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_1_c000_a5a1c000() {
    // Encoding: 0xA5A1C000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=1, Rn=0, Zt=0
    let encoding: u32 = 0xA5A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_2_c000_a5bec000() {
    // Encoding: 0xA5BEC000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=30, Pg=0
    let encoding: u32 = 0xA5BEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_3_c000_a5bfc000() {
    // Encoding: 0xA5BFC000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, Rm=31
    let encoding: u32 = 0xA5BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_4_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_5_c000_a5a0c400() {
    // Encoding: 0xA5A0C400
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=0, Pg=1
    let encoding: u32 = 0xA5A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_6_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_7_c000_a5a0c020() {
    // Encoding: 0xA5A0C020
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xA5A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_8_c000_a5a0c3c0() {
    // Encoding: 0xA5A0C3C0
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30
    let encoding: u32 = 0xA5A0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_9_c000_a5a0c3e0() {
    // Encoding: 0xA5A0C3E0
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xA5A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld2d_z_p_br_contiguous_combo_10_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld2d_z_p_br_contiguous_combo_11_c000_a5a0c001() {
    // Encoding: 0xA5A0C001
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Rm=0, Pg=0, Zt=1
    let encoding: u32 = 0xA5A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld2d_z_p_br_contiguous_combo_12_c000_a5a0c01e() {
    // Encoding: 0xA5A0C01E
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xA5A0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld2d_z_p_br_contiguous_combo_13_c000_a5a0c01f() {
    // Encoding: 0xA5A0C01F
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Zt=31, Rm=0, Rn=0
    let encoding: u32 = 0xA5A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_14_c000_a5a1c400() {
    // Encoding: 0xA5A1C400
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xA5A1C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_15_c000_a5bfdc00() {
    // Encoding: 0xA5BFDC00
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Rm=31, Zt=0, Pg=31, Rn=0
    let encoding: u32 = 0xA5BFDC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_16_c000_a5a1c020() {
    // Encoding: 0xA5A1C020
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Rm=1, Rn=1, Zt=0, Pg=0
    let encoding: u32 = 0xA5A1C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_17_c000_a5bfc3e0() {
    // Encoding: 0xA5BFC3E0
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, Rm=31, Pg=0, Rn=31
    let encoding: u32 = 0xA5BFC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_18_c000_a5a0c420() {
    // Encoding: 0xA5A0C420
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Pg=1, Zt=0, Rm=0, Rn=1
    let encoding: u32 = 0xA5A0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld2d_z_p_br_contiguous_combo_19_c000_a5a0dfe0() {
    // Encoding: 0xA5A0DFE0
    // Test LD2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA5A0DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld2d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_49152_a5a0c3e0() {
    // Encoding: 0xA5A0C3E0
    // Test LD2D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xA5A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_0_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_1_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_2_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld2d_z_p_br_contiguous_invalid_3_c000_a5a0c000() {
    // Encoding: 0xA5A0C000
    // Test LD2D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xA5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD2D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld2d_z_p_br_contiguous_sp_rn_a5a0c3e0() {
    // Test LD2D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xA5A0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xA5A0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_0_zero_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e531e000() {
    // Encoding: 0xE531E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=1, Zt=0
    let encoding: u32 = 0xE531E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e533e000() {
    // Encoding: 0xE533E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE533E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e534e000() {
    // Encoding: 0xE534E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=4, Rn=0
    let encoding: u32 = 0xE534E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e537e000() {
    // Encoding: 0xE537E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm4=7, Zt=0
    let encoding: u32 = 0xE537E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e538e000() {
    // Encoding: 0xE538E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE538E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_15_max_e000_e53fe000() {
    // Encoding: 0xE53FE000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=15
    let encoding: u32 = 0xE53FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_pg_0_min_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e530e400() {
    // Encoding: 0xE530E400
    // Test ST2W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xE530E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_0_min_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e530e020() {
    // Encoding: 0xE530E020
    // Test ST2W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=1
    let encoding: u32 = 0xE530E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e530e3c0() {
    // Encoding: 0xE530E3C0
    // Test ST2W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=30, Zt=0
    let encoding: u32 = 0xE530E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_31_max_e000_e530e3e0() {
    // Encoding: 0xE530E3E0
    // Test ST2W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=31
    let encoding: u32 = 0xE530E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_0_min_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e530e001() {
    // Encoding: 0xE530E001
    // Test ST2W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xE530E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e530e01e() {
    // Encoding: 0xE530E01E
    // Test ST2W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE530E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_31_max_e000_e530e01f() {
    // Encoding: 0xE530E01F
    // Test ST2W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, imm4=0
    let encoding: u32 = 0xE530E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_0_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=1 (immediate value 1)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_1_e000_e531e000() {
    // Encoding: 0xE531E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=1, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, imm4=1
    let encoding: u32 = 0xE531E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=3 (2^2 - 1 = 3)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_2_e000_e533e000() {
    // Encoding: 0xE533E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=3, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=3, Zt=0
    let encoding: u32 = 0xE533E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=4 (power of 2 (2^2 = 4))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_3_e000_e534e000() {
    // Encoding: 0xE534E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=4, Pg=0, Rn=0, Zt=0
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE534E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=7 (immediate midpoint (7))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_4_e000_e537e000() {
    // Encoding: 0xE537E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=7, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, imm4=7
    let encoding: u32 = 0xE537E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=8 (power of 2 (2^3 = 8))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_5_e000_e538e000() {
    // Encoding: 0xE538E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=8, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, imm4=8, Pg=0, Rn=0
    let encoding: u32 = 0xE538E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=15 (maximum immediate (15))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_6_e000_e53fe000() {
    // Encoding: 0xE53FE000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=15, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, imm4=15, Rn=0
    let encoding: u32 = 0xE53FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_7_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_8_e000_e530e400() {
    // Encoding: 0xE530E400
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xE530E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_9_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_10_e000_e530e020() {
    // Encoding: 0xE530E020
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE530E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_11_e000_e530e3c0() {
    // Encoding: 0xE530E3C0
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Rn=30, Zt=0, imm4=0
    let encoding: u32 = 0xE530E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_12_e000_e530e3e0() {
    // Encoding: 0xE530E3E0
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=31, Zt=0
    // Fields: imm4=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE530E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_13_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_14_e000_e530e001() {
    // Encoding: 0xE530E001
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE530E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_15_e000_e530e01e() {
    // Encoding: 0xE530E01E
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=30
    // Fields: imm4=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xE530E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_16_e000_e530e01f() {
    // Encoding: 0xE530E01F
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Rn=0, imm4=0, Zt=31
    let encoding: u32 = 0xE530E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_17_e000_e530e420() {
    // Encoding: 0xE530E420
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=1, Rn=1, Zt=0
    // Fields: Pg=1, Rn=1, Zt=0, imm4=0
    let encoding: u32 = 0xE530E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_st2w_z_p_bi_contiguous_combo_18_e000_e530ffe0() {
    // Encoding: 0xE530FFE0
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Pg=31, imm4=0, Rn=31
    let encoding: u32 = 0xE530FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e530e3e0() {
    // Encoding: 0xE530E3E0
    // Test ST2W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE530E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_bi_contiguous_invalid_0_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_bi_contiguous_invalid_1_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2w_z_p_bi_contiguous_sp_rn_e530e3e0() {
    // Test ST2W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE530E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE530E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2w_z_p_bi_contiguous_store_0_e530e020() {
    // Test ST2W_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE530E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE530E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LD1H_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_xs_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_xs_1_max_4000_84e04000() {
    // Encoding: 0x84E04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Pg=0, xs=1, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0x84E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_4000_84a14000() {
    // Encoding: 0x84A14000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, xs=0, Zm=1, Rn=0
    let encoding: u32 = 0x84A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_4000_84be4000() {
    // Encoding: 0x84BE4000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=30, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0x84BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zm_31_max_4000_84bf4000() {
    // Encoding: 0x84BF4000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Rn=0, xs=0, Zt=0, Zm=31
    let encoding: u32 = 0x84BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_pg_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_4000_84a04400() {
    // Encoding: 0x84A04400
    // Test LD1H_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0x84A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_4000_84a04020() {
    // Encoding: 0x84A04020
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=1
    let encoding: u32 = 0x84A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_4000_84a043c0() {
    // Encoding: 0x84A043C0
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Rn=30, Zt=0, Zm=0
    let encoding: u32 = 0x84A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_rn_31_max_4000_84a043e0() {
    // Encoding: 0x84A043E0
    // Test LD1H_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, xs=0, Zm=0, Rn=31
    let encoding: u32 = 0x84A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_0_min_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_4000_84a04001() {
    // Encoding: 0x84A04001
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x84A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_4000_84a0401e() {
    // Encoding: 0x84A0401E
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, xs=0, Pg=0, Zm=0, Zt=30
    let encoding: u32 = 0x84A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_field_zt_31_max_4000_84a0401f() {
    // Encoding: 0x84A0401F
    // Test LD1H_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0x84A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_0_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_1_4000_84e04000() {
    // Encoding: 0x84E04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, xs=1, Pg=0, Zm=0
    let encoding: u32 = 0x84E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_2_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_3_4000_84a14000() {
    // Encoding: 0x84A14000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zm=1, Pg=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0x84A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_4_4000_84be4000() {
    // Encoding: 0x84BE4000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Zm=30, Pg=0, Zt=0
    let encoding: u32 = 0x84BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_5_4000_84bf4000() {
    // Encoding: 0x84BF4000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zm=31, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_6_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_7_4000_84a04400() {
    // Encoding: 0x84A04400
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, xs=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0x84A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_8_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_9_4000_84a04020() {
    // Encoding: 0x84A04020
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zt=0, Rn=1, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x84A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_10_4000_84a043c0() {
    // Encoding: 0x84A043C0
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zm=0, Zt=0, Rn=30, xs=0, Pg=0
    let encoding: u32 = 0x84A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_11_4000_84a043e0() {
    // Encoding: 0x84A043E0
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Pg=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0x84A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_12_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_13_4000_84a04001() {
    // Encoding: 0x84A04001
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Zt=1, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0x84A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_14_4000_84a0401e() {
    // Encoding: 0x84A0401E
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, xs=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0x84A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_15_4000_84a0401f() {
    // Encoding: 0x84A0401F
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Rn=0, xs=0, Zm=0, Zt=31
    let encoding: u32 = 0x84A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_16_4000_84a04420() {
    // Encoding: 0x84A04420
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Zt=0, xs=0, Pg=1, Zm=0
    let encoding: u32 = 0x84A04420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_combo_17_4000_84a05fe0() {
    // Encoding: 0x84A05FE0
    // Test LD1H_Z.P.BZ_S.x32.scaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Pg=31, Zm=0, Rn=31, xs=0
    let encoding: u32 = 0x84A05FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_84a043e0() {
    // Encoding: 0x84A043E0
    // Test LD1H_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zm=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0x84A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_invalid_0_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, xs=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_invalid_1_4000_84a04000() {
    // Encoding: 0x84A04000
    // Test LD1H_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_xs_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_xs_1_max_4000_c4e04000() {
    // Encoding: 0xC4E04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Rn=0, Zm=0, xs=1, Zt=0, Pg=0
    let encoding: u32 = 0xC4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_4000_c4a14000() {
    // Encoding: 0xC4A14000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=1, Rn=0, Zt=0
    let encoding: u32 = 0xC4A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_4000_c4be4000() {
    // Encoding: 0xC4BE4000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Zm=30, Pg=0, Rn=0
    let encoding: u32 = 0xC4BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zm_31_max_4000_c4bf4000() {
    // Encoding: 0xC4BF4000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Rn=0, xs=0, Pg=0, Zt=0, Zm=31
    let encoding: u32 = 0xC4BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_pg_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_4000_c4a04400() {
    // Encoding: 0xC4A04400
    // Test LD1H_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Zm=0, Pg=1, Rn=0
    let encoding: u32 = 0xC4A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_4000_c4a04020() {
    // Encoding: 0xC4A04020
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_4000_c4a043c0() {
    // Encoding: 0xC4A043C0
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=30, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_rn_31_max_4000_c4a043e0() {
    // Encoding: 0xC4A043E0
    // Test LD1H_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=31, xs=0
    let encoding: u32 = 0xC4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_0_min_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_4000_c4a04001() {
    // Encoding: 0xC4A04001
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xC4A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_4000_c4a0401e() {
    // Encoding: 0xC4A0401E
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xC4A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_field_zt_31_max_4000_c4a0401f() {
    // Encoding: 0xC4A0401F
    // Test LD1H_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Pg=0, xs=0, Zt=31
    let encoding: u32 = 0xC4A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_0_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_1_4000_c4e04000() {
    // Encoding: 0xC4E04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=1, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_2_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_3_4000_c4a14000() {
    // Encoding: 0xC4A14000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4A14000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_4_4000_c4be4000() {
    // Encoding: 0xC4BE4000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=30, xs=0, Rn=0
    let encoding: u32 = 0xC4BE4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_5_4000_c4bf4000() {
    // Encoding: 0xC4BF4000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Pg=0, Zm=31, Zt=0
    let encoding: u32 = 0xC4BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_6_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=0, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_7_4000_c4a04400() {
    // Encoding: 0xC4A04400
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Zm=0, Pg=1, Zt=0
    let encoding: u32 = 0xC4A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_8_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_9_4000_c4a04020() {
    // Encoding: 0xC4A04020
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: xs=0, Rn=1, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4A04020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_10_4000_c4a043c0() {
    // Encoding: 0xC4A043C0
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: xs=0, Zm=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xC4A043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_11_4000_c4a043e0() {
    // Encoding: 0xC4A043E0
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xC4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_12_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_13_4000_c4a04001() {
    // Encoding: 0xC4A04001
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zm=0, Zt=1, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xC4A04001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_14_4000_c4a0401e() {
    // Encoding: 0xC4A0401E
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=30
    let encoding: u32 = 0xC4A0401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_15_4000_c4a0401f() {
    // Encoding: 0xC4A0401F
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: xs=0, Zt=31, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4A0401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_16_4000_c4a04420() {
    // Encoding: 0xC4A04420
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zm=0, Rn=1, Zt=0, xs=0, Pg=1
    let encoding: u32 = 0xC4A04420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_combo_17_4000_c4a05fe0() {
    // Encoding: 0xC4A05FE0
    // Test LD1H_Z.P.BZ_D.x32.scaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: xs=0, Rn=31, Zm=0, Pg=31, Zt=0
    let encoding: u32 = 0xC4A05FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c4a043e0() {
    // Encoding: 0xC4A043E0
    // Test LD1H_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0xC4A043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_invalid_0_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_invalid_1_4000_c4a04000() {
    // Encoding: 0xC4A04000
    // Test LD1H_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_xs_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_xs_1_max_4000_c4c04000() {
    // Encoding: 0xC4C04000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Zm=0, Zt=0, Pg=0, xs=1, Rn=0
    let encoding: u32 = 0xC4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_4000_c4814000() {
    // Encoding: 0xC4814000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=1, Zt=0, Rn=0
    let encoding: u32 = 0xC4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_4000_c49e4000() {
    // Encoding: 0xC49E4000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zt=0, Rn=0, Zm=30
    let encoding: u32 = 0xC49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zm_31_max_4000_c49f4000() {
    // Encoding: 0xC49F4000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, xs=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xC49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_pg_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_4000_c4804400() {
    // Encoding: 0xC4804400
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, xs=0, Rn=0, Pg=1
    let encoding: u32 = 0xC4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_4000_c4804020() {
    // Encoding: 0xC4804020
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xC4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_4000_c48043c0() {
    // Encoding: 0xC48043C0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=30, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_rn_31_max_4000_c48043e0() {
    // Encoding: 0xC48043E0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, xs=0, Pg=0, Rn=31
    let encoding: u32 = 0xC48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_0_min_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_4000_c4804001() {
    // Encoding: 0xC4804001
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xC4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_4000_c480401e() {
    // Encoding: 0xC480401E
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=30, xs=0
    let encoding: u32 = 0xC480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_field_zt_31_max_4000_c480401f() {
    // Encoding: 0xC480401F
    // Test LD1H_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0xC480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_0_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_1_4000_c4c04000() {
    // Encoding: 0xC4C04000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_2_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_3_4000_c4814000() {
    // Encoding: 0xC4814000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, xs=0, Pg=0, Zm=1
    let encoding: u32 = 0xC4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_4_4000_c49e4000() {
    // Encoding: 0xC49E4000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zt=0, Rn=0, Pg=0, Zm=30
    let encoding: u32 = 0xC49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_5_4000_c49f4000() {
    // Encoding: 0xC49F4000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=31, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xC49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_6_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, xs=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_7_4000_c4804400() {
    // Encoding: 0xC4804400
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Pg=1, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xC4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_8_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_9_4000_c4804020() {
    // Encoding: 0xC4804020
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: xs=0, Rn=1, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_10_4000_c48043c0() {
    // Encoding: 0xC48043C0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=30
    let encoding: u32 = 0xC48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_11_4000_c48043e0() {
    // Encoding: 0xC48043E0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Zm=0, xs=0, Zt=0, Rn=31
    let encoding: u32 = 0xC48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_12_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_13_4000_c4804001() {
    // Encoding: 0xC4804001
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: xs=0, Pg=0, Zt=1, Zm=0, Rn=0
    let encoding: u32 = 0xC4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_14_4000_c480401e() {
    // Encoding: 0xC480401E
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=30
    let encoding: u32 = 0xC480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_15_4000_c480401f() {
    // Encoding: 0xC480401F
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xC480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_16_4000_c4804420() {
    // Encoding: 0xC4804420
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Zt=0, Pg=1, Zm=0, xs=0
    let encoding: u32 = 0xC4804420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_combo_17_4000_c4805fe0() {
    // Encoding: 0xC4805FE0
    // Test LD1H_Z.P.BZ_D.x32.unscaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: xs=0, Zt=0, Zm=0, Pg=31, Rn=31
    let encoding: u32 = 0xC4805FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_c48043e0() {
    // Encoding: 0xC48043E0
    // Test LD1H_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xC48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_invalid_0_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_invalid_1_4000_c4804000() {
    // Encoding: 0xC4804000
    // Test LD1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, xs=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_xs_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 22 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_xs_1_max_4000_84c04000() {
    // Encoding: 0x84C04000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: xs=1, Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0x84C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_4000_84814000() {
    // Encoding: 0x84814000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Pg=0, Rn=0, Zm=1
    let encoding: u32 = 0x84814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_4000_849e4000() {
    // Encoding: 0x849E4000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Pg=0, Zm=30, Rn=0
    let encoding: u32 = 0x849E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zm_31_max_4000_849f4000() {
    // Encoding: 0x849F4000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Rn=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0x849F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_pg_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_4000_84804400() {
    // Encoding: 0x84804400
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=1, xs=0, Zt=0, Zm=0
    let encoding: u32 = 0x84804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_4000_84804020() {
    // Encoding: 0x84804020
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=1, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0x84804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_4000_848043c0() {
    // Encoding: 0x848043C0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, xs=0, Rn=30, Zt=0
    let encoding: u32 = 0x848043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_rn_31_max_4000_848043e0() {
    // Encoding: 0x848043E0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x848043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_0_min_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_4000_84804001() {
    // Encoding: 0x84804001
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=1, xs=0
    let encoding: u32 = 0x84804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_4000_8480401e() {
    // Encoding: 0x8480401E
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zm=0, Rn=0, Pg=0, xs=0
    let encoding: u32 = 0x8480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_field_zt_31_max_4000_8480401f() {
    // Encoding: 0x8480401F
    // Test LD1H_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Zt=31, xs=0, Pg=0
    let encoding: u32 = 0x8480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=0 (minimum value)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_0_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// xs=1 (maximum value (1))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_1_4000_84c04000() {
    // Encoding: 0x84C04000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=1, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Pg=0, xs=1, Zt=0
    let encoding: u32 = 0x84C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_2_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_3_4000_84814000() {
    // Encoding: 0x84814000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Zm=1, Pg=0, Rn=0
    let encoding: u32 = 0x84814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_4_4000_849e4000() {
    // Encoding: 0x849E4000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Pg=0, Zt=0, Zm=30
    let encoding: u32 = 0x849E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_5_4000_849f4000() {
    // Encoding: 0x849F4000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=31, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0x849F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_6_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_7_4000_84804400() {
    // Encoding: 0x84804400
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zm=0, Pg=1, xs=0, Rn=0, Zt=0
    let encoding: u32 = 0x84804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_8_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_9_4000_84804020() {
    // Encoding: 0x84804020
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Pg=0, Rn=1, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0x84804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_10_4000_848043c0() {
    // Encoding: 0x848043C0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zt=0, Zm=0, Rn=30, xs=0, Pg=0
    let encoding: u32 = 0x848043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_11_4000_848043e0() {
    // Encoding: 0x848043E0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: xs=0, Rn=31, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0x848043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_12_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_13_4000_84804001() {
    // Encoding: 0x84804001
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=1
    let encoding: u32 = 0x84804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_14_4000_8480401e() {
    // Encoding: 0x8480401E
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=30
    let encoding: u32 = 0x8480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_15_4000_8480401f() {
    // Encoding: 0x8480401F
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zm=0, xs=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0x8480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_16_4000_84804420() {
    // Encoding: 0x84804420
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zm=0, Pg=1, xs=0, Rn=1, Zt=0
    let encoding: u32 = 0x84804420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_combo_17_4000_84805fe0() {
    // Encoding: 0x84805FE0
    // Test LD1H_Z.P.BZ_S.x32.unscaled field combination: xs=0, Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Pg=31, Zm=0, xs=0, Rn=31, Zt=0
    let encoding: u32 = 0x84805FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_16384_848043e0() {
    // Encoding: 0x848043E0
    // Test LD1H_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0x848043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_invalid_0_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_invalid_1_4000_84804000() {
    // Encoding: 0x84804000
    // Test LD1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0x84804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_c000_c4e1c000() {
    // Encoding: 0xC4E1C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=1
    let encoding: u32 = 0xC4E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_c000_c4fec000() {
    // Encoding: 0xC4FEC000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=30
    let encoding: u32 = 0xC4FEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zm_31_max_c000_c4ffc000() {
    // Encoding: 0xC4FFC000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Rn=0, Zt=0
    let encoding: u32 = 0xC4FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_pg_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_c000_c4e0c400() {
    // Encoding: 0xC4E0C400
    // Test LD1H_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xC4E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_c000_c4e0c020() {
    // Encoding: 0xC4E0C020
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_c000_c4e0c3c0() {
    // Encoding: 0xC4E0C3C0
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=30
    let encoding: u32 = 0xC4E0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_rn_31_max_c000_c4e0c3e0() {
    // Encoding: 0xC4E0C3E0
    // Test LD1H_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xC4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_0_min_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_c000_c4e0c001() {
    // Encoding: 0xC4E0C001
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xC4E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_c000_c4e0c01e() {
    // Encoding: 0xC4E0C01E
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xC4E0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_field_zt_31_max_c000_c4e0c01f() {
    // Encoding: 0xC4E0C01F
    // Test LD1H_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, Zm=0
    let encoding: u32 = 0xC4E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_0_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_1_c000_c4e1c000() {
    // Encoding: 0xC4E1C000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, Zm=1
    let encoding: u32 = 0xC4E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_2_c000_c4fec000() {
    // Encoding: 0xC4FEC000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xC4FEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_3_c000_c4ffc000() {
    // Encoding: 0xC4FFC000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Zm=31, Pg=0
    let encoding: u32 = 0xC4FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_4_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_5_c000_c4e0c400() {
    // Encoding: 0xC4E0C400
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=1, Zm=0
    let encoding: u32 = 0xC4E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_6_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_7_c000_c4e0c020() {
    // Encoding: 0xC4E0C020
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_8_c000_c4e0c3c0() {
    // Encoding: 0xC4E0C3C0
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Zm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xC4E0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_9_c000_c4e0c3e0() {
    // Encoding: 0xC4E0C3E0
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Pg=0, Rn=31, Zt=0, Zm=0
    let encoding: u32 = 0xC4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_10_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_11_c000_c4e0c001() {
    // Encoding: 0xC4E0C001
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_12_c000_c4e0c01e() {
    // Encoding: 0xC4E0C01E
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Rn=0, Zt=30, Zm=0, Pg=0
    let encoding: u32 = 0xC4E0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_13_c000_c4e0c01f() {
    // Encoding: 0xC4E0C01F
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0xC4E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_14_c000_c4e0c420() {
    // Encoding: 0xC4E0C420
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zt=0, Pg=1, Rn=1, Zm=0
    let encoding: u32 = 0xC4E0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_combo_15_c000_c4e0dfe0() {
    // Encoding: 0xC4E0DFE0
    // Test LD1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Rn=31, Zm=0, Pg=31, Zt=0
    let encoding: u32 = 0xC4E0DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c4e0c3e0() {
    // Encoding: 0xC4E0C3E0
    // Test LD1H_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_invalid_0_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_invalid_1_c000_c4e0c000() {
    // Encoding: 0xC4E0C000
    // Test LD1H_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_c000_c4c1c000() {
    // Encoding: 0xC4C1C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=1
    let encoding: u32 = 0xC4C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_c000_c4dec000() {
    // Encoding: 0xC4DEC000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zm_31_max_c000_c4dfc000() {
    // Encoding: 0xC4DFC000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=31
    let encoding: u32 = 0xC4DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_pg_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_c000_c4c0c400() {
    // Encoding: 0xC4C0C400
    // Test LD1H_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_c000_c4c0c020() {
    // Encoding: 0xC4C0C020
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=1
    let encoding: u32 = 0xC4C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_c000_c4c0c3c0() {
    // Encoding: 0xC4C0C3C0
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_rn_31_max_c000_c4c0c3e0() {
    // Encoding: 0xC4C0C3E0
    // Test LD1H_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, Zm=0
    let encoding: u32 = 0xC4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_0_min_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_c000_c4c0c001() {
    // Encoding: 0xC4C0C001
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xC4C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_c000_c4c0c01e() {
    // Encoding: 0xC4C0C01E
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xC4C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_field_zt_31_max_c000_c4c0c01f() {
    // Encoding: 0xC4C0C01F
    // Test LD1H_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0
    let encoding: u32 = 0xC4C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_0_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_1_c000_c4c1c000() {
    // Encoding: 0xC4C1C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=1, Rn=0
    let encoding: u32 = 0xC4C1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_2_c000_c4dec000() {
    // Encoding: 0xC4DEC000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=30, Pg=0, Rn=0, Zt=0
    // Fields: Zm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4DEC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_3_c000_c4dfc000() {
    // Encoding: 0xC4DFC000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=31, Pg=0, Rn=0, Zt=0
    // Fields: Zm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xC4DFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_4_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_5_c000_c4c0c400() {
    // Encoding: 0xC4C0C400
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Zm=0, Pg=1
    let encoding: u32 = 0xC4C0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_6_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_7_c000_c4c0c020() {
    // Encoding: 0xC4C0C020
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=1, Zt=0
    // Fields: Zm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xC4C0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_8_c000_c4c0c3c0() {
    // Encoding: 0xC4C0C3C0
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Zm=0, Rn=30, Zt=0
    let encoding: u32 = 0xC4C0C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_9_c000_c4c0c3e0() {
    // Encoding: 0xC4C0C3E0
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=31, Zt=0
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0xC4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_10_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_11_c000_c4c0c001() {
    // Encoding: 0xC4C0C001
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=1
    // Fields: Zt=1, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xC4C0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_12_c000_c4c0c01e() {
    // Encoding: 0xC4C0C01E
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=30
    // Fields: Zt=30, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xC4C0C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_13_c000_c4c0c01f() {
    // Encoding: 0xC4C0C01F
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=31
    // Fields: Pg=0, Rn=0, Zm=0, Zt=31
    let encoding: u32 = 0xC4C0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_14_c000_c4c0c420() {
    // Encoding: 0xC4C0C420
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=1, Rn=1, Zt=0
    // Fields: Zm=0, Rn=1, Zt=0, Pg=1
    let encoding: u32 = 0xC4C0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_combo_15_c000_c4c0dfe0() {
    // Encoding: 0xC4C0DFE0
    // Test LD1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=31, Rn=31, Zt=0
    // Fields: Rn=31, Pg=31, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_49152_c4c0c3e0() {
    // Encoding: 0xC4C0C3E0
    // Test LD1H_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xC4C0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_invalid_0_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_invalid_1_c000_c4c0c000() {
    // Encoding: 0xC4C0C000
    // Test LD1H_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xC4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_reg_write_0_84a04000() {
    // Test LD1H_Z.P.BZ_S.x32.scaled register write: SimdFromField("t")
    // Encoding: 0x84A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_s_x32_scaled_sp_rn_84a043e0() {
    // Test LD1H_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0x84A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_reg_write_0_c4a04000() {
    // Test LD1H_Z.P.BZ_D.x32.scaled register write: SimdFromField("t")
    // Encoding: 0xC4A04000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A04000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_x32_scaled_sp_rn_c4a043e0() {
    // Test LD1H_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xC4A043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4A043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_reg_write_0_c4804000() {
    // Test LD1H_Z.P.BZ_D.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_x32_unscaled_sp_rn_c48043e0() {
    // Test LD1H_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xC48043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC48043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_reg_write_0_84804000() {
    // Test LD1H_Z.P.BZ_S.x32.unscaled register write: SimdFromField("t")
    // Encoding: 0x84804000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x84804000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_s_x32_unscaled_sp_rn_848043e0() {
    // Test LD1H_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0x848043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x848043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_reg_write_0_c4e0c000() {
    // Test LD1H_Z.P.BZ_D.64.scaled register write: SimdFromField("t")
    // Encoding: 0xC4E0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_64_scaled_sp_rn_c4e0c3e0() {
    // Test LD1H_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xC4E0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4E0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `SimdFromField("t") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("t")
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_reg_write_0_c4c0c000() {
    // Test LD1H_Z.P.BZ_D.64.unscaled register write: SimdFromField("t")
    // Encoding: 0xC4C0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LD1H_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_ld1h_z_p_bz_d_64_unscaled_sp_rn_c4c0c3e0() {
    // Test LD1H_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xC4C0C3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xC4C0C3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqdecp_z_p_z_field_size_0_min_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqdecp_z_p_z_field_size_1_poweroftwo_8000_256b8000() {
    // Encoding: 0x256B8000
    // Test UQDECP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x256B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqdecp_z_p_z_field_size_2_poweroftwo_8000_25ab8000() {
    // Encoding: 0x25AB8000
    // Test UQDECP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zdn=0
    let encoding: u32 = 0x25AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqdecp_z_p_z_field_size_3_max_8000_25eb8000() {
    // Encoding: 0x25EB8000
    // Test UQDECP_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x25EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqdecp_z_p_z_field_pg_0_min_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqdecp_z_p_z_field_pg_1_poweroftwo_8000_252b8020() {
    // Encoding: 0x252B8020
    // Test UQDECP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zdn=0
    let encoding: u32 = 0x252B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecp_z_p_z_field_zdn_0_min_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecp_z_p_z_field_zdn_1_poweroftwo_8000_252b8001() {
    // Encoding: 0x252B8001
    // Test UQDECP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, Pg=0
    let encoding: u32 = 0x252B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecp_z_p_z_field_zdn_15_poweroftwominusone_8000_252b800f() {
    // Encoding: 0x252B800F
    // Test UQDECP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zdn=15
    let encoding: u32 = 0x252B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecp_z_p_z_field_zdn_31_max_8000_252b801f() {
    // Encoding: 0x252B801F
    // Test UQDECP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31
    let encoding: u32 = 0x252B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqdecp_z_p_z_combo_0_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_uqdecp_z_p_z_combo_1_8000_256b8000() {
    // Encoding: 0x256B8000
    // Test UQDECP_Z.P.Z__ field combination: size=1, Pg=0, Zdn=0
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_uqdecp_z_p_z_combo_2_8000_25ab8000() {
    // Encoding: 0x25AB8000
    // Test UQDECP_Z.P.Z__ field combination: size=2, Pg=0, Zdn=0
    // Fields: size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x25AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_uqdecp_z_p_z_combo_3_8000_25eb8000() {
    // Encoding: 0x25EB8000
    // Test UQDECP_Z.P.Z__ field combination: size=3, Pg=0, Zdn=0
    // Fields: size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x25EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_uqdecp_z_p_z_combo_4_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_uqdecp_z_p_z_combo_5_8000_252b8020() {
    // Encoding: 0x252B8020
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=1, Zdn=0
    // Fields: size=0, Zdn=0, Pg=1
    let encoding: u32 = 0x252B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_uqdecp_z_p_z_combo_6_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_uqdecp_z_p_z_combo_7_8000_252b8001() {
    // Encoding: 0x252B8001
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=1
    // Fields: size=0, Zdn=1, Pg=0
    let encoding: u32 = 0x252B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_uqdecp_z_p_z_combo_8_8000_252b800f() {
    // Encoding: 0x252B800F
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=15
    // Fields: Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x252B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_uqdecp_z_p_z_combo_9_8000_252b801f() {
    // Encoding: 0x252B801F
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=31
    // Fields: size=0, Zdn=31, Pg=0
    let encoding: u32 = 0x252B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqdecp_z_p_z_special_size_0_size_variant_0_32768_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqdecp_z_p_z_special_size_1_size_variant_1_32768_256b8000() {
    // Encoding: 0x256B8000
    // Test UQDECP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x256B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqdecp_z_p_z_special_size_2_size_variant_2_32768_25ab8000() {
    // Encoding: 0x25AB8000
    // Test UQDECP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x25AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqdecp_z_p_z_special_size_3_size_variant_3_32768_25eb8000() {
    // Encoding: 0x25EB8000
    // Test UQDECP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x25EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_0_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_1_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_2_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_3_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqdecp_z_p_z_reg_write_0_252b8000() {
    // Test UQDECP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x252B8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252B8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CPY_Z.P.V__ Tests
// ============================================================================

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cpy_z_p_v_field_size_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field size = 0 (Min)
    // Fields: size=0, Zd=0, Vn=0, Pg=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cpy_z_p_v_field_size_1_poweroftwo_8000_05608000() {
    // Encoding: 0x05608000
    // Test CPY_Z.P.V__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Vn=0, size=1, Pg=0
    let encoding: u32 = 0x05608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cpy_z_p_v_field_size_2_poweroftwo_8000_05a08000() {
    // Encoding: 0x05A08000
    // Test CPY_Z.P.V__ field size = 2 (PowerOfTwo)
    // Fields: Vn=0, size=2, Zd=0, Pg=0
    let encoding: u32 = 0x05A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cpy_z_p_v_field_size_3_max_8000_05e08000() {
    // Encoding: 0x05E08000
    // Test CPY_Z.P.V__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Zd=0, Vn=0
    let encoding: u32 = 0x05E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cpy_z_p_v_field_pg_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, size=0, Vn=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cpy_z_p_v_field_pg_1_poweroftwo_8000_05208400() {
    // Encoding: 0x05208400
    // Test CPY_Z.P.V__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Vn=0, Zd=0, size=0
    let encoding: u32 = 0x05208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cpy_z_p_v_field_vn_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field Vn = 0 (Min)
    // Fields: Zd=0, Pg=0, size=0, Vn=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cpy_z_p_v_field_vn_1_poweroftwo_8000_05208020() {
    // Encoding: 0x05208020
    // Test CPY_Z.P.V__ field Vn = 1 (PowerOfTwo)
    // Fields: Vn=1, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x05208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cpy_z_p_v_field_vn_30_poweroftwominusone_8000_052083c0() {
    // Encoding: 0x052083C0
    // Test CPY_Z.P.V__ field Vn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zd=0, Vn=30
    let encoding: u32 = 0x052083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cpy_z_p_v_field_vn_31_max_8000_052083e0() {
    // Encoding: 0x052083E0
    // Test CPY_Z.P.V__ field Vn = 31 (Max)
    // Fields: Zd=0, size=0, Vn=31, Pg=0
    let encoding: u32 = 0x052083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cpy_z_p_v_field_zd_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field Zd = 0 (Min)
    // Fields: Vn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cpy_z_p_v_field_zd_1_poweroftwo_8000_05208001() {
    // Encoding: 0x05208001
    // Test CPY_Z.P.V__ field Zd = 1 (PowerOfTwo)
    // Fields: Vn=0, size=0, Pg=0, Zd=1
    let encoding: u32 = 0x05208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cpy_z_p_v_field_zd_30_poweroftwominusone_8000_0520801e() {
    // Encoding: 0x0520801E
    // Test CPY_Z.P.V__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vn=0, Pg=0, Zd=30
    let encoding: u32 = 0x0520801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cpy_z_p_v_field_zd_31_max_8000_0520801f() {
    // Encoding: 0x0520801F
    // Test CPY_Z.P.V__ field Zd = 31 (Max)
    // Fields: Zd=31, Vn=0, Pg=0, size=0
    let encoding: u32 = 0x0520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cpy_z_p_v_combo_0_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=0
    // Fields: size=0, Vn=0, Pg=0, Zd=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_cpy_z_p_v_combo_1_8000_05608000() {
    // Encoding: 0x05608000
    // Test CPY_Z.P.V__ field combination: size=1, Pg=0, Vn=0, Zd=0
    // Fields: Vn=0, Pg=0, Zd=0, size=1
    let encoding: u32 = 0x05608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_cpy_z_p_v_combo_2_8000_05a08000() {
    // Encoding: 0x05A08000
    // Test CPY_Z.P.V__ field combination: size=2, Pg=0, Vn=0, Zd=0
    // Fields: Vn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x05A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_cpy_z_p_v_combo_3_8000_05e08000() {
    // Encoding: 0x05E08000
    // Test CPY_Z.P.V__ field combination: size=3, Pg=0, Vn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=3, Vn=0
    let encoding: u32 = 0x05E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_cpy_z_p_v_combo_4_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=0
    // Fields: Vn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_cpy_z_p_v_combo_5_8000_05208400() {
    // Encoding: 0x05208400
    // Test CPY_Z.P.V__ field combination: size=0, Pg=1, Vn=0, Zd=0
    // Fields: size=0, Vn=0, Pg=1, Zd=0
    let encoding: u32 = 0x05208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=0 (SIMD register V0)
#[test]
fn test_cpy_z_p_v_combo_6_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=0
    // Fields: size=0, Zd=0, Vn=0, Pg=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=1 (SIMD register V1)
#[test]
fn test_cpy_z_p_v_combo_7_8000_05208020() {
    // Encoding: 0x05208020
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=1, Zd=0
    // Fields: size=0, Pg=0, Vn=1, Zd=0
    let encoding: u32 = 0x05208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=30 (SIMD register V30)
#[test]
fn test_cpy_z_p_v_combo_8_8000_052083c0() {
    // Encoding: 0x052083C0
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=30, Zd=0
    // Fields: Pg=0, Vn=30, size=0, Zd=0
    let encoding: u32 = 0x052083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Vn=31 (SIMD register V31)
#[test]
fn test_cpy_z_p_v_combo_9_8000_052083e0() {
    // Encoding: 0x052083E0
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=31, Zd=0
    // Fields: size=0, Pg=0, Vn=31, Zd=0
    let encoding: u32 = 0x052083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_cpy_z_p_v_combo_10_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=0
    // Fields: Pg=0, size=0, Vn=0, Zd=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_cpy_z_p_v_combo_11_8000_05208001() {
    // Encoding: 0x05208001
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=1
    // Fields: Pg=0, size=0, Vn=0, Zd=1
    let encoding: u32 = 0x05208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_cpy_z_p_v_combo_12_8000_0520801e() {
    // Encoding: 0x0520801E
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=30
    // Fields: Pg=0, Zd=30, Vn=0, size=0
    let encoding: u32 = 0x0520801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=31 (SIMD register V31)
#[test]
fn test_cpy_z_p_v_combo_13_8000_0520801f() {
    // Encoding: 0x0520801F
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=31
    // Fields: Pg=0, size=0, Zd=31, Vn=0
    let encoding: u32 = 0x0520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cpy_z_p_v_special_size_0_size_variant_0_32768_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ special value size = 0 (Size variant 0)
    // Fields: Vn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cpy_z_p_v_special_size_1_size_variant_1_32768_05608000() {
    // Encoding: 0x05608000
    // Test CPY_Z.P.V__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Vn=0, Zd=0, size=1
    let encoding: u32 = 0x05608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cpy_z_p_v_special_size_2_size_variant_2_32768_05a08000() {
    // Encoding: 0x05A08000
    // Test CPY_Z.P.V__ special value size = 2 (Size variant 2)
    // Fields: Vn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x05A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cpy_z_p_v_special_size_3_size_variant_3_32768_05e08000() {
    // Encoding: 0x05E08000
    // Test CPY_Z.P.V__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Vn=0, Zd=0
    let encoding: u32 = 0x05E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_v_invalid_0_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zd=0, Vn=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_v_invalid_1_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Vn=0, Zd=0, size=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: CPY_Z.P.V__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cpy_z_p_v_reg_write_0_05208000() {
    // Test CPY_Z.P.V__ register write: SimdFromField("d")
    // Encoding: 0x05208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4816000() {
    // Encoding: 0xE4816000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xE4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e49e6000() {
    // Encoding: 0xE49E6000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Pg=0, Zt=0
    let encoding: u32 = 0xE49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_31_max_6000_e49f6000() {
    // Encoding: 0xE49F6000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Rm=31, Pg=0
    let encoding: u32 = 0xE49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_pg_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4806400() {
    // Encoding: 0xE4806400
    // Test STNT1H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4806020() {
    // Encoding: 0xE4806020
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, Rm=0
    let encoding: u32 = 0xE4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e48063c0() {
    // Encoding: 0xE48063C0
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Rm=0
    let encoding: u32 = 0xE48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_31_max_6000_e48063e0() {
    // Encoding: 0xE48063E0
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xE48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4806001() {
    // Encoding: 0xE4806001
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=1
    let encoding: u32 = 0xE4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e480601e() {
    // Encoding: 0xE480601E
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=30, Rn=0
    let encoding: u32 = 0xE480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_31_max_6000_e480601f() {
    // Encoding: 0xE480601F
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_0_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_1_6000_e4816000() {
    // Encoding: 0xE4816000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xE4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_2_6000_e49e6000() {
    // Encoding: 0xE49E6000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=30, Pg=0, Rn=0, Zt=0
    // Fields: Rm=30, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_3_6000_e49f6000() {
    // Encoding: 0xE49F6000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=31, Zt=0
    let encoding: u32 = 0xE49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_4_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_5_6000_e4806400() {
    // Encoding: 0xE4806400
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xE4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=0 (register index 0 (first register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_6_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=1 (register index 1 (second register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_7_6000_e4806020() {
    // Encoding: 0xE4806020
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=1, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xE4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=30 (register index 30 (LR in some contexts))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_8_6000_e48063c0() {
    // Encoding: 0xE48063C0
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=30, Zt=0
    // Fields: Pg=0, Rm=0, Rn=30, Zt=0
    let encoding: u32 = 0xE48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rn=31 (register index 31 (SP - stack pointer))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_9_6000_e48063e0() {
    // Encoding: 0xE48063E0
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=31, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xE48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=0 (SIMD register V0)
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_10_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=1 (SIMD register V1)
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_11_6000_e4806001() {
    // Encoding: 0xE4806001
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=1
    // Fields: Pg=0, Rm=0, Zt=1, Rn=0
    let encoding: u32 = 0xE4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=30 (SIMD register V30)
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_12_6000_e480601e() {
    // Encoding: 0xE480601E
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=30
    // Fields: Pg=0, Zt=30, Rn=0, Rm=0
    let encoding: u32 = 0xE480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zt=31 (SIMD register V31)
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_13_6000_e480601f() {
    // Encoding: 0xE480601F
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=31
    // Fields: Zt=31, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Pg=1 (same register test (reg=1))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_14_6000_e4816400() {
    // Encoding: 0xE4816400
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=1, Pg=1, Rn=0, Zt=0
    // Fields: Rm=1, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xE4816400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Pg=31 (same register test (reg=31))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_15_6000_e49f7c00() {
    // Encoding: 0xE49F7C00
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=31, Pg=31, Rn=0, Zt=0
    // Fields: Rm=31, Zt=0, Rn=0, Pg=31
    let encoding: u32 = 0xE49F7C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_16_6000_e4816020() {
    // Encoding: 0xE4816020
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=1, Pg=0, Rn=1, Zt=0
    // Fields: Rn=1, Pg=0, Zt=0, Rm=1
    let encoding: u32 = 0xE4816020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_17_6000_e49f63e0() {
    // Encoding: 0xE49F63E0
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=31, Pg=0, Rn=31, Zt=0
    // Fields: Rn=31, Rm=31, Pg=0, Zt=0
    let encoding: u32 = 0xE49F63E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (same register test (reg=1)), Rn=1 (same register test (reg=1))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_18_6000_e4806420() {
    // Encoding: 0xE4806420
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=1, Rn=1, Zt=0
    // Fields: Rn=1, Pg=1, Rm=0, Zt=0
    let encoding: u32 = 0xE4806420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=31 (same register test (reg=31)), Rn=31 (same register test (reg=31))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_19_6000_e4807fe0() {
    // Encoding: 0xE4807FE0
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=31, Rn=31, Zt=0
    // Fields: Zt=0, Pg=31, Rn=31, Rm=0
    let encoding: u32 = 0xE4807FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e48063e0() {
    // Encoding: 0xE48063E0
    // Test STNT1H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_0_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_1_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_2_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_3_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1h_z_p_br_contiguous_sp_rn_e48063e0() {
    // Test STNT1H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE48063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE48063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1h_z_p_br_contiguous_store_0_e4806020() {
    // Test STNT1H_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4806020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4806020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.P.ZI__ Tests
// ============================================================================

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zi_field_tszh_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field tszh = 0 (Min)
    // Fields: imm3=0, Zdn=0, tszh=0, tszl=0, Pg=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zi_field_tszh_1_poweroftwo_8000_04438000() {
    // Encoding: 0x04438000
    // Test LSL_Z.P.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: Zdn=0, tszl=0, Pg=0, imm3=0, tszh=1
    let encoding: u32 = 0x04438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_p_zi_field_tszh_3_max_8000_04c38000() {
    // Encoding: 0x04C38000
    // Test LSL_Z.P.ZI__ field tszh = 3 (Max)
    // Fields: tszh=3, Pg=0, tszl=0, Zdn=0, imm3=0
    let encoding: u32 = 0x04C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsl_z_p_zi_field_pg_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field Pg = 0 (Min)
    // Fields: tszl=0, Pg=0, Zdn=0, imm3=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsl_z_p_zi_field_pg_1_poweroftwo_8000_04038400() {
    // Encoding: 0x04038400
    // Test LSL_Z.P.ZI__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=1, imm3=0, tszh=0, tszl=0
    let encoding: u32 = 0x04038400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zi_field_tszl_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field tszl = 0 (Min)
    // Fields: tszh=0, imm3=0, tszl=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zi_field_tszl_1_poweroftwo_8000_04038100() {
    // Encoding: 0x04038100
    // Test LSL_Z.P.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: tszh=0, Pg=0, Zdn=0, imm3=0, tszl=1
    let encoding: u32 = 0x04038100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_p_zi_field_tszl_3_max_8000_04038300() {
    // Encoding: 0x04038300
    // Test LSL_Z.P.ZI__ field tszl = 3 (Max)
    // Fields: Zdn=0, Pg=0, imm3=0, tszh=0, tszl=3
    let encoding: u32 = 0x04038300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsl_z_p_zi_field_imm3_0_zero_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field imm3 = 0 (Zero)
    // Fields: tszl=0, Zdn=0, imm3=0, Pg=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsl_z_p_zi_field_imm3_1_poweroftwo_8000_04038020() {
    // Encoding: 0x04038020
    // Test LSL_Z.P.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszl=0, Zdn=0, tszh=0, imm3=1, Pg=0
    let encoding: u32 = 0x04038020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsl_z_p_zi_field_imm3_3_poweroftwominusone_8000_04038060() {
    // Encoding: 0x04038060
    // Test LSL_Z.P.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszh=0, tszl=0, Pg=0, Zdn=0, imm3=3
    let encoding: u32 = 0x04038060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsl_z_p_zi_field_imm3_7_max_8000_040380e0() {
    // Encoding: 0x040380E0
    // Test LSL_Z.P.ZI__ field imm3 = 7 (Max)
    // Fields: tszl=0, Pg=0, tszh=0, imm3=7, Zdn=0
    let encoding: u32 = 0x040380E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zi_field_zdn_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field Zdn = 0 (Min)
    // Fields: tszl=0, tszh=0, Pg=0, Zdn=0, imm3=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zi_field_zdn_1_poweroftwo_8000_04038001() {
    // Encoding: 0x04038001
    // Test LSL_Z.P.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: tszl=0, Zdn=1, Pg=0, imm3=0, tszh=0
    let encoding: u32 = 0x04038001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsl_z_p_zi_field_zdn_15_poweroftwominusone_8000_0403800f() {
    // Encoding: 0x0403800F
    // Test LSL_Z.P.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: tszl=0, tszh=0, Pg=0, imm3=0, Zdn=15
    let encoding: u32 = 0x0403800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsl_z_p_zi_field_zdn_31_max_8000_0403801f() {
    // Encoding: 0x0403801F
    // Test LSL_Z.P.ZI__ field Zdn = 31 (Max)
    // Fields: imm3=0, Zdn=31, tszh=0, Pg=0, tszl=0
    let encoding: u32 = 0x0403801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsl_z_p_zi_combo_0_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Pg=0, tszh=0, imm3=0, tszl=0, Zdn=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=1 (value 1)
#[test]
fn test_lsl_z_p_zi_combo_1_8000_04438000() {
    // Encoding: 0x04438000
    // Test LSL_Z.P.ZI__ field combination: tszh=1, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszl=0, Pg=0, imm3=0, Zdn=0, tszh=1
    let encoding: u32 = 0x04438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=3 (maximum value (3))
#[test]
fn test_lsl_z_p_zi_combo_2_8000_04c38000() {
    // Encoding: 0x04C38000
    // Test LSL_Z.P.ZI__ field combination: tszh=3, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=3, Pg=0, tszl=0, Zdn=0, imm3=0
    let encoding: u32 = 0x04C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_lsl_z_p_zi_combo_3_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: imm3=0, Pg=0, Zdn=0, tszl=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=1 (register index 1 (second register))
#[test]
fn test_lsl_z_p_zi_combo_4_8000_04038400() {
    // Encoding: 0x04038400
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=1, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=0, tszl=0, imm3=0, Pg=1, Zdn=0
    let encoding: u32 = 0x04038400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=0 (minimum value)
#[test]
fn test_lsl_z_p_zi_combo_5_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=0, tszl=0, Zdn=0, imm3=0, Pg=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=1 (value 1)
#[test]
fn test_lsl_z_p_zi_combo_6_8000_04038100() {
    // Encoding: 0x04038100
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=1, imm3=0, Zdn=0
    // Fields: tszh=0, tszl=1, imm3=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04038100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszl=3 (maximum value (3))
#[test]
fn test_lsl_z_p_zi_combo_7_8000_04038300() {
    // Encoding: 0x04038300
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=3, imm3=0, Zdn=0
    // Fields: tszh=0, imm3=0, Zdn=0, Pg=0, tszl=3
    let encoding: u32 = 0x04038300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=0 (immediate value 0)
#[test]
fn test_lsl_z_p_zi_combo_8_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Zdn=0, Pg=0, tszl=0, tszh=0, imm3=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=1 (immediate value 1)
#[test]
fn test_lsl_z_p_zi_combo_9_8000_04038020() {
    // Encoding: 0x04038020
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=1, Zdn=0
    // Fields: Zdn=0, tszl=0, Pg=0, tszh=0, imm3=1
    let encoding: u32 = 0x04038020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=3 (immediate midpoint (3))
#[test]
fn test_lsl_z_p_zi_combo_10_8000_04038060() {
    // Encoding: 0x04038060
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=3, Zdn=0
    // Fields: Pg=0, imm3=3, Zdn=0, tszh=0, tszl=0
    let encoding: u32 = 0x04038060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm3=7 (maximum immediate (7))
#[test]
fn test_lsl_z_p_zi_combo_11_8000_040380e0() {
    // Encoding: 0x040380E0
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=7, Zdn=0
    // Fields: Pg=0, imm3=7, tszl=0, tszh=0, Zdn=0
    let encoding: u32 = 0x040380E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=0 (minimum value)
#[test]
fn test_lsl_z_p_zi_combo_12_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszl=0, imm3=0, tszh=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=1 (value 1)
#[test]
fn test_lsl_z_p_zi_combo_13_8000_04038001() {
    // Encoding: 0x04038001
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=1
    // Fields: imm3=0, tszh=0, Zdn=1, tszl=0, Pg=0
    let encoding: u32 = 0x04038001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=15 (midpoint (15))
#[test]
fn test_lsl_z_p_zi_combo_14_8000_0403800f() {
    // Encoding: 0x0403800F
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=15
    // Fields: imm3=0, tszl=0, tszh=0, Pg=0, Zdn=15
    let encoding: u32 = 0x0403800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zdn=31 (maximum value (31))
#[test]
fn test_lsl_z_p_zi_combo_15_8000_0403801f() {
    // Encoding: 0x0403801F
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=31
    // Fields: Zdn=31, tszl=0, Pg=0, imm3=0, tszh=0
    let encoding: u32 = 0x0403801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zi_invalid_0_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, tszl=0, imm3=0, Zdn=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zi_invalid_1_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm3=0, tszl=0, tszh=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zi_invalid_2_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm3=0, Pg=0, Zdn=0, tszl=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsl_z_p_zi_reg_write_0_04038000() {
    // Test LSL_Z.P.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x04038000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04038000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INDEX_Z.IR__ Tests
// ============================================================================

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_index_z_ir_field_size_0_min_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field size = 0 (Min)
    // Fields: size=0, imm5=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_index_z_ir_field_size_1_poweroftwo_4800_04604800() {
    // Encoding: 0x04604800
    // Test INDEX_Z.IR__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, imm5=0, Rm=0
    let encoding: u32 = 0x04604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_index_z_ir_field_size_2_poweroftwo_4800_04a04800() {
    // Encoding: 0x04A04800
    // Test INDEX_Z.IR__ field size = 2 (PowerOfTwo)
    // Fields: imm5=0, Rm=0, Zd=0, size=2
    let encoding: u32 = 0x04A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_index_z_ir_field_size_3_max_4800_04e04800() {
    // Encoding: 0x04E04800
    // Test INDEX_Z.IR__ field size = 3 (Max)
    // Fields: imm5=0, size=3, Rm=0, Zd=0
    let encoding: u32 = 0x04E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_index_z_ir_field_rm_0_min_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field Rm = 0 (Min)
    // Fields: imm5=0, size=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_index_z_ir_field_rm_1_poweroftwo_4800_04214800() {
    // Encoding: 0x04214800
    // Test INDEX_Z.IR__ field Rm = 1 (PowerOfTwo)
    // Fields: imm5=0, Zd=0, size=0, Rm=1
    let encoding: u32 = 0x04214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_index_z_ir_field_rm_30_poweroftwominusone_4800_043e4800() {
    // Encoding: 0x043E4800
    // Test INDEX_Z.IR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zd=0, size=0, imm5=0
    let encoding: u32 = 0x043E4800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_index_z_ir_field_rm_31_max_4800_043f4800() {
    // Encoding: 0x043F4800
    // Test INDEX_Z.IR__ field Rm = 31 (Max)
    // Fields: size=0, Rm=31, Zd=0, imm5=0
    let encoding: u32 = 0x043F4800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_index_z_ir_field_imm5_0_zero_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field imm5 = 0 (Zero)
    // Fields: size=0, imm5=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_index_z_ir_field_imm5_1_poweroftwo_4800_04204820() {
    // Encoding: 0x04204820
    // Test INDEX_Z.IR__ field imm5 = 1 (PowerOfTwo)
    // Fields: Rm=0, imm5=1, size=0, Zd=0
    let encoding: u32 = 0x04204820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_index_z_ir_field_imm5_3_poweroftwominusone_4800_04204860() {
    // Encoding: 0x04204860
    // Test INDEX_Z.IR__ field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zd=0, imm5=3, Rm=0, size=0
    let encoding: u32 = 0x04204860;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_index_z_ir_field_imm5_4_poweroftwo_4800_04204880() {
    // Encoding: 0x04204880
    // Test INDEX_Z.IR__ field imm5 = 4 (PowerOfTwo)
    // Fields: Rm=0, imm5=4, Zd=0, size=0
    let encoding: u32 = 0x04204880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_index_z_ir_field_imm5_7_poweroftwominusone_4800_042048e0() {
    // Encoding: 0x042048E0
    // Test INDEX_Z.IR__ field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, imm5=7, Zd=0, Rm=0
    let encoding: u32 = 0x042048E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_index_z_ir_field_imm5_8_poweroftwo_4800_04204900() {
    // Encoding: 0x04204900
    // Test INDEX_Z.IR__ field imm5 = 8 (PowerOfTwo)
    // Fields: size=0, imm5=8, Rm=0, Zd=0
    let encoding: u32 = 0x04204900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_index_z_ir_field_imm5_15_poweroftwominusone_4800_042049e0() {
    // Encoding: 0x042049E0
    // Test INDEX_Z.IR__ field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Rm=0, imm5=15, size=0, Zd=0
    let encoding: u32 = 0x042049E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_index_z_ir_field_imm5_16_poweroftwo_4800_04204a00() {
    // Encoding: 0x04204A00
    // Test INDEX_Z.IR__ field imm5 = 16 (PowerOfTwo)
    // Fields: Zd=0, imm5=16, size=0, Rm=0
    let encoding: u32 = 0x04204A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_index_z_ir_field_imm5_31_max_4800_04204be0() {
    // Encoding: 0x04204BE0
    // Test INDEX_Z.IR__ field imm5 = 31 (Max)
    // Fields: Rm=0, imm5=31, Zd=0, size=0
    let encoding: u32 = 0x04204BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_index_z_ir_field_zd_0_min_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field Zd = 0 (Min)
    // Fields: size=0, Rm=0, Zd=0, imm5=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_index_z_ir_field_zd_1_poweroftwo_4800_04204801() {
    // Encoding: 0x04204801
    // Test INDEX_Z.IR__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Rm=0, imm5=0, size=0
    let encoding: u32 = 0x04204801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_index_z_ir_field_zd_30_poweroftwominusone_4800_0420481e() {
    // Encoding: 0x0420481E
    // Test INDEX_Z.IR__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zd=30, imm5=0, size=0
    let encoding: u32 = 0x0420481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_index_z_ir_field_zd_31_max_4800_0420481f() {
    // Encoding: 0x0420481F
    // Test INDEX_Z.IR__ field Zd = 31 (Max)
    // Fields: Zd=31, imm5=0, Rm=0, size=0
    let encoding: u32 = 0x0420481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_index_z_ir_combo_0_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=0
    // Fields: size=0, Rm=0, imm5=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 1`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=1 (16-bit / halfword size)
#[test]
fn test_index_z_ir_combo_1_4800_04604800() {
    // Encoding: 0x04604800
    // Test INDEX_Z.IR__ field combination: size=1, Rm=0, imm5=0, Zd=0
    // Fields: size=1, Zd=0, Rm=0, imm5=0
    let encoding: u32 = 0x04604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 2`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=2 (32-bit / word size)
#[test]
fn test_index_z_ir_combo_2_4800_04a04800() {
    // Encoding: 0x04A04800
    // Test INDEX_Z.IR__ field combination: size=2, Rm=0, imm5=0, Zd=0
    // Fields: imm5=0, size=2, Zd=0, Rm=0
    let encoding: u32 = 0x04A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 3`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=3 (64-bit / doubleword size)
#[test]
fn test_index_z_ir_combo_3_4800_04e04800() {
    // Encoding: 0x04E04800
    // Test INDEX_Z.IR__ field combination: size=3, Rm=0, imm5=0, Zd=0
    // Fields: Rm=0, size=3, imm5=0, Zd=0
    let encoding: u32 = 0x04E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 4`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_index_z_ir_combo_4_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=0
    // Fields: size=0, imm5=0, Zd=0, Rm=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 5`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=1 (register index 1 (second register))
#[test]
fn test_index_z_ir_combo_5_4800_04214800() {
    // Encoding: 0x04214800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=1, imm5=0, Zd=0
    // Fields: imm5=0, size=0, Zd=0, Rm=1
    let encoding: u32 = 0x04214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 6`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=30 (register index 30 (LR in some contexts))
#[test]
fn test_index_z_ir_combo_6_4800_043e4800() {
    // Encoding: 0x043E4800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=30, imm5=0, Zd=0
    // Fields: size=0, Rm=30, imm5=0, Zd=0
    let encoding: u32 = 0x043E4800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 7`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=31 (register index 31 (special))
#[test]
fn test_index_z_ir_combo_7_4800_043f4800() {
    // Encoding: 0x043F4800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=31, imm5=0, Zd=0
    // Fields: Zd=0, imm5=0, size=0, Rm=31
    let encoding: u32 = 0x043F4800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 8`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_index_z_ir_combo_8_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=0
    // Fields: imm5=0, size=0, Zd=0, Rm=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 9`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=1 (immediate value 1)
#[test]
fn test_index_z_ir_combo_9_4800_04204820() {
    // Encoding: 0x04204820
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=1, Zd=0
    // Fields: imm5=1, size=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 10`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=3 (2^2 - 1 = 3)
#[test]
fn test_index_z_ir_combo_10_4800_04204860() {
    // Encoding: 0x04204860
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=3, Zd=0
    // Fields: Rm=0, imm5=3, Zd=0, size=0
    let encoding: u32 = 0x04204860;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 11`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=4 (power of 2 (2^2 = 4))
#[test]
fn test_index_z_ir_combo_11_4800_04204880() {
    // Encoding: 0x04204880
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=4, Zd=0
    // Fields: imm5=4, Rm=0, size=0, Zd=0
    let encoding: u32 = 0x04204880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 12`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=7 (2^3 - 1 = 7)
#[test]
fn test_index_z_ir_combo_12_4800_042048e0() {
    // Encoding: 0x042048E0
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=7, Zd=0
    // Fields: Rm=0, imm5=7, Zd=0, size=0
    let encoding: u32 = 0x042048E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 13`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=8 (power of 2 (2^3 = 8))
#[test]
fn test_index_z_ir_combo_13_4800_04204900() {
    // Encoding: 0x04204900
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=8, Zd=0
    // Fields: size=0, imm5=8, Rm=0, Zd=0
    let encoding: u32 = 0x04204900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 14`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=15 (immediate midpoint (15))
#[test]
fn test_index_z_ir_combo_14_4800_042049e0() {
    // Encoding: 0x042049E0
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=15, Zd=0
    // Fields: size=0, imm5=15, Zd=0, Rm=0
    let encoding: u32 = 0x042049E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 15`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=16 (power of 2 (2^4 = 16))
#[test]
fn test_index_z_ir_combo_15_4800_04204a00() {
    // Encoding: 0x04204A00
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=16, Zd=0
    // Fields: size=0, Rm=0, imm5=16, Zd=0
    let encoding: u32 = 0x04204A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 16`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=31 (maximum immediate (31))
#[test]
fn test_index_z_ir_combo_16_4800_04204be0() {
    // Encoding: 0x04204BE0
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=31, Zd=0
    // Fields: imm5=31, size=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 17`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=0 (SIMD register V0)
#[test]
fn test_index_z_ir_combo_17_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=0
    // Fields: imm5=0, Rm=0, size=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 18`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=1 (SIMD register V1)
#[test]
fn test_index_z_ir_combo_18_4800_04204801() {
    // Encoding: 0x04204801
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=1
    // Fields: Rm=0, size=0, imm5=0, Zd=1
    let encoding: u32 = 0x04204801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 19`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zd=30 (SIMD register V30)
#[test]
fn test_index_z_ir_combo_19_4800_0420481e() {
    // Encoding: 0x0420481E
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=30
    // Fields: Rm=0, imm5=0, size=0, Zd=30
    let encoding: u32 = 0x0420481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_index_z_ir_special_size_0_size_variant_0_18432_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Rm=0, imm5=0, size=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_index_z_ir_special_size_1_size_variant_1_18432_04604800() {
    // Encoding: 0x04604800
    // Test INDEX_Z.IR__ special value size = 1 (Size variant 1)
    // Fields: size=1, imm5=0, Rm=0, Zd=0
    let encoding: u32 = 0x04604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_index_z_ir_special_size_2_size_variant_2_18432_04a04800() {
    // Encoding: 0x04A04800
    // Test INDEX_Z.IR__ special value size = 2 (Size variant 2)
    // Fields: imm5=0, Zd=0, Rm=0, size=2
    let encoding: u32 = 0x04A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_index_z_ir_special_size_3_size_variant_3_18432_04e04800() {
    // Encoding: 0x04E04800
    // Test INDEX_Z.IR__ special value size = 3 (Size variant 3)
    // Fields: Rm=0, imm5=0, size=3, Zd=0
    let encoding: u32 = 0x04E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_index_z_ir_invalid_0_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, Rm=0, size=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_index_z_ir_invalid_1_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, Zd=0, size=0, Rm=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: INDEX_Z.IR__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_index_z_ir_reg_write_0_04204800() {
    // Test INDEX_Z.IR__ register write: SimdFromField("d")
    // Encoding: 0x04204800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

