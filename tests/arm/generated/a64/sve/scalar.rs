//! A64 sve scalar tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// SQDECH_R.RS_SX Tests
// ============================================================================

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdech_r_rs_sx_field_imm4_0_zero_f800_0460f800() {
    // Encoding: 0x0460F800
    // Test SQDECH_R.RS_SX field imm4 = 0 (Zero)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0460F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdech_r_rs_sx_field_imm4_1_poweroftwo_f800_0461f800() {
    // Encoding: 0x0461F800
    // Test SQDECH_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0461F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdech_r_rs_sx_field_imm4_3_poweroftwominusone_f800_0463f800() {
    // Encoding: 0x0463F800
    // Test SQDECH_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x0463F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdech_r_rs_sx_field_imm4_4_poweroftwo_f800_0464f800() {
    // Encoding: 0x0464F800
    // Test SQDECH_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rdn=0
    let encoding: u32 = 0x0464F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdech_r_rs_sx_field_imm4_7_poweroftwominusone_f800_0467f800() {
    // Encoding: 0x0467F800
    // Test SQDECH_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0467F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdech_r_rs_sx_field_imm4_8_poweroftwo_f800_0468f800() {
    // Encoding: 0x0468F800
    // Test SQDECH_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0468F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdech_r_rs_sx_field_imm4_15_max_f800_046ff800() {
    // Encoding: 0x046FF800
    // Test SQDECH_R.RS_SX field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x046FF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_r_rs_sx_field_pattern_0_min_f800_0460f800() {
    // Encoding: 0x0460F800
    // Test SQDECH_R.RS_SX field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_r_rs_sx_field_pattern_1_poweroftwo_f800_0460f820() {
    // Encoding: 0x0460F820
    // Test SQDECH_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x0460F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_r_rs_sx_field_pattern_15_poweroftwominusone_f800_0460f9e0() {
    // Encoding: 0x0460F9E0
    // Test SQDECH_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x0460F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_r_rs_sx_field_pattern_31_max_f800_0460fbe0() {
    // Encoding: 0x0460FBE0
    // Test SQDECH_R.RS_SX field pattern = 31 (Max)
    // Fields: pattern=31, imm4=0, Rdn=0
    let encoding: u32 = 0x0460FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_r_rs_sx_field_rdn_0_min_f800_0460f800() {
    // Encoding: 0x0460F800
    // Test SQDECH_R.RS_SX field Rdn = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0460F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_r_rs_sx_field_rdn_1_poweroftwo_f800_0460f801() {
    // Encoding: 0x0460F801
    // Test SQDECH_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0460F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_r_rs_sx_field_rdn_15_poweroftwominusone_f800_0460f80f() {
    // Encoding: 0x0460F80F
    // Test SQDECH_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x0460F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_r_rs_sx_field_rdn_31_max_f800_0460f81f() {
    // Encoding: 0x0460F81F
    // Test SQDECH_R.RS_SX field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x0460F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdech_r_rs_sx_combo_0_f800_0460f800() {
    // Encoding: 0x0460F800
    // Test SQDECH_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0460F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdech_r_rs_sx_invalid_0_f800_0460f800() {
    // Encoding: 0x0460F800
    // Test SQDECH_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0460F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdech_r_rs_sx_invalid_1_f800_0460f800() {
    // Encoding: 0x0460F800
    // Test SQDECH_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0460F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdech_r_rs_x_field_imm4_0_zero_f800_0470f800() {
    // Encoding: 0x0470F800
    // Test SQDECH_R.RS_X field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdech_r_rs_x_field_imm4_1_poweroftwo_f800_0471f800() {
    // Encoding: 0x0471F800
    // Test SQDECH_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=1
    let encoding: u32 = 0x0471F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdech_r_rs_x_field_imm4_3_poweroftwominusone_f800_0473f800() {
    // Encoding: 0x0473F800
    // Test SQDECH_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x0473F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdech_r_rs_x_field_imm4_4_poweroftwo_f800_0474f800() {
    // Encoding: 0x0474F800
    // Test SQDECH_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x0474F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdech_r_rs_x_field_imm4_7_poweroftwominusone_f800_0477f800() {
    // Encoding: 0x0477F800
    // Test SQDECH_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0477F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdech_r_rs_x_field_imm4_8_poweroftwo_f800_0478f800() {
    // Encoding: 0x0478F800
    // Test SQDECH_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0478F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdech_r_rs_x_field_imm4_15_max_f800_047ff800() {
    // Encoding: 0x047FF800
    // Test SQDECH_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x047FF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_r_rs_x_field_pattern_0_min_f800_0470f800() {
    // Encoding: 0x0470F800
    // Test SQDECH_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0470F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_r_rs_x_field_pattern_1_poweroftwo_f800_0470f820() {
    // Encoding: 0x0470F820
    // Test SQDECH_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0470F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_r_rs_x_field_pattern_15_poweroftwominusone_f800_0470f9e0() {
    // Encoding: 0x0470F9E0
    // Test SQDECH_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Rdn=0
    let encoding: u32 = 0x0470F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_r_rs_x_field_pattern_31_max_f800_0470fbe0() {
    // Encoding: 0x0470FBE0
    // Test SQDECH_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x0470FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_r_rs_x_field_rdn_0_min_f800_0470f800() {
    // Encoding: 0x0470F800
    // Test SQDECH_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_r_rs_x_field_rdn_1_poweroftwo_f800_0470f801() {
    // Encoding: 0x0470F801
    // Test SQDECH_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0470F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_r_rs_x_field_rdn_15_poweroftwominusone_f800_0470f80f() {
    // Encoding: 0x0470F80F
    // Test SQDECH_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x0470F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_r_rs_x_field_rdn_31_max_f800_0470f81f() {
    // Encoding: 0x0470F81F
    // Test SQDECH_R.RS_X field Rdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Rdn=31
    let encoding: u32 = 0x0470F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdech_r_rs_x_combo_0_f800_0470f800() {
    // Encoding: 0x0470F800
    // Test SQDECH_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0470F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdech_r_rs_x_invalid_0_f800_0470f800() {
    // Encoding: 0x0470F800
    // Test SQDECH_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdech_r_rs_x_invalid_1_f800_0470f800() {
    // Encoding: 0x0470F800
    // Test SQDECH_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECH_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdech_r_rs_sx_reg_write_0_0460f800() {
    // Test SQDECH_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x0460F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQDECH_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdech_r_rs_x_reg_write_0_0470f800() {
    // Test SQDECH_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0470F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECW_Z.ZS__ Tests
// ============================================================================

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecw_z_zs_field_imm4_0_zero_cc00_04a0cc00() {
    // Encoding: 0x04A0CC00
    // Test UQDECW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04A0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecw_z_zs_field_imm4_1_poweroftwo_cc00_04a1cc00() {
    // Encoding: 0x04A1CC00
    // Test UQDECW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04A1CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecw_z_zs_field_imm4_3_poweroftwominusone_cc00_04a3cc00() {
    // Encoding: 0x04A3CC00
    // Test UQDECW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zdn=0, pattern=0
    let encoding: u32 = 0x04A3CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecw_z_zs_field_imm4_4_poweroftwo_cc00_04a4cc00() {
    // Encoding: 0x04A4CC00
    // Test UQDECW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Zdn=0
    let encoding: u32 = 0x04A4CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecw_z_zs_field_imm4_7_poweroftwominusone_cc00_04a7cc00() {
    // Encoding: 0x04A7CC00
    // Test UQDECW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x04A7CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecw_z_zs_field_imm4_8_poweroftwo_cc00_04a8cc00() {
    // Encoding: 0x04A8CC00
    // Test UQDECW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Zdn=0
    let encoding: u32 = 0x04A8CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecw_z_zs_field_imm4_15_max_cc00_04afcc00() {
    // Encoding: 0x04AFCC00
    // Test UQDECW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x04AFCC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_z_zs_field_pattern_0_min_cc00_04a0cc00() {
    // Encoding: 0x04A0CC00
    // Test UQDECW_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04A0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_z_zs_field_pattern_1_poweroftwo_cc00_04a0cc20() {
    // Encoding: 0x04A0CC20
    // Test UQDECW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04A0CC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_z_zs_field_pattern_15_poweroftwominusone_cc00_04a0cde0() {
    // Encoding: 0x04A0CDE0
    // Test UQDECW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04A0CDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_z_zs_field_pattern_31_max_cc00_04a0cfe0() {
    // Encoding: 0x04A0CFE0
    // Test UQDECW_Z.ZS__ field pattern = 31 (Max)
    // Fields: Zdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04A0CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_z_zs_field_zdn_0_min_cc00_04a0cc00() {
    // Encoding: 0x04A0CC00
    // Test UQDECW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_z_zs_field_zdn_1_poweroftwo_cc00_04a0cc01() {
    // Encoding: 0x04A0CC01
    // Test UQDECW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Zdn=1
    let encoding: u32 = 0x04A0CC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_z_zs_field_zdn_15_poweroftwominusone_cc00_04a0cc0f() {
    // Encoding: 0x04A0CC0F
    // Test UQDECW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=0, Zdn=15
    let encoding: u32 = 0x04A0CC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_z_zs_field_zdn_31_max_cc00_04a0cc1f() {
    // Encoding: 0x04A0CC1F
    // Test UQDECW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x04A0CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecw_z_zs_combo_0_cc00_04a0cc00() {
    // Encoding: 0x04A0CC00
    // Test UQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecw_z_zs_invalid_0_cc00_04a0cc00() {
    // Encoding: 0x04A0CC00
    // Test UQDECW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecw_z_zs_invalid_1_cc00_04a0cc00() {
    // Encoding: 0x04A0CC00
    // Test UQDECW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04A0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqdecw_z_zs_reg_write_0_04a0cc00() {
    // Test UQDECW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04A0CC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0CC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CNT_Z.P.Z__ Tests
// ============================================================================

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cnt_z_p_z_field_size_0_min_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cnt_z_p_z_field_size_1_poweroftwo_a000_045aa000() {
    // Encoding: 0x045AA000
    // Test CNT_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x045AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cnt_z_p_z_field_size_2_poweroftwo_a000_049aa000() {
    // Encoding: 0x049AA000
    // Test CNT_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, Pg=0, size=2
    let encoding: u32 = 0x049AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cnt_z_p_z_field_size_3_max_a000_04daa000() {
    // Encoding: 0x04DAA000
    // Test CNT_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zn=0, size=3, Zd=0
    let encoding: u32 = 0x04DAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cnt_z_p_z_field_pg_0_min_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cnt_z_p_z_field_pg_1_poweroftwo_a000_041aa400() {
    // Encoding: 0x041AA400
    // Test CNT_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Pg=1, Zd=0
    let encoding: u32 = 0x041AA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cnt_z_p_z_field_zn_0_min_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cnt_z_p_z_field_zn_1_poweroftwo_a000_041aa020() {
    // Encoding: 0x041AA020
    // Test CNT_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, size=0, Zd=0
    let encoding: u32 = 0x041AA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cnt_z_p_z_field_zn_30_poweroftwominusone_a000_041aa3c0() {
    // Encoding: 0x041AA3C0
    // Test CNT_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Pg=0, Zn=30
    let encoding: u32 = 0x041AA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cnt_z_p_z_field_zn_31_max_a000_041aa3e0() {
    // Encoding: 0x041AA3E0
    // Test CNT_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Pg=0, Zn=31, Zd=0
    let encoding: u32 = 0x041AA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cnt_z_p_z_field_zd_0_min_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cnt_z_p_z_field_zd_1_poweroftwo_a000_041aa001() {
    // Encoding: 0x041AA001
    // Test CNT_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0, size=0
    let encoding: u32 = 0x041AA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cnt_z_p_z_field_zd_30_poweroftwominusone_a000_041aa01e() {
    // Encoding: 0x041AA01E
    // Test CNT_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x041AA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cnt_z_p_z_field_zd_31_max_a000_041aa01f() {
    // Encoding: 0x041AA01F
    // Test CNT_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Pg=0, size=0, Zd=31
    let encoding: u32 = 0x041AA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cnt_z_p_z_combo_0_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cnt_z_p_z_special_size_0_size_variant_0_40960_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cnt_z_p_z_special_size_1_size_variant_1_40960_045aa000() {
    // Encoding: 0x045AA000
    // Test CNT_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zd=0, size=1, Zn=0
    let encoding: u32 = 0x045AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cnt_z_p_z_special_size_2_size_variant_2_40960_049aa000() {
    // Encoding: 0x049AA000
    // Test CNT_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x049AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cnt_z_p_z_special_size_3_size_variant_3_40960_04daa000() {
    // Encoding: 0x04DAA000
    // Test CNT_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04DAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cnt_z_p_z_invalid_0_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cnt_z_p_z_invalid_1_a000_041aa000() {
    // Encoding: 0x041AA000
    // Test CNT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x041AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNT_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cnt_z_p_z_reg_write_0_041aa000() {
    // Test CNT_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x041AA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041AA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECB_R.RS_SX Tests
// ============================================================================

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_0_zero_f800_0420f800() {
    // Encoding: 0x0420F800
    // Test SQDECB_R.RS_SX field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0420F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_1_poweroftwo_f800_0421f800() {
    // Encoding: 0x0421F800
    // Test SQDECB_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x0421F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_3_poweroftwominusone_f800_0423f800() {
    // Encoding: 0x0423F800
    // Test SQDECB_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x0423F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_4_poweroftwo_f800_0424f800() {
    // Encoding: 0x0424F800
    // Test SQDECB_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x0424F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_7_poweroftwominusone_f800_0427f800() {
    // Encoding: 0x0427F800
    // Test SQDECB_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0427F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_8_poweroftwo_f800_0428f800() {
    // Encoding: 0x0428F800
    // Test SQDECB_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x0428F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecb_r_rs_sx_field_imm4_15_max_f800_042ff800() {
    // Encoding: 0x042FF800
    // Test SQDECB_R.RS_SX field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x042FF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecb_r_rs_sx_field_pattern_0_min_f800_0420f800() {
    // Encoding: 0x0420F800
    // Test SQDECB_R.RS_SX field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecb_r_rs_sx_field_pattern_1_poweroftwo_f800_0420f820() {
    // Encoding: 0x0420F820
    // Test SQDECB_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x0420F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecb_r_rs_sx_field_pattern_15_poweroftwominusone_f800_0420f9e0() {
    // Encoding: 0x0420F9E0
    // Test SQDECB_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0420F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecb_r_rs_sx_field_pattern_31_max_f800_0420fbe0() {
    // Encoding: 0x0420FBE0
    // Test SQDECB_R.RS_SX field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x0420FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecb_r_rs_sx_field_rdn_0_min_f800_0420f800() {
    // Encoding: 0x0420F800
    // Test SQDECB_R.RS_SX field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0420F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecb_r_rs_sx_field_rdn_1_poweroftwo_f800_0420f801() {
    // Encoding: 0x0420F801
    // Test SQDECB_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0420F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecb_r_rs_sx_field_rdn_15_poweroftwominusone_f800_0420f80f() {
    // Encoding: 0x0420F80F
    // Test SQDECB_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x0420F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecb_r_rs_sx_field_rdn_31_max_f800_0420f81f() {
    // Encoding: 0x0420F81F
    // Test SQDECB_R.RS_SX field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x0420F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecb_r_rs_sx_combo_0_f800_0420f800() {
    // Encoding: 0x0420F800
    // Test SQDECB_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecb_r_rs_sx_invalid_0_f800_0420f800() {
    // Encoding: 0x0420F800
    // Test SQDECB_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0420F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecb_r_rs_sx_invalid_1_f800_0420f800() {
    // Encoding: 0x0420F800
    // Test SQDECB_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecb_r_rs_x_field_imm4_0_zero_f800_0430f800() {
    // Encoding: 0x0430F800
    // Test SQDECB_R.RS_X field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0430F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecb_r_rs_x_field_imm4_1_poweroftwo_f800_0431f800() {
    // Encoding: 0x0431F800
    // Test SQDECB_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x0431F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecb_r_rs_x_field_imm4_3_poweroftwominusone_f800_0433f800() {
    // Encoding: 0x0433F800
    // Test SQDECB_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x0433F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecb_r_rs_x_field_imm4_4_poweroftwo_f800_0434f800() {
    // Encoding: 0x0434F800
    // Test SQDECB_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x0434F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecb_r_rs_x_field_imm4_7_poweroftwominusone_f800_0437f800() {
    // Encoding: 0x0437F800
    // Test SQDECB_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0437F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecb_r_rs_x_field_imm4_8_poweroftwo_f800_0438f800() {
    // Encoding: 0x0438F800
    // Test SQDECB_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0438F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecb_r_rs_x_field_imm4_15_max_f800_043ff800() {
    // Encoding: 0x043FF800
    // Test SQDECB_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x043FF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecb_r_rs_x_field_pattern_0_min_f800_0430f800() {
    // Encoding: 0x0430F800
    // Test SQDECB_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecb_r_rs_x_field_pattern_1_poweroftwo_f800_0430f820() {
    // Encoding: 0x0430F820
    // Test SQDECB_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecb_r_rs_x_field_pattern_15_poweroftwominusone_f800_0430f9e0() {
    // Encoding: 0x0430F9E0
    // Test SQDECB_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x0430F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecb_r_rs_x_field_pattern_31_max_f800_0430fbe0() {
    // Encoding: 0x0430FBE0
    // Test SQDECB_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0430FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecb_r_rs_x_field_rdn_0_min_f800_0430f800() {
    // Encoding: 0x0430F800
    // Test SQDECB_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0430F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecb_r_rs_x_field_rdn_1_poweroftwo_f800_0430f801() {
    // Encoding: 0x0430F801
    // Test SQDECB_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x0430F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecb_r_rs_x_field_rdn_15_poweroftwominusone_f800_0430f80f() {
    // Encoding: 0x0430F80F
    // Test SQDECB_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x0430F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecb_r_rs_x_field_rdn_31_max_f800_0430f81f() {
    // Encoding: 0x0430F81F
    // Test SQDECB_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x0430F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecb_r_rs_x_combo_0_f800_0430f800() {
    // Encoding: 0x0430F800
    // Test SQDECB_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecb_r_rs_x_invalid_0_f800_0430f800() {
    // Encoding: 0x0430F800
    // Test SQDECB_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecb_r_rs_x_invalid_1_f800_0430f800() {
    // Encoding: 0x0430F800
    // Test SQDECB_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0430F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECB_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecb_r_rs_sx_reg_write_0_0420f800() {
    // Test SQDECB_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x0420F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQDECB_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecb_r_rs_x_reg_write_0_0430f800() {
    // Test SQDECB_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0430F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0430F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCD_Z.ZS__ Tests
// ============================================================================

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincd_z_zs_field_imm4_0_zero_c400_04e0c400() {
    // Encoding: 0x04E0C400
    // Test UQINCD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincd_z_zs_field_imm4_1_poweroftwo_c400_04e1c400() {
    // Encoding: 0x04E1C400
    // Test UQINCD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zdn=0, pattern=0
    let encoding: u32 = 0x04E1C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincd_z_zs_field_imm4_3_poweroftwominusone_c400_04e3c400() {
    // Encoding: 0x04E3C400
    // Test UQINCD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04E3C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincd_z_zs_field_imm4_4_poweroftwo_c400_04e4c400() {
    // Encoding: 0x04E4C400
    // Test UQINCD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zdn=0, pattern=0
    let encoding: u32 = 0x04E4C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincd_z_zs_field_imm4_7_poweroftwominusone_c400_04e7c400() {
    // Encoding: 0x04E7C400
    // Test UQINCD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04E7C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincd_z_zs_field_imm4_8_poweroftwo_c400_04e8c400() {
    // Encoding: 0x04E8C400
    // Test UQINCD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x04E8C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincd_z_zs_field_imm4_15_max_c400_04efc400() {
    // Encoding: 0x04EFC400
    // Test UQINCD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, Zdn=0, imm4=15
    let encoding: u32 = 0x04EFC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_z_zs_field_pattern_0_min_c400_04e0c400() {
    // Encoding: 0x04E0C400
    // Test UQINCD_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_z_zs_field_pattern_1_poweroftwo_c400_04e0c420() {
    // Encoding: 0x04E0C420
    // Test UQINCD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04E0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_z_zs_field_pattern_15_poweroftwominusone_c400_04e0c5e0() {
    // Encoding: 0x04E0C5E0
    // Test UQINCD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x04E0C5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_z_zs_field_pattern_31_max_c400_04e0c7e0() {
    // Encoding: 0x04E0C7E0
    // Test UQINCD_Z.ZS__ field pattern = 31 (Max)
    // Fields: Zdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04E0C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_z_zs_field_zdn_0_min_c400_04e0c400() {
    // Encoding: 0x04E0C400
    // Test UQINCD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_z_zs_field_zdn_1_poweroftwo_c400_04e0c401() {
    // Encoding: 0x04E0C401
    // Test UQINCD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=1, imm4=0
    let encoding: u32 = 0x04E0C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_z_zs_field_zdn_15_poweroftwominusone_c400_04e0c40f() {
    // Encoding: 0x04E0C40F
    // Test UQINCD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x04E0C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_z_zs_field_zdn_31_max_c400_04e0c41f() {
    // Encoding: 0x04E0C41F
    // Test UQINCD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04E0C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincd_z_zs_combo_0_c400_04e0c400() {
    // Encoding: 0x04E0C400
    // Test UQINCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincd_z_zs_invalid_0_c400_04e0c400() {
    // Encoding: 0x04E0C400
    // Test UQINCD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincd_z_zs_invalid_1_c400_04e0c400() {
    // Encoding: 0x04E0C400
    // Test UQINCD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04E0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqincd_z_zs_reg_write_0_04e0c400() {
    // Test UQINCD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04E0C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECP_R.P.R_UW Tests
// ============================================================================

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqdecp_r_p_r_uw_field_size_0_min_8800_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW field size = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqdecp_r_p_r_uw_field_size_1_poweroftwo_8800_256b8800() {
    // Encoding: 0x256B8800
    // Test UQDECP_R.P.R_UW field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Rdn=0
    let encoding: u32 = 0x256B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqdecp_r_p_r_uw_field_size_2_poweroftwo_8800_25ab8800() {
    // Encoding: 0x25AB8800
    // Test UQDECP_R.P.R_UW field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Rdn=0
    let encoding: u32 = 0x25AB8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqdecp_r_p_r_uw_field_size_3_max_8800_25eb8800() {
    // Encoding: 0x25EB8800
    // Test UQDECP_R.P.R_UW field size = 3 (Max)
    // Fields: Pg=0, Rdn=0, size=3
    let encoding: u32 = 0x25EB8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqdecp_r_p_r_uw_field_pg_0_min_8800_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqdecp_r_p_r_uw_field_pg_1_poweroftwo_8800_252b8820() {
    // Encoding: 0x252B8820
    // Test UQDECP_R.P.R_UW field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rdn=0, size=0
    let encoding: u32 = 0x252B8820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecp_r_p_r_uw_field_rdn_0_min_8800_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW field Rdn = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecp_r_p_r_uw_field_rdn_1_poweroftwo_8800_252b8801() {
    // Encoding: 0x252B8801
    // Test UQDECP_R.P.R_UW field Rdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=1, size=0
    let encoding: u32 = 0x252B8801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecp_r_p_r_uw_field_rdn_15_poweroftwominusone_8800_252b880f() {
    // Encoding: 0x252B880F
    // Test UQDECP_R.P.R_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Rdn=15
    let encoding: u32 = 0x252B880F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecp_r_p_r_uw_field_rdn_31_max_8800_252b881f() {
    // Encoding: 0x252B881F
    // Test UQDECP_R.P.R_UW field Rdn = 31 (Max)
    // Fields: Pg=0, Rdn=31, size=0
    let encoding: u32 = 0x252B881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqdecp_r_p_r_uw_combo_0_8800_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW field combination: size=0, Pg=0, Rdn=0
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqdecp_r_p_r_uw_special_size_0_size_variant_0_34816_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqdecp_r_p_r_uw_special_size_1_size_variant_1_34816_256b8800() {
    // Encoding: 0x256B8800
    // Test UQDECP_R.P.R_UW special value size = 1 (Size variant 1)
    // Fields: Pg=0, Rdn=0, size=1
    let encoding: u32 = 0x256B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqdecp_r_p_r_uw_special_size_2_size_variant_2_34816_25ab8800() {
    // Encoding: 0x25AB8800
    // Test UQDECP_R.P.R_UW special value size = 2 (Size variant 2)
    // Fields: Rdn=0, Pg=0, size=2
    let encoding: u32 = 0x25AB8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqdecp_r_p_r_uw_special_size_3_size_variant_3_34816_25eb8800() {
    // Encoding: 0x25EB8800
    // Test UQDECP_R.P.R_UW special value size = 3 (Size variant 3)
    // Fields: Rdn=0, Pg=0, size=3
    let encoding: u32 = 0x25EB8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecp_r_p_r_uw_invalid_0_8800_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecp_r_p_r_uw_invalid_1_8800_252b8800() {
    // Encoding: 0x252B8800
    // Test UQDECP_R.P.R_UW invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252B8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqdecp_r_p_r_x_field_size_0_min_8c00_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X field size = 0 (Min)
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqdecp_r_p_r_x_field_size_1_poweroftwo_8c00_256b8c00() {
    // Encoding: 0x256B8C00
    // Test UQDECP_R.P.R_X field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=0, size=1
    let encoding: u32 = 0x256B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqdecp_r_p_r_x_field_size_2_poweroftwo_8c00_25ab8c00() {
    // Encoding: 0x25AB8C00
    // Test UQDECP_R.P.R_X field size = 2 (PowerOfTwo)
    // Fields: size=2, Rdn=0, Pg=0
    let encoding: u32 = 0x25AB8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqdecp_r_p_r_x_field_size_3_max_8c00_25eb8c00() {
    // Encoding: 0x25EB8C00
    // Test UQDECP_R.P.R_X field size = 3 (Max)
    // Fields: Pg=0, Rdn=0, size=3
    let encoding: u32 = 0x25EB8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqdecp_r_p_r_x_field_pg_0_min_8c00_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X field Pg = 0 (Min)
    // Fields: Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqdecp_r_p_r_x_field_pg_1_poweroftwo_8c00_252b8c20() {
    // Encoding: 0x252B8C20
    // Test UQDECP_R.P.R_X field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Rdn=0, Pg=1
    let encoding: u32 = 0x252B8C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecp_r_p_r_x_field_rdn_0_min_8c00_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X field Rdn = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecp_r_p_r_x_field_rdn_1_poweroftwo_8c00_252b8c01() {
    // Encoding: 0x252B8C01
    // Test UQDECP_R.P.R_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, size=0, Pg=0
    let encoding: u32 = 0x252B8C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecp_r_p_r_x_field_rdn_15_poweroftwominusone_8c00_252b8c0f() {
    // Encoding: 0x252B8C0F
    // Test UQDECP_R.P.R_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Rdn=15
    let encoding: u32 = 0x252B8C0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecp_r_p_r_x_field_rdn_31_max_8c00_252b8c1f() {
    // Encoding: 0x252B8C1F
    // Test UQDECP_R.P.R_X field Rdn = 31 (Max)
    // Fields: Pg=0, size=0, Rdn=31
    let encoding: u32 = 0x252B8C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqdecp_r_p_r_x_combo_0_8c00_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X field combination: size=0, Pg=0, Rdn=0
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqdecp_r_p_r_x_special_size_0_size_variant_0_35840_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X special value size = 0 (Size variant 0)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqdecp_r_p_r_x_special_size_1_size_variant_1_35840_256b8c00() {
    // Encoding: 0x256B8C00
    // Test UQDECP_R.P.R_X special value size = 1 (Size variant 1)
    // Fields: Rdn=0, size=1, Pg=0
    let encoding: u32 = 0x256B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqdecp_r_p_r_x_special_size_2_size_variant_2_35840_25ab8c00() {
    // Encoding: 0x25AB8C00
    // Test UQDECP_R.P.R_X special value size = 2 (Size variant 2)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AB8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqdecp_r_p_r_x_special_size_3_size_variant_3_35840_25eb8c00() {
    // Encoding: 0x25EB8C00
    // Test UQDECP_R.P.R_X special value size = 3 (Size variant 3)
    // Fields: size=3, Rdn=0, Pg=0
    let encoding: u32 = 0x25EB8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecp_r_p_r_x_invalid_0_8c00_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecp_r_p_r_x_invalid_1_8c00_252b8c00() {
    // Encoding: 0x252B8C00
    // Test UQDECP_R.P.R_X invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252B8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_R.P.R_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecp_r_p_r_uw_reg_write_0_252b8800() {
    // Test UQDECP_R.P.R_UW register write: GpFromField("dn")
    // Encoding: 0x252B8800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252B8800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQDECP_R.P.R_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecp_r_p_r_x_reg_write_0_252b8c00() {
    // Test UQDECP_R.P.R_X register write: GpFromField("dn")
    // Encoding: 0x252B8C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252B8C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DECP_R.P.R__ Tests
// ============================================================================

/// Provenance: DECP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_decp_r_p_r_field_size_0_min_8800_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ field size = 0 (Min)
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_decp_r_p_r_field_size_1_poweroftwo_8800_256d8800() {
    // Encoding: 0x256D8800
    // Test DECP_R.P.R__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Rdn=0, Pg=0
    let encoding: u32 = 0x256D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_decp_r_p_r_field_size_2_poweroftwo_8800_25ad8800() {
    // Encoding: 0x25AD8800
    // Test DECP_R.P.R__ field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AD8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_decp_r_p_r_field_size_3_max_8800_25ed8800() {
    // Encoding: 0x25ED8800
    // Test DECP_R.P.R__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Rdn=0
    let encoding: u32 = 0x25ED8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_decp_r_p_r_field_pg_0_min_8800_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ field Pg = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_decp_r_p_r_field_pg_1_poweroftwo_8800_252d8820() {
    // Encoding: 0x252D8820
    // Test DECP_R.P.R__ field Pg = 1 (PowerOfTwo)
    // Fields: Rdn=0, size=0, Pg=1
    let encoding: u32 = 0x252D8820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decp_r_p_r_field_rdn_0_min_8800_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ field Rdn = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decp_r_p_r_field_rdn_1_poweroftwo_8800_252d8801() {
    // Encoding: 0x252D8801
    // Test DECP_R.P.R__ field Rdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Rdn=1
    let encoding: u32 = 0x252D8801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decp_r_p_r_field_rdn_15_poweroftwominusone_8800_252d880f() {
    // Encoding: 0x252D880F
    // Test DECP_R.P.R__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Rdn=15
    let encoding: u32 = 0x252D880F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decp_r_p_r_field_rdn_31_max_8800_252d881f() {
    // Encoding: 0x252D881F
    // Test DECP_R.P.R__ field Rdn = 31 (Max)
    // Fields: Rdn=31, Pg=0, size=0
    let encoding: u32 = 0x252D881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_decp_r_p_r_combo_0_8800_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ field combination: size=0, Pg=0, Rdn=0
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_decp_r_p_r_special_size_0_size_variant_0_34816_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_decp_r_p_r_special_size_1_size_variant_1_34816_256d8800() {
    // Encoding: 0x256D8800
    // Test DECP_R.P.R__ special value size = 1 (Size variant 1)
    // Fields: size=1, Rdn=0, Pg=0
    let encoding: u32 = 0x256D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_decp_r_p_r_special_size_2_size_variant_2_34816_25ad8800() {
    // Encoding: 0x25AD8800
    // Test DECP_R.P.R__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Rdn=0
    let encoding: u32 = 0x25AD8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_decp_r_p_r_special_size_3_size_variant_3_34816_25ed8800() {
    // Encoding: 0x25ED8800
    // Test DECP_R.P.R__ special value size = 3 (Size variant 3)
    // Fields: size=3, Rdn=0, Pg=0
    let encoding: u32 = 0x25ED8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decp_r_p_r_invalid_0_8800_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decp_r_p_r_invalid_1_8800_252d8800() {
    // Encoding: 0x252D8800
    // Test DECP_R.P.R__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252D8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECP_R.P.R__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_decp_r_p_r_reg_write_0_252d8800() {
    // Test DECP_R.P.R__ register write: GpFromField("dn")
    // Encoding: 0x252D8800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252D8800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCD_R.RS_SX Tests
// ============================================================================

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincd_r_rs_sx_field_imm4_0_zero_f000_04e0f000() {
    // Encoding: 0x04E0F000
    // Test SQINCD_R.RS_SX field imm4 = 0 (Zero)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04E0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincd_r_rs_sx_field_imm4_1_poweroftwo_f000_04e1f000() {
    // Encoding: 0x04E1F000
    // Test SQINCD_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=1
    let encoding: u32 = 0x04E1F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincd_r_rs_sx_field_imm4_3_poweroftwominusone_f000_04e3f000() {
    // Encoding: 0x04E3F000
    // Test SQINCD_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rdn=0, pattern=0
    let encoding: u32 = 0x04E3F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincd_r_rs_sx_field_imm4_4_poweroftwo_f000_04e4f000() {
    // Encoding: 0x04E4F000
    // Test SQINCD_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x04E4F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincd_r_rs_sx_field_imm4_7_poweroftwominusone_f000_04e7f000() {
    // Encoding: 0x04E7F000
    // Test SQINCD_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04E7F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincd_r_rs_sx_field_imm4_8_poweroftwo_f000_04e8f000() {
    // Encoding: 0x04E8F000
    // Test SQINCD_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04E8F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincd_r_rs_sx_field_imm4_15_max_f000_04eff000() {
    // Encoding: 0x04EFF000
    // Test SQINCD_R.RS_SX field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04EFF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincd_r_rs_sx_field_pattern_0_min_f000_04e0f000() {
    // Encoding: 0x04E0F000
    // Test SQINCD_R.RS_SX field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincd_r_rs_sx_field_pattern_1_poweroftwo_f000_04e0f020() {
    // Encoding: 0x04E0F020
    // Test SQINCD_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04E0F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincd_r_rs_sx_field_pattern_15_poweroftwominusone_f000_04e0f1e0() {
    // Encoding: 0x04E0F1E0
    // Test SQINCD_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04E0F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincd_r_rs_sx_field_pattern_31_max_f000_04e0f3e0() {
    // Encoding: 0x04E0F3E0
    // Test SQINCD_R.RS_SX field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04E0F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincd_r_rs_sx_field_rdn_0_min_f000_04e0f000() {
    // Encoding: 0x04E0F000
    // Test SQINCD_R.RS_SX field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04E0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincd_r_rs_sx_field_rdn_1_poweroftwo_f000_04e0f001() {
    // Encoding: 0x04E0F001
    // Test SQINCD_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=1, pattern=0
    let encoding: u32 = 0x04E0F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincd_r_rs_sx_field_rdn_15_poweroftwominusone_f000_04e0f00f() {
    // Encoding: 0x04E0F00F
    // Test SQINCD_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=15, pattern=0
    let encoding: u32 = 0x04E0F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincd_r_rs_sx_field_rdn_31_max_f000_04e0f01f() {
    // Encoding: 0x04E0F01F
    // Test SQINCD_R.RS_SX field Rdn = 31 (Max)
    // Fields: imm4=0, Rdn=31, pattern=0
    let encoding: u32 = 0x04E0F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincd_r_rs_sx_combo_0_f000_04e0f000() {
    // Encoding: 0x04E0F000
    // Test SQINCD_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04E0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincd_r_rs_sx_invalid_0_f000_04e0f000() {
    // Encoding: 0x04E0F000
    // Test SQINCD_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04E0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincd_r_rs_sx_invalid_1_f000_04e0f000() {
    // Encoding: 0x04E0F000
    // Test SQINCD_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincd_r_rs_x_field_imm4_0_zero_f000_04f0f000() {
    // Encoding: 0x04F0F000
    // Test SQINCD_R.RS_X field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincd_r_rs_x_field_imm4_1_poweroftwo_f000_04f1f000() {
    // Encoding: 0x04F1F000
    // Test SQINCD_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rdn=0, pattern=0
    let encoding: u32 = 0x04F1F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincd_r_rs_x_field_imm4_3_poweroftwominusone_f000_04f3f000() {
    // Encoding: 0x04F3F000
    // Test SQINCD_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04F3F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincd_r_rs_x_field_imm4_4_poweroftwo_f000_04f4f000() {
    // Encoding: 0x04F4F000
    // Test SQINCD_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x04F4F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincd_r_rs_x_field_imm4_7_poweroftwominusone_f000_04f7f000() {
    // Encoding: 0x04F7F000
    // Test SQINCD_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=7
    let encoding: u32 = 0x04F7F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincd_r_rs_x_field_imm4_8_poweroftwo_f000_04f8f000() {
    // Encoding: 0x04F8F000
    // Test SQINCD_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04F8F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincd_r_rs_x_field_imm4_15_max_f000_04fff000() {
    // Encoding: 0x04FFF000
    // Test SQINCD_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04FFF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincd_r_rs_x_field_pattern_0_min_f000_04f0f000() {
    // Encoding: 0x04F0F000
    // Test SQINCD_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincd_r_rs_x_field_pattern_1_poweroftwo_f000_04f0f020() {
    // Encoding: 0x04F0F020
    // Test SQINCD_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x04F0F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincd_r_rs_x_field_pattern_15_poweroftwominusone_f000_04f0f1e0() {
    // Encoding: 0x04F0F1E0
    // Test SQINCD_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x04F0F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincd_r_rs_x_field_pattern_31_max_f000_04f0f3e0() {
    // Encoding: 0x04F0F3E0
    // Test SQINCD_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04F0F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincd_r_rs_x_field_rdn_0_min_f000_04f0f000() {
    // Encoding: 0x04F0F000
    // Test SQINCD_R.RS_X field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincd_r_rs_x_field_rdn_1_poweroftwo_f000_04f0f001() {
    // Encoding: 0x04F0F001
    // Test SQINCD_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincd_r_rs_x_field_rdn_15_poweroftwominusone_f000_04f0f00f() {
    // Encoding: 0x04F0F00F
    // Test SQINCD_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincd_r_rs_x_field_rdn_31_max_f000_04f0f01f() {
    // Encoding: 0x04F0F01F
    // Test SQINCD_R.RS_X field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincd_r_rs_x_combo_0_f000_04f0f000() {
    // Encoding: 0x04F0F000
    // Test SQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincd_r_rs_x_invalid_0_f000_04f0f000() {
    // Encoding: 0x04F0F000
    // Test SQINCD_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincd_r_rs_x_invalid_1_f000_04f0f000() {
    // Encoding: 0x04F0F000
    // Test SQINCD_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCD_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincd_r_rs_sx_reg_write_0_04e0f000() {
    // Test SQINCD_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x04E0F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQINCD_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincd_r_rs_x_reg_write_0_04f0f000() {
    // Test SQINCD_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04F0F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DECB_R.RS__ Tests
// ============================================================================

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_decb_r_rs_field_imm4_0_zero_e400_0430e400() {
    // Encoding: 0x0430E400
    // Test DECB_R.RS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_decb_r_rs_field_imm4_1_poweroftwo_e400_0431e400() {
    // Encoding: 0x0431E400
    // Test DECB_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0431E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_decb_r_rs_field_imm4_3_poweroftwominusone_e400_0433e400() {
    // Encoding: 0x0433E400
    // Test DECB_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x0433E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_decb_r_rs_field_imm4_4_poweroftwo_e400_0434e400() {
    // Encoding: 0x0434E400
    // Test DECB_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rdn=0
    let encoding: u32 = 0x0434E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_decb_r_rs_field_imm4_7_poweroftwominusone_e400_0437e400() {
    // Encoding: 0x0437E400
    // Test DECB_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rdn=0, pattern=0
    let encoding: u32 = 0x0437E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_decb_r_rs_field_imm4_8_poweroftwo_e400_0438e400() {
    // Encoding: 0x0438E400
    // Test DECB_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x0438E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_decb_r_rs_field_imm4_15_max_e400_043fe400() {
    // Encoding: 0x043FE400
    // Test DECB_R.RS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x043FE400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decb_r_rs_field_pattern_0_min_e400_0430e400() {
    // Encoding: 0x0430E400
    // Test DECB_R.RS__ field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decb_r_rs_field_pattern_1_poweroftwo_e400_0430e420() {
    // Encoding: 0x0430E420
    // Test DECB_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x0430E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decb_r_rs_field_pattern_15_poweroftwominusone_e400_0430e5e0() {
    // Encoding: 0x0430E5E0
    // Test DECB_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x0430E5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decb_r_rs_field_pattern_31_max_e400_0430e7e0() {
    // Encoding: 0x0430E7E0
    // Test DECB_R.RS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x0430E7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decb_r_rs_field_rdn_0_min_e400_0430e400() {
    // Encoding: 0x0430E400
    // Test DECB_R.RS__ field Rdn = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decb_r_rs_field_rdn_1_poweroftwo_e400_0430e401() {
    // Encoding: 0x0430E401
    // Test DECB_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x0430E401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decb_r_rs_field_rdn_15_poweroftwominusone_e400_0430e40f() {
    // Encoding: 0x0430E40F
    // Test DECB_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0430E40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decb_r_rs_field_rdn_31_max_e400_0430e41f() {
    // Encoding: 0x0430E41F
    // Test DECB_R.RS__ field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x0430E41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_decb_r_rs_combo_0_e400_0430e400() {
    // Encoding: 0x0430E400
    // Test DECB_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decb_r_rs_invalid_0_e400_0430e400() {
    // Encoding: 0x0430E400
    // Test DECB_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decb_r_rs_invalid_1_e400_0430e400() {
    // Encoding: 0x0430E400
    // Test DECB_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_decd_r_rs_field_imm4_0_zero_e400_04f0e400() {
    // Encoding: 0x04F0E400
    // Test DECD_R.RS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_decd_r_rs_field_imm4_1_poweroftwo_e400_04f1e400() {
    // Encoding: 0x04F1E400
    // Test DECD_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Rdn=0
    let encoding: u32 = 0x04F1E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_decd_r_rs_field_imm4_3_poweroftwominusone_e400_04f3e400() {
    // Encoding: 0x04F3E400
    // Test DECD_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x04F3E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_decd_r_rs_field_imm4_4_poweroftwo_e400_04f4e400() {
    // Encoding: 0x04F4E400
    // Test DECD_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x04F4E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_decd_r_rs_field_imm4_7_poweroftwominusone_e400_04f7e400() {
    // Encoding: 0x04F7E400
    // Test DECD_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04F7E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_decd_r_rs_field_imm4_8_poweroftwo_e400_04f8e400() {
    // Encoding: 0x04F8E400
    // Test DECD_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04F8E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_decd_r_rs_field_imm4_15_max_e400_04ffe400() {
    // Encoding: 0x04FFE400
    // Test DECD_R.RS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04FFE400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decd_r_rs_field_pattern_0_min_e400_04f0e400() {
    // Encoding: 0x04F0E400
    // Test DECD_R.RS__ field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decd_r_rs_field_pattern_1_poweroftwo_e400_04f0e420() {
    // Encoding: 0x04F0E420
    // Test DECD_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04F0E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decd_r_rs_field_pattern_15_poweroftwominusone_e400_04f0e5e0() {
    // Encoding: 0x04F0E5E0
    // Test DECD_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=0, pattern=15
    let encoding: u32 = 0x04F0E5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decd_r_rs_field_pattern_31_max_e400_04f0e7e0() {
    // Encoding: 0x04F0E7E0
    // Test DECD_R.RS__ field pattern = 31 (Max)
    // Fields: pattern=31, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0E7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decd_r_rs_field_rdn_0_min_e400_04f0e400() {
    // Encoding: 0x04F0E400
    // Test DECD_R.RS__ field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decd_r_rs_field_rdn_1_poweroftwo_e400_04f0e401() {
    // Encoding: 0x04F0E401
    // Test DECD_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04F0E401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decd_r_rs_field_rdn_15_poweroftwominusone_e400_04f0e40f() {
    // Encoding: 0x04F0E40F
    // Test DECD_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04F0E40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decd_r_rs_field_rdn_31_max_e400_04f0e41f() {
    // Encoding: 0x04F0E41F
    // Test DECD_R.RS__ field Rdn = 31 (Max)
    // Fields: pattern=0, Rdn=31, imm4=0
    let encoding: u32 = 0x04F0E41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_decd_r_rs_combo_0_e400_04f0e400() {
    // Encoding: 0x04F0E400
    // Test DECD_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decd_r_rs_invalid_0_e400_04f0e400() {
    // Encoding: 0x04F0E400
    // Test DECD_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECD_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decd_r_rs_invalid_1_e400_04f0e400() {
    // Encoding: 0x04F0E400
    // Test DECD_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_dech_r_rs_field_imm4_0_zero_e400_0470e400() {
    // Encoding: 0x0470E400
    // Test DECH_R.RS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_dech_r_rs_field_imm4_1_poweroftwo_e400_0471e400() {
    // Encoding: 0x0471E400
    // Test DECH_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x0471E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_dech_r_rs_field_imm4_3_poweroftwominusone_e400_0473e400() {
    // Encoding: 0x0473E400
    // Test DECH_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rdn=0, pattern=0
    let encoding: u32 = 0x0473E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_dech_r_rs_field_imm4_4_poweroftwo_e400_0474e400() {
    // Encoding: 0x0474E400
    // Test DECH_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x0474E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_dech_r_rs_field_imm4_7_poweroftwominusone_e400_0477e400() {
    // Encoding: 0x0477E400
    // Test DECH_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0477E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_dech_r_rs_field_imm4_8_poweroftwo_e400_0478e400() {
    // Encoding: 0x0478E400
    // Test DECH_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0478E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_dech_r_rs_field_imm4_15_max_e400_047fe400() {
    // Encoding: 0x047FE400
    // Test DECH_R.RS__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Rdn=0
    let encoding: u32 = 0x047FE400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_dech_r_rs_field_pattern_0_min_e400_0470e400() {
    // Encoding: 0x0470E400
    // Test DECH_R.RS__ field pattern = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_dech_r_rs_field_pattern_1_poweroftwo_e400_0470e420() {
    // Encoding: 0x0470E420
    // Test DECH_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0470E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_dech_r_rs_field_pattern_15_poweroftwominusone_e400_0470e5e0() {
    // Encoding: 0x0470E5E0
    // Test DECH_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=0, pattern=15
    let encoding: u32 = 0x0470E5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_dech_r_rs_field_pattern_31_max_e400_0470e7e0() {
    // Encoding: 0x0470E7E0
    // Test DECH_R.RS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x0470E7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_dech_r_rs_field_rdn_0_min_e400_0470e400() {
    // Encoding: 0x0470E400
    // Test DECH_R.RS__ field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_dech_r_rs_field_rdn_1_poweroftwo_e400_0470e401() {
    // Encoding: 0x0470E401
    // Test DECH_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x0470E401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_dech_r_rs_field_rdn_15_poweroftwominusone_e400_0470e40f() {
    // Encoding: 0x0470E40F
    // Test DECH_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0470E40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_dech_r_rs_field_rdn_31_max_e400_0470e41f() {
    // Encoding: 0x0470E41F
    // Test DECH_R.RS__ field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x0470E41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_dech_r_rs_combo_0_e400_0470e400() {
    // Encoding: 0x0470E400
    // Test DECH_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_dech_r_rs_invalid_0_e400_0470e400() {
    // Encoding: 0x0470E400
    // Test DECH_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECH_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dech_r_rs_invalid_1_e400_0470e400() {
    // Encoding: 0x0470E400
    // Test DECH_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_decw_r_rs_field_imm4_0_zero_e400_04b0e400() {
    // Encoding: 0x04B0E400
    // Test DECW_R.RS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_decw_r_rs_field_imm4_1_poweroftwo_e400_04b1e400() {
    // Encoding: 0x04B1E400
    // Test DECW_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04B1E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_decw_r_rs_field_imm4_3_poweroftwominusone_e400_04b3e400() {
    // Encoding: 0x04B3E400
    // Test DECW_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04B3E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_decw_r_rs_field_imm4_4_poweroftwo_e400_04b4e400() {
    // Encoding: 0x04B4E400
    // Test DECW_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x04B4E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_decw_r_rs_field_imm4_7_poweroftwominusone_e400_04b7e400() {
    // Encoding: 0x04B7E400
    // Test DECW_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04B7E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_decw_r_rs_field_imm4_8_poweroftwo_e400_04b8e400() {
    // Encoding: 0x04B8E400
    // Test DECW_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=8
    let encoding: u32 = 0x04B8E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_decw_r_rs_field_imm4_15_max_e400_04bfe400() {
    // Encoding: 0x04BFE400
    // Test DECW_R.RS__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Rdn=0
    let encoding: u32 = 0x04BFE400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decw_r_rs_field_pattern_0_min_e400_04b0e400() {
    // Encoding: 0x04B0E400
    // Test DECW_R.RS__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decw_r_rs_field_pattern_1_poweroftwo_e400_04b0e420() {
    // Encoding: 0x04B0E420
    // Test DECW_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04B0E420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decw_r_rs_field_pattern_15_poweroftwominusone_e400_04b0e5e0() {
    // Encoding: 0x04B0E5E0
    // Test DECW_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0E5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decw_r_rs_field_pattern_31_max_e400_04b0e7e0() {
    // Encoding: 0x04B0E7E0
    // Test DECW_R.RS__ field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x04B0E7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decw_r_rs_field_rdn_0_min_e400_04b0e400() {
    // Encoding: 0x04B0E400
    // Test DECW_R.RS__ field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decw_r_rs_field_rdn_1_poweroftwo_e400_04b0e401() {
    // Encoding: 0x04B0E401
    // Test DECW_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04B0E401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decw_r_rs_field_rdn_15_poweroftwominusone_e400_04b0e40f() {
    // Encoding: 0x04B0E40F
    // Test DECW_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=0, Rdn=15
    let encoding: u32 = 0x04B0E40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decw_r_rs_field_rdn_31_max_e400_04b0e41f() {
    // Encoding: 0x04B0E41F
    // Test DECW_R.RS__ field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04B0E41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_decw_r_rs_combo_0_e400_04b0e400() {
    // Encoding: 0x04B0E400
    // Test DECW_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decw_r_rs_invalid_0_e400_04b0e400() {
    // Encoding: 0x04B0E400
    // Test DECW_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECW_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decw_r_rs_invalid_1_e400_04b0e400() {
    // Encoding: 0x04B0E400
    // Test DECW_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECB_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_decb_r_rs_reg_write_0_0430e400() {
    // Test DECB_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x0430E400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0430E400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: DECD_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_decd_r_rs_reg_write_0_04f0e400() {
    // Test DECD_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x04F0E400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0E400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: DECH_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_dech_r_rs_reg_write_0_0470e400() {
    // Test DECH_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x0470E400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470E400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: DECW_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_decw_r_rs_reg_write_0_04b0e400() {
    // Test DECW_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x04B0E400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0E400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECH_Z.ZS__ Tests
// ============================================================================

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdech_z_zs_field_imm4_0_zero_cc00_0460cc00() {
    // Encoding: 0x0460CC00
    // Test UQDECH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdech_z_zs_field_imm4_1_poweroftwo_cc00_0461cc00() {
    // Encoding: 0x0461CC00
    // Test UQDECH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0461CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdech_z_zs_field_imm4_3_poweroftwominusone_cc00_0463cc00() {
    // Encoding: 0x0463CC00
    // Test UQDECH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x0463CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdech_z_zs_field_imm4_4_poweroftwo_cc00_0464cc00() {
    // Encoding: 0x0464CC00
    // Test UQDECH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Zdn=0
    let encoding: u32 = 0x0464CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdech_z_zs_field_imm4_7_poweroftwominusone_cc00_0467cc00() {
    // Encoding: 0x0467CC00
    // Test UQDECH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x0467CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdech_z_zs_field_imm4_8_poweroftwo_cc00_0468cc00() {
    // Encoding: 0x0468CC00
    // Test UQDECH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0468CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdech_z_zs_field_imm4_15_max_cc00_046fcc00() {
    // Encoding: 0x046FCC00
    // Test UQDECH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, Zdn=0, imm4=15
    let encoding: u32 = 0x046FCC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdech_z_zs_field_pattern_0_min_cc00_0460cc00() {
    // Encoding: 0x0460CC00
    // Test UQDECH_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdech_z_zs_field_pattern_1_poweroftwo_cc00_0460cc20() {
    // Encoding: 0x0460CC20
    // Test UQDECH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x0460CC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdech_z_zs_field_pattern_15_poweroftwominusone_cc00_0460cde0() {
    // Encoding: 0x0460CDE0
    // Test UQDECH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0460CDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdech_z_zs_field_pattern_31_max_cc00_0460cfe0() {
    // Encoding: 0x0460CFE0
    // Test UQDECH_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, Zdn=0, pattern=31
    let encoding: u32 = 0x0460CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdech_z_zs_field_zdn_0_min_cc00_0460cc00() {
    // Encoding: 0x0460CC00
    // Test UQDECH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdech_z_zs_field_zdn_1_poweroftwo_cc00_0460cc01() {
    // Encoding: 0x0460CC01
    // Test UQDECH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zdn=1, pattern=0
    let encoding: u32 = 0x0460CC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdech_z_zs_field_zdn_15_poweroftwominusone_cc00_0460cc0f() {
    // Encoding: 0x0460CC0F
    // Test UQDECH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=0, Zdn=15
    let encoding: u32 = 0x0460CC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdech_z_zs_field_zdn_31_max_cc00_0460cc1f() {
    // Encoding: 0x0460CC1F
    // Test UQDECH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x0460CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdech_z_zs_combo_0_cc00_0460cc00() {
    // Encoding: 0x0460CC00
    // Test UQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdech_z_zs_invalid_0_cc00_0460cc00() {
    // Encoding: 0x0460CC00
    // Test UQDECH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdech_z_zs_invalid_1_cc00_0460cc00() {
    // Encoding: 0x0460CC00
    // Test UQDECH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x0460CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqdech_z_zs_reg_write_0_0460cc00() {
    // Test UQDECH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0460CC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460CC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECW_R.RS_SX Tests
// ============================================================================

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_0_zero_f800_04a0f800() {
    // Encoding: 0x04A0F800
    // Test SQDECW_R.RS_SX field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_1_poweroftwo_f800_04a1f800() {
    // Encoding: 0x04A1F800
    // Test SQDECW_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rdn=0, pattern=0
    let encoding: u32 = 0x04A1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_3_poweroftwominusone_f800_04a3f800() {
    // Encoding: 0x04A3F800
    // Test SQDECW_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04A3F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_4_poweroftwo_f800_04a4f800() {
    // Encoding: 0x04A4F800
    // Test SQDECW_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x04A4F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_7_poweroftwominusone_f800_04a7f800() {
    // Encoding: 0x04A7F800
    // Test SQDECW_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04A7F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_8_poweroftwo_f800_04a8f800() {
    // Encoding: 0x04A8F800
    // Test SQDECW_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04A8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecw_r_rs_sx_field_imm4_15_max_f800_04aff800() {
    // Encoding: 0x04AFF800
    // Test SQDECW_R.RS_SX field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04AFF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_r_rs_sx_field_pattern_0_min_f800_04a0f800() {
    // Encoding: 0x04A0F800
    // Test SQDECW_R.RS_SX field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_r_rs_sx_field_pattern_1_poweroftwo_f800_04a0f820() {
    // Encoding: 0x04A0F820
    // Test SQDECW_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x04A0F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_r_rs_sx_field_pattern_15_poweroftwominusone_f800_04a0f9e0() {
    // Encoding: 0x04A0F9E0
    // Test SQDECW_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x04A0F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_r_rs_sx_field_pattern_31_max_f800_04a0fbe0() {
    // Encoding: 0x04A0FBE0
    // Test SQDECW_R.RS_SX field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04A0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_r_rs_sx_field_rdn_0_min_f800_04a0f800() {
    // Encoding: 0x04A0F800
    // Test SQDECW_R.RS_SX field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_r_rs_sx_field_rdn_1_poweroftwo_f800_04a0f801() {
    // Encoding: 0x04A0F801
    // Test SQDECW_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04A0F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_r_rs_sx_field_rdn_15_poweroftwominusone_f800_04a0f80f() {
    // Encoding: 0x04A0F80F
    // Test SQDECW_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=0, Rdn=15
    let encoding: u32 = 0x04A0F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_r_rs_sx_field_rdn_31_max_f800_04a0f81f() {
    // Encoding: 0x04A0F81F
    // Test SQDECW_R.RS_SX field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04A0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecw_r_rs_sx_combo_0_f800_04a0f800() {
    // Encoding: 0x04A0F800
    // Test SQDECW_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecw_r_rs_sx_invalid_0_f800_04a0f800() {
    // Encoding: 0x04A0F800
    // Test SQDECW_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecw_r_rs_sx_invalid_1_f800_04a0f800() {
    // Encoding: 0x04A0F800
    // Test SQDECW_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecw_r_rs_x_field_imm4_0_zero_f800_04b0f800() {
    // Encoding: 0x04B0F800
    // Test SQDECW_R.RS_X field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecw_r_rs_x_field_imm4_1_poweroftwo_f800_04b1f800() {
    // Encoding: 0x04B1F800
    // Test SQDECW_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04B1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecw_r_rs_x_field_imm4_3_poweroftwominusone_f800_04b3f800() {
    // Encoding: 0x04B3F800
    // Test SQDECW_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04B3F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecw_r_rs_x_field_imm4_4_poweroftwo_f800_04b4f800() {
    // Encoding: 0x04B4F800
    // Test SQDECW_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04B4F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecw_r_rs_x_field_imm4_7_poweroftwominusone_f800_04b7f800() {
    // Encoding: 0x04B7F800
    // Test SQDECW_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Rdn=0
    let encoding: u32 = 0x04B7F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecw_r_rs_x_field_imm4_8_poweroftwo_f800_04b8f800() {
    // Encoding: 0x04B8F800
    // Test SQDECW_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x04B8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecw_r_rs_x_field_imm4_15_max_f800_04bff800() {
    // Encoding: 0x04BFF800
    // Test SQDECW_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04BFF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_r_rs_x_field_pattern_0_min_f800_04b0f800() {
    // Encoding: 0x04B0F800
    // Test SQDECW_R.RS_X field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_r_rs_x_field_pattern_1_poweroftwo_f800_04b0f820() {
    // Encoding: 0x04B0F820
    // Test SQDECW_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=0, pattern=1
    let encoding: u32 = 0x04B0F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_r_rs_x_field_pattern_15_poweroftwominusone_f800_04b0f9e0() {
    // Encoding: 0x04B0F9E0
    // Test SQDECW_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_r_rs_x_field_pattern_31_max_f800_04b0fbe0() {
    // Encoding: 0x04B0FBE0
    // Test SQDECW_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04B0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_r_rs_x_field_rdn_0_min_f800_04b0f800() {
    // Encoding: 0x04B0F800
    // Test SQDECW_R.RS_X field Rdn = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_r_rs_x_field_rdn_1_poweroftwo_f800_04b0f801() {
    // Encoding: 0x04B0F801
    // Test SQDECW_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x04B0F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_r_rs_x_field_rdn_15_poweroftwominusone_f800_04b0f80f() {
    // Encoding: 0x04B0F80F
    // Test SQDECW_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04B0F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_r_rs_x_field_rdn_31_max_f800_04b0f81f() {
    // Encoding: 0x04B0F81F
    // Test SQDECW_R.RS_X field Rdn = 31 (Max)
    // Fields: pattern=0, Rdn=31, imm4=0
    let encoding: u32 = 0x04B0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecw_r_rs_x_combo_0_f800_04b0f800() {
    // Encoding: 0x04B0F800
    // Test SQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecw_r_rs_x_invalid_0_f800_04b0f800() {
    // Encoding: 0x04B0F800
    // Test SQDECW_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecw_r_rs_x_invalid_1_f800_04b0f800() {
    // Encoding: 0x04B0F800
    // Test SQDECW_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04B0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECW_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecw_r_rs_sx_reg_write_0_04a0f800() {
    // Test SQDECW_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x04A0F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQDECW_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecw_r_rs_x_reg_write_0_04b0f800() {
    // Test SQDECW_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04B0F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECP_R.P.R_SX Tests
// ============================================================================

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqdecp_r_p_r_sx_field_size_0_min_8800_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX field size = 0 (Min)
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqdecp_r_p_r_sx_field_size_1_poweroftwo_8800_256a8800() {
    // Encoding: 0x256A8800
    // Test SQDECP_R.P.R_SX field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=0, size=1
    let encoding: u32 = 0x256A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqdecp_r_p_r_sx_field_size_2_poweroftwo_8800_25aa8800() {
    // Encoding: 0x25AA8800
    // Test SQDECP_R.P.R_SX field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AA8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqdecp_r_p_r_sx_field_size_3_max_8800_25ea8800() {
    // Encoding: 0x25EA8800
    // Test SQDECP_R.P.R_SX field size = 3 (Max)
    // Fields: Pg=0, Rdn=0, size=3
    let encoding: u32 = 0x25EA8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sqdecp_r_p_r_sx_field_pg_0_min_8800_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX field Pg = 0 (Min)
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sqdecp_r_p_r_sx_field_pg_1_poweroftwo_8800_252a8820() {
    // Encoding: 0x252A8820
    // Test SQDECP_R.P.R_SX field Pg = 1 (PowerOfTwo)
    // Fields: Rdn=0, size=0, Pg=1
    let encoding: u32 = 0x252A8820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecp_r_p_r_sx_field_rdn_0_min_8800_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX field Rdn = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecp_r_p_r_sx_field_rdn_1_poweroftwo_8800_252a8801() {
    // Encoding: 0x252A8801
    // Test SQDECP_R.P.R_SX field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, size=0, Pg=0
    let encoding: u32 = 0x252A8801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecp_r_p_r_sx_field_rdn_15_poweroftwominusone_8800_252a880f() {
    // Encoding: 0x252A880F
    // Test SQDECP_R.P.R_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Rdn=15
    let encoding: u32 = 0x252A880F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecp_r_p_r_sx_field_rdn_31_max_8800_252a881f() {
    // Encoding: 0x252A881F
    // Test SQDECP_R.P.R_SX field Rdn = 31 (Max)
    // Fields: Pg=0, Rdn=31, size=0
    let encoding: u32 = 0x252A881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqdecp_r_p_r_sx_combo_0_8800_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX field combination: size=0, Pg=0, Rdn=0
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqdecp_r_p_r_sx_special_size_0_size_variant_0_34816_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX special value size = 0 (Size variant 0)
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqdecp_r_p_r_sx_special_size_1_size_variant_1_34816_256a8800() {
    // Encoding: 0x256A8800
    // Test SQDECP_R.P.R_SX special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Rdn=0
    let encoding: u32 = 0x256A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqdecp_r_p_r_sx_special_size_2_size_variant_2_34816_25aa8800() {
    // Encoding: 0x25AA8800
    // Test SQDECP_R.P.R_SX special value size = 2 (Size variant 2)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AA8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqdecp_r_p_r_sx_special_size_3_size_variant_3_34816_25ea8800() {
    // Encoding: 0x25EA8800
    // Test SQDECP_R.P.R_SX special value size = 3 (Size variant 3)
    // Fields: Rdn=0, size=3, Pg=0
    let encoding: u32 = 0x25EA8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecp_r_p_r_sx_invalid_0_8800_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecp_r_p_r_sx_invalid_1_8800_252a8800() {
    // Encoding: 0x252A8800
    // Test SQDECP_R.P.R_SX invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x252A8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqdecp_r_p_r_x_field_size_0_min_8c00_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X field size = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqdecp_r_p_r_x_field_size_1_poweroftwo_8c00_256a8c00() {
    // Encoding: 0x256A8C00
    // Test SQDECP_R.P.R_X field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Rdn=0
    let encoding: u32 = 0x256A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqdecp_r_p_r_x_field_size_2_poweroftwo_8c00_25aa8c00() {
    // Encoding: 0x25AA8C00
    // Test SQDECP_R.P.R_X field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Rdn=0
    let encoding: u32 = 0x25AA8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqdecp_r_p_r_x_field_size_3_max_8c00_25ea8c00() {
    // Encoding: 0x25EA8C00
    // Test SQDECP_R.P.R_X field size = 3 (Max)
    // Fields: Rdn=0, Pg=0, size=3
    let encoding: u32 = 0x25EA8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sqdecp_r_p_r_x_field_pg_0_min_8c00_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sqdecp_r_p_r_x_field_pg_1_poweroftwo_8c00_252a8c20() {
    // Encoding: 0x252A8C20
    // Test SQDECP_R.P.R_X field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Rdn=0
    let encoding: u32 = 0x252A8C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecp_r_p_r_x_field_rdn_0_min_8c00_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X field Rdn = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecp_r_p_r_x_field_rdn_1_poweroftwo_8c00_252a8c01() {
    // Encoding: 0x252A8C01
    // Test SQDECP_R.P.R_X field Rdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=1, size=0
    let encoding: u32 = 0x252A8C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecp_r_p_r_x_field_rdn_15_poweroftwominusone_8c00_252a8c0f() {
    // Encoding: 0x252A8C0F
    // Test SQDECP_R.P.R_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Rdn=15, Pg=0
    let encoding: u32 = 0x252A8C0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecp_r_p_r_x_field_rdn_31_max_8c00_252a8c1f() {
    // Encoding: 0x252A8C1F
    // Test SQDECP_R.P.R_X field Rdn = 31 (Max)
    // Fields: size=0, Rdn=31, Pg=0
    let encoding: u32 = 0x252A8C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqdecp_r_p_r_x_combo_0_8c00_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X field combination: size=0, Pg=0, Rdn=0
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqdecp_r_p_r_x_special_size_0_size_variant_0_35840_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X special value size = 0 (Size variant 0)
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqdecp_r_p_r_x_special_size_1_size_variant_1_35840_256a8c00() {
    // Encoding: 0x256A8C00
    // Test SQDECP_R.P.R_X special value size = 1 (Size variant 1)
    // Fields: Pg=0, Rdn=0, size=1
    let encoding: u32 = 0x256A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqdecp_r_p_r_x_special_size_2_size_variant_2_35840_25aa8c00() {
    // Encoding: 0x25AA8C00
    // Test SQDECP_R.P.R_X special value size = 2 (Size variant 2)
    // Fields: size=2, Rdn=0, Pg=0
    let encoding: u32 = 0x25AA8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqdecp_r_p_r_x_special_size_3_size_variant_3_35840_25ea8c00() {
    // Encoding: 0x25EA8C00
    // Test SQDECP_R.P.R_X special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Rdn=0
    let encoding: u32 = 0x25EA8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecp_r_p_r_x_invalid_0_8c00_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecp_r_p_r_x_invalid_1_8c00_252a8c00() {
    // Encoding: 0x252A8C00
    // Test SQDECP_R.P.R_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x252A8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_R.P.R_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecp_r_p_r_sx_reg_write_0_252a8800() {
    // Test SQDECP_R.P.R_SX register write: GpFromField("dn")
    // Encoding: 0x252A8800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252A8800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQDECP_R.P.R_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecp_r_p_r_x_reg_write_0_252a8c00() {
    // Test SQDECP_R.P.R_X register write: GpFromField("dn")
    // Encoding: 0x252A8C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252A8C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCB_R.RS_SX Tests
// ============================================================================

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincb_r_rs_sx_field_imm4_0_zero_f000_0420f000() {
    // Encoding: 0x0420F000
    // Test SQINCB_R.RS_SX field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0420F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincb_r_rs_sx_field_imm4_1_poweroftwo_f000_0421f000() {
    // Encoding: 0x0421F000
    // Test SQINCB_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x0421F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincb_r_rs_sx_field_imm4_3_poweroftwominusone_f000_0423f000() {
    // Encoding: 0x0423F000
    // Test SQINCB_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x0423F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincb_r_rs_sx_field_imm4_4_poweroftwo_f000_0424f000() {
    // Encoding: 0x0424F000
    // Test SQINCB_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x0424F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincb_r_rs_sx_field_imm4_7_poweroftwominusone_f000_0427f000() {
    // Encoding: 0x0427F000
    // Test SQINCB_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0427F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincb_r_rs_sx_field_imm4_8_poweroftwo_f000_0428f000() {
    // Encoding: 0x0428F000
    // Test SQINCB_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x0428F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincb_r_rs_sx_field_imm4_15_max_f000_042ff000() {
    // Encoding: 0x042FF000
    // Test SQINCB_R.RS_SX field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Rdn=0
    let encoding: u32 = 0x042FF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincb_r_rs_sx_field_pattern_0_min_f000_0420f000() {
    // Encoding: 0x0420F000
    // Test SQINCB_R.RS_SX field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0420F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincb_r_rs_sx_field_pattern_1_poweroftwo_f000_0420f020() {
    // Encoding: 0x0420F020
    // Test SQINCB_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x0420F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincb_r_rs_sx_field_pattern_15_poweroftwominusone_f000_0420f1e0() {
    // Encoding: 0x0420F1E0
    // Test SQINCB_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x0420F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincb_r_rs_sx_field_pattern_31_max_f000_0420f3e0() {
    // Encoding: 0x0420F3E0
    // Test SQINCB_R.RS_SX field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0420F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincb_r_rs_sx_field_rdn_0_min_f000_0420f000() {
    // Encoding: 0x0420F000
    // Test SQINCB_R.RS_SX field Rdn = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0420F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincb_r_rs_sx_field_rdn_1_poweroftwo_f000_0420f001() {
    // Encoding: 0x0420F001
    // Test SQINCB_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0420F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincb_r_rs_sx_field_rdn_15_poweroftwominusone_f000_0420f00f() {
    // Encoding: 0x0420F00F
    // Test SQINCB_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x0420F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincb_r_rs_sx_field_rdn_31_max_f000_0420f01f() {
    // Encoding: 0x0420F01F
    // Test SQINCB_R.RS_SX field Rdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Rdn=31
    let encoding: u32 = 0x0420F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincb_r_rs_sx_combo_0_f000_0420f000() {
    // Encoding: 0x0420F000
    // Test SQINCB_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincb_r_rs_sx_invalid_0_f000_0420f000() {
    // Encoding: 0x0420F000
    // Test SQINCB_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincb_r_rs_sx_invalid_1_f000_0420f000() {
    // Encoding: 0x0420F000
    // Test SQINCB_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincb_r_rs_x_field_imm4_0_zero_f000_0430f000() {
    // Encoding: 0x0430F000
    // Test SQINCB_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincb_r_rs_x_field_imm4_1_poweroftwo_f000_0431f000() {
    // Encoding: 0x0431F000
    // Test SQINCB_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0431F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincb_r_rs_x_field_imm4_3_poweroftwominusone_f000_0433f000() {
    // Encoding: 0x0433F000
    // Test SQINCB_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x0433F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincb_r_rs_x_field_imm4_4_poweroftwo_f000_0434f000() {
    // Encoding: 0x0434F000
    // Test SQINCB_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x0434F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincb_r_rs_x_field_imm4_7_poweroftwominusone_f000_0437f000() {
    // Encoding: 0x0437F000
    // Test SQINCB_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0437F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincb_r_rs_x_field_imm4_8_poweroftwo_f000_0438f000() {
    // Encoding: 0x0438F000
    // Test SQINCB_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x0438F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincb_r_rs_x_field_imm4_15_max_f000_043ff000() {
    // Encoding: 0x043FF000
    // Test SQINCB_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x043FF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincb_r_rs_x_field_pattern_0_min_f000_0430f000() {
    // Encoding: 0x0430F000
    // Test SQINCB_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincb_r_rs_x_field_pattern_1_poweroftwo_f000_0430f020() {
    // Encoding: 0x0430F020
    // Test SQINCB_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0430F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincb_r_rs_x_field_pattern_15_poweroftwominusone_f000_0430f1e0() {
    // Encoding: 0x0430F1E0
    // Test SQINCB_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincb_r_rs_x_field_pattern_31_max_f000_0430f3e0() {
    // Encoding: 0x0430F3E0
    // Test SQINCB_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x0430F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincb_r_rs_x_field_rdn_0_min_f000_0430f000() {
    // Encoding: 0x0430F000
    // Test SQINCB_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincb_r_rs_x_field_rdn_1_poweroftwo_f000_0430f001() {
    // Encoding: 0x0430F001
    // Test SQINCB_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0430F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincb_r_rs_x_field_rdn_15_poweroftwominusone_f000_0430f00f() {
    // Encoding: 0x0430F00F
    // Test SQINCB_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x0430F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincb_r_rs_x_field_rdn_31_max_f000_0430f01f() {
    // Encoding: 0x0430F01F
    // Test SQINCB_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x0430F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincb_r_rs_x_combo_0_f000_0430f000() {
    // Encoding: 0x0430F000
    // Test SQINCB_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincb_r_rs_x_invalid_0_f000_0430f000() {
    // Encoding: 0x0430F000
    // Test SQINCB_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincb_r_rs_x_invalid_1_f000_0430f000() {
    // Encoding: 0x0430F000
    // Test SQINCB_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCB_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincb_r_rs_sx_reg_write_0_0420f000() {
    // Test SQINCB_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x0420F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQINCB_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincb_r_rs_x_reg_write_0_0430f000() {
    // Test SQINCB_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0430F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0430F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECD_Z.ZS__ Tests
// ============================================================================

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecd_z_zs_field_imm4_0_zero_cc00_04e0cc00() {
    // Encoding: 0x04E0CC00
    // Test UQDECD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04E0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecd_z_zs_field_imm4_1_poweroftwo_cc00_04e1cc00() {
    // Encoding: 0x04E1CC00
    // Test UQDECD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=1
    let encoding: u32 = 0x04E1CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecd_z_zs_field_imm4_3_poweroftwominusone_cc00_04e3cc00() {
    // Encoding: 0x04E3CC00
    // Test UQDECD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x04E3CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecd_z_zs_field_imm4_4_poweroftwo_cc00_04e4cc00() {
    // Encoding: 0x04E4CC00
    // Test UQDECD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x04E4CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecd_z_zs_field_imm4_7_poweroftwominusone_cc00_04e7cc00() {
    // Encoding: 0x04E7CC00
    // Test UQDECD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=7
    let encoding: u32 = 0x04E7CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecd_z_zs_field_imm4_8_poweroftwo_cc00_04e8cc00() {
    // Encoding: 0x04E8CC00
    // Test UQDECD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x04E8CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecd_z_zs_field_imm4_15_max_cc00_04efcc00() {
    // Encoding: 0x04EFCC00
    // Test UQDECD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: Zdn=0, pattern=0, imm4=15
    let encoding: u32 = 0x04EFCC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecd_z_zs_field_pattern_0_min_cc00_04e0cc00() {
    // Encoding: 0x04E0CC00
    // Test UQDECD_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04E0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecd_z_zs_field_pattern_1_poweroftwo_cc00_04e0cc20() {
    // Encoding: 0x04E0CC20
    // Test UQDECD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0CC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecd_z_zs_field_pattern_15_poweroftwominusone_cc00_04e0cde0() {
    // Encoding: 0x04E0CDE0
    // Test UQDECD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x04E0CDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecd_z_zs_field_pattern_31_max_cc00_04e0cfe0() {
    // Encoding: 0x04E0CFE0
    // Test UQDECD_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, imm4=0, Zdn=0
    let encoding: u32 = 0x04E0CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecd_z_zs_field_zdn_0_min_cc00_04e0cc00() {
    // Encoding: 0x04E0CC00
    // Test UQDECD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecd_z_zs_field_zdn_1_poweroftwo_cc00_04e0cc01() {
    // Encoding: 0x04E0CC01
    // Test UQDECD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=1, imm4=0
    let encoding: u32 = 0x04E0CC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecd_z_zs_field_zdn_15_poweroftwominusone_cc00_04e0cc0f() {
    // Encoding: 0x04E0CC0F
    // Test UQDECD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04E0CC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecd_z_zs_field_zdn_31_max_cc00_04e0cc1f() {
    // Encoding: 0x04E0CC1F
    // Test UQDECD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: pattern=0, Zdn=31, imm4=0
    let encoding: u32 = 0x04E0CC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecd_z_zs_combo_0_cc00_04e0cc00() {
    // Encoding: 0x04E0CC00
    // Test UQDECD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecd_z_zs_invalid_0_cc00_04e0cc00() {
    // Encoding: 0x04E0CC00
    // Test UQDECD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecd_z_zs_invalid_1_cc00_04e0cc00() {
    // Encoding: 0x04E0CC00
    // Test UQDECD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04E0CC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqdecd_z_zs_reg_write_0_04e0cc00() {
    // Test UQDECD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04E0CC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0CC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CNTB_R.S__ Tests
// ============================================================================

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_cntb_r_s_field_imm4_0_zero_e000_0420e000() {
    // Encoding: 0x0420E000
    // Test CNTB_R.S__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Rd=0, imm4=0
    let encoding: u32 = 0x0420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_cntb_r_s_field_imm4_1_poweroftwo_e000_0421e000() {
    // Encoding: 0x0421E000
    // Test CNTB_R.S__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rd=0, imm4=1
    let encoding: u32 = 0x0421E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_cntb_r_s_field_imm4_3_poweroftwominusone_e000_0423e000() {
    // Encoding: 0x0423E000
    // Test CNTB_R.S__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rd=0, pattern=0, imm4=3
    let encoding: u32 = 0x0423E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_cntb_r_s_field_imm4_4_poweroftwo_e000_0424e000() {
    // Encoding: 0x0424E000
    // Test CNTB_R.S__ field imm4 = 4 (PowerOfTwo)
    // Fields: Rd=0, imm4=4, pattern=0
    let encoding: u32 = 0x0424E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_cntb_r_s_field_imm4_7_poweroftwominusone_e000_0427e000() {
    // Encoding: 0x0427E000
    // Test CNTB_R.S__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rd=0, pattern=0, imm4=7
    let encoding: u32 = 0x0427E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_cntb_r_s_field_imm4_8_poweroftwo_e000_0428e000() {
    // Encoding: 0x0428E000
    // Test CNTB_R.S__ field imm4 = 8 (PowerOfTwo)
    // Fields: Rd=0, imm4=8, pattern=0
    let encoding: u32 = 0x0428E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_cntb_r_s_field_imm4_15_max_e000_042fe000() {
    // Encoding: 0x042FE000
    // Test CNTB_R.S__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rd=0
    let encoding: u32 = 0x042FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_cntb_r_s_field_pattern_0_min_e000_0420e000() {
    // Encoding: 0x0420E000
    // Test CNTB_R.S__ field pattern = 0 (Min)
    // Fields: pattern=0, Rd=0, imm4=0
    let encoding: u32 = 0x0420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_cntb_r_s_field_pattern_1_poweroftwo_e000_0420e020() {
    // Encoding: 0x0420E020
    // Test CNTB_R.S__ field pattern = 1 (PowerOfTwo)
    // Fields: Rd=0, imm4=0, pattern=1
    let encoding: u32 = 0x0420E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_cntb_r_s_field_pattern_15_poweroftwominusone_e000_0420e1e0() {
    // Encoding: 0x0420E1E0
    // Test CNTB_R.S__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rd=0, imm4=0, pattern=15
    let encoding: u32 = 0x0420E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_cntb_r_s_field_pattern_31_max_e000_0420e3e0() {
    // Encoding: 0x0420E3E0
    // Test CNTB_R.S__ field pattern = 31 (Max)
    // Fields: pattern=31, Rd=0, imm4=0
    let encoding: u32 = 0x0420E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cntb_r_s_field_rd_0_min_e000_0420e000() {
    // Encoding: 0x0420E000
    // Test CNTB_R.S__ field Rd = 0 (Min)
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x0420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cntb_r_s_field_rd_1_poweroftwo_e000_0420e001() {
    // Encoding: 0x0420E001
    // Test CNTB_R.S__ field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, imm4=0, pattern=0
    let encoding: u32 = 0x0420E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_cntb_r_s_field_rd_30_poweroftwominusone_e000_0420e01e() {
    // Encoding: 0x0420E01E
    // Test CNTB_R.S__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, imm4=0, pattern=0
    let encoding: u32 = 0x0420E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_cntb_r_s_field_rd_31_max_e000_0420e01f() {
    // Encoding: 0x0420E01F
    // Test CNTB_R.S__ field Rd = 31 (Max)
    // Fields: imm4=0, Rd=31, pattern=0
    let encoding: u32 = 0x0420E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_cntb_r_s_combo_0_e000_0420e000() {
    // Encoding: 0x0420E000
    // Test CNTB_R.S__ field combination: imm4=0, pattern=0, Rd=0
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x0420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_cntb_r_s_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_57344_0420e01f() {
    // Encoding: 0x0420E01F
    // Test CNTB_R.S__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: imm4=0, pattern=0, Rd=31
    let encoding: u32 = 0x0420E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cntb_r_s_invalid_0_e000_0420e000() {
    // Encoding: 0x0420E000
    // Test CNTB_R.S__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rd=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cntb_r_s_invalid_1_e000_0420e000() {
    // Encoding: 0x0420E000
    // Test CNTB_R.S__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x0420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_cntd_r_s_field_imm4_0_zero_e000_04e0e000() {
    // Encoding: 0x04E0E000
    // Test CNTD_R.S__ field imm4 = 0 (Zero)
    // Fields: Rd=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_cntd_r_s_field_imm4_1_poweroftwo_e000_04e1e000() {
    // Encoding: 0x04E1E000
    // Test CNTD_R.S__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rd=0, imm4=1, pattern=0
    let encoding: u32 = 0x04E1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_cntd_r_s_field_imm4_3_poweroftwominusone_e000_04e3e000() {
    // Encoding: 0x04E3E000
    // Test CNTD_R.S__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rd=0
    let encoding: u32 = 0x04E3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_cntd_r_s_field_imm4_4_poweroftwo_e000_04e4e000() {
    // Encoding: 0x04E4E000
    // Test CNTD_R.S__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rd=0
    let encoding: u32 = 0x04E4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_cntd_r_s_field_imm4_7_poweroftwominusone_e000_04e7e000() {
    // Encoding: 0x04E7E000
    // Test CNTD_R.S__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rd=0, imm4=7
    let encoding: u32 = 0x04E7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_cntd_r_s_field_imm4_8_poweroftwo_e000_04e8e000() {
    // Encoding: 0x04E8E000
    // Test CNTD_R.S__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rd=0, imm4=8
    let encoding: u32 = 0x04E8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_cntd_r_s_field_imm4_15_max_e000_04efe000() {
    // Encoding: 0x04EFE000
    // Test CNTD_R.S__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Rd=0
    let encoding: u32 = 0x04EFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_cntd_r_s_field_pattern_0_min_e000_04e0e000() {
    // Encoding: 0x04E0E000
    // Test CNTD_R.S__ field pattern = 0 (Min)
    // Fields: imm4=0, Rd=0, pattern=0
    let encoding: u32 = 0x04E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_cntd_r_s_field_pattern_1_poweroftwo_e000_04e0e020() {
    // Encoding: 0x04E0E020
    // Test CNTD_R.S__ field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rd=0, imm4=0
    let encoding: u32 = 0x04E0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_cntd_r_s_field_pattern_15_poweroftwominusone_e000_04e0e1e0() {
    // Encoding: 0x04E0E1E0
    // Test CNTD_R.S__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rd=0, imm4=0
    let encoding: u32 = 0x04E0E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_cntd_r_s_field_pattern_31_max_e000_04e0e3e0() {
    // Encoding: 0x04E0E3E0
    // Test CNTD_R.S__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rd=0
    let encoding: u32 = 0x04E0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cntd_r_s_field_rd_0_min_e000_04e0e000() {
    // Encoding: 0x04E0E000
    // Test CNTD_R.S__ field Rd = 0 (Min)
    // Fields: pattern=0, imm4=0, Rd=0
    let encoding: u32 = 0x04E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cntd_r_s_field_rd_1_poweroftwo_e000_04e0e001() {
    // Encoding: 0x04E0E001
    // Test CNTD_R.S__ field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, pattern=0, imm4=0
    let encoding: u32 = 0x04E0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_cntd_r_s_field_rd_30_poweroftwominusone_e000_04e0e01e() {
    // Encoding: 0x04E0E01E
    // Test CNTD_R.S__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Rd=30, imm4=0, pattern=0
    let encoding: u32 = 0x04E0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_cntd_r_s_field_rd_31_max_e000_04e0e01f() {
    // Encoding: 0x04E0E01F
    // Test CNTD_R.S__ field Rd = 31 (Max)
    // Fields: pattern=0, Rd=31, imm4=0
    let encoding: u32 = 0x04E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_cntd_r_s_combo_0_e000_04e0e000() {
    // Encoding: 0x04E0E000
    // Test CNTD_R.S__ field combination: imm4=0, pattern=0, Rd=0
    // Fields: pattern=0, imm4=0, Rd=0
    let encoding: u32 = 0x04E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_cntd_r_s_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_57344_04e0e01f() {
    // Encoding: 0x04E0E01F
    // Test CNTD_R.S__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: pattern=0, Rd=31, imm4=0
    let encoding: u32 = 0x04E0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cntd_r_s_invalid_0_e000_04e0e000() {
    // Encoding: 0x04E0E000
    // Test CNTD_R.S__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x04E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTD_R.S__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cntd_r_s_invalid_1_e000_04e0e000() {
    // Encoding: 0x04E0E000
    // Test CNTD_R.S__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rd=0, imm4=0
    let encoding: u32 = 0x04E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_cnth_r_s_field_imm4_0_zero_e000_0460e000() {
    // Encoding: 0x0460E000
    // Test CNTH_R.S__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x0460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_cnth_r_s_field_imm4_1_poweroftwo_e000_0461e000() {
    // Encoding: 0x0461E000
    // Test CNTH_R.S__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rd=0, pattern=0, imm4=1
    let encoding: u32 = 0x0461E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_cnth_r_s_field_imm4_3_poweroftwominusone_e000_0463e000() {
    // Encoding: 0x0463E000
    // Test CNTH_R.S__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rd=0, imm4=3, pattern=0
    let encoding: u32 = 0x0463E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_cnth_r_s_field_imm4_4_poweroftwo_e000_0464e000() {
    // Encoding: 0x0464E000
    // Test CNTH_R.S__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rd=0
    let encoding: u32 = 0x0464E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_cnth_r_s_field_imm4_7_poweroftwominusone_e000_0467e000() {
    // Encoding: 0x0467E000
    // Test CNTH_R.S__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rd=0, pattern=0, imm4=7
    let encoding: u32 = 0x0467E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_cnth_r_s_field_imm4_8_poweroftwo_e000_0468e000() {
    // Encoding: 0x0468E000
    // Test CNTH_R.S__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rd=0
    let encoding: u32 = 0x0468E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_cnth_r_s_field_imm4_15_max_e000_046fe000() {
    // Encoding: 0x046FE000
    // Test CNTH_R.S__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rd=0
    let encoding: u32 = 0x046FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_cnth_r_s_field_pattern_0_min_e000_0460e000() {
    // Encoding: 0x0460E000
    // Test CNTH_R.S__ field pattern = 0 (Min)
    // Fields: imm4=0, Rd=0, pattern=0
    let encoding: u32 = 0x0460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_cnth_r_s_field_pattern_1_poweroftwo_e000_0460e020() {
    // Encoding: 0x0460E020
    // Test CNTH_R.S__ field pattern = 1 (PowerOfTwo)
    // Fields: Rd=0, pattern=1, imm4=0
    let encoding: u32 = 0x0460E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_cnth_r_s_field_pattern_15_poweroftwominusone_e000_0460e1e0() {
    // Encoding: 0x0460E1E0
    // Test CNTH_R.S__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rd=0
    let encoding: u32 = 0x0460E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_cnth_r_s_field_pattern_31_max_e000_0460e3e0() {
    // Encoding: 0x0460E3E0
    // Test CNTH_R.S__ field pattern = 31 (Max)
    // Fields: Rd=0, imm4=0, pattern=31
    let encoding: u32 = 0x0460E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cnth_r_s_field_rd_0_min_e000_0460e000() {
    // Encoding: 0x0460E000
    // Test CNTH_R.S__ field Rd = 0 (Min)
    // Fields: imm4=0, Rd=0, pattern=0
    let encoding: u32 = 0x0460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cnth_r_s_field_rd_1_poweroftwo_e000_0460e001() {
    // Encoding: 0x0460E001
    // Test CNTH_R.S__ field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, pattern=0, imm4=0
    let encoding: u32 = 0x0460E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_cnth_r_s_field_rd_30_poweroftwominusone_e000_0460e01e() {
    // Encoding: 0x0460E01E
    // Test CNTH_R.S__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rd=30
    let encoding: u32 = 0x0460E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_cnth_r_s_field_rd_31_max_e000_0460e01f() {
    // Encoding: 0x0460E01F
    // Test CNTH_R.S__ field Rd = 31 (Max)
    // Fields: Rd=31, pattern=0, imm4=0
    let encoding: u32 = 0x0460E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_cnth_r_s_combo_0_e000_0460e000() {
    // Encoding: 0x0460E000
    // Test CNTH_R.S__ field combination: imm4=0, pattern=0, Rd=0
    // Fields: Rd=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_cnth_r_s_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_57344_0460e01f() {
    // Encoding: 0x0460E01F
    // Test CNTH_R.S__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: pattern=0, imm4=0, Rd=31
    let encoding: u32 = 0x0460E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cnth_r_s_invalid_0_e000_0460e000() {
    // Encoding: 0x0460E000
    // Test CNTH_R.S__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rd=0, imm4=0
    let encoding: u32 = 0x0460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTH_R.S__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cnth_r_s_invalid_1_e000_0460e000() {
    // Encoding: 0x0460E000
    // Test CNTH_R.S__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rd=0, imm4=0
    let encoding: u32 = 0x0460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_cntw_r_s_field_imm4_0_zero_e000_04a0e000() {
    // Encoding: 0x04A0E000
    // Test CNTW_R.S__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x04A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_cntw_r_s_field_imm4_1_poweroftwo_e000_04a1e000() {
    // Encoding: 0x04A1E000
    // Test CNTW_R.S__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rd=0, imm4=1, pattern=0
    let encoding: u32 = 0x04A1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_cntw_r_s_field_imm4_3_poweroftwominusone_e000_04a3e000() {
    // Encoding: 0x04A3E000
    // Test CNTW_R.S__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rd=0, imm4=3
    let encoding: u32 = 0x04A3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_cntw_r_s_field_imm4_4_poweroftwo_e000_04a4e000() {
    // Encoding: 0x04A4E000
    // Test CNTW_R.S__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rd=0
    let encoding: u32 = 0x04A4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_cntw_r_s_field_imm4_7_poweroftwominusone_e000_04a7e000() {
    // Encoding: 0x04A7E000
    // Test CNTW_R.S__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Rd=0
    let encoding: u32 = 0x04A7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_cntw_r_s_field_imm4_8_poweroftwo_e000_04a8e000() {
    // Encoding: 0x04A8E000
    // Test CNTW_R.S__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rd=0
    let encoding: u32 = 0x04A8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_cntw_r_s_field_imm4_15_max_e000_04afe000() {
    // Encoding: 0x04AFE000
    // Test CNTW_R.S__ field imm4 = 15 (Max)
    // Fields: pattern=0, Rd=0, imm4=15
    let encoding: u32 = 0x04AFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_cntw_r_s_field_pattern_0_min_e000_04a0e000() {
    // Encoding: 0x04A0E000
    // Test CNTW_R.S__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rd=0
    let encoding: u32 = 0x04A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_cntw_r_s_field_pattern_1_poweroftwo_e000_04a0e020() {
    // Encoding: 0x04A0E020
    // Test CNTW_R.S__ field pattern = 1 (PowerOfTwo)
    // Fields: Rd=0, pattern=1, imm4=0
    let encoding: u32 = 0x04A0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_cntw_r_s_field_pattern_15_poweroftwominusone_e000_04a0e1e0() {
    // Encoding: 0x04A0E1E0
    // Test CNTW_R.S__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rd=0, pattern=15, imm4=0
    let encoding: u32 = 0x04A0E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_cntw_r_s_field_pattern_31_max_e000_04a0e3e0() {
    // Encoding: 0x04A0E3E0
    // Test CNTW_R.S__ field pattern = 31 (Max)
    // Fields: Rd=0, pattern=31, imm4=0
    let encoding: u32 = 0x04A0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cntw_r_s_field_rd_0_min_e000_04a0e000() {
    // Encoding: 0x04A0E000
    // Test CNTW_R.S__ field Rd = 0 (Min)
    // Fields: Rd=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cntw_r_s_field_rd_1_poweroftwo_e000_04a0e001() {
    // Encoding: 0x04A0E001
    // Test CNTW_R.S__ field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, imm4=0, pattern=0
    let encoding: u32 = 0x04A0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_cntw_r_s_field_rd_30_poweroftwominusone_e000_04a0e01e() {
    // Encoding: 0x04A0E01E
    // Test CNTW_R.S__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rd=30, pattern=0
    let encoding: u32 = 0x04A0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_cntw_r_s_field_rd_31_max_e000_04a0e01f() {
    // Encoding: 0x04A0E01F
    // Test CNTW_R.S__ field Rd = 31 (Max)
    // Fields: pattern=0, imm4=0, Rd=31
    let encoding: u32 = 0x04A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_cntw_r_s_combo_0_e000_04a0e000() {
    // Encoding: 0x04A0E000
    // Test CNTW_R.S__ field combination: imm4=0, pattern=0, Rd=0
    // Fields: pattern=0, Rd=0, imm4=0
    let encoding: u32 = 0x04A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_cntw_r_s_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_57344_04a0e01f() {
    // Encoding: 0x04A0E01F
    // Test CNTW_R.S__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: pattern=0, Rd=31, imm4=0
    let encoding: u32 = 0x04A0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cntw_r_s_invalid_0_e000_04a0e000() {
    // Encoding: 0x04A0E000
    // Test CNTW_R.S__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rd=0
    let encoding: u32 = 0x04A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTW_R.S__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cntw_r_s_invalid_1_e000_04a0e000() {
    // Encoding: 0x04A0E000
    // Test CNTW_R.S__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Rd=0
    let encoding: u32 = 0x04A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTB_R.S__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_cntb_r_s_reg_write_0_0420e000() {
    // Test CNTB_R.S__ register write: GpFromField("d")
    // Encoding: 0x0420E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CNTB_R.S__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_cntb_r_s_zr_rd_0420e01f() {
    // Test CNTB_R.S__ with Rd = ZR (31)
    // Encoding: 0x0420E01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420E01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: CNTD_R.S__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_cntd_r_s_reg_write_0_04e0e000() {
    // Test CNTD_R.S__ register write: GpFromField("d")
    // Encoding: 0x04E0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CNTD_R.S__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_cntd_r_s_zr_rd_04e0e01f() {
    // Test CNTD_R.S__ with Rd = ZR (31)
    // Encoding: 0x04E0E01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0E01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: CNTH_R.S__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_cnth_r_s_reg_write_0_0460e000() {
    // Test CNTH_R.S__ register write: GpFromField("d")
    // Encoding: 0x0460E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CNTH_R.S__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_cnth_r_s_zr_rd_0460e01f() {
    // Test CNTH_R.S__ with Rd = ZR (31)
    // Encoding: 0x0460E01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460E01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

/// Provenance: CNTW_R.S__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_cntw_r_s_reg_write_0_04a0e000() {
    // Test CNTW_R.S__ register write: GpFromField("d")
    // Encoding: 0x04A0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CNTW_R.S__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_cntw_r_s_zr_rd_04a0e01f() {
    // Test CNTW_R.S__ with Rd = ZR (31)
    // Encoding: 0x04A0E01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0E01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// UQINCP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqincp_z_p_z_field_size_0_min_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqincp_z_p_z_field_size_1_poweroftwo_8000_25698000() {
    // Encoding: 0x25698000
    // Test UQINCP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zdn=0
    let encoding: u32 = 0x25698000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqincp_z_p_z_field_size_2_poweroftwo_8000_25a98000() {
    // Encoding: 0x25A98000
    // Test UQINCP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x25A98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqincp_z_p_z_field_size_3_max_8000_25e98000() {
    // Encoding: 0x25E98000
    // Test UQINCP_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x25E98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqincp_z_p_z_field_pg_0_min_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqincp_z_p_z_field_pg_1_poweroftwo_8000_25298020() {
    // Encoding: 0x25298020
    // Test UQINCP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=1, size=0
    let encoding: u32 = 0x25298020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincp_z_p_z_field_zdn_0_min_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincp_z_p_z_field_zdn_1_poweroftwo_8000_25298001() {
    // Encoding: 0x25298001
    // Test UQINCP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zdn=1
    let encoding: u32 = 0x25298001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincp_z_p_z_field_zdn_15_poweroftwominusone_8000_2529800f() {
    // Encoding: 0x2529800F
    // Test UQINCP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x2529800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincp_z_p_z_field_zdn_31_max_8000_2529801f() {
    // Encoding: 0x2529801F
    // Test UQINCP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31
    let encoding: u32 = 0x2529801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqincp_z_p_z_combo_0_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqincp_z_p_z_special_size_0_size_variant_0_32768_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqincp_z_p_z_special_size_1_size_variant_1_32768_25698000() {
    // Encoding: 0x25698000
    // Test UQINCP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x25698000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqincp_z_p_z_special_size_2_size_variant_2_32768_25a98000() {
    // Encoding: 0x25A98000
    // Test UQINCP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x25A98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqincp_z_p_z_special_size_3_size_variant_3_32768_25e98000() {
    // Encoding: 0x25E98000
    // Test UQINCP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x25E98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincp_z_p_z_invalid_0_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincp_z_p_z_invalid_1_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_uqincp_z_p_z_invalid_2_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincp_z_p_z_invalid_3_8000_25298000() {
    // Encoding: 0x25298000
    // Test UQINCP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x25298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqincp_z_p_z_reg_write_0_25298000() {
    // Test UQINCP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x25298000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25298000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCH_R.RS_SX Tests
// ============================================================================

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqinch_r_rs_sx_field_imm4_0_zero_f000_0460f000() {
    // Encoding: 0x0460F000
    // Test SQINCH_R.RS_SX field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0460F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqinch_r_rs_sx_field_imm4_1_poweroftwo_f000_0461f000() {
    // Encoding: 0x0461F000
    // Test SQINCH_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=1
    let encoding: u32 = 0x0461F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqinch_r_rs_sx_field_imm4_3_poweroftwominusone_f000_0463f000() {
    // Encoding: 0x0463F000
    // Test SQINCH_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x0463F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqinch_r_rs_sx_field_imm4_4_poweroftwo_f000_0464f000() {
    // Encoding: 0x0464F000
    // Test SQINCH_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x0464F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqinch_r_rs_sx_field_imm4_7_poweroftwominusone_f000_0467f000() {
    // Encoding: 0x0467F000
    // Test SQINCH_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Rdn=0
    let encoding: u32 = 0x0467F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqinch_r_rs_sx_field_imm4_8_poweroftwo_f000_0468f000() {
    // Encoding: 0x0468F000
    // Test SQINCH_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0468F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqinch_r_rs_sx_field_imm4_15_max_f000_046ff000() {
    // Encoding: 0x046FF000
    // Test SQINCH_R.RS_SX field imm4 = 15 (Max)
    // Fields: pattern=0, Rdn=0, imm4=15
    let encoding: u32 = 0x046FF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqinch_r_rs_sx_field_pattern_0_min_f000_0460f000() {
    // Encoding: 0x0460F000
    // Test SQINCH_R.RS_SX field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0460F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqinch_r_rs_sx_field_pattern_1_poweroftwo_f000_0460f020() {
    // Encoding: 0x0460F020
    // Test SQINCH_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=0, pattern=1
    let encoding: u32 = 0x0460F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqinch_r_rs_sx_field_pattern_15_poweroftwominusone_f000_0460f1e0() {
    // Encoding: 0x0460F1E0
    // Test SQINCH_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x0460F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqinch_r_rs_sx_field_pattern_31_max_f000_0460f3e0() {
    // Encoding: 0x0460F3E0
    // Test SQINCH_R.RS_SX field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x0460F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqinch_r_rs_sx_field_rdn_0_min_f000_0460f000() {
    // Encoding: 0x0460F000
    // Test SQINCH_R.RS_SX field Rdn = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0460F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqinch_r_rs_sx_field_rdn_1_poweroftwo_f000_0460f001() {
    // Encoding: 0x0460F001
    // Test SQINCH_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0460F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqinch_r_rs_sx_field_rdn_15_poweroftwominusone_f000_0460f00f() {
    // Encoding: 0x0460F00F
    // Test SQINCH_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0460F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqinch_r_rs_sx_field_rdn_31_max_f000_0460f01f() {
    // Encoding: 0x0460F01F
    // Test SQINCH_R.RS_SX field Rdn = 31 (Max)
    // Fields: pattern=0, Rdn=31, imm4=0
    let encoding: u32 = 0x0460F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqinch_r_rs_sx_combo_0_f000_0460f000() {
    // Encoding: 0x0460F000
    // Test SQINCH_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0460F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqinch_r_rs_sx_invalid_0_f000_0460f000() {
    // Encoding: 0x0460F000
    // Test SQINCH_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqinch_r_rs_sx_invalid_1_f000_0460f000() {
    // Encoding: 0x0460F000
    // Test SQINCH_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0460F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqinch_r_rs_x_field_imm4_0_zero_f000_0470f000() {
    // Encoding: 0x0470F000
    // Test SQINCH_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqinch_r_rs_x_field_imm4_1_poweroftwo_f000_0471f000() {
    // Encoding: 0x0471F000
    // Test SQINCH_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Rdn=0
    let encoding: u32 = 0x0471F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqinch_r_rs_x_field_imm4_3_poweroftwominusone_f000_0473f000() {
    // Encoding: 0x0473F000
    // Test SQINCH_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x0473F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqinch_r_rs_x_field_imm4_4_poweroftwo_f000_0474f000() {
    // Encoding: 0x0474F000
    // Test SQINCH_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x0474F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqinch_r_rs_x_field_imm4_7_poweroftwominusone_f000_0477f000() {
    // Encoding: 0x0477F000
    // Test SQINCH_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x0477F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqinch_r_rs_x_field_imm4_8_poweroftwo_f000_0478f000() {
    // Encoding: 0x0478F000
    // Test SQINCH_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0478F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqinch_r_rs_x_field_imm4_15_max_f000_047ff000() {
    // Encoding: 0x047FF000
    // Test SQINCH_R.RS_X field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Rdn=0
    let encoding: u32 = 0x047FF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqinch_r_rs_x_field_pattern_0_min_f000_0470f000() {
    // Encoding: 0x0470F000
    // Test SQINCH_R.RS_X field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqinch_r_rs_x_field_pattern_1_poweroftwo_f000_0470f020() {
    // Encoding: 0x0470F020
    // Test SQINCH_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqinch_r_rs_x_field_pattern_15_poweroftwominusone_f000_0470f1e0() {
    // Encoding: 0x0470F1E0
    // Test SQINCH_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqinch_r_rs_x_field_pattern_31_max_f000_0470f3e0() {
    // Encoding: 0x0470F3E0
    // Test SQINCH_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0470F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqinch_r_rs_x_field_rdn_0_min_f000_0470f000() {
    // Encoding: 0x0470F000
    // Test SQINCH_R.RS_X field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0470F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqinch_r_rs_x_field_rdn_1_poweroftwo_f000_0470f001() {
    // Encoding: 0x0470F001
    // Test SQINCH_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x0470F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqinch_r_rs_x_field_rdn_15_poweroftwominusone_f000_0470f00f() {
    // Encoding: 0x0470F00F
    // Test SQINCH_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x0470F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqinch_r_rs_x_field_rdn_31_max_f000_0470f01f() {
    // Encoding: 0x0470F01F
    // Test SQINCH_R.RS_X field Rdn = 31 (Max)
    // Fields: pattern=0, Rdn=31, imm4=0
    let encoding: u32 = 0x0470F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqinch_r_rs_x_combo_0_f000_0470f000() {
    // Encoding: 0x0470F000
    // Test SQINCH_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0470F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqinch_r_rs_x_invalid_0_f000_0470f000() {
    // Encoding: 0x0470F000
    // Test SQINCH_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqinch_r_rs_x_invalid_1_f000_0470f000() {
    // Encoding: 0x0470F000
    // Test SQINCH_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0470F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCH_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqinch_r_rs_sx_reg_write_0_0460f000() {
    // Test SQINCH_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x0460F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQINCH_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqinch_r_rs_x_reg_write_0_0470f000() {
    // Test SQINCH_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0470F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INCP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_incp_z_p_z_field_size_0_min_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_incp_z_p_z_field_size_1_poweroftwo_8000_256c8000() {
    // Encoding: 0x256C8000
    // Test INCP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x256C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_incp_z_p_z_field_size_2_poweroftwo_8000_25ac8000() {
    // Encoding: 0x25AC8000
    // Test INCP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_incp_z_p_z_field_size_3_max_8000_25ec8000() {
    // Encoding: 0x25EC8000
    // Test INCP_Z.P.Z__ field size = 3 (Max)
    // Fields: Zdn=0, Pg=0, size=3
    let encoding: u32 = 0x25EC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_incp_z_p_z_field_pg_0_min_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_incp_z_p_z_field_pg_1_poweroftwo_8000_252c8020() {
    // Encoding: 0x252C8020
    // Test INCP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zdn=0
    let encoding: u32 = 0x252C8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incp_z_p_z_field_zdn_0_min_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incp_z_p_z_field_zdn_1_poweroftwo_8000_252c8001() {
    // Encoding: 0x252C8001
    // Test INCP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x252C8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incp_z_p_z_field_zdn_15_poweroftwominusone_8000_252c800f() {
    // Encoding: 0x252C800F
    // Test INCP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x252C800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incp_z_p_z_field_zdn_31_max_8000_252c801f() {
    // Encoding: 0x252C801F
    // Test INCP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Pg=0
    let encoding: u32 = 0x252C801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_incp_z_p_z_combo_0_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_incp_z_p_z_special_size_0_size_variant_0_32768_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_incp_z_p_z_special_size_1_size_variant_1_32768_256c8000() {
    // Encoding: 0x256C8000
    // Test INCP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x256C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_incp_z_p_z_special_size_2_size_variant_2_32768_25ac8000() {
    // Encoding: 0x25AC8000
    // Test INCP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x25AC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_incp_z_p_z_special_size_3_size_variant_3_32768_25ec8000() {
    // Encoding: 0x25EC8000
    // Test INCP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x25EC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incp_z_p_z_invalid_0_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incp_z_p_z_invalid_1_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_incp_z_p_z_invalid_2_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incp_z_p_z_invalid_3_8000_252c8000() {
    // Encoding: 0x252C8000
    // Test INCP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_incp_z_p_z_reg_write_0_252c8000() {
    // Test INCP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x252C8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252C8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CNTP_R.P.P__ Tests
// ============================================================================

/// Provenance: CNTP_R.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cntp_r_p_p_field_size_0_min_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ field size = 0 (Min)
    // Fields: Pn=0, size=0, Pg=0, Rd=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cntp_r_p_p_field_size_1_poweroftwo_8000_25608000() {
    // Encoding: 0x25608000
    // Test CNTP_R.P.P__ field size = 1 (PowerOfTwo)
    // Fields: Pn=0, Pg=0, Rd=0, size=1
    let encoding: u32 = 0x25608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cntp_r_p_p_field_size_2_poweroftwo_8000_25a08000() {
    // Encoding: 0x25A08000
    // Test CNTP_R.P.P__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Rd=0, size=2, Pn=0
    let encoding: u32 = 0x25A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cntp_r_p_p_field_size_3_max_8000_25e08000() {
    // Encoding: 0x25E08000
    // Test CNTP_R.P.P__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Pn=0, Rd=0
    let encoding: u32 = 0x25E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cntp_r_p_p_field_pg_0_min_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Pn=0, Rd=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cntp_r_p_p_field_pg_1_poweroftwo_8000_25208400() {
    // Encoding: 0x25208400
    // Test CNTP_R.P.P__ field Pg = 1 (PowerOfTwo)
    // Fields: Rd=0, Pn=0, Pg=1, size=0
    let encoding: u32 = 0x25208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cntp_r_p_p_field_pn_0_min_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ field Pn = 0 (Min)
    // Fields: Pg=0, Rd=0, size=0, Pn=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cntp_r_p_p_field_pn_1_poweroftwo_8000_25208020() {
    // Encoding: 0x25208020
    // Test CNTP_R.P.P__ field Pn = 1 (PowerOfTwo)
    // Fields: Pg=0, Pn=1, Rd=0, size=0
    let encoding: u32 = 0x25208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cntp_r_p_p_field_rd_0_min_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ field Rd = 0 (Min)
    // Fields: size=0, Pg=0, Pn=0, Rd=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cntp_r_p_p_field_rd_1_poweroftwo_8000_25208001() {
    // Encoding: 0x25208001
    // Test CNTP_R.P.P__ field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Rd=1, Pn=0
    let encoding: u32 = 0x25208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_cntp_r_p_p_field_rd_30_poweroftwominusone_8000_2520801e() {
    // Encoding: 0x2520801E
    // Test CNTP_R.P.P__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Pn=0, size=0, Pg=0, Rd=30
    let encoding: u32 = 0x2520801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_cntp_r_p_p_field_rd_31_max_8000_2520801f() {
    // Encoding: 0x2520801F
    // Test CNTP_R.P.P__ field Rd = 31 (Max)
    // Fields: Rd=31, size=0, Pn=0, Pg=0
    let encoding: u32 = 0x2520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cntp_r_p_p_combo_0_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ field combination: size=0, Pg=0, Pn=0, Rd=0
    // Fields: Pn=0, Pg=0, Rd=0, size=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cntp_r_p_p_special_size_0_size_variant_0_32768_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ special value size = 0 (Size variant 0)
    // Fields: Rd=0, Pn=0, Pg=0, size=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cntp_r_p_p_special_size_1_size_variant_1_32768_25608000() {
    // Encoding: 0x25608000
    // Test CNTP_R.P.P__ special value size = 1 (Size variant 1)
    // Fields: Rd=0, size=1, Pn=0, Pg=0
    let encoding: u32 = 0x25608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cntp_r_p_p_special_size_2_size_variant_2_32768_25a08000() {
    // Encoding: 0x25A08000
    // Test CNTP_R.P.P__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Rd=0, size=2, Pn=0
    let encoding: u32 = 0x25A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cntp_r_p_p_special_size_3_size_variant_3_32768_25e08000() {
    // Encoding: 0x25E08000
    // Test CNTP_R.P.P__ special value size = 3 (Size variant 3)
    // Fields: Pn=0, Pg=0, Rd=0, size=3
    let encoding: u32 = 0x25E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_cntp_r_p_p_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_32768_2520801f()
{
    // Encoding: 0x2520801F
    // Test CNTP_R.P.P__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Pn=0, size=0, Pg=0, Rd=31
    let encoding: u32 = 0x2520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cntp_r_p_p_invalid_0_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Pn=0, size=0, Rd=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cntp_r_p_p_invalid_1_8000_25208000() {
    // Encoding: 0x25208000
    // Test CNTP_R.P.P__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, size=0, Pn=0, Pg=0
    let encoding: u32 = 0x25208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNTP_R.P.P__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_cntp_r_p_p_reg_write_0_25208000() {
    // Test CNTP_R.P.P__ register write: GpFromField("d")
    // Encoding: 0x25208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CNTP_R.P.P__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_cntp_r_p_p_zr_rd_2520801f() {
    // Test CNTP_R.P.P__ with Rd = ZR (31)
    // Encoding: 0x2520801F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2520801F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// UQINCW_Z.ZS__ Tests
// ============================================================================

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincw_z_zs_field_imm4_0_zero_c400_04a0c400() {
    // Encoding: 0x04A0C400
    // Test UQINCW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincw_z_zs_field_imm4_1_poweroftwo_c400_04a1c400() {
    // Encoding: 0x04A1C400
    // Test UQINCW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Zdn=0
    let encoding: u32 = 0x04A1C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincw_z_zs_field_imm4_3_poweroftwominusone_c400_04a3c400() {
    // Encoding: 0x04A3C400
    // Test UQINCW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04A3C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincw_z_zs_field_imm4_4_poweroftwo_c400_04a4c400() {
    // Encoding: 0x04A4C400
    // Test UQINCW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Zdn=0
    let encoding: u32 = 0x04A4C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincw_z_zs_field_imm4_7_poweroftwominusone_c400_04a7c400() {
    // Encoding: 0x04A7C400
    // Test UQINCW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=7
    let encoding: u32 = 0x04A7C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincw_z_zs_field_imm4_8_poweroftwo_c400_04a8c400() {
    // Encoding: 0x04A8C400
    // Test UQINCW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x04A8C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincw_z_zs_field_imm4_15_max_c400_04afc400() {
    // Encoding: 0x04AFC400
    // Test UQINCW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Zdn=0
    let encoding: u32 = 0x04AFC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincw_z_zs_field_pattern_0_min_c400_04a0c400() {
    // Encoding: 0x04A0C400
    // Test UQINCW_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincw_z_zs_field_pattern_1_poweroftwo_c400_04a0c420() {
    // Encoding: 0x04A0C420
    // Test UQINCW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x04A0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincw_z_zs_field_pattern_15_poweroftwominusone_c400_04a0c5e0() {
    // Encoding: 0x04A0C5E0
    // Test UQINCW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=0, pattern=15
    let encoding: u32 = 0x04A0C5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincw_z_zs_field_pattern_31_max_c400_04a0c7e0() {
    // Encoding: 0x04A0C7E0
    // Test UQINCW_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x04A0C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincw_z_zs_field_zdn_0_min_c400_04a0c400() {
    // Encoding: 0x04A0C400
    // Test UQINCW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincw_z_zs_field_zdn_1_poweroftwo_c400_04a0c401() {
    // Encoding: 0x04A0C401
    // Test UQINCW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x04A0C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincw_z_zs_field_zdn_15_poweroftwominusone_c400_04a0c40f() {
    // Encoding: 0x04A0C40F
    // Test UQINCW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04A0C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincw_z_zs_field_zdn_31_max_c400_04a0c41f() {
    // Encoding: 0x04A0C41F
    // Test UQINCW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, Zdn=31, pattern=0
    let encoding: u32 = 0x04A0C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincw_z_zs_combo_0_c400_04a0c400() {
    // Encoding: 0x04A0C400
    // Test UQINCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincw_z_zs_invalid_0_c400_04a0c400() {
    // Encoding: 0x04A0C400
    // Test UQINCW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincw_z_zs_invalid_1_c400_04a0c400() {
    // Encoding: 0x04A0C400
    // Test UQINCW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqincw_z_zs_reg_write_0_04a0c400() {
    // Test UQINCW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04A0C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCH_Z.ZS__ Tests
// ============================================================================

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqinch_z_zs_field_imm4_0_zero_c400_0460c400() {
    // Encoding: 0x0460C400
    // Test UQINCH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x0460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqinch_z_zs_field_imm4_1_poweroftwo_c400_0461c400() {
    // Encoding: 0x0461C400
    // Test UQINCH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0461C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqinch_z_zs_field_imm4_3_poweroftwominusone_c400_0463c400() {
    // Encoding: 0x0463C400
    // Test UQINCH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x0463C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqinch_z_zs_field_imm4_4_poweroftwo_c400_0464c400() {
    // Encoding: 0x0464C400
    // Test UQINCH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Zdn=0
    let encoding: u32 = 0x0464C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqinch_z_zs_field_imm4_7_poweroftwominusone_c400_0467c400() {
    // Encoding: 0x0467C400
    // Test UQINCH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=7
    let encoding: u32 = 0x0467C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqinch_z_zs_field_imm4_8_poweroftwo_c400_0468c400() {
    // Encoding: 0x0468C400
    // Test UQINCH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0468C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqinch_z_zs_field_imm4_15_max_c400_046fc400() {
    // Encoding: 0x046FC400
    // Test UQINCH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Zdn=0
    let encoding: u32 = 0x046FC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqinch_z_zs_field_pattern_0_min_c400_0460c400() {
    // Encoding: 0x0460C400
    // Test UQINCH_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x0460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqinch_z_zs_field_pattern_1_poweroftwo_c400_0460c420() {
    // Encoding: 0x0460C420
    // Test UQINCH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqinch_z_zs_field_pattern_15_poweroftwominusone_c400_0460c5e0() {
    // Encoding: 0x0460C5E0
    // Test UQINCH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=0, pattern=15
    let encoding: u32 = 0x0460C5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqinch_z_zs_field_pattern_31_max_c400_0460c7e0() {
    // Encoding: 0x0460C7E0
    // Test UQINCH_Z.ZS__ field pattern = 31 (Max)
    // Fields: Zdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x0460C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqinch_z_zs_field_zdn_0_min_c400_0460c400() {
    // Encoding: 0x0460C400
    // Test UQINCH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqinch_z_zs_field_zdn_1_poweroftwo_c400_0460c401() {
    // Encoding: 0x0460C401
    // Test UQINCH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, pattern=0, imm4=0
    let encoding: u32 = 0x0460C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqinch_z_zs_field_zdn_15_poweroftwominusone_c400_0460c40f() {
    // Encoding: 0x0460C40F
    // Test UQINCH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x0460C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqinch_z_zs_field_zdn_31_max_c400_0460c41f() {
    // Encoding: 0x0460C41F
    // Test UQINCH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x0460C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqinch_z_zs_combo_0_c400_0460c400() {
    // Encoding: 0x0460C400
    // Test UQINCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqinch_z_zs_invalid_0_c400_0460c400() {
    // Encoding: 0x0460C400
    // Test UQINCH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqinch_z_zs_invalid_1_c400_0460c400() {
    // Encoding: 0x0460C400
    // Test UQINCH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqinch_z_zs_reg_write_0_0460c400() {
    // Test UQINCH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0460C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCW_R.RS_SX Tests
// ============================================================================

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincw_r_rs_sx_field_imm4_0_zero_f000_04a0f000() {
    // Encoding: 0x04A0F000
    // Test SQINCW_R.RS_SX field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincw_r_rs_sx_field_imm4_1_poweroftwo_f000_04a1f000() {
    // Encoding: 0x04A1F000
    // Test SQINCW_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x04A1F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincw_r_rs_sx_field_imm4_3_poweroftwominusone_f000_04a3f000() {
    // Encoding: 0x04A3F000
    // Test SQINCW_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x04A3F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincw_r_rs_sx_field_imm4_4_poweroftwo_f000_04a4f000() {
    // Encoding: 0x04A4F000
    // Test SQINCW_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x04A4F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincw_r_rs_sx_field_imm4_7_poweroftwominusone_f000_04a7f000() {
    // Encoding: 0x04A7F000
    // Test SQINCW_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04A7F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincw_r_rs_sx_field_imm4_8_poweroftwo_f000_04a8f000() {
    // Encoding: 0x04A8F000
    // Test SQINCW_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=8
    let encoding: u32 = 0x04A8F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincw_r_rs_sx_field_imm4_15_max_f000_04aff000() {
    // Encoding: 0x04AFF000
    // Test SQINCW_R.RS_SX field imm4 = 15 (Max)
    // Fields: pattern=0, Rdn=0, imm4=15
    let encoding: u32 = 0x04AFF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincw_r_rs_sx_field_pattern_0_min_f000_04a0f000() {
    // Encoding: 0x04A0F000
    // Test SQINCW_R.RS_SX field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincw_r_rs_sx_field_pattern_1_poweroftwo_f000_04a0f020() {
    // Encoding: 0x04A0F020
    // Test SQINCW_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincw_r_rs_sx_field_pattern_15_poweroftwominusone_f000_04a0f1e0() {
    // Encoding: 0x04A0F1E0
    // Test SQINCW_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincw_r_rs_sx_field_pattern_31_max_f000_04a0f3e0() {
    // Encoding: 0x04A0F3E0
    // Test SQINCW_R.RS_SX field pattern = 31 (Max)
    // Fields: pattern=31, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincw_r_rs_sx_field_rdn_0_min_f000_04a0f000() {
    // Encoding: 0x04A0F000
    // Test SQINCW_R.RS_SX field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincw_r_rs_sx_field_rdn_1_poweroftwo_f000_04a0f001() {
    // Encoding: 0x04A0F001
    // Test SQINCW_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Rdn=1
    let encoding: u32 = 0x04A0F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincw_r_rs_sx_field_rdn_15_poweroftwominusone_f000_04a0f00f() {
    // Encoding: 0x04A0F00F
    // Test SQINCW_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x04A0F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincw_r_rs_sx_field_rdn_31_max_f000_04a0f01f() {
    // Encoding: 0x04A0F01F
    // Test SQINCW_R.RS_SX field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x04A0F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincw_r_rs_sx_combo_0_f000_04a0f000() {
    // Encoding: 0x04A0F000
    // Test SQINCW_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincw_r_rs_sx_invalid_0_f000_04a0f000() {
    // Encoding: 0x04A0F000
    // Test SQINCW_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04A0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincw_r_rs_sx_invalid_1_f000_04a0f000() {
    // Encoding: 0x04A0F000
    // Test SQINCW_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincw_r_rs_x_field_imm4_0_zero_f000_04b0f000() {
    // Encoding: 0x04B0F000
    // Test SQINCW_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincw_r_rs_x_field_imm4_1_poweroftwo_f000_04b1f000() {
    // Encoding: 0x04B1F000
    // Test SQINCW_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x04B1F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincw_r_rs_x_field_imm4_3_poweroftwominusone_f000_04b3f000() {
    // Encoding: 0x04B3F000
    // Test SQINCW_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x04B3F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincw_r_rs_x_field_imm4_4_poweroftwo_f000_04b4f000() {
    // Encoding: 0x04B4F000
    // Test SQINCW_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04B4F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincw_r_rs_x_field_imm4_7_poweroftwominusone_f000_04b7f000() {
    // Encoding: 0x04B7F000
    // Test SQINCW_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04B7F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincw_r_rs_x_field_imm4_8_poweroftwo_f000_04b8f000() {
    // Encoding: 0x04B8F000
    // Test SQINCW_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04B8F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincw_r_rs_x_field_imm4_15_max_f000_04bff000() {
    // Encoding: 0x04BFF000
    // Test SQINCW_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04BFF000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincw_r_rs_x_field_pattern_0_min_f000_04b0f000() {
    // Encoding: 0x04B0F000
    // Test SQINCW_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincw_r_rs_x_field_pattern_1_poweroftwo_f000_04b0f020() {
    // Encoding: 0x04B0F020
    // Test SQINCW_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0F020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincw_r_rs_x_field_pattern_15_poweroftwominusone_f000_04b0f1e0() {
    // Encoding: 0x04B0F1E0
    // Test SQINCW_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0F1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincw_r_rs_x_field_pattern_31_max_f000_04b0f3e0() {
    // Encoding: 0x04B0F3E0
    // Test SQINCW_R.RS_X field pattern = 31 (Max)
    // Fields: pattern=31, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0F3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincw_r_rs_x_field_rdn_0_min_f000_04b0f000() {
    // Encoding: 0x04B0F000
    // Test SQINCW_R.RS_X field Rdn = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04B0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincw_r_rs_x_field_rdn_1_poweroftwo_f000_04b0f001() {
    // Encoding: 0x04B0F001
    // Test SQINCW_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Rdn=1
    let encoding: u32 = 0x04B0F001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincw_r_rs_x_field_rdn_15_poweroftwominusone_f000_04b0f00f() {
    // Encoding: 0x04B0F00F
    // Test SQINCW_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x04B0F00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincw_r_rs_x_field_rdn_31_max_f000_04b0f01f() {
    // Encoding: 0x04B0F01F
    // Test SQINCW_R.RS_X field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x04B0F01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincw_r_rs_x_combo_0_f000_04b0f000() {
    // Encoding: 0x04B0F000
    // Test SQINCW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincw_r_rs_x_invalid_0_f000_04b0f000() {
    // Encoding: 0x04B0F000
    // Test SQINCW_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincw_r_rs_x_invalid_1_f000_04b0f000() {
    // Encoding: 0x04B0F000
    // Test SQINCW_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0F000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCW_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincw_r_rs_sx_reg_write_0_04a0f000() {
    // Test SQINCW_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x04A0F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQINCW_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincw_r_rs_x_reg_write_0_04b0f000() {
    // Test SQINCW_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04B0F000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0F000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECD_R.RS_SX Tests
// ============================================================================

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_0_zero_f800_04e0f800() {
    // Encoding: 0x04E0F800
    // Test SQDECD_R.RS_SX field imm4 = 0 (Zero)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_1_poweroftwo_f800_04e1f800() {
    // Encoding: 0x04E1F800
    // Test SQDECD_R.RS_SX field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04E1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_3_poweroftwominusone_f800_04e3f800() {
    // Encoding: 0x04E3F800
    // Test SQDECD_R.RS_SX field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rdn=0, pattern=0
    let encoding: u32 = 0x04E3F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_4_poweroftwo_f800_04e4f800() {
    // Encoding: 0x04E4F800
    // Test SQDECD_R.RS_SX field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rdn=0
    let encoding: u32 = 0x04E4F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_7_poweroftwominusone_f800_04e7f800() {
    // Encoding: 0x04E7F800
    // Test SQDECD_R.RS_SX field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04E7F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_8_poweroftwo_f800_04e8f800() {
    // Encoding: 0x04E8F800
    // Test SQDECD_R.RS_SX field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x04E8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecd_r_rs_sx_field_imm4_15_max_f800_04eff800() {
    // Encoding: 0x04EFF800
    // Test SQDECD_R.RS_SX field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04EFF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecd_r_rs_sx_field_pattern_0_min_f800_04e0f800() {
    // Encoding: 0x04E0F800
    // Test SQDECD_R.RS_SX field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecd_r_rs_sx_field_pattern_1_poweroftwo_f800_04e0f820() {
    // Encoding: 0x04E0F820
    // Test SQDECD_R.RS_SX field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04E0F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecd_r_rs_sx_field_pattern_15_poweroftwominusone_f800_04e0f9e0() {
    // Encoding: 0x04E0F9E0
    // Test SQDECD_R.RS_SX field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04E0F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecd_r_rs_sx_field_pattern_31_max_f800_04e0fbe0() {
    // Encoding: 0x04E0FBE0
    // Test SQDECD_R.RS_SX field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x04E0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecd_r_rs_sx_field_rdn_0_min_f800_04e0f800() {
    // Encoding: 0x04E0F800
    // Test SQDECD_R.RS_SX field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04E0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecd_r_rs_sx_field_rdn_1_poweroftwo_f800_04e0f801() {
    // Encoding: 0x04E0F801
    // Test SQDECD_R.RS_SX field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x04E0F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecd_r_rs_sx_field_rdn_15_poweroftwominusone_f800_04e0f80f() {
    // Encoding: 0x04E0F80F
    // Test SQDECD_R.RS_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecd_r_rs_sx_field_rdn_31_max_f800_04e0f81f() {
    // Encoding: 0x04E0F81F
    // Test SQDECD_R.RS_SX field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecd_r_rs_sx_combo_0_f800_04e0f800() {
    // Encoding: 0x04E0F800
    // Test SQDECD_R.RS_SX field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecd_r_rs_sx_invalid_0_f800_04e0f800() {
    // Encoding: 0x04E0F800
    // Test SQDECD_R.RS_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecd_r_rs_sx_invalid_1_f800_04e0f800() {
    // Encoding: 0x04E0F800
    // Test SQDECD_R.RS_SX invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04E0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecd_r_rs_x_field_imm4_0_zero_f800_04f0f800() {
    // Encoding: 0x04F0F800
    // Test SQDECD_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecd_r_rs_x_field_imm4_1_poweroftwo_f800_04f1f800() {
    // Encoding: 0x04F1F800
    // Test SQDECD_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=1
    let encoding: u32 = 0x04F1F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecd_r_rs_x_field_imm4_3_poweroftwominusone_f800_04f3f800() {
    // Encoding: 0x04F3F800
    // Test SQDECD_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04F3F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecd_r_rs_x_field_imm4_4_poweroftwo_f800_04f4f800() {
    // Encoding: 0x04F4F800
    // Test SQDECD_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x04F4F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecd_r_rs_x_field_imm4_7_poweroftwominusone_f800_04f7f800() {
    // Encoding: 0x04F7F800
    // Test SQDECD_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=7
    let encoding: u32 = 0x04F7F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecd_r_rs_x_field_imm4_8_poweroftwo_f800_04f8f800() {
    // Encoding: 0x04F8F800
    // Test SQDECD_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x04F8F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecd_r_rs_x_field_imm4_15_max_f800_04fff800() {
    // Encoding: 0x04FFF800
    // Test SQDECD_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04FFF800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecd_r_rs_x_field_pattern_0_min_f800_04f0f800() {
    // Encoding: 0x04F0F800
    // Test SQDECD_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecd_r_rs_x_field_pattern_1_poweroftwo_f800_04f0f820() {
    // Encoding: 0x04F0F820
    // Test SQDECD_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x04F0F820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecd_r_rs_x_field_pattern_15_poweroftwominusone_f800_04f0f9e0() {
    // Encoding: 0x04F0F9E0
    // Test SQDECD_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecd_r_rs_x_field_pattern_31_max_f800_04f0fbe0() {
    // Encoding: 0x04F0FBE0
    // Test SQDECD_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x04F0FBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecd_r_rs_x_field_rdn_0_min_f800_04f0f800() {
    // Encoding: 0x04F0F800
    // Test SQDECD_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecd_r_rs_x_field_rdn_1_poweroftwo_f800_04f0f801() {
    // Encoding: 0x04F0F801
    // Test SQDECD_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, pattern=0, imm4=0
    let encoding: u32 = 0x04F0F801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecd_r_rs_x_field_rdn_15_poweroftwominusone_f800_04f0f80f() {
    // Encoding: 0x04F0F80F
    // Test SQDECD_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x04F0F80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecd_r_rs_x_field_rdn_31_max_f800_04f0f81f() {
    // Encoding: 0x04F0F81F
    // Test SQDECD_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x04F0F81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecd_r_rs_x_combo_0_f800_04f0f800() {
    // Encoding: 0x04F0F800
    // Test SQDECD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04F0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecd_r_rs_x_invalid_0_f800_04f0f800() {
    // Encoding: 0x04F0F800
    // Test SQDECD_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04F0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecd_r_rs_x_invalid_1_f800_04f0f800() {
    // Encoding: 0x04F0F800
    // Test SQDECD_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0F800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECD_R.RS_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecd_r_rs_sx_reg_write_0_04e0f800() {
    // Test SQDECD_R.RS_SX register write: GpFromField("dn")
    // Encoding: 0x04E0F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQDECD_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqdecd_r_rs_x_reg_write_0_04f0f800() {
    // Test SQDECD_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04F0F800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0F800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INCB_R.RS__ Tests
// ============================================================================

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incb_r_rs_field_imm4_0_zero_e000_0430e000() {
    // Encoding: 0x0430E000
    // Test INCB_R.RS__ field imm4 = 0 (Zero)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incb_r_rs_field_imm4_1_poweroftwo_e000_0431e000() {
    // Encoding: 0x0431E000
    // Test INCB_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0431E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incb_r_rs_field_imm4_3_poweroftwominusone_e000_0433e000() {
    // Encoding: 0x0433E000
    // Test INCB_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x0433E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incb_r_rs_field_imm4_4_poweroftwo_e000_0434e000() {
    // Encoding: 0x0434E000
    // Test INCB_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rdn=0
    let encoding: u32 = 0x0434E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incb_r_rs_field_imm4_7_poweroftwominusone_e000_0437e000() {
    // Encoding: 0x0437E000
    // Test INCB_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=7
    let encoding: u32 = 0x0437E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incb_r_rs_field_imm4_8_poweroftwo_e000_0438e000() {
    // Encoding: 0x0438E000
    // Test INCB_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0438E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incb_r_rs_field_imm4_15_max_e000_043fe000() {
    // Encoding: 0x043FE000
    // Test INCB_R.RS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x043FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incb_r_rs_field_pattern_0_min_e000_0430e000() {
    // Encoding: 0x0430E000
    // Test INCB_R.RS__ field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incb_r_rs_field_pattern_1_poweroftwo_e000_0430e020() {
    // Encoding: 0x0430E020
    // Test INCB_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x0430E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incb_r_rs_field_pattern_15_poweroftwominusone_e000_0430e1e0() {
    // Encoding: 0x0430E1E0
    // Test INCB_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0430E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incb_r_rs_field_pattern_31_max_e000_0430e3e0() {
    // Encoding: 0x0430E3E0
    // Test INCB_R.RS__ field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x0430E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incb_r_rs_field_rdn_0_min_e000_0430e000() {
    // Encoding: 0x0430E000
    // Test INCB_R.RS__ field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incb_r_rs_field_rdn_1_poweroftwo_e000_0430e001() {
    // Encoding: 0x0430E001
    // Test INCB_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=1, pattern=0
    let encoding: u32 = 0x0430E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incb_r_rs_field_rdn_15_poweroftwominusone_e000_0430e00f() {
    // Encoding: 0x0430E00F
    // Test INCB_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x0430E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incb_r_rs_field_rdn_31_max_e000_0430e01f() {
    // Encoding: 0x0430E01F
    // Test INCB_R.RS__ field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x0430E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incb_r_rs_combo_0_e000_0430e000() {
    // Encoding: 0x0430E000
    // Test INCB_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incb_r_rs_invalid_0_e000_0430e000() {
    // Encoding: 0x0430E000
    // Test INCB_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incb_r_rs_invalid_1_e000_0430e000() {
    // Encoding: 0x0430E000
    // Test INCB_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incd_r_rs_field_imm4_0_zero_e000_04f0e000() {
    // Encoding: 0x04F0E000
    // Test INCD_R.RS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incd_r_rs_field_imm4_1_poweroftwo_e000_04f1e000() {
    // Encoding: 0x04F1E000
    // Test INCD_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rdn=0, pattern=0
    let encoding: u32 = 0x04F1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incd_r_rs_field_imm4_3_poweroftwominusone_e000_04f3e000() {
    // Encoding: 0x04F3E000
    // Test INCD_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04F3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incd_r_rs_field_imm4_4_poweroftwo_e000_04f4e000() {
    // Encoding: 0x04F4E000
    // Test INCD_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x04F4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incd_r_rs_field_imm4_7_poweroftwominusone_e000_04f7e000() {
    // Encoding: 0x04F7E000
    // Test INCD_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rdn=0, pattern=0
    let encoding: u32 = 0x04F7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incd_r_rs_field_imm4_8_poweroftwo_e000_04f8e000() {
    // Encoding: 0x04F8E000
    // Test INCD_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04F8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incd_r_rs_field_imm4_15_max_e000_04ffe000() {
    // Encoding: 0x04FFE000
    // Test INCD_R.RS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incd_r_rs_field_pattern_0_min_e000_04f0e000() {
    // Encoding: 0x04F0E000
    // Test INCD_R.RS__ field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incd_r_rs_field_pattern_1_poweroftwo_e000_04f0e020() {
    // Encoding: 0x04F0E020
    // Test INCD_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04F0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incd_r_rs_field_pattern_15_poweroftwominusone_e000_04f0e1e0() {
    // Encoding: 0x04F0E1E0
    // Test INCD_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incd_r_rs_field_pattern_31_max_e000_04f0e3e0() {
    // Encoding: 0x04F0E3E0
    // Test INCD_R.RS__ field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x04F0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incd_r_rs_field_rdn_0_min_e000_04f0e000() {
    // Encoding: 0x04F0E000
    // Test INCD_R.RS__ field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incd_r_rs_field_rdn_1_poweroftwo_e000_04f0e001() {
    // Encoding: 0x04F0E001
    // Test INCD_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x04F0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incd_r_rs_field_rdn_15_poweroftwominusone_e000_04f0e00f() {
    // Encoding: 0x04F0E00F
    // Test INCD_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x04F0E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incd_r_rs_field_rdn_31_max_e000_04f0e01f() {
    // Encoding: 0x04F0E01F
    // Test INCD_R.RS__ field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x04F0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incd_r_rs_combo_0_e000_04f0e000() {
    // Encoding: 0x04F0E000
    // Test INCD_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incd_r_rs_invalid_0_e000_04f0e000() {
    // Encoding: 0x04F0E000
    // Test INCD_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCD_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incd_r_rs_invalid_1_e000_04f0e000() {
    // Encoding: 0x04F0E000
    // Test INCD_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_inch_r_rs_field_imm4_0_zero_e000_0470e000() {
    // Encoding: 0x0470E000
    // Test INCH_R.RS__ field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_inch_r_rs_field_imm4_1_poweroftwo_e000_0471e000() {
    // Encoding: 0x0471E000
    // Test INCH_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x0471E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_inch_r_rs_field_imm4_3_poweroftwominusone_e000_0473e000() {
    // Encoding: 0x0473E000
    // Test INCH_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x0473E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_inch_r_rs_field_imm4_4_poweroftwo_e000_0474e000() {
    // Encoding: 0x0474E000
    // Test INCH_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x0474E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_inch_r_rs_field_imm4_7_poweroftwominusone_e000_0477e000() {
    // Encoding: 0x0477E000
    // Test INCH_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0477E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_inch_r_rs_field_imm4_8_poweroftwo_e000_0478e000() {
    // Encoding: 0x0478E000
    // Test INCH_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x0478E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_inch_r_rs_field_imm4_15_max_e000_047fe000() {
    // Encoding: 0x047FE000
    // Test INCH_R.RS__ field imm4 = 15 (Max)
    // Fields: pattern=0, Rdn=0, imm4=15
    let encoding: u32 = 0x047FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_inch_r_rs_field_pattern_0_min_e000_0470e000() {
    // Encoding: 0x0470E000
    // Test INCH_R.RS__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_inch_r_rs_field_pattern_1_poweroftwo_e000_0470e020() {
    // Encoding: 0x0470E020
    // Test INCH_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0470E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_inch_r_rs_field_pattern_15_poweroftwominusone_e000_0470e1e0() {
    // Encoding: 0x0470E1E0
    // Test INCH_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Rdn=0
    let encoding: u32 = 0x0470E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_inch_r_rs_field_pattern_31_max_e000_0470e3e0() {
    // Encoding: 0x0470E3E0
    // Test INCH_R.RS__ field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x0470E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_inch_r_rs_field_rdn_0_min_e000_0470e000() {
    // Encoding: 0x0470E000
    // Test INCH_R.RS__ field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_inch_r_rs_field_rdn_1_poweroftwo_e000_0470e001() {
    // Encoding: 0x0470E001
    // Test INCH_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x0470E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_inch_r_rs_field_rdn_15_poweroftwominusone_e000_0470e00f() {
    // Encoding: 0x0470E00F
    // Test INCH_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x0470E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_inch_r_rs_field_rdn_31_max_e000_0470e01f() {
    // Encoding: 0x0470E01F
    // Test INCH_R.RS__ field Rdn = 31 (Max)
    // Fields: imm4=0, Rdn=31, pattern=0
    let encoding: u32 = 0x0470E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_inch_r_rs_combo_0_e000_0470e000() {
    // Encoding: 0x0470E000
    // Test INCH_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_inch_r_rs_invalid_0_e000_0470e000() {
    // Encoding: 0x0470E000
    // Test INCH_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCH_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_inch_r_rs_invalid_1_e000_0470e000() {
    // Encoding: 0x0470E000
    // Test INCH_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incw_r_rs_field_imm4_0_zero_e000_04b0e000() {
    // Encoding: 0x04B0E000
    // Test INCW_R.RS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incw_r_rs_field_imm4_1_poweroftwo_e000_04b1e000() {
    // Encoding: 0x04B1E000
    // Test INCW_R.RS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04B1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incw_r_rs_field_imm4_3_poweroftwominusone_e000_04b3e000() {
    // Encoding: 0x04B3E000
    // Test INCW_R.RS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x04B3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incw_r_rs_field_imm4_4_poweroftwo_e000_04b4e000() {
    // Encoding: 0x04B4E000
    // Test INCW_R.RS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04B4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incw_r_rs_field_imm4_7_poweroftwominusone_e000_04b7e000() {
    // Encoding: 0x04B7E000
    // Test INCW_R.RS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x04B7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incw_r_rs_field_imm4_8_poweroftwo_e000_04b8e000() {
    // Encoding: 0x04B8E000
    // Test INCW_R.RS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04B8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incw_r_rs_field_imm4_15_max_e000_04bfe000() {
    // Encoding: 0x04BFE000
    // Test INCW_R.RS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x04BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incw_r_rs_field_pattern_0_min_e000_04b0e000() {
    // Encoding: 0x04B0E000
    // Test INCW_R.RS__ field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incw_r_rs_field_pattern_1_poweroftwo_e000_04b0e020() {
    // Encoding: 0x04B0E020
    // Test INCW_R.RS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=0, pattern=1
    let encoding: u32 = 0x04B0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incw_r_rs_field_pattern_15_poweroftwominusone_e000_04b0e1e0() {
    // Encoding: 0x04B0E1E0
    // Test INCW_R.RS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04B0E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incw_r_rs_field_pattern_31_max_e000_04b0e3e0() {
    // Encoding: 0x04B0E3E0
    // Test INCW_R.RS__ field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incw_r_rs_field_rdn_0_min_e000_04b0e000() {
    // Encoding: 0x04B0E000
    // Test INCW_R.RS__ field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incw_r_rs_field_rdn_1_poweroftwo_e000_04b0e001() {
    // Encoding: 0x04B0E001
    // Test INCW_R.RS__ field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x04B0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incw_r_rs_field_rdn_15_poweroftwominusone_e000_04b0e00f() {
    // Encoding: 0x04B0E00F
    // Test INCW_R.RS__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=15, pattern=0
    let encoding: u32 = 0x04B0E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incw_r_rs_field_rdn_31_max_e000_04b0e01f() {
    // Encoding: 0x04B0E01F
    // Test INCW_R.RS__ field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x04B0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incw_r_rs_combo_0_e000_04b0e000() {
    // Encoding: 0x04B0E000
    // Test INCW_R.RS__ field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incw_r_rs_invalid_0_e000_04b0e000() {
    // Encoding: 0x04B0E000
    // Test INCW_R.RS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCW_R.RS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incw_r_rs_invalid_1_e000_04b0e000() {
    // Encoding: 0x04B0E000
    // Test INCW_R.RS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCB_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_incb_r_rs_reg_write_0_0430e000() {
    // Test INCB_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x0430E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0430E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCD_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_incd_r_rs_reg_write_0_04f0e000() {
    // Test INCD_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x04F0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCH_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_inch_r_rs_reg_write_0_0470e000() {
    // Test INCH_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x0470E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCW_R.RS__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_incw_r_rs_reg_write_0_04b0e000() {
    // Test INCW_R.RS__ register write: GpFromField("dn")
    // Encoding: 0x04B0E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqincp_z_p_z_field_size_0_min_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqincp_z_p_z_field_size_1_poweroftwo_8000_25688000() {
    // Encoding: 0x25688000
    // Test SQINCP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zdn=0, Pg=0
    let encoding: u32 = 0x25688000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqincp_z_p_z_field_size_2_poweroftwo_8000_25a88000() {
    // Encoding: 0x25A88000
    // Test SQINCP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x25A88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqincp_z_p_z_field_size_3_max_8000_25e88000() {
    // Encoding: 0x25E88000
    // Test SQINCP_Z.P.Z__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x25E88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sqincp_z_p_z_field_pg_0_min_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sqincp_z_p_z_field_pg_1_poweroftwo_8000_25288020() {
    // Encoding: 0x25288020
    // Test SQINCP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=1
    let encoding: u32 = 0x25288020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincp_z_p_z_field_zdn_0_min_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincp_z_p_z_field_zdn_1_poweroftwo_8000_25288001() {
    // Encoding: 0x25288001
    // Test SQINCP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x25288001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincp_z_p_z_field_zdn_15_poweroftwominusone_8000_2528800f() {
    // Encoding: 0x2528800F
    // Test SQINCP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=15, Pg=0
    let encoding: u32 = 0x2528800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincp_z_p_z_field_zdn_31_max_8000_2528801f() {
    // Encoding: 0x2528801F
    // Test SQINCP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x2528801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqincp_z_p_z_combo_0_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqincp_z_p_z_special_size_0_size_variant_0_32768_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqincp_z_p_z_special_size_1_size_variant_1_32768_25688000() {
    // Encoding: 0x25688000
    // Test SQINCP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zdn=0
    let encoding: u32 = 0x25688000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqincp_z_p_z_special_size_2_size_variant_2_32768_25a88000() {
    // Encoding: 0x25A88000
    // Test SQINCP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zdn=0
    let encoding: u32 = 0x25A88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqincp_z_p_z_special_size_3_size_variant_3_32768_25e88000() {
    // Encoding: 0x25E88000
    // Test SQINCP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x25E88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincp_z_p_z_invalid_0_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincp_z_p_z_invalid_1_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_sqincp_z_p_z_invalid_2_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincp_z_p_z_invalid_3_8000_25288000() {
    // Encoding: 0x25288000
    // Test SQINCP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x25288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqincp_z_p_z_reg_write_0_25288000() {
    // Test SQINCP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x25288000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25288000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCH_R.RS_UW Tests
// ============================================================================

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqinch_r_rs_uw_field_imm4_0_zero_f400_0460f400() {
    // Encoding: 0x0460F400
    // Test UQINCH_R.RS_UW field imm4 = 0 (Zero)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqinch_r_rs_uw_field_imm4_1_poweroftwo_f400_0461f400() {
    // Encoding: 0x0461F400
    // Test UQINCH_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=1
    let encoding: u32 = 0x0461F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqinch_r_rs_uw_field_imm4_3_poweroftwominusone_f400_0463f400() {
    // Encoding: 0x0463F400
    // Test UQINCH_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x0463F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqinch_r_rs_uw_field_imm4_4_poweroftwo_f400_0464f400() {
    // Encoding: 0x0464F400
    // Test UQINCH_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x0464F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqinch_r_rs_uw_field_imm4_7_poweroftwominusone_f400_0467f400() {
    // Encoding: 0x0467F400
    // Test UQINCH_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0467F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqinch_r_rs_uw_field_imm4_8_poweroftwo_f400_0468f400() {
    // Encoding: 0x0468F400
    // Test UQINCH_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x0468F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqinch_r_rs_uw_field_imm4_15_max_f400_046ff400() {
    // Encoding: 0x046FF400
    // Test UQINCH_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x046FF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqinch_r_rs_uw_field_pattern_0_min_f400_0460f400() {
    // Encoding: 0x0460F400
    // Test UQINCH_R.RS_UW field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqinch_r_rs_uw_field_pattern_1_poweroftwo_f400_0460f420() {
    // Encoding: 0x0460F420
    // Test UQINCH_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0460F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqinch_r_rs_uw_field_pattern_15_poweroftwominusone_f400_0460f5e0() {
    // Encoding: 0x0460F5E0
    // Test UQINCH_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0460F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqinch_r_rs_uw_field_pattern_31_max_f400_0460f7e0() {
    // Encoding: 0x0460F7E0
    // Test UQINCH_R.RS_UW field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0460F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqinch_r_rs_uw_field_rdn_0_min_f400_0460f400() {
    // Encoding: 0x0460F400
    // Test UQINCH_R.RS_UW field Rdn = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqinch_r_rs_uw_field_rdn_1_poweroftwo_f400_0460f401() {
    // Encoding: 0x0460F401
    // Test UQINCH_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=1, pattern=0
    let encoding: u32 = 0x0460F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqinch_r_rs_uw_field_rdn_15_poweroftwominusone_f400_0460f40f() {
    // Encoding: 0x0460F40F
    // Test UQINCH_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=0, Rdn=15
    let encoding: u32 = 0x0460F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqinch_r_rs_uw_field_rdn_31_max_f400_0460f41f() {
    // Encoding: 0x0460F41F
    // Test UQINCH_R.RS_UW field Rdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Rdn=31
    let encoding: u32 = 0x0460F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqinch_r_rs_uw_combo_0_f400_0460f400() {
    // Encoding: 0x0460F400
    // Test UQINCH_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0460F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqinch_r_rs_uw_invalid_0_f400_0460f400() {
    // Encoding: 0x0460F400
    // Test UQINCH_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0460F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqinch_r_rs_uw_invalid_1_f400_0460f400() {
    // Encoding: 0x0460F400
    // Test UQINCH_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0460F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqinch_r_rs_x_field_imm4_0_zero_f400_0470f400() {
    // Encoding: 0x0470F400
    // Test UQINCH_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqinch_r_rs_x_field_imm4_1_poweroftwo_f400_0471f400() {
    // Encoding: 0x0471F400
    // Test UQINCH_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x0471F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqinch_r_rs_x_field_imm4_3_poweroftwominusone_f400_0473f400() {
    // Encoding: 0x0473F400
    // Test UQINCH_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x0473F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqinch_r_rs_x_field_imm4_4_poweroftwo_f400_0474f400() {
    // Encoding: 0x0474F400
    // Test UQINCH_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x0474F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqinch_r_rs_x_field_imm4_7_poweroftwominusone_f400_0477f400() {
    // Encoding: 0x0477F400
    // Test UQINCH_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x0477F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqinch_r_rs_x_field_imm4_8_poweroftwo_f400_0478f400() {
    // Encoding: 0x0478F400
    // Test UQINCH_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0478F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqinch_r_rs_x_field_imm4_15_max_f400_047ff400() {
    // Encoding: 0x047FF400
    // Test UQINCH_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x047FF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqinch_r_rs_x_field_pattern_0_min_f400_0470f400() {
    // Encoding: 0x0470F400
    // Test UQINCH_R.RS_X field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqinch_r_rs_x_field_pattern_1_poweroftwo_f400_0470f420() {
    // Encoding: 0x0470F420
    // Test UQINCH_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqinch_r_rs_x_field_pattern_15_poweroftwominusone_f400_0470f5e0() {
    // Encoding: 0x0470F5E0
    // Test UQINCH_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqinch_r_rs_x_field_pattern_31_max_f400_0470f7e0() {
    // Encoding: 0x0470F7E0
    // Test UQINCH_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x0470F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqinch_r_rs_x_field_rdn_0_min_f400_0470f400() {
    // Encoding: 0x0470F400
    // Test UQINCH_R.RS_X field Rdn = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqinch_r_rs_x_field_rdn_1_poweroftwo_f400_0470f401() {
    // Encoding: 0x0470F401
    // Test UQINCH_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x0470F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqinch_r_rs_x_field_rdn_15_poweroftwominusone_f400_0470f40f() {
    // Encoding: 0x0470F40F
    // Test UQINCH_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=0, Rdn=15
    let encoding: u32 = 0x0470F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqinch_r_rs_x_field_rdn_31_max_f400_0470f41f() {
    // Encoding: 0x0470F41F
    // Test UQINCH_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, Rdn=31, pattern=0
    let encoding: u32 = 0x0470F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqinch_r_rs_x_combo_0_f400_0470f400() {
    // Encoding: 0x0470F400
    // Test UQINCH_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqinch_r_rs_x_invalid_0_f400_0470f400() {
    // Encoding: 0x0470F400
    // Test UQINCH_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0470F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqinch_r_rs_x_invalid_1_f400_0470f400() {
    // Encoding: 0x0470F400
    // Test UQINCH_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCH_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqinch_r_rs_uw_reg_write_0_0460f400() {
    // Test UQINCH_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x0460F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQINCH_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqinch_r_rs_x_reg_write_0_0470f400() {
    // Test UQINCH_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0470F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCW_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincw_z_zs_field_imm4_0_zero_c000_04a0c000() {
    // Encoding: 0x04A0C000
    // Test SQINCW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincw_z_zs_field_imm4_1_poweroftwo_c000_04a1c000() {
    // Encoding: 0x04A1C000
    // Test SQINCW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Zdn=0
    let encoding: u32 = 0x04A1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincw_z_zs_field_imm4_3_poweroftwominusone_c000_04a3c000() {
    // Encoding: 0x04A3C000
    // Test SQINCW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04A3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincw_z_zs_field_imm4_4_poweroftwo_c000_04a4c000() {
    // Encoding: 0x04A4C000
    // Test SQINCW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x04A4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincw_z_zs_field_imm4_7_poweroftwominusone_c000_04a7c000() {
    // Encoding: 0x04A7C000
    // Test SQINCW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x04A7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincw_z_zs_field_imm4_8_poweroftwo_c000_04a8c000() {
    // Encoding: 0x04A8C000
    // Test SQINCW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=8
    let encoding: u32 = 0x04A8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincw_z_zs_field_imm4_15_max_c000_04afc000() {
    // Encoding: 0x04AFC000
    // Test SQINCW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x04AFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincw_z_zs_field_pattern_0_min_c000_04a0c000() {
    // Encoding: 0x04A0C000
    // Test SQINCW_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincw_z_zs_field_pattern_1_poweroftwo_c000_04a0c020() {
    // Encoding: 0x04A0C020
    // Test SQINCW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincw_z_zs_field_pattern_15_poweroftwominusone_c000_04a0c1e0() {
    // Encoding: 0x04A0C1E0
    // Test SQINCW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=0, pattern=15
    let encoding: u32 = 0x04A0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincw_z_zs_field_pattern_31_max_c000_04a0c3e0() {
    // Encoding: 0x04A0C3E0
    // Test SQINCW_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, Zdn=0, pattern=31
    let encoding: u32 = 0x04A0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincw_z_zs_field_zdn_0_min_c000_04a0c000() {
    // Encoding: 0x04A0C000
    // Test SQINCW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincw_z_zs_field_zdn_1_poweroftwo_c000_04a0c001() {
    // Encoding: 0x04A0C001
    // Test SQINCW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x04A0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincw_z_zs_field_zdn_15_poweroftwominusone_c000_04a0c00f() {
    // Encoding: 0x04A0C00F
    // Test SQINCW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=15, pattern=0
    let encoding: u32 = 0x04A0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincw_z_zs_field_zdn_31_max_c000_04a0c01f() {
    // Encoding: 0x04A0C01F
    // Test SQINCW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: pattern=0, Zdn=31, imm4=0
    let encoding: u32 = 0x04A0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincw_z_zs_combo_0_c000_04a0c000() {
    // Encoding: 0x04A0C000
    // Test SQINCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincw_z_zs_invalid_0_c000_04a0c000() {
    // Encoding: 0x04A0C000
    // Test SQINCW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincw_z_zs_invalid_1_c000_04a0c000() {
    // Encoding: 0x04A0C000
    // Test SQINCW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqincw_z_zs_reg_write_0_04a0c000() {
    // Test SQINCW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04A0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCP_R.P.R_SX Tests
// ============================================================================

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqincp_r_p_r_sx_field_size_0_min_8800_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX field size = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqincp_r_p_r_sx_field_size_1_poweroftwo_8800_25688800() {
    // Encoding: 0x25688800
    // Test SQINCP_R.P.R_SX field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Rdn=0
    let encoding: u32 = 0x25688800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqincp_r_p_r_sx_field_size_2_poweroftwo_8800_25a88800() {
    // Encoding: 0x25A88800
    // Test SQINCP_R.P.R_SX field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, Pg=0, size=2
    let encoding: u32 = 0x25A88800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqincp_r_p_r_sx_field_size_3_max_8800_25e88800() {
    // Encoding: 0x25E88800
    // Test SQINCP_R.P.R_SX field size = 3 (Max)
    // Fields: Rdn=0, Pg=0, size=3
    let encoding: u32 = 0x25E88800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sqincp_r_p_r_sx_field_pg_0_min_8800_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sqincp_r_p_r_sx_field_pg_1_poweroftwo_8800_25288820() {
    // Encoding: 0x25288820
    // Test SQINCP_R.P.R_SX field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Rdn=0
    let encoding: u32 = 0x25288820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincp_r_p_r_sx_field_rdn_0_min_8800_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX field Rdn = 0 (Min)
    // Fields: Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincp_r_p_r_sx_field_rdn_1_poweroftwo_8800_25288801() {
    // Encoding: 0x25288801
    // Test SQINCP_R.P.R_SX field Rdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Rdn=1
    let encoding: u32 = 0x25288801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincp_r_p_r_sx_field_rdn_15_poweroftwominusone_8800_2528880f() {
    // Encoding: 0x2528880F
    // Test SQINCP_R.P.R_SX field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, size=0, Pg=0
    let encoding: u32 = 0x2528880F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincp_r_p_r_sx_field_rdn_31_max_8800_2528881f() {
    // Encoding: 0x2528881F
    // Test SQINCP_R.P.R_SX field Rdn = 31 (Max)
    // Fields: Rdn=31, size=0, Pg=0
    let encoding: u32 = 0x2528881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqincp_r_p_r_sx_combo_0_8800_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX field combination: size=0, Pg=0, Rdn=0
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqincp_r_p_r_sx_special_size_0_size_variant_0_34816_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX special value size = 0 (Size variant 0)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqincp_r_p_r_sx_special_size_1_size_variant_1_34816_25688800() {
    // Encoding: 0x25688800
    // Test SQINCP_R.P.R_SX special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Rdn=0
    let encoding: u32 = 0x25688800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqincp_r_p_r_sx_special_size_2_size_variant_2_34816_25a88800() {
    // Encoding: 0x25A88800
    // Test SQINCP_R.P.R_SX special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Rdn=0
    let encoding: u32 = 0x25A88800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqincp_r_p_r_sx_special_size_3_size_variant_3_34816_25e88800() {
    // Encoding: 0x25E88800
    // Test SQINCP_R.P.R_SX special value size = 3 (Size variant 3)
    // Fields: size=3, Rdn=0, Pg=0
    let encoding: u32 = 0x25E88800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincp_r_p_r_sx_invalid_0_8800_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincp_r_p_r_sx_invalid_1_8800_25288800() {
    // Encoding: 0x25288800
    // Test SQINCP_R.P.R_SX invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqincp_r_p_r_x_field_size_0_min_8c00_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X field size = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqincp_r_p_r_x_field_size_1_poweroftwo_8c00_25688c00() {
    // Encoding: 0x25688C00
    // Test SQINCP_R.P.R_X field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Rdn=0
    let encoding: u32 = 0x25688C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqincp_r_p_r_x_field_size_2_poweroftwo_8c00_25a88c00() {
    // Encoding: 0x25A88C00
    // Test SQINCP_R.P.R_X field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25A88C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqincp_r_p_r_x_field_size_3_max_8c00_25e88c00() {
    // Encoding: 0x25E88C00
    // Test SQINCP_R.P.R_X field size = 3 (Max)
    // Fields: Rdn=0, size=3, Pg=0
    let encoding: u32 = 0x25E88C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sqincp_r_p_r_x_field_pg_0_min_8c00_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sqincp_r_p_r_x_field_pg_1_poweroftwo_8c00_25288c20() {
    // Encoding: 0x25288C20
    // Test SQINCP_R.P.R_X field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Rdn=0, Pg=1
    let encoding: u32 = 0x25288C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincp_r_p_r_x_field_rdn_0_min_8c00_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X field Rdn = 0 (Min)
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincp_r_p_r_x_field_rdn_1_poweroftwo_8c00_25288c01() {
    // Encoding: 0x25288C01
    // Test SQINCP_R.P.R_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, size=0, Pg=0
    let encoding: u32 = 0x25288C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincp_r_p_r_x_field_rdn_15_poweroftwominusone_8c00_25288c0f() {
    // Encoding: 0x25288C0F
    // Test SQINCP_R.P.R_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, Pg=0, size=0
    let encoding: u32 = 0x25288C0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincp_r_p_r_x_field_rdn_31_max_8c00_25288c1f() {
    // Encoding: 0x25288C1F
    // Test SQINCP_R.P.R_X field Rdn = 31 (Max)
    // Fields: Rdn=31, size=0, Pg=0
    let encoding: u32 = 0x25288C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqincp_r_p_r_x_combo_0_8c00_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X field combination: size=0, Pg=0, Rdn=0
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqincp_r_p_r_x_special_size_0_size_variant_0_35840_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqincp_r_p_r_x_special_size_1_size_variant_1_35840_25688c00() {
    // Encoding: 0x25688C00
    // Test SQINCP_R.P.R_X special value size = 1 (Size variant 1)
    // Fields: Rdn=0, size=1, Pg=0
    let encoding: u32 = 0x25688C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqincp_r_p_r_x_special_size_2_size_variant_2_35840_25a88c00() {
    // Encoding: 0x25A88C00
    // Test SQINCP_R.P.R_X special value size = 2 (Size variant 2)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25A88C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqincp_r_p_r_x_special_size_3_size_variant_3_35840_25e88c00() {
    // Encoding: 0x25E88C00
    // Test SQINCP_R.P.R_X special value size = 3 (Size variant 3)
    // Fields: Rdn=0, size=3, Pg=0
    let encoding: u32 = 0x25E88C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincp_r_p_r_x_invalid_0_8c00_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincp_r_p_r_x_invalid_1_8c00_25288c00() {
    // Encoding: 0x25288C00
    // Test SQINCP_R.P.R_X invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x25288C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCP_R.P.R_SX
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincp_r_p_r_sx_reg_write_0_25288800() {
    // Test SQINCP_R.P.R_SX register write: GpFromField("dn")
    // Encoding: 0x25288800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25288800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SQINCP_R.P.R_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_sqincp_r_p_r_x_reg_write_0_25288c00() {
    // Test SQINCP_R.P.R_X register write: GpFromField("dn")
    // Encoding: 0x25288C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25288C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCB_R.RS_UW Tests
// ============================================================================

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincb_r_rs_uw_field_imm4_0_zero_f400_0420f400() {
    // Encoding: 0x0420F400
    // Test UQINCB_R.RS_UW field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0420F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincb_r_rs_uw_field_imm4_1_poweroftwo_f400_0421f400() {
    // Encoding: 0x0421F400
    // Test UQINCB_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rdn=0, pattern=0
    let encoding: u32 = 0x0421F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincb_r_rs_uw_field_imm4_3_poweroftwominusone_f400_0423f400() {
    // Encoding: 0x0423F400
    // Test UQINCB_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x0423F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincb_r_rs_uw_field_imm4_4_poweroftwo_f400_0424f400() {
    // Encoding: 0x0424F400
    // Test UQINCB_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x0424F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincb_r_rs_uw_field_imm4_7_poweroftwominusone_f400_0427f400() {
    // Encoding: 0x0427F400
    // Test UQINCB_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0427F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincb_r_rs_uw_field_imm4_8_poweroftwo_f400_0428f400() {
    // Encoding: 0x0428F400
    // Test UQINCB_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0428F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincb_r_rs_uw_field_imm4_15_max_f400_042ff400() {
    // Encoding: 0x042FF400
    // Test UQINCB_R.RS_UW field imm4 = 15 (Max)
    // Fields: pattern=0, Rdn=0, imm4=15
    let encoding: u32 = 0x042FF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincb_r_rs_uw_field_pattern_0_min_f400_0420f400() {
    // Encoding: 0x0420F400
    // Test UQINCB_R.RS_UW field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0420F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincb_r_rs_uw_field_pattern_1_poweroftwo_f400_0420f420() {
    // Encoding: 0x0420F420
    // Test UQINCB_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x0420F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincb_r_rs_uw_field_pattern_15_poweroftwominusone_f400_0420f5e0() {
    // Encoding: 0x0420F5E0
    // Test UQINCB_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x0420F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincb_r_rs_uw_field_pattern_31_max_f400_0420f7e0() {
    // Encoding: 0x0420F7E0
    // Test UQINCB_R.RS_UW field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x0420F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincb_r_rs_uw_field_rdn_0_min_f400_0420f400() {
    // Encoding: 0x0420F400
    // Test UQINCB_R.RS_UW field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincb_r_rs_uw_field_rdn_1_poweroftwo_f400_0420f401() {
    // Encoding: 0x0420F401
    // Test UQINCB_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=1, pattern=0
    let encoding: u32 = 0x0420F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincb_r_rs_uw_field_rdn_15_poweroftwominusone_f400_0420f40f() {
    // Encoding: 0x0420F40F
    // Test UQINCB_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0420F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincb_r_rs_uw_field_rdn_31_max_f400_0420f41f() {
    // Encoding: 0x0420F41F
    // Test UQINCB_R.RS_UW field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x0420F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincb_r_rs_uw_combo_0_f400_0420f400() {
    // Encoding: 0x0420F400
    // Test UQINCB_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincb_r_rs_uw_invalid_0_f400_0420f400() {
    // Encoding: 0x0420F400
    // Test UQINCB_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincb_r_rs_uw_invalid_1_f400_0420f400() {
    // Encoding: 0x0420F400
    // Test UQINCB_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincb_r_rs_x_field_imm4_0_zero_f400_0430f400() {
    // Encoding: 0x0430F400
    // Test UQINCB_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincb_r_rs_x_field_imm4_1_poweroftwo_f400_0431f400() {
    // Encoding: 0x0431F400
    // Test UQINCB_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x0431F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincb_r_rs_x_field_imm4_3_poweroftwominusone_f400_0433f400() {
    // Encoding: 0x0433F400
    // Test UQINCB_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x0433F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincb_r_rs_x_field_imm4_4_poweroftwo_f400_0434f400() {
    // Encoding: 0x0434F400
    // Test UQINCB_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x0434F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincb_r_rs_x_field_imm4_7_poweroftwominusone_f400_0437f400() {
    // Encoding: 0x0437F400
    // Test UQINCB_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0437F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincb_r_rs_x_field_imm4_8_poweroftwo_f400_0438f400() {
    // Encoding: 0x0438F400
    // Test UQINCB_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0438F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincb_r_rs_x_field_imm4_15_max_f400_043ff400() {
    // Encoding: 0x043FF400
    // Test UQINCB_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x043FF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincb_r_rs_x_field_pattern_0_min_f400_0430f400() {
    // Encoding: 0x0430F400
    // Test UQINCB_R.RS_X field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0430F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincb_r_rs_x_field_pattern_1_poweroftwo_f400_0430f420() {
    // Encoding: 0x0430F420
    // Test UQINCB_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincb_r_rs_x_field_pattern_15_poweroftwominusone_f400_0430f5e0() {
    // Encoding: 0x0430F5E0
    // Test UQINCB_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0430F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincb_r_rs_x_field_pattern_31_max_f400_0430f7e0() {
    // Encoding: 0x0430F7E0
    // Test UQINCB_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0430F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincb_r_rs_x_field_rdn_0_min_f400_0430f400() {
    // Encoding: 0x0430F400
    // Test UQINCB_R.RS_X field Rdn = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0430F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincb_r_rs_x_field_rdn_1_poweroftwo_f400_0430f401() {
    // Encoding: 0x0430F401
    // Test UQINCB_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x0430F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincb_r_rs_x_field_rdn_15_poweroftwominusone_f400_0430f40f() {
    // Encoding: 0x0430F40F
    // Test UQINCB_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x0430F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincb_r_rs_x_field_rdn_31_max_f400_0430f41f() {
    // Encoding: 0x0430F41F
    // Test UQINCB_R.RS_X field Rdn = 31 (Max)
    // Fields: pattern=0, Rdn=31, imm4=0
    let encoding: u32 = 0x0430F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincb_r_rs_x_combo_0_f400_0430f400() {
    // Encoding: 0x0430F400
    // Test UQINCB_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0430F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincb_r_rs_x_invalid_0_f400_0430f400() {
    // Encoding: 0x0430F400
    // Test UQINCB_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincb_r_rs_x_invalid_1_f400_0430f400() {
    // Encoding: 0x0430F400
    // Test UQINCB_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0430F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCB_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincb_r_rs_uw_reg_write_0_0420f400() {
    // Test UQINCB_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x0420F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQINCB_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincb_r_rs_x_reg_write_0_0430f400() {
    // Test UQINCB_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0430F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0430F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECD_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecd_z_zs_field_imm4_0_zero_c800_04e0c800() {
    // Encoding: 0x04E0C800
    // Test SQDECD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecd_z_zs_field_imm4_1_poweroftwo_c800_04e1c800() {
    // Encoding: 0x04E1C800
    // Test SQDECD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=1
    let encoding: u32 = 0x04E1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecd_z_zs_field_imm4_3_poweroftwominusone_c800_04e3c800() {
    // Encoding: 0x04E3C800
    // Test SQDECD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x04E3C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecd_z_zs_field_imm4_4_poweroftwo_c800_04e4c800() {
    // Encoding: 0x04E4C800
    // Test SQDECD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Zdn=0
    let encoding: u32 = 0x04E4C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecd_z_zs_field_imm4_7_poweroftwominusone_c800_04e7c800() {
    // Encoding: 0x04E7C800
    // Test SQDECD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x04E7C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecd_z_zs_field_imm4_8_poweroftwo_c800_04e8c800() {
    // Encoding: 0x04E8C800
    // Test SQDECD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x04E8C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecd_z_zs_field_imm4_15_max_c800_04efc800() {
    // Encoding: 0x04EFC800
    // Test SQDECD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x04EFC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecd_z_zs_field_pattern_0_min_c800_04e0c800() {
    // Encoding: 0x04E0C800
    // Test SQDECD_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04E0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecd_z_zs_field_pattern_1_poweroftwo_c800_04e0c820() {
    // Encoding: 0x04E0C820
    // Test SQDECD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecd_z_zs_field_pattern_15_poweroftwominusone_c800_04e0c9e0() {
    // Encoding: 0x04E0C9E0
    // Test SQDECD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=0, pattern=15
    let encoding: u32 = 0x04E0C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecd_z_zs_field_pattern_31_max_c800_04e0cbe0() {
    // Encoding: 0x04E0CBE0
    // Test SQDECD_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecd_z_zs_field_zdn_0_min_c800_04e0c800() {
    // Encoding: 0x04E0C800
    // Test SQDECD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04E0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecd_z_zs_field_zdn_1_poweroftwo_c800_04e0c801() {
    // Encoding: 0x04E0C801
    // Test SQDECD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=1, imm4=0
    let encoding: u32 = 0x04E0C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecd_z_zs_field_zdn_15_poweroftwominusone_c800_04e0c80f() {
    // Encoding: 0x04E0C80F
    // Test SQDECD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=15, imm4=0
    let encoding: u32 = 0x04E0C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecd_z_zs_field_zdn_31_max_c800_04e0c81f() {
    // Encoding: 0x04E0C81F
    // Test SQDECD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x04E0C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecd_z_zs_combo_0_c800_04e0c800() {
    // Encoding: 0x04E0C800
    // Test SQDECD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecd_z_zs_invalid_0_c800_04e0c800() {
    // Encoding: 0x04E0C800
    // Test SQDECD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04E0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecd_z_zs_invalid_1_c800_04e0c800() {
    // Encoding: 0x04E0C800
    // Test SQDECD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqdecd_z_zs_reg_write_0_04e0c800() {
    // Test SQDECD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04E0C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// RDVL_R.I__ Tests
// ============================================================================

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_rdvl_r_i_field_imm6_0_zero_5000_04bf5000() {
    // Encoding: 0x04BF5000
    // Test RDVL_R.I__ field imm6 = 0 (Zero)
    // Fields: imm6=0, Rd=0
    let encoding: u32 = 0x04BF5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_rdvl_r_i_field_imm6_1_poweroftwo_5000_04bf5020() {
    // Encoding: 0x04BF5020
    // Test RDVL_R.I__ field imm6 = 1 (PowerOfTwo)
    // Fields: imm6=1, Rd=0
    let encoding: u32 = 0x04BF5020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_rdvl_r_i_field_imm6_3_poweroftwominusone_5000_04bf5060() {
    // Encoding: 0x04BF5060
    // Test RDVL_R.I__ field imm6 = 3 (PowerOfTwoMinusOne)
    // Fields: imm6=3, Rd=0
    let encoding: u32 = 0x04BF5060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_rdvl_r_i_field_imm6_4_poweroftwo_5000_04bf5080() {
    // Encoding: 0x04BF5080
    // Test RDVL_R.I__ field imm6 = 4 (PowerOfTwo)
    // Fields: imm6=4, Rd=0
    let encoding: u32 = 0x04BF5080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_rdvl_r_i_field_imm6_7_poweroftwominusone_5000_04bf50e0() {
    // Encoding: 0x04BF50E0
    // Test RDVL_R.I__ field imm6 = 7 (PowerOfTwoMinusOne)
    // Fields: imm6=7, Rd=0
    let encoding: u32 = 0x04BF50E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_rdvl_r_i_field_imm6_8_poweroftwo_5000_04bf5100() {
    // Encoding: 0x04BF5100
    // Test RDVL_R.I__ field imm6 = 8 (PowerOfTwo)
    // Fields: imm6=8, Rd=0
    let encoding: u32 = 0x04BF5100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_rdvl_r_i_field_imm6_15_poweroftwominusone_5000_04bf51e0() {
    // Encoding: 0x04BF51E0
    // Test RDVL_R.I__ field imm6 = 15 (PowerOfTwoMinusOne)
    // Fields: imm6=15, Rd=0
    let encoding: u32 = 0x04BF51E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_rdvl_r_i_field_imm6_16_poweroftwo_5000_04bf5200() {
    // Encoding: 0x04BF5200
    // Test RDVL_R.I__ field imm6 = 16 (PowerOfTwo)
    // Fields: imm6=16, Rd=0
    let encoding: u32 = 0x04BF5200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_rdvl_r_i_field_imm6_31_poweroftwominusone_5000_04bf53e0() {
    // Encoding: 0x04BF53E0
    // Test RDVL_R.I__ field imm6 = 31 (PowerOfTwoMinusOne)
    // Fields: imm6=31, Rd=0
    let encoding: u32 = 0x04BF53E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_rdvl_r_i_field_imm6_32_poweroftwo_5000_04bf5400() {
    // Encoding: 0x04BF5400
    // Test RDVL_R.I__ field imm6 = 32 (PowerOfTwo)
    // Fields: imm6=32, Rd=0
    let encoding: u32 = 0x04BF5400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field imm6 5 +: 6`
/// Requirement: FieldBoundary { field: "imm6", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_rdvl_r_i_field_imm6_63_max_5000_04bf57e0() {
    // Encoding: 0x04BF57E0
    // Test RDVL_R.I__ field imm6 = 63 (Max)
    // Fields: imm6=63, Rd=0
    let encoding: u32 = 0x04BF57E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_rdvl_r_i_field_rd_0_min_5000_04bf5000() {
    // Encoding: 0x04BF5000
    // Test RDVL_R.I__ field Rd = 0 (Min)
    // Fields: imm6=0, Rd=0
    let encoding: u32 = 0x04BF5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_rdvl_r_i_field_rd_1_poweroftwo_5000_04bf5001() {
    // Encoding: 0x04BF5001
    // Test RDVL_R.I__ field Rd = 1 (PowerOfTwo)
    // Fields: Rd=1, imm6=0
    let encoding: u32 = 0x04BF5001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_rdvl_r_i_field_rd_30_poweroftwominusone_5000_04bf501e() {
    // Encoding: 0x04BF501E
    // Test RDVL_R.I__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: imm6=0, Rd=30
    let encoding: u32 = 0x04BF501E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_rdvl_r_i_field_rd_31_max_5000_04bf501f() {
    // Encoding: 0x04BF501F
    // Test RDVL_R.I__ field Rd = 31 (Max)
    // Fields: Rd=31, imm6=0
    let encoding: u32 = 0x04BF501F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm6=0 (immediate value 0)
#[test]
fn test_rdvl_r_i_combo_0_5000_04bf5000() {
    // Encoding: 0x04BF5000
    // Test RDVL_R.I__ field combination: imm6=0, Rd=0
    // Fields: Rd=0, imm6=0
    let encoding: u32 = 0x04BF5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_rdvl_r_i_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_20480_04bf501f() {
    // Encoding: 0x04BF501F
    // Test RDVL_R.I__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: imm6=0, Rd=31
    let encoding: u32 = 0x04BF501F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_rdvl_r_i_invalid_0_5000_04bf5000() {
    // Encoding: 0x04BF5000
    // Test RDVL_R.I__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rd=0, imm6=0
    let encoding: u32 = 0x04BF5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_rdvl_r_i_invalid_1_5000_04bf5000() {
    // Encoding: 0x04BF5000
    // Test RDVL_R.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rd=0, imm6=0
    let encoding: u32 = 0x04BF5000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: RDVL_R.I__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_rdvl_r_i_reg_write_0_04bf5000() {
    // Test RDVL_R.I__ register write: GpFromField("d")
    // Encoding: 0x04BF5000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04BF5000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: RDVL_R.I__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_rdvl_r_i_zr_rd_04bf501f() {
    // Test RDVL_R.I__ with Rd = ZR (31)
    // Encoding: 0x04BF501F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04BF501F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// DECD_Z.ZS__ Tests
// ============================================================================

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_decd_z_zs_field_imm4_0_zero_c400_04f0c400() {
    // Encoding: 0x04F0C400
    // Test DECD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04F0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_decd_z_zs_field_imm4_1_poweroftwo_c400_04f1c400() {
    // Encoding: 0x04F1C400
    // Test DECD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Zdn=0
    let encoding: u32 = 0x04F1C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_decd_z_zs_field_imm4_3_poweroftwominusone_c400_04f3c400() {
    // Encoding: 0x04F3C400
    // Test DECD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04F3C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_decd_z_zs_field_imm4_4_poweroftwo_c400_04f4c400() {
    // Encoding: 0x04F4C400
    // Test DECD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x04F4C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_decd_z_zs_field_imm4_7_poweroftwominusone_c400_04f7c400() {
    // Encoding: 0x04F7C400
    // Test DECD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04F7C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_decd_z_zs_field_imm4_8_poweroftwo_c400_04f8c400() {
    // Encoding: 0x04F8C400
    // Test DECD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zdn=0, pattern=0
    let encoding: u32 = 0x04F8C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_decd_z_zs_field_imm4_15_max_c400_04ffc400() {
    // Encoding: 0x04FFC400
    // Test DECD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x04FFC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decd_z_zs_field_pattern_0_min_c400_04f0c400() {
    // Encoding: 0x04F0C400
    // Test DECD_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04F0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decd_z_zs_field_pattern_1_poweroftwo_c400_04f0c420() {
    // Encoding: 0x04F0C420
    // Test DECD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04F0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decd_z_zs_field_pattern_15_poweroftwominusone_c400_04f0c5e0() {
    // Encoding: 0x04F0C5E0
    // Test DECD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x04F0C5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decd_z_zs_field_pattern_31_max_c400_04f0c7e0() {
    // Encoding: 0x04F0C7E0
    // Test DECD_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x04F0C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decd_z_zs_field_zdn_0_min_c400_04f0c400() {
    // Encoding: 0x04F0C400
    // Test DECD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04F0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decd_z_zs_field_zdn_1_poweroftwo_c400_04f0c401() {
    // Encoding: 0x04F0C401
    // Test DECD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Zdn=1
    let encoding: u32 = 0x04F0C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decd_z_zs_field_zdn_15_poweroftwominusone_c400_04f0c40f() {
    // Encoding: 0x04F0C40F
    // Test DECD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04F0C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decd_z_zs_field_zdn_31_max_c400_04f0c41f() {
    // Encoding: 0x04F0C41F
    // Test DECD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04F0C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_decd_z_zs_combo_0_c400_04f0c400() {
    // Encoding: 0x04F0C400
    // Test DECD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04F0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decd_z_zs_invalid_0_c400_04f0c400() {
    // Encoding: 0x04F0C400
    // Test DECD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04F0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decd_z_zs_invalid_1_c400_04f0c400() {
    // Encoding: 0x04F0C400
    // Test DECD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04F0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_dech_z_zs_field_imm4_0_zero_c400_0470c400() {
    // Encoding: 0x0470C400
    // Test DECH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_dech_z_zs_field_imm4_1_poweroftwo_c400_0471c400() {
    // Encoding: 0x0471C400
    // Test DECH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zdn=0, pattern=0
    let encoding: u32 = 0x0471C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_dech_z_zs_field_imm4_3_poweroftwominusone_c400_0473c400() {
    // Encoding: 0x0473C400
    // Test DECH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Zdn=0
    let encoding: u32 = 0x0473C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_dech_z_zs_field_imm4_4_poweroftwo_c400_0474c400() {
    // Encoding: 0x0474C400
    // Test DECH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x0474C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_dech_z_zs_field_imm4_7_poweroftwominusone_c400_0477c400() {
    // Encoding: 0x0477C400
    // Test DECH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=7
    let encoding: u32 = 0x0477C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_dech_z_zs_field_imm4_8_poweroftwo_c400_0478c400() {
    // Encoding: 0x0478C400
    // Test DECH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x0478C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_dech_z_zs_field_imm4_15_max_c400_047fc400() {
    // Encoding: 0x047FC400
    // Test DECH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Zdn=0
    let encoding: u32 = 0x047FC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_dech_z_zs_field_pattern_0_min_c400_0470c400() {
    // Encoding: 0x0470C400
    // Test DECH_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0470C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_dech_z_zs_field_pattern_1_poweroftwo_c400_0470c420() {
    // Encoding: 0x0470C420
    // Test DECH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, pattern=1, imm4=0
    let encoding: u32 = 0x0470C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_dech_z_zs_field_pattern_15_poweroftwominusone_c400_0470c5e0() {
    // Encoding: 0x0470C5E0
    // Test DECH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x0470C5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_dech_z_zs_field_pattern_31_max_c400_0470c7e0() {
    // Encoding: 0x0470C7E0
    // Test DECH_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x0470C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_dech_z_zs_field_zdn_0_min_c400_0470c400() {
    // Encoding: 0x0470C400
    // Test DECH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_dech_z_zs_field_zdn_1_poweroftwo_c400_0470c401() {
    // Encoding: 0x0470C401
    // Test DECH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x0470C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_dech_z_zs_field_zdn_15_poweroftwominusone_c400_0470c40f() {
    // Encoding: 0x0470C40F
    // Test DECH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x0470C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_dech_z_zs_field_zdn_31_max_c400_0470c41f() {
    // Encoding: 0x0470C41F
    // Test DECH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, Zdn=31, pattern=0
    let encoding: u32 = 0x0470C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_dech_z_zs_combo_0_c400_0470c400() {
    // Encoding: 0x0470C400
    // Test DECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x0470C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_dech_z_zs_invalid_0_c400_0470c400() {
    // Encoding: 0x0470C400
    // Test DECH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dech_z_zs_invalid_1_c400_0470c400() {
    // Encoding: 0x0470C400
    // Test DECH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_decw_z_zs_field_imm4_0_zero_c400_04b0c400() {
    // Encoding: 0x04B0C400
    // Test DECW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_decw_z_zs_field_imm4_1_poweroftwo_c400_04b1c400() {
    // Encoding: 0x04B1C400
    // Test DECW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=1
    let encoding: u32 = 0x04B1C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_decw_z_zs_field_imm4_3_poweroftwominusone_c400_04b3c400() {
    // Encoding: 0x04B3C400
    // Test DECW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x04B3C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_decw_z_zs_field_imm4_4_poweroftwo_c400_04b4c400() {
    // Encoding: 0x04B4C400
    // Test DECW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04B4C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_decw_z_zs_field_imm4_7_poweroftwominusone_c400_04b7c400() {
    // Encoding: 0x04B7C400
    // Test DECW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=7
    let encoding: u32 = 0x04B7C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_decw_z_zs_field_imm4_8_poweroftwo_c400_04b8c400() {
    // Encoding: 0x04B8C400
    // Test DECW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Zdn=0
    let encoding: u32 = 0x04B8C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_decw_z_zs_field_imm4_15_max_c400_04bfc400() {
    // Encoding: 0x04BFC400
    // Test DECW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Zdn=0
    let encoding: u32 = 0x04BFC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decw_z_zs_field_pattern_0_min_c400_04b0c400() {
    // Encoding: 0x04B0C400
    // Test DECW_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04B0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decw_z_zs_field_pattern_1_poweroftwo_c400_04b0c420() {
    // Encoding: 0x04B0C420
    // Test DECW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04B0C420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decw_z_zs_field_pattern_15_poweroftwominusone_c400_04b0c5e0() {
    // Encoding: 0x04B0C5E0
    // Test DECW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decw_z_zs_field_pattern_31_max_c400_04b0c7e0() {
    // Encoding: 0x04B0C7E0
    // Test DECW_Z.ZS__ field pattern = 31 (Max)
    // Fields: Zdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x04B0C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decw_z_zs_field_zdn_0_min_c400_04b0c400() {
    // Encoding: 0x04B0C400
    // Test DECW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04B0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decw_z_zs_field_zdn_1_poweroftwo_c400_04b0c401() {
    // Encoding: 0x04B0C401
    // Test DECW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zdn=1, pattern=0
    let encoding: u32 = 0x04B0C401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decw_z_zs_field_zdn_15_poweroftwominusone_c400_04b0c40f() {
    // Encoding: 0x04B0C40F
    // Test DECW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x04B0C40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decw_z_zs_field_zdn_31_max_c400_04b0c41f() {
    // Encoding: 0x04B0C41F
    // Test DECW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Zdn=31
    let encoding: u32 = 0x04B0C41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_decw_z_zs_combo_0_c400_04b0c400() {
    // Encoding: 0x04B0C400
    // Test DECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decw_z_zs_invalid_0_c400_04b0c400() {
    // Encoding: 0x04B0C400
    // Test DECW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04B0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decw_z_zs_invalid_1_c400_04b0c400() {
    // Encoding: 0x04B0C400
    // Test DECW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04B0C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_decd_z_zs_reg_write_0_04f0c400() {
    // Test DECD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04F0C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: DECH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_dech_z_zs_reg_write_0_0470c400() {
    // Test DECH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0470C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: DECW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_decw_z_zs_reg_write_0_04b0c400() {
    // Test DECW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04B0C400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0C400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECD_R.RS_UW Tests
// ============================================================================

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_0_zero_fc00_04e0fc00() {
    // Encoding: 0x04E0FC00
    // Test UQDECD_R.RS_UW field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04E0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_1_poweroftwo_fc00_04e1fc00() {
    // Encoding: 0x04E1FC00
    // Test UQDECD_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04E1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_3_poweroftwominusone_fc00_04e3fc00() {
    // Encoding: 0x04E3FC00
    // Test UQDECD_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04E3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_4_poweroftwo_fc00_04e4fc00() {
    // Encoding: 0x04E4FC00
    // Test UQDECD_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x04E4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_7_poweroftwominusone_fc00_04e7fc00() {
    // Encoding: 0x04E7FC00
    // Test UQDECD_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=7
    let encoding: u32 = 0x04E7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_8_poweroftwo_fc00_04e8fc00() {
    // Encoding: 0x04E8FC00
    // Test UQDECD_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rdn=0, pattern=0
    let encoding: u32 = 0x04E8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecd_r_rs_uw_field_imm4_15_max_fc00_04effc00() {
    // Encoding: 0x04EFFC00
    // Test UQDECD_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04EFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecd_r_rs_uw_field_pattern_0_min_fc00_04e0fc00() {
    // Encoding: 0x04E0FC00
    // Test UQDECD_R.RS_UW field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecd_r_rs_uw_field_pattern_1_poweroftwo_fc00_04e0fc20() {
    // Encoding: 0x04E0FC20
    // Test UQDECD_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04E0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecd_r_rs_uw_field_pattern_15_poweroftwominusone_fc00_04e0fde0() {
    // Encoding: 0x04E0FDE0
    // Test UQDECD_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=0, pattern=15
    let encoding: u32 = 0x04E0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecd_r_rs_uw_field_pattern_31_max_fc00_04e0ffe0() {
    // Encoding: 0x04E0FFE0
    // Test UQDECD_R.RS_UW field pattern = 31 (Max)
    // Fields: pattern=31, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecd_r_rs_uw_field_rdn_0_min_fc00_04e0fc00() {
    // Encoding: 0x04E0FC00
    // Test UQDECD_R.RS_UW field Rdn = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecd_r_rs_uw_field_rdn_1_poweroftwo_fc00_04e0fc01() {
    // Encoding: 0x04E0FC01
    // Test UQDECD_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Rdn=1
    let encoding: u32 = 0x04E0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecd_r_rs_uw_field_rdn_15_poweroftwominusone_fc00_04e0fc0f() {
    // Encoding: 0x04E0FC0F
    // Test UQDECD_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04E0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecd_r_rs_uw_field_rdn_31_max_fc00_04e0fc1f() {
    // Encoding: 0x04E0FC1F
    // Test UQDECD_R.RS_UW field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x04E0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecd_r_rs_uw_combo_0_fc00_04e0fc00() {
    // Encoding: 0x04E0FC00
    // Test UQDECD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecd_r_rs_uw_invalid_0_fc00_04e0fc00() {
    // Encoding: 0x04E0FC00
    // Test UQDECD_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecd_r_rs_uw_invalid_1_fc00_04e0fc00() {
    // Encoding: 0x04E0FC00
    // Test UQDECD_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecd_r_rs_x_field_imm4_0_zero_fc00_04f0fc00() {
    // Encoding: 0x04F0FC00
    // Test UQDECD_R.RS_X field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecd_r_rs_x_field_imm4_1_poweroftwo_fc00_04f1fc00() {
    // Encoding: 0x04F1FC00
    // Test UQDECD_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04F1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecd_r_rs_x_field_imm4_3_poweroftwominusone_fc00_04f3fc00() {
    // Encoding: 0x04F3FC00
    // Test UQDECD_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04F3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecd_r_rs_x_field_imm4_4_poweroftwo_fc00_04f4fc00() {
    // Encoding: 0x04F4FC00
    // Test UQDECD_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x04F4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecd_r_rs_x_field_imm4_7_poweroftwominusone_fc00_04f7fc00() {
    // Encoding: 0x04F7FC00
    // Test UQDECD_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rdn=0, pattern=0
    let encoding: u32 = 0x04F7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecd_r_rs_x_field_imm4_8_poweroftwo_fc00_04f8fc00() {
    // Encoding: 0x04F8FC00
    // Test UQDECD_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04F8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecd_r_rs_x_field_imm4_15_max_fc00_04fffc00() {
    // Encoding: 0x04FFFC00
    // Test UQDECD_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04FFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecd_r_rs_x_field_pattern_0_min_fc00_04f0fc00() {
    // Encoding: 0x04F0FC00
    // Test UQDECD_R.RS_X field pattern = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecd_r_rs_x_field_pattern_1_poweroftwo_fc00_04f0fc20() {
    // Encoding: 0x04F0FC20
    // Test UQDECD_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecd_r_rs_x_field_pattern_15_poweroftwominusone_fc00_04f0fde0() {
    // Encoding: 0x04F0FDE0
    // Test UQDECD_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04F0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecd_r_rs_x_field_pattern_31_max_fc00_04f0ffe0() {
    // Encoding: 0x04F0FFE0
    // Test UQDECD_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04F0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecd_r_rs_x_field_rdn_0_min_fc00_04f0fc00() {
    // Encoding: 0x04F0FC00
    // Test UQDECD_R.RS_X field Rdn = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04F0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecd_r_rs_x_field_rdn_1_poweroftwo_fc00_04f0fc01() {
    // Encoding: 0x04F0FC01
    // Test UQDECD_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04F0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecd_r_rs_x_field_rdn_15_poweroftwominusone_fc00_04f0fc0f() {
    // Encoding: 0x04F0FC0F
    // Test UQDECD_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x04F0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecd_r_rs_x_field_rdn_31_max_fc00_04f0fc1f() {
    // Encoding: 0x04F0FC1F
    // Test UQDECD_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, Rdn=31, pattern=0
    let encoding: u32 = 0x04F0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecd_r_rs_x_combo_0_fc00_04f0fc00() {
    // Encoding: 0x04F0FC00
    // Test UQDECD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04F0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecd_r_rs_x_invalid_0_fc00_04f0fc00() {
    // Encoding: 0x04F0FC00
    // Test UQDECD_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecd_r_rs_x_invalid_1_fc00_04f0fc00() {
    // Encoding: 0x04F0FC00
    // Test UQDECD_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04F0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECD_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecd_r_rs_uw_reg_write_0_04e0fc00() {
    // Test UQDECD_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x04E0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQDECD_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecd_r_rs_x_reg_write_0_04f0fc00() {
    // Test UQDECD_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04F0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCH_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqinch_z_zs_field_imm4_0_zero_c000_0460c000() {
    // Encoding: 0x0460C000
    // Test SQINCH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqinch_z_zs_field_imm4_1_poweroftwo_c000_0461c000() {
    // Encoding: 0x0461C000
    // Test SQINCH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Zdn=0
    let encoding: u32 = 0x0461C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqinch_z_zs_field_imm4_3_poweroftwominusone_c000_0463c000() {
    // Encoding: 0x0463C000
    // Test SQINCH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x0463C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqinch_z_zs_field_imm4_4_poweroftwo_c000_0464c000() {
    // Encoding: 0x0464C000
    // Test SQINCH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x0464C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqinch_z_zs_field_imm4_7_poweroftwominusone_c000_0467c000() {
    // Encoding: 0x0467C000
    // Test SQINCH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0467C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqinch_z_zs_field_imm4_8_poweroftwo_c000_0468c000() {
    // Encoding: 0x0468C000
    // Test SQINCH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zdn=0, pattern=0
    let encoding: u32 = 0x0468C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqinch_z_zs_field_imm4_15_max_c000_046fc000() {
    // Encoding: 0x046FC000
    // Test SQINCH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Zdn=0
    let encoding: u32 = 0x046FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqinch_z_zs_field_pattern_0_min_c000_0460c000() {
    // Encoding: 0x0460C000
    // Test SQINCH_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqinch_z_zs_field_pattern_1_poweroftwo_c000_0460c020() {
    // Encoding: 0x0460C020
    // Test SQINCH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x0460C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqinch_z_zs_field_pattern_15_poweroftwominusone_c000_0460c1e0() {
    // Encoding: 0x0460C1E0
    // Test SQINCH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x0460C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqinch_z_zs_field_pattern_31_max_c000_0460c3e0() {
    // Encoding: 0x0460C3E0
    // Test SQINCH_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqinch_z_zs_field_zdn_0_min_c000_0460c000() {
    // Encoding: 0x0460C000
    // Test SQINCH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqinch_z_zs_field_zdn_1_poweroftwo_c000_0460c001() {
    // Encoding: 0x0460C001
    // Test SQINCH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, pattern=0, imm4=0
    let encoding: u32 = 0x0460C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqinch_z_zs_field_zdn_15_poweroftwominusone_c000_0460c00f() {
    // Encoding: 0x0460C00F
    // Test SQINCH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x0460C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqinch_z_zs_field_zdn_31_max_c000_0460c01f() {
    // Encoding: 0x0460C01F
    // Test SQINCH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x0460C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqinch_z_zs_combo_0_c000_0460c000() {
    // Encoding: 0x0460C000
    // Test SQINCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x0460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqinch_z_zs_invalid_0_c000_0460c000() {
    // Encoding: 0x0460C000
    // Test SQINCH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqinch_z_zs_invalid_1_c000_0460c000() {
    // Encoding: 0x0460C000
    // Test SQINCH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqinch_z_zs_reg_write_0_0460c000() {
    // Test SQINCH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0460C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INCP_R.P.R__ Tests
// ============================================================================

/// Provenance: INCP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_incp_r_p_r_field_size_0_min_8800_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ field size = 0 (Min)
    // Fields: Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_incp_r_p_r_field_size_1_poweroftwo_8800_256c8800() {
    // Encoding: 0x256C8800
    // Test INCP_R.P.R__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Rdn=0, Pg=0
    let encoding: u32 = 0x256C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_incp_r_p_r_field_size_2_poweroftwo_8800_25ac8800() {
    // Encoding: 0x25AC8800
    // Test INCP_R.P.R__ field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, Pg=0, size=2
    let encoding: u32 = 0x25AC8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_incp_r_p_r_field_size_3_max_8800_25ec8800() {
    // Encoding: 0x25EC8800
    // Test INCP_R.P.R__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Rdn=0
    let encoding: u32 = 0x25EC8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_incp_r_p_r_field_pg_0_min_8800_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_incp_r_p_r_field_pg_1_poweroftwo_8800_252c8820() {
    // Encoding: 0x252C8820
    // Test INCP_R.P.R__ field Pg = 1 (PowerOfTwo)
    // Fields: Rdn=0, size=0, Pg=1
    let encoding: u32 = 0x252C8820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incp_r_p_r_field_rdn_0_min_8800_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ field Rdn = 0 (Min)
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incp_r_p_r_field_rdn_1_poweroftwo_8800_252c8801() {
    // Encoding: 0x252C8801
    // Test INCP_R.P.R__ field Rdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=1, size=0
    let encoding: u32 = 0x252C8801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incp_r_p_r_field_rdn_15_poweroftwominusone_8800_252c880f() {
    // Encoding: 0x252C880F
    // Test INCP_R.P.R__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Rdn=15
    let encoding: u32 = 0x252C880F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incp_r_p_r_field_rdn_31_max_8800_252c881f() {
    // Encoding: 0x252C881F
    // Test INCP_R.P.R__ field Rdn = 31 (Max)
    // Fields: Pg=0, size=0, Rdn=31
    let encoding: u32 = 0x252C881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_incp_r_p_r_combo_0_8800_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ field combination: size=0, Pg=0, Rdn=0
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_incp_r_p_r_special_size_0_size_variant_0_34816_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_incp_r_p_r_special_size_1_size_variant_1_34816_256c8800() {
    // Encoding: 0x256C8800
    // Test INCP_R.P.R__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Rdn=0
    let encoding: u32 = 0x256C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_incp_r_p_r_special_size_2_size_variant_2_34816_25ac8800() {
    // Encoding: 0x25AC8800
    // Test INCP_R.P.R__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Rdn=0
    let encoding: u32 = 0x25AC8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_incp_r_p_r_special_size_3_size_variant_3_34816_25ec8800() {
    // Encoding: 0x25EC8800
    // Test INCP_R.P.R__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Rdn=0
    let encoding: u32 = 0x25EC8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incp_r_p_r_invalid_0_8800_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incp_r_p_r_invalid_1_8800_252c8800() {
    // Encoding: 0x252C8800
    // Test INCP_R.P.R__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x252C8800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCP_R.P.R__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_incp_r_p_r_reg_write_0_252c8800() {
    // Test INCP_R.P.R__ register write: GpFromField("dn")
    // Encoding: 0x252C8800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252C8800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCW_R.RS_UW Tests
// ============================================================================

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincw_r_rs_uw_field_imm4_0_zero_f400_04a0f400() {
    // Encoding: 0x04A0F400
    // Test UQINCW_R.RS_UW field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincw_r_rs_uw_field_imm4_1_poweroftwo_f400_04a1f400() {
    // Encoding: 0x04A1F400
    // Test UQINCW_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x04A1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincw_r_rs_uw_field_imm4_3_poweroftwominusone_f400_04a3f400() {
    // Encoding: 0x04A3F400
    // Test UQINCW_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=3
    let encoding: u32 = 0x04A3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincw_r_rs_uw_field_imm4_4_poweroftwo_f400_04a4f400() {
    // Encoding: 0x04A4F400
    // Test UQINCW_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x04A4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincw_r_rs_uw_field_imm4_7_poweroftwominusone_f400_04a7f400() {
    // Encoding: 0x04A7F400
    // Test UQINCW_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Rdn=0
    let encoding: u32 = 0x04A7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincw_r_rs_uw_field_imm4_8_poweroftwo_f400_04a8f400() {
    // Encoding: 0x04A8F400
    // Test UQINCW_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04A8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincw_r_rs_uw_field_imm4_15_max_f400_04aff400() {
    // Encoding: 0x04AFF400
    // Test UQINCW_R.RS_UW field imm4 = 15 (Max)
    // Fields: pattern=0, Rdn=0, imm4=15
    let encoding: u32 = 0x04AFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincw_r_rs_uw_field_pattern_0_min_f400_04a0f400() {
    // Encoding: 0x04A0F400
    // Test UQINCW_R.RS_UW field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincw_r_rs_uw_field_pattern_1_poweroftwo_f400_04a0f420() {
    // Encoding: 0x04A0F420
    // Test UQINCW_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04A0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincw_r_rs_uw_field_pattern_15_poweroftwominusone_f400_04a0f5e0() {
    // Encoding: 0x04A0F5E0
    // Test UQINCW_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04A0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincw_r_rs_uw_field_pattern_31_max_f400_04a0f7e0() {
    // Encoding: 0x04A0F7E0
    // Test UQINCW_R.RS_UW field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04A0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincw_r_rs_uw_field_rdn_0_min_f400_04a0f400() {
    // Encoding: 0x04A0F400
    // Test UQINCW_R.RS_UW field Rdn = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincw_r_rs_uw_field_rdn_1_poweroftwo_f400_04a0f401() {
    // Encoding: 0x04A0F401
    // Test UQINCW_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04A0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincw_r_rs_uw_field_rdn_15_poweroftwominusone_f400_04a0f40f() {
    // Encoding: 0x04A0F40F
    // Test UQINCW_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04A0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincw_r_rs_uw_field_rdn_31_max_f400_04a0f41f() {
    // Encoding: 0x04A0F41F
    // Test UQINCW_R.RS_UW field Rdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Rdn=31
    let encoding: u32 = 0x04A0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincw_r_rs_uw_combo_0_f400_04a0f400() {
    // Encoding: 0x04A0F400
    // Test UQINCW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincw_r_rs_uw_invalid_0_f400_04a0f400() {
    // Encoding: 0x04A0F400
    // Test UQINCW_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincw_r_rs_uw_invalid_1_f400_04a0f400() {
    // Encoding: 0x04A0F400
    // Test UQINCW_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincw_r_rs_x_field_imm4_0_zero_f400_04b0f400() {
    // Encoding: 0x04B0F400
    // Test UQINCW_R.RS_X field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincw_r_rs_x_field_imm4_1_poweroftwo_f400_04b1f400() {
    // Encoding: 0x04B1F400
    // Test UQINCW_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=1
    let encoding: u32 = 0x04B1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincw_r_rs_x_field_imm4_3_poweroftwominusone_f400_04b3f400() {
    // Encoding: 0x04B3F400
    // Test UQINCW_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x04B3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincw_r_rs_x_field_imm4_4_poweroftwo_f400_04b4f400() {
    // Encoding: 0x04B4F400
    // Test UQINCW_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, pattern=0, Rdn=0
    let encoding: u32 = 0x04B4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincw_r_rs_x_field_imm4_7_poweroftwominusone_f400_04b7f400() {
    // Encoding: 0x04B7F400
    // Test UQINCW_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04B7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincw_r_rs_x_field_imm4_8_poweroftwo_f400_04b8f400() {
    // Encoding: 0x04B8F400
    // Test UQINCW_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=8
    let encoding: u32 = 0x04B8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincw_r_rs_x_field_imm4_15_max_f400_04bff400() {
    // Encoding: 0x04BFF400
    // Test UQINCW_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04BFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincw_r_rs_x_field_pattern_0_min_f400_04b0f400() {
    // Encoding: 0x04B0F400
    // Test UQINCW_R.RS_X field pattern = 0 (Min)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincw_r_rs_x_field_pattern_1_poweroftwo_f400_04b0f420() {
    // Encoding: 0x04B0F420
    // Test UQINCW_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04B0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincw_r_rs_x_field_pattern_15_poweroftwominusone_f400_04b0f5e0() {
    // Encoding: 0x04B0F5E0
    // Test UQINCW_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincw_r_rs_x_field_pattern_31_max_f400_04b0f7e0() {
    // Encoding: 0x04B0F7E0
    // Test UQINCW_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x04B0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincw_r_rs_x_field_rdn_0_min_f400_04b0f400() {
    // Encoding: 0x04B0F400
    // Test UQINCW_R.RS_X field Rdn = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04B0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincw_r_rs_x_field_rdn_1_poweroftwo_f400_04b0f401() {
    // Encoding: 0x04B0F401
    // Test UQINCW_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, Rdn=1, pattern=0
    let encoding: u32 = 0x04B0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincw_r_rs_x_field_rdn_15_poweroftwominusone_f400_04b0f40f() {
    // Encoding: 0x04B0F40F
    // Test UQINCW_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x04B0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincw_r_rs_x_field_rdn_31_max_f400_04b0f41f() {
    // Encoding: 0x04B0F41F
    // Test UQINCW_R.RS_X field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x04B0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincw_r_rs_x_combo_0_f400_04b0f400() {
    // Encoding: 0x04B0F400
    // Test UQINCW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincw_r_rs_x_invalid_0_f400_04b0f400() {
    // Encoding: 0x04B0F400
    // Test UQINCW_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04B0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincw_r_rs_x_invalid_1_f400_04b0f400() {
    // Encoding: 0x04B0F400
    // Test UQINCW_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04B0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCW_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincw_r_rs_uw_reg_write_0_04a0f400() {
    // Test UQINCW_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x04A0F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQINCW_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincw_r_rs_x_reg_write_0_04b0f400() {
    // Test UQINCW_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04B0F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCP_R.P.R_UW Tests
// ============================================================================

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqincp_r_p_r_uw_field_size_0_min_8800_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW field size = 0 (Min)
    // Fields: Pg=0, Rdn=0, size=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqincp_r_p_r_uw_field_size_1_poweroftwo_8800_25698800() {
    // Encoding: 0x25698800
    // Test UQINCP_R.P.R_UW field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Rdn=0
    let encoding: u32 = 0x25698800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqincp_r_p_r_uw_field_size_2_poweroftwo_8800_25a98800() {
    // Encoding: 0x25A98800
    // Test UQINCP_R.P.R_UW field size = 2 (PowerOfTwo)
    // Fields: Rdn=0, size=2, Pg=0
    let encoding: u32 = 0x25A98800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqincp_r_p_r_uw_field_size_3_max_8800_25e98800() {
    // Encoding: 0x25E98800
    // Test UQINCP_R.P.R_UW field size = 3 (Max)
    // Fields: size=3, Pg=0, Rdn=0
    let encoding: u32 = 0x25E98800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqincp_r_p_r_uw_field_pg_0_min_8800_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW field Pg = 0 (Min)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqincp_r_p_r_uw_field_pg_1_poweroftwo_8800_25298820() {
    // Encoding: 0x25298820
    // Test UQINCP_R.P.R_UW field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Rdn=0
    let encoding: u32 = 0x25298820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincp_r_p_r_uw_field_rdn_0_min_8800_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW field Rdn = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincp_r_p_r_uw_field_rdn_1_poweroftwo_8800_25298801() {
    // Encoding: 0x25298801
    // Test UQINCP_R.P.R_UW field Rdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Rdn=1
    let encoding: u32 = 0x25298801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincp_r_p_r_uw_field_rdn_15_poweroftwominusone_8800_2529880f() {
    // Encoding: 0x2529880F
    // Test UQINCP_R.P.R_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Rdn=15, Pg=0
    let encoding: u32 = 0x2529880F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincp_r_p_r_uw_field_rdn_31_max_8800_2529881f() {
    // Encoding: 0x2529881F
    // Test UQINCP_R.P.R_UW field Rdn = 31 (Max)
    // Fields: Rdn=31, Pg=0, size=0
    let encoding: u32 = 0x2529881F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqincp_r_p_r_uw_combo_0_8800_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW field combination: size=0, Pg=0, Rdn=0
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqincp_r_p_r_uw_special_size_0_size_variant_0_34816_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW special value size = 0 (Size variant 0)
    // Fields: Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqincp_r_p_r_uw_special_size_1_size_variant_1_34816_25698800() {
    // Encoding: 0x25698800
    // Test UQINCP_R.P.R_UW special value size = 1 (Size variant 1)
    // Fields: size=1, Rdn=0, Pg=0
    let encoding: u32 = 0x25698800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqincp_r_p_r_uw_special_size_2_size_variant_2_34816_25a98800() {
    // Encoding: 0x25A98800
    // Test UQINCP_R.P.R_UW special value size = 2 (Size variant 2)
    // Fields: Pg=0, Rdn=0, size=2
    let encoding: u32 = 0x25A98800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqincp_r_p_r_uw_special_size_3_size_variant_3_34816_25e98800() {
    // Encoding: 0x25E98800
    // Test UQINCP_R.P.R_UW special value size = 3 (Size variant 3)
    // Fields: size=3, Rdn=0, Pg=0
    let encoding: u32 = 0x25E98800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincp_r_p_r_uw_invalid_0_8800_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincp_r_p_r_uw_invalid_1_8800_25298800() {
    // Encoding: 0x25298800
    // Test UQINCP_R.P.R_UW invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x25298800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqincp_r_p_r_x_field_size_0_min_8c00_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X field size = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqincp_r_p_r_x_field_size_1_poweroftwo_8c00_25698c00() {
    // Encoding: 0x25698C00
    // Test UQINCP_R.P.R_X field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=0, size=1
    let encoding: u32 = 0x25698C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqincp_r_p_r_x_field_size_2_poweroftwo_8c00_25a98c00() {
    // Encoding: 0x25A98C00
    // Test UQINCP_R.P.R_X field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Rdn=0
    let encoding: u32 = 0x25A98C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqincp_r_p_r_x_field_size_3_max_8c00_25e98c00() {
    // Encoding: 0x25E98C00
    // Test UQINCP_R.P.R_X field size = 3 (Max)
    // Fields: Rdn=0, Pg=0, size=3
    let encoding: u32 = 0x25E98C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqincp_r_p_r_x_field_pg_0_min_8c00_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqincp_r_p_r_x_field_pg_1_poweroftwo_8c00_25298c20() {
    // Encoding: 0x25298C20
    // Test UQINCP_R.P.R_X field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Rdn=0
    let encoding: u32 = 0x25298C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincp_r_p_r_x_field_rdn_0_min_8c00_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X field Rdn = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincp_r_p_r_x_field_rdn_1_poweroftwo_8c00_25298c01() {
    // Encoding: 0x25298C01
    // Test UQINCP_R.P.R_X field Rdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=1, size=0
    let encoding: u32 = 0x25298C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincp_r_p_r_x_field_rdn_15_poweroftwominusone_8c00_25298c0f() {
    // Encoding: 0x25298C0F
    // Test UQINCP_R.P.R_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, size=0, Pg=0
    let encoding: u32 = 0x25298C0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincp_r_p_r_x_field_rdn_31_max_8c00_25298c1f() {
    // Encoding: 0x25298C1F
    // Test UQINCP_R.P.R_X field Rdn = 31 (Max)
    // Fields: Rdn=31, size=0, Pg=0
    let encoding: u32 = 0x25298C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqincp_r_p_r_x_combo_0_8c00_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X field combination: size=0, Pg=0, Rdn=0
    // Fields: Rdn=0, Pg=0, size=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqincp_r_p_r_x_special_size_0_size_variant_0_35840_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X special value size = 0 (Size variant 0)
    // Fields: size=0, Rdn=0, Pg=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqincp_r_p_r_x_special_size_1_size_variant_1_35840_25698c00() {
    // Encoding: 0x25698C00
    // Test UQINCP_R.P.R_X special value size = 1 (Size variant 1)
    // Fields: size=1, Rdn=0, Pg=0
    let encoding: u32 = 0x25698C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqincp_r_p_r_x_special_size_2_size_variant_2_35840_25a98c00() {
    // Encoding: 0x25A98C00
    // Test UQINCP_R.P.R_X special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Rdn=0
    let encoding: u32 = 0x25A98C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqincp_r_p_r_x_special_size_3_size_variant_3_35840_25e98c00() {
    // Encoding: 0x25E98C00
    // Test UQINCP_R.P.R_X special value size = 3 (Size variant 3)
    // Fields: Rdn=0, size=3, Pg=0
    let encoding: u32 = 0x25E98C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincp_r_p_r_x_invalid_0_8c00_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincp_r_p_r_x_invalid_1_8c00_25298c00() {
    // Encoding: 0x25298C00
    // Test UQINCP_R.P.R_X invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x25298C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCP_R.P.R_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincp_r_p_r_uw_reg_write_0_25298800() {
    // Test UQINCP_R.P.R_UW register write: GpFromField("dn")
    // Encoding: 0x25298800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25298800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQINCP_R.P.R_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincp_r_p_r_x_reg_write_0_25298c00() {
    // Test UQINCP_R.P.R_X register write: GpFromField("dn")
    // Encoding: 0x25298C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x25298C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECB_R.RS_UW Tests
// ============================================================================

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_0_zero_fc00_0420fc00() {
    // Encoding: 0x0420FC00
    // Test UQDECB_R.RS_UW field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_1_poweroftwo_fc00_0421fc00() {
    // Encoding: 0x0421FC00
    // Test UQDECB_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x0421FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_3_poweroftwominusone_fc00_0423fc00() {
    // Encoding: 0x0423FC00
    // Test UQDECB_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rdn=0, pattern=0
    let encoding: u32 = 0x0423FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_4_poweroftwo_fc00_0424fc00() {
    // Encoding: 0x0424FC00
    // Test UQDECB_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x0424FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_7_poweroftwominusone_fc00_0427fc00() {
    // Encoding: 0x0427FC00
    // Test UQDECB_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x0427FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_8_poweroftwo_fc00_0428fc00() {
    // Encoding: 0x0428FC00
    // Test UQDECB_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x0428FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecb_r_rs_uw_field_imm4_15_max_fc00_042ffc00() {
    // Encoding: 0x042FFC00
    // Test UQDECB_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x042FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecb_r_rs_uw_field_pattern_0_min_fc00_0420fc00() {
    // Encoding: 0x0420FC00
    // Test UQDECB_R.RS_UW field pattern = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0420FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecb_r_rs_uw_field_pattern_1_poweroftwo_fc00_0420fc20() {
    // Encoding: 0x0420FC20
    // Test UQDECB_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, imm4=0, Rdn=0
    let encoding: u32 = 0x0420FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecb_r_rs_uw_field_pattern_15_poweroftwominusone_fc00_0420fde0() {
    // Encoding: 0x0420FDE0
    // Test UQDECB_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rdn=0, pattern=15
    let encoding: u32 = 0x0420FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecb_r_rs_uw_field_pattern_31_max_fc00_0420ffe0() {
    // Encoding: 0x0420FFE0
    // Test UQDECB_R.RS_UW field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0420FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecb_r_rs_uw_field_rdn_0_min_fc00_0420fc00() {
    // Encoding: 0x0420FC00
    // Test UQDECB_R.RS_UW field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecb_r_rs_uw_field_rdn_1_poweroftwo_fc00_0420fc01() {
    // Encoding: 0x0420FC01
    // Test UQDECB_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x0420FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecb_r_rs_uw_field_rdn_15_poweroftwominusone_fc00_0420fc0f() {
    // Encoding: 0x0420FC0F
    // Test UQDECB_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x0420FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecb_r_rs_uw_field_rdn_31_max_fc00_0420fc1f() {
    // Encoding: 0x0420FC1F
    // Test UQDECB_R.RS_UW field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x0420FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecb_r_rs_uw_combo_0_fc00_0420fc00() {
    // Encoding: 0x0420FC00
    // Test UQDECB_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0420FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecb_r_rs_uw_invalid_0_fc00_0420fc00() {
    // Encoding: 0x0420FC00
    // Test UQDECB_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0420FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecb_r_rs_uw_invalid_1_fc00_0420fc00() {
    // Encoding: 0x0420FC00
    // Test UQDECB_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0420FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecb_r_rs_x_field_imm4_0_zero_fc00_0430fc00() {
    // Encoding: 0x0430FC00
    // Test UQDECB_R.RS_X field imm4 = 0 (Zero)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0430FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecb_r_rs_x_field_imm4_1_poweroftwo_fc00_0431fc00() {
    // Encoding: 0x0431FC00
    // Test UQDECB_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x0431FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecb_r_rs_x_field_imm4_3_poweroftwominusone_fc00_0433fc00() {
    // Encoding: 0x0433FC00
    // Test UQDECB_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x0433FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecb_r_rs_x_field_imm4_4_poweroftwo_fc00_0434fc00() {
    // Encoding: 0x0434FC00
    // Test UQDECB_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rdn=0, pattern=0
    let encoding: u32 = 0x0434FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecb_r_rs_x_field_imm4_7_poweroftwominusone_fc00_0437fc00() {
    // Encoding: 0x0437FC00
    // Test UQDECB_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x0437FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecb_r_rs_x_field_imm4_8_poweroftwo_fc00_0438fc00() {
    // Encoding: 0x0438FC00
    // Test UQDECB_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0438FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecb_r_rs_x_field_imm4_15_max_fc00_043ffc00() {
    // Encoding: 0x043FFC00
    // Test UQDECB_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x043FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecb_r_rs_x_field_pattern_0_min_fc00_0430fc00() {
    // Encoding: 0x0430FC00
    // Test UQDECB_R.RS_X field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecb_r_rs_x_field_pattern_1_poweroftwo_fc00_0430fc20() {
    // Encoding: 0x0430FC20
    // Test UQDECB_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0430FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecb_r_rs_x_field_pattern_15_poweroftwominusone_fc00_0430fde0() {
    // Encoding: 0x0430FDE0
    // Test UQDECB_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Rdn=0, imm4=0
    let encoding: u32 = 0x0430FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecb_r_rs_x_field_pattern_31_max_fc00_0430ffe0() {
    // Encoding: 0x0430FFE0
    // Test UQDECB_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x0430FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecb_r_rs_x_field_rdn_0_min_fc00_0430fc00() {
    // Encoding: 0x0430FC00
    // Test UQDECB_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0430FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecb_r_rs_x_field_rdn_1_poweroftwo_fc00_0430fc01() {
    // Encoding: 0x0430FC01
    // Test UQDECB_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Rdn=1
    let encoding: u32 = 0x0430FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecb_r_rs_x_field_rdn_15_poweroftwominusone_fc00_0430fc0f() {
    // Encoding: 0x0430FC0F
    // Test UQDECB_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0430FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecb_r_rs_x_field_rdn_31_max_fc00_0430fc1f() {
    // Encoding: 0x0430FC1F
    // Test UQDECB_R.RS_X field Rdn = 31 (Max)
    // Fields: pattern=0, Rdn=31, imm4=0
    let encoding: u32 = 0x0430FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecb_r_rs_x_combo_0_fc00_0430fc00() {
    // Encoding: 0x0430FC00
    // Test UQDECB_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecb_r_rs_x_invalid_0_fc00_0430fc00() {
    // Encoding: 0x0430FC00
    // Test UQDECB_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0430FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecb_r_rs_x_invalid_1_fc00_0430fc00() {
    // Encoding: 0x0430FC00
    // Test UQDECB_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0430FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECB_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecb_r_rs_uw_reg_write_0_0420fc00() {
    // Test UQDECB_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x0420FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQDECB_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecb_r_rs_x_reg_write_0_0430fc00() {
    // Test UQDECB_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0430FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0430FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQINCD_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqincd_z_zs_field_imm4_0_zero_c000_04e0c000() {
    // Encoding: 0x04E0C000
    // Test SQINCD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqincd_z_zs_field_imm4_1_poweroftwo_c000_04e1c000() {
    // Encoding: 0x04E1C000
    // Test SQINCD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04E1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqincd_z_zs_field_imm4_3_poweroftwominusone_c000_04e3c000() {
    // Encoding: 0x04E3C000
    // Test SQINCD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x04E3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqincd_z_zs_field_imm4_4_poweroftwo_c000_04e4c000() {
    // Encoding: 0x04E4C000
    // Test SQINCD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04E4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqincd_z_zs_field_imm4_7_poweroftwominusone_c000_04e7c000() {
    // Encoding: 0x04E7C000
    // Test SQINCD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x04E7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqincd_z_zs_field_imm4_8_poweroftwo_c000_04e8c000() {
    // Encoding: 0x04E8C000
    // Test SQINCD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x04E8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqincd_z_zs_field_imm4_15_max_c000_04efc000() {
    // Encoding: 0x04EFC000
    // Test SQINCD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, Zdn=0, imm4=15
    let encoding: u32 = 0x04EFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincd_z_zs_field_pattern_0_min_c000_04e0c000() {
    // Encoding: 0x04E0C000
    // Test SQINCD_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincd_z_zs_field_pattern_1_poweroftwo_c000_04e0c020() {
    // Encoding: 0x04E0C020
    // Test SQINCD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x04E0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincd_z_zs_field_pattern_15_poweroftwominusone_c000_04e0c1e0() {
    // Encoding: 0x04E0C1E0
    // Test SQINCD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x04E0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincd_z_zs_field_pattern_31_max_c000_04e0c3e0() {
    // Encoding: 0x04E0C3E0
    // Test SQINCD_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqincd_z_zs_field_zdn_0_min_c000_04e0c000() {
    // Encoding: 0x04E0C000
    // Test SQINCD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqincd_z_zs_field_zdn_1_poweroftwo_c000_04e0c001() {
    // Encoding: 0x04E0C001
    // Test SQINCD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Zdn=1
    let encoding: u32 = 0x04E0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqincd_z_zs_field_zdn_15_poweroftwominusone_c000_04e0c00f() {
    // Encoding: 0x04E0C00F
    // Test SQINCD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=15, imm4=0
    let encoding: u32 = 0x04E0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqincd_z_zs_field_zdn_31_max_c000_04e0c01f() {
    // Encoding: 0x04E0C01F
    // Test SQINCD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: pattern=0, Zdn=31, imm4=0
    let encoding: u32 = 0x04E0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqincd_z_zs_combo_0_c000_04e0c000() {
    // Encoding: 0x04E0C000
    // Test SQINCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqincd_z_zs_invalid_0_c000_04e0c000() {
    // Encoding: 0x04E0C000
    // Test SQINCD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqincd_z_zs_invalid_1_c000_04e0c000() {
    // Encoding: 0x04E0C000
    // Test SQINCD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQINCD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqincd_z_zs_reg_write_0_04e0c000() {
    // Test SQINCD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04E0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECH_R.RS_UW Tests
// ============================================================================

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdech_r_rs_uw_field_imm4_0_zero_fc00_0460fc00() {
    // Encoding: 0x0460FC00
    // Test UQDECH_R.RS_UW field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0460FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdech_r_rs_uw_field_imm4_1_poweroftwo_fc00_0461fc00() {
    // Encoding: 0x0461FC00
    // Test UQDECH_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x0461FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdech_r_rs_uw_field_imm4_3_poweroftwominusone_fc00_0463fc00() {
    // Encoding: 0x0463FC00
    // Test UQDECH_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=3, Rdn=0
    let encoding: u32 = 0x0463FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdech_r_rs_uw_field_imm4_4_poweroftwo_fc00_0464fc00() {
    // Encoding: 0x0464FC00
    // Test UQDECH_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x0464FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdech_r_rs_uw_field_imm4_7_poweroftwominusone_fc00_0467fc00() {
    // Encoding: 0x0467FC00
    // Test UQDECH_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0467FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdech_r_rs_uw_field_imm4_8_poweroftwo_fc00_0468fc00() {
    // Encoding: 0x0468FC00
    // Test UQDECH_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0468FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdech_r_rs_uw_field_imm4_15_max_fc00_046ffc00() {
    // Encoding: 0x046FFC00
    // Test UQDECH_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Rdn=0
    let encoding: u32 = 0x046FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdech_r_rs_uw_field_pattern_0_min_fc00_0460fc00() {
    // Encoding: 0x0460FC00
    // Test UQDECH_R.RS_UW field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0460FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdech_r_rs_uw_field_pattern_1_poweroftwo_fc00_0460fc20() {
    // Encoding: 0x0460FC20
    // Test UQDECH_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x0460FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdech_r_rs_uw_field_pattern_15_poweroftwominusone_fc00_0460fde0() {
    // Encoding: 0x0460FDE0
    // Test UQDECH_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, imm4=0, Rdn=0
    let encoding: u32 = 0x0460FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdech_r_rs_uw_field_pattern_31_max_fc00_0460ffe0() {
    // Encoding: 0x0460FFE0
    // Test UQDECH_R.RS_UW field pattern = 31 (Max)
    // Fields: pattern=31, imm4=0, Rdn=0
    let encoding: u32 = 0x0460FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdech_r_rs_uw_field_rdn_0_min_fc00_0460fc00() {
    // Encoding: 0x0460FC00
    // Test UQDECH_R.RS_UW field Rdn = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x0460FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdech_r_rs_uw_field_rdn_1_poweroftwo_fc00_0460fc01() {
    // Encoding: 0x0460FC01
    // Test UQDECH_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, pattern=0, imm4=0
    let encoding: u32 = 0x0460FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdech_r_rs_uw_field_rdn_15_poweroftwominusone_fc00_0460fc0f() {
    // Encoding: 0x0460FC0F
    // Test UQDECH_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x0460FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdech_r_rs_uw_field_rdn_31_max_fc00_0460fc1f() {
    // Encoding: 0x0460FC1F
    // Test UQDECH_R.RS_UW field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x0460FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdech_r_rs_uw_combo_0_fc00_0460fc00() {
    // Encoding: 0x0460FC00
    // Test UQDECH_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdech_r_rs_uw_invalid_0_fc00_0460fc00() {
    // Encoding: 0x0460FC00
    // Test UQDECH_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0460FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdech_r_rs_uw_invalid_1_fc00_0460fc00() {
    // Encoding: 0x0460FC00
    // Test UQDECH_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x0460FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdech_r_rs_x_field_imm4_0_zero_fc00_0470fc00() {
    // Encoding: 0x0470FC00
    // Test UQDECH_R.RS_X field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdech_r_rs_x_field_imm4_1_poweroftwo_fc00_0471fc00() {
    // Encoding: 0x0471FC00
    // Test UQDECH_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x0471FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdech_r_rs_x_field_imm4_3_poweroftwominusone_fc00_0473fc00() {
    // Encoding: 0x0473FC00
    // Test UQDECH_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x0473FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdech_r_rs_x_field_imm4_4_poweroftwo_fc00_0474fc00() {
    // Encoding: 0x0474FC00
    // Test UQDECH_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x0474FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdech_r_rs_x_field_imm4_7_poweroftwominusone_fc00_0477fc00() {
    // Encoding: 0x0477FC00
    // Test UQDECH_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Rdn=0
    let encoding: u32 = 0x0477FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdech_r_rs_x_field_imm4_8_poweroftwo_fc00_0478fc00() {
    // Encoding: 0x0478FC00
    // Test UQDECH_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x0478FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdech_r_rs_x_field_imm4_15_max_fc00_047ffc00() {
    // Encoding: 0x047FFC00
    // Test UQDECH_R.RS_X field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x047FFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdech_r_rs_x_field_pattern_0_min_fc00_0470fc00() {
    // Encoding: 0x0470FC00
    // Test UQDECH_R.RS_X field pattern = 0 (Min)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0470FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdech_r_rs_x_field_pattern_1_poweroftwo_fc00_0470fc20() {
    // Encoding: 0x0470FC20
    // Test UQDECH_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x0470FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdech_r_rs_x_field_pattern_15_poweroftwominusone_fc00_0470fde0() {
    // Encoding: 0x0470FDE0
    // Test UQDECH_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x0470FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdech_r_rs_x_field_pattern_31_max_fc00_0470ffe0() {
    // Encoding: 0x0470FFE0
    // Test UQDECH_R.RS_X field pattern = 31 (Max)
    // Fields: pattern=31, Rdn=0, imm4=0
    let encoding: u32 = 0x0470FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdech_r_rs_x_field_rdn_0_min_fc00_0470fc00() {
    // Encoding: 0x0470FC00
    // Test UQDECH_R.RS_X field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x0470FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdech_r_rs_x_field_rdn_1_poweroftwo_fc00_0470fc01() {
    // Encoding: 0x0470FC01
    // Test UQDECH_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x0470FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdech_r_rs_x_field_rdn_15_poweroftwominusone_fc00_0470fc0f() {
    // Encoding: 0x0470FC0F
    // Test UQDECH_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0470FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdech_r_rs_x_field_rdn_31_max_fc00_0470fc1f() {
    // Encoding: 0x0470FC1F
    // Test UQDECH_R.RS_X field Rdn = 31 (Max)
    // Fields: Rdn=31, imm4=0, pattern=0
    let encoding: u32 = 0x0470FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdech_r_rs_x_combo_0_fc00_0470fc00() {
    // Encoding: 0x0470FC00
    // Test UQDECH_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x0470FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdech_r_rs_x_invalid_0_fc00_0470fc00() {
    // Encoding: 0x0470FC00
    // Test UQDECH_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x0470FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdech_r_rs_x_invalid_1_fc00_0470fc00() {
    // Encoding: 0x0470FC00
    // Test UQDECH_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECH_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdech_r_rs_uw_reg_write_0_0460fc00() {
    // Test UQDECH_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x0460FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQDECH_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdech_r_rs_x_reg_write_0_0470fc00() {
    // Test UQDECH_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x0470FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqdecp_z_p_z_field_size_0_min_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqdecp_z_p_z_field_size_1_poweroftwo_8000_256a8000() {
    // Encoding: 0x256A8000
    // Test SQDECP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqdecp_z_p_z_field_size_2_poweroftwo_8000_25aa8000() {
    // Encoding: 0x25AA8000
    // Test SQDECP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2
    let encoding: u32 = 0x25AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqdecp_z_p_z_field_size_3_max_8000_25ea8000() {
    // Encoding: 0x25EA8000
    // Test SQDECP_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x25EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sqdecp_z_p_z_field_pg_0_min_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sqdecp_z_p_z_field_pg_1_poweroftwo_8000_252a8020() {
    // Encoding: 0x252A8020
    // Test SQDECP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Pg=1
    let encoding: u32 = 0x252A8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecp_z_p_z_field_zdn_0_min_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecp_z_p_z_field_zdn_1_poweroftwo_8000_252a8001() {
    // Encoding: 0x252A8001
    // Test SQDECP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x252A8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecp_z_p_z_field_zdn_15_poweroftwominusone_8000_252a800f() {
    // Encoding: 0x252A800F
    // Test SQDECP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=15
    let encoding: u32 = 0x252A800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecp_z_p_z_field_zdn_31_max_8000_252a801f() {
    // Encoding: 0x252A801F
    // Test SQDECP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x252A801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqdecp_z_p_z_combo_0_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqdecp_z_p_z_special_size_0_size_variant_0_32768_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqdecp_z_p_z_special_size_1_size_variant_1_32768_256a8000() {
    // Encoding: 0x256A8000
    // Test SQDECP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Pg=0, size=1
    let encoding: u32 = 0x256A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqdecp_z_p_z_special_size_2_size_variant_2_32768_25aa8000() {
    // Encoding: 0x25AA8000
    // Test SQDECP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zdn=0
    let encoding: u32 = 0x25AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqdecp_z_p_z_special_size_3_size_variant_3_32768_25ea8000() {
    // Encoding: 0x25EA8000
    // Test SQDECP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Pg=0, size=3
    let encoding: u32 = 0x25EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecp_z_p_z_invalid_0_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecp_z_p_z_invalid_1_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_sqdecp_z_p_z_invalid_2_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecp_z_p_z_invalid_3_8000_252a8000() {
    // Encoding: 0x252A8000
    // Test SQDECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqdecp_z_p_z_reg_write_0_252a8000() {
    // Test SQDECP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x252A8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252A8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECW_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdecw_z_zs_field_imm4_0_zero_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdecw_z_zs_field_imm4_1_poweroftwo_c800_04a1c800() {
    // Encoding: 0x04A1C800
    // Test SQDECW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=1
    let encoding: u32 = 0x04A1C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdecw_z_zs_field_imm4_3_poweroftwominusone_c800_04a3c800() {
    // Encoding: 0x04A3C800
    // Test SQDECW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04A3C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdecw_z_zs_field_imm4_4_poweroftwo_c800_04a4c800() {
    // Encoding: 0x04A4C800
    // Test SQDECW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04A4C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdecw_z_zs_field_imm4_7_poweroftwominusone_c800_04a7c800() {
    // Encoding: 0x04A7C800
    // Test SQDECW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=7
    let encoding: u32 = 0x04A7C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdecw_z_zs_field_imm4_8_poweroftwo_c800_04a8c800() {
    // Encoding: 0x04A8C800
    // Test SQDECW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm4=8, pattern=0
    let encoding: u32 = 0x04A8C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdecw_z_zs_field_imm4_15_max_c800_04afc800() {
    // Encoding: 0x04AFC800
    // Test SQDECW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Zdn=0
    let encoding: u32 = 0x04AFC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_z_zs_field_pattern_0_min_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_z_zs_field_pattern_1_poweroftwo_c800_04a0c820() {
    // Encoding: 0x04A0C820
    // Test SQDECW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, Zdn=0, pattern=1
    let encoding: u32 = 0x04A0C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_z_zs_field_pattern_15_poweroftwominusone_c800_04a0c9e0() {
    // Encoding: 0x04A0C9E0
    // Test SQDECW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_z_zs_field_pattern_31_max_c800_04a0cbe0() {
    // Encoding: 0x04A0CBE0
    // Test SQDECW_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x04A0CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdecw_z_zs_field_zdn_0_min_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdecw_z_zs_field_zdn_1_poweroftwo_c800_04a0c801() {
    // Encoding: 0x04A0C801
    // Test SQDECW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Zdn=1
    let encoding: u32 = 0x04A0C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdecw_z_zs_field_zdn_15_poweroftwominusone_c800_04a0c80f() {
    // Encoding: 0x04A0C80F
    // Test SQDECW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x04A0C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdecw_z_zs_field_zdn_31_max_c800_04a0c81f() {
    // Encoding: 0x04A0C81F
    // Test SQDECW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x04A0C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdecw_z_zs_combo_0_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdecw_z_zs_invalid_0_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdecw_z_zs_invalid_1_c800_04a0c800() {
    // Encoding: 0x04A0C800
    // Test SQDECW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqdecw_z_zs_reg_write_0_04a0c800() {
    // Test SQDECW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04A0C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQDECH_Z.ZS__ Tests
// ============================================================================

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqdech_z_zs_field_imm4_0_zero_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqdech_z_zs_field_imm4_1_poweroftwo_c800_0461c800() {
    // Encoding: 0x0461C800
    // Test SQDECH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x0461C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqdech_z_zs_field_imm4_3_poweroftwominusone_c800_0463c800() {
    // Encoding: 0x0463C800
    // Test SQDECH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Zdn=0, pattern=0
    let encoding: u32 = 0x0463C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqdech_z_zs_field_imm4_4_poweroftwo_c800_0464c800() {
    // Encoding: 0x0464C800
    // Test SQDECH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zdn=0, pattern=0
    let encoding: u32 = 0x0464C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_sqdech_z_zs_field_imm4_7_poweroftwominusone_c800_0467c800() {
    // Encoding: 0x0467C800
    // Test SQDECH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x0467C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqdech_z_zs_field_imm4_8_poweroftwo_c800_0468c800() {
    // Encoding: 0x0468C800
    // Test SQDECH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Zdn=0
    let encoding: u32 = 0x0468C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_sqdech_z_zs_field_imm4_15_max_c800_046fc800() {
    // Encoding: 0x046FC800
    // Test SQDECH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, pattern=0, Zdn=0
    let encoding: u32 = 0x046FC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_z_zs_field_pattern_0_min_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_z_zs_field_pattern_1_poweroftwo_c800_0460c820() {
    // Encoding: 0x0460C820
    // Test SQDECH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x0460C820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_z_zs_field_pattern_15_poweroftwominusone_c800_0460c9e0() {
    // Encoding: 0x0460C9E0
    // Test SQDECH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Zdn=0, imm4=0
    let encoding: u32 = 0x0460C9E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_z_zs_field_pattern_31_max_c800_0460cbe0() {
    // Encoding: 0x0460CBE0
    // Test SQDECH_Z.ZS__ field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Zdn=0
    let encoding: u32 = 0x0460CBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqdech_z_zs_field_zdn_0_min_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqdech_z_zs_field_zdn_1_poweroftwo_c800_0460c801() {
    // Encoding: 0x0460C801
    // Test SQDECH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, imm4=0, pattern=0
    let encoding: u32 = 0x0460C801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqdech_z_zs_field_zdn_15_poweroftwominusone_c800_0460c80f() {
    // Encoding: 0x0460C80F
    // Test SQDECH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, imm4=0, pattern=0
    let encoding: u32 = 0x0460C80F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqdech_z_zs_field_zdn_31_max_c800_0460c81f() {
    // Encoding: 0x0460C81F
    // Test SQDECH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x0460C81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_sqdech_z_zs_combo_0_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqdech_z_zs_invalid_0_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqdech_z_zs_invalid_1_c800_0460c800() {
    // Encoding: 0x0460C800
    // Test SQDECH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0460C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQDECH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqdech_z_zs_reg_write_0_0460c800() {
    // Test SQDECH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0460C800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460C800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECW_R.RS_UW Tests
// ============================================================================

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_0_zero_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_1_poweroftwo_fc00_04a1fc00() {
    // Encoding: 0x04A1FC00
    // Test UQDECW_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04A1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_3_poweroftwominusone_fc00_04a3fc00() {
    // Encoding: 0x04A3FC00
    // Test UQDECW_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04A3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_4_poweroftwo_fc00_04a4fc00() {
    // Encoding: 0x04A4FC00
    // Test UQDECW_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, imm4=4, Rdn=0
    let encoding: u32 = 0x04A4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_7_poweroftwominusone_fc00_04a7fc00() {
    // Encoding: 0x04A7FC00
    // Test UQDECW_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x04A7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_8_poweroftwo_fc00_04a8fc00() {
    // Encoding: 0x04A8FC00
    // Test UQDECW_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Rdn=0
    let encoding: u32 = 0x04A8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecw_r_rs_uw_field_imm4_15_max_fc00_04affc00() {
    // Encoding: 0x04AFFC00
    // Test UQDECW_R.RS_UW field imm4 = 15 (Max)
    // Fields: Rdn=0, imm4=15, pattern=0
    let encoding: u32 = 0x04AFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_0_min_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_1_poweroftwo_fc00_04a0fc20() {
    // Encoding: 0x04A0FC20
    // Test UQDECW_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04A0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_15_poweroftwominusone_fc00_04a0fde0() {
    // Encoding: 0x04A0FDE0
    // Test UQDECW_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x04A0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_uw_field_pattern_31_max_fc00_04a0ffe0() {
    // Encoding: 0x04A0FFE0
    // Test UQDECW_R.RS_UW field pattern = 31 (Max)
    // Fields: Rdn=0, pattern=31, imm4=0
    let encoding: u32 = 0x04A0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_0_min_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field Rdn = 0 (Min)
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_1_poweroftwo_fc00_04a0fc01() {
    // Encoding: 0x04A0FC01
    // Test UQDECW_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: pattern=0, Rdn=1, imm4=0
    let encoding: u32 = 0x04A0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_15_poweroftwominusone_fc00_04a0fc0f() {
    // Encoding: 0x04A0FC0F
    // Test UQDECW_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=15, imm4=0
    let encoding: u32 = 0x04A0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_uw_field_rdn_31_max_fc00_04a0fc1f() {
    // Encoding: 0x04A0FC1F
    // Test UQDECW_R.RS_UW field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x04A0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecw_r_rs_uw_combo_0_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_uw_invalid_0_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_uw_invalid_1_fc00_04a0fc00() {
    // Encoding: 0x04A0FC00
    // Test UQDECW_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04A0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqdecw_r_rs_x_field_imm4_0_zero_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field imm4 = 0 (Zero)
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqdecw_r_rs_x_field_imm4_1_poweroftwo_fc00_04b1fc00() {
    // Encoding: 0x04B1FC00
    // Test UQDECW_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Rdn=0
    let encoding: u32 = 0x04B1FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqdecw_r_rs_x_field_imm4_3_poweroftwominusone_fc00_04b3fc00() {
    // Encoding: 0x04B3FC00
    // Test UQDECW_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04B3FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_4_poweroftwo_fc00_04b4fc00() {
    // Encoding: 0x04B4FC00
    // Test UQDECW_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Rdn=0, imm4=4
    let encoding: u32 = 0x04B4FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_7_poweroftwominusone_fc00_04b7fc00() {
    // Encoding: 0x04B7FC00
    // Test UQDECW_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Rdn=0, pattern=0
    let encoding: u32 = 0x04B7FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_8_poweroftwo_fc00_04b8fc00() {
    // Encoding: 0x04B8FC00
    // Test UQDECW_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Rdn=0
    let encoding: u32 = 0x04B8FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqdecw_r_rs_x_field_imm4_15_max_fc00_04bffc00() {
    // Encoding: 0x04BFFC00
    // Test UQDECW_R.RS_X field imm4 = 15 (Max)
    // Fields: Rdn=0, pattern=0, imm4=15
    let encoding: u32 = 0x04BFFC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_x_field_pattern_0_min_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_x_field_pattern_1_poweroftwo_fc00_04b0fc20() {
    // Encoding: 0x04B0FC20
    // Test UQDECW_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0FC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_x_field_pattern_15_poweroftwominusone_fc00_04b0fde0() {
    // Encoding: 0x04B0FDE0
    // Test UQDECW_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, imm4=0, pattern=15
    let encoding: u32 = 0x04B0FDE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_x_field_pattern_31_max_fc00_04b0ffe0() {
    // Encoding: 0x04B0FFE0
    // Test UQDECW_R.RS_X field pattern = 31 (Max)
    // Fields: imm4=0, pattern=31, Rdn=0
    let encoding: u32 = 0x04B0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecw_r_rs_x_field_rdn_0_min_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field Rdn = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecw_r_rs_x_field_rdn_1_poweroftwo_fc00_04b0fc01() {
    // Encoding: 0x04B0FC01
    // Test UQDECW_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x04B0FC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecw_r_rs_x_field_rdn_15_poweroftwominusone_fc00_04b0fc0f() {
    // Encoding: 0x04B0FC0F
    // Test UQDECW_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04B0FC0F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecw_r_rs_x_field_rdn_31_max_fc00_04b0fc1f() {
    // Encoding: 0x04B0FC1F
    // Test UQDECW_R.RS_X field Rdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Rdn=31
    let encoding: u32 = 0x04B0FC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqdecw_r_rs_x_combo_0_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, Rdn=0, imm4=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_x_invalid_0_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecw_r_rs_x_invalid_1_fc00_04b0fc00() {
    // Encoding: 0x04B0FC00
    // Test UQDECW_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04B0FC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECW_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecw_r_rs_uw_reg_write_0_04a0fc00() {
    // Test UQDECW_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x04A0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQDECW_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqdecw_r_rs_x_reg_write_0_04b0fc00() {
    // Test UQDECW_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04B0FC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0FC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INCD_Z.ZS__ Tests
// ============================================================================

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incd_z_zs_field_imm4_0_zero_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: imm4=0, Zdn=0, pattern=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incd_z_zs_field_imm4_1_poweroftwo_c000_04f1c000() {
    // Encoding: 0x04F1C000
    // Test INCD_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=1, Zdn=0
    let encoding: u32 = 0x04F1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incd_z_zs_field_imm4_3_poweroftwominusone_c000_04f3c000() {
    // Encoding: 0x04F3C000
    // Test INCD_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=0, imm4=3
    let encoding: u32 = 0x04F3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incd_z_zs_field_imm4_4_poweroftwo_c000_04f4c000() {
    // Encoding: 0x04F4C000
    // Test INCD_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zdn=0, pattern=0
    let encoding: u32 = 0x04F4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incd_z_zs_field_imm4_7_poweroftwominusone_c000_04f7c000() {
    // Encoding: 0x04F7C000
    // Test INCD_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=7, pattern=0
    let encoding: u32 = 0x04F7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incd_z_zs_field_imm4_8_poweroftwo_c000_04f8c000() {
    // Encoding: 0x04F8C000
    // Test INCD_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, pattern=0, Zdn=0
    let encoding: u32 = 0x04F8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incd_z_zs_field_imm4_15_max_c000_04ffc000() {
    // Encoding: 0x04FFC000
    // Test INCD_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x04FFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incd_z_zs_field_pattern_0_min_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field pattern = 0 (Min)
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incd_z_zs_field_pattern_1_poweroftwo_c000_04f0c020() {
    // Encoding: 0x04F0C020
    // Test INCD_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Zdn=0
    let encoding: u32 = 0x04F0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incd_z_zs_field_pattern_15_poweroftwominusone_c000_04f0c1e0() {
    // Encoding: 0x04F0C1E0
    // Test INCD_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=15, Zdn=0, imm4=0
    let encoding: u32 = 0x04F0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incd_z_zs_field_pattern_31_max_c000_04f0c3e0() {
    // Encoding: 0x04F0C3E0
    // Test INCD_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, Zdn=0, imm4=0
    let encoding: u32 = 0x04F0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incd_z_zs_field_zdn_0_min_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field Zdn = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incd_z_zs_field_zdn_1_poweroftwo_c000_04f0c001() {
    // Encoding: 0x04F0C001
    // Test INCD_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: pattern=0, imm4=0, Zdn=1
    let encoding: u32 = 0x04F0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incd_z_zs_field_zdn_15_poweroftwominusone_c000_04f0c00f() {
    // Encoding: 0x04F0C00F
    // Test INCD_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Zdn=15, imm4=0
    let encoding: u32 = 0x04F0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incd_z_zs_field_zdn_31_max_c000_04f0c01f() {
    // Encoding: 0x04F0C01F
    // Test INCD_Z.ZS__ field Zdn = 31 (Max)
    // Fields: pattern=0, Zdn=31, imm4=0
    let encoding: u32 = 0x04F0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incd_z_zs_combo_0_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incd_z_zs_invalid_0_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incd_z_zs_invalid_1_c000_04f0c000() {
    // Encoding: 0x04F0C000
    // Test INCD_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04F0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_inch_z_zs_field_imm4_0_zero_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_inch_z_zs_field_imm4_1_poweroftwo_c000_0471c000() {
    // Encoding: 0x0471C000
    // Test INCH_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zdn=0, pattern=0
    let encoding: u32 = 0x0471C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_inch_z_zs_field_imm4_3_poweroftwominusone_c000_0473c000() {
    // Encoding: 0x0473C000
    // Test INCH_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Zdn=0
    let encoding: u32 = 0x0473C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_inch_z_zs_field_imm4_4_poweroftwo_c000_0474c000() {
    // Encoding: 0x0474C000
    // Test INCH_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zdn=0, pattern=0
    let encoding: u32 = 0x0474C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_inch_z_zs_field_imm4_7_poweroftwominusone_c000_0477c000() {
    // Encoding: 0x0477C000
    // Test INCH_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, imm4=7, Zdn=0
    let encoding: u32 = 0x0477C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_inch_z_zs_field_imm4_8_poweroftwo_c000_0478c000() {
    // Encoding: 0x0478C000
    // Test INCH_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=8
    let encoding: u32 = 0x0478C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_inch_z_zs_field_imm4_15_max_c000_047fc000() {
    // Encoding: 0x047FC000
    // Test INCH_Z.ZS__ field imm4 = 15 (Max)
    // Fields: imm4=15, Zdn=0, pattern=0
    let encoding: u32 = 0x047FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_inch_z_zs_field_pattern_0_min_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field pattern = 0 (Min)
    // Fields: pattern=0, Zdn=0, imm4=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_inch_z_zs_field_pattern_1_poweroftwo_c000_0470c020() {
    // Encoding: 0x0470C020
    // Test INCH_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Zdn=0, imm4=0
    let encoding: u32 = 0x0470C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_inch_z_zs_field_pattern_15_poweroftwominusone_c000_0470c1e0() {
    // Encoding: 0x0470C1E0
    // Test INCH_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zdn=0, pattern=15
    let encoding: u32 = 0x0470C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_inch_z_zs_field_pattern_31_max_c000_0470c3e0() {
    // Encoding: 0x0470C3E0
    // Test INCH_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, imm4=0, Zdn=0
    let encoding: u32 = 0x0470C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_inch_z_zs_field_zdn_0_min_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_inch_z_zs_field_zdn_1_poweroftwo_c000_0470c001() {
    // Encoding: 0x0470C001
    // Test INCH_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x0470C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_inch_z_zs_field_zdn_15_poweroftwominusone_c000_0470c00f() {
    // Encoding: 0x0470C00F
    // Test INCH_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Zdn=15
    let encoding: u32 = 0x0470C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_inch_z_zs_field_zdn_31_max_c000_0470c01f() {
    // Encoding: 0x0470C01F
    // Test INCH_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x0470C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_inch_z_zs_combo_0_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_inch_z_zs_invalid_0_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCH_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_inch_z_zs_invalid_1_c000_0470c000() {
    // Encoding: 0x0470C000
    // Test INCH_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x0470C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_incw_z_zs_field_imm4_0_zero_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field imm4 = 0 (Zero)
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_incw_z_zs_field_imm4_1_poweroftwo_c000_04b1c000() {
    // Encoding: 0x04B1C000
    // Test INCW_Z.ZS__ field imm4 = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=1, pattern=0
    let encoding: u32 = 0x04B1C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_incw_z_zs_field_imm4_3_poweroftwominusone_c000_04b3c000() {
    // Encoding: 0x04B3C000
    // Test INCW_Z.ZS__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm4=3, pattern=0
    let encoding: u32 = 0x04B3C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_incw_z_zs_field_imm4_4_poweroftwo_c000_04b4c000() {
    // Encoding: 0x04B4C000
    // Test INCW_Z.ZS__ field imm4 = 4 (PowerOfTwo)
    // Fields: pattern=0, Zdn=0, imm4=4
    let encoding: u32 = 0x04B4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_incw_z_zs_field_imm4_7_poweroftwominusone_c000_04b7c000() {
    // Encoding: 0x04B7C000
    // Test INCW_Z.ZS__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, pattern=0, Zdn=0
    let encoding: u32 = 0x04B7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_incw_z_zs_field_imm4_8_poweroftwo_c000_04b8c000() {
    // Encoding: 0x04B8C000
    // Test INCW_Z.ZS__ field imm4 = 8 (PowerOfTwo)
    // Fields: pattern=0, imm4=8, Zdn=0
    let encoding: u32 = 0x04B8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_incw_z_zs_field_imm4_15_max_c000_04bfc000() {
    // Encoding: 0x04BFC000
    // Test INCW_Z.ZS__ field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Zdn=0
    let encoding: u32 = 0x04BFC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incw_z_zs_field_pattern_0_min_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field pattern = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incw_z_zs_field_pattern_1_poweroftwo_c000_04b0c020() {
    // Encoding: 0x04B0C020
    // Test INCW_Z.ZS__ field pattern = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm4=0, pattern=1
    let encoding: u32 = 0x04B0C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incw_z_zs_field_pattern_15_poweroftwominusone_c000_04b0c1e0() {
    // Encoding: 0x04B0C1E0
    // Test INCW_Z.ZS__ field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Zdn=0
    let encoding: u32 = 0x04B0C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incw_z_zs_field_pattern_31_max_c000_04b0c3e0() {
    // Encoding: 0x04B0C3E0
    // Test INCW_Z.ZS__ field pattern = 31 (Max)
    // Fields: pattern=31, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_incw_z_zs_field_zdn_0_min_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_incw_z_zs_field_zdn_1_poweroftwo_c000_04b0c001() {
    // Encoding: 0x04B0C001
    // Test INCW_Z.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Zdn=1
    let encoding: u32 = 0x04B0C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_incw_z_zs_field_zdn_15_poweroftwominusone_c000_04b0c00f() {
    // Encoding: 0x04B0C00F
    // Test INCW_Z.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, pattern=0, imm4=0
    let encoding: u32 = 0x04B0C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_incw_z_zs_field_zdn_31_max_c000_04b0c01f() {
    // Encoding: 0x04B0C01F
    // Test INCW_Z.ZS__ field Zdn = 31 (Max)
    // Fields: imm4=0, pattern=0, Zdn=31
    let encoding: u32 = 0x04B0C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_incw_z_zs_combo_0_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ field combination: imm4=0, pattern=0, Zdn=0
    // Fields: pattern=0, imm4=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_incw_z_zs_invalid_0_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, pattern=0, Zdn=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCW_Z.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_incw_z_zs_invalid_1_c000_04b0c000() {
    // Encoding: 0x04B0C000
    // Test INCW_Z.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04B0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INCD_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_incd_z_zs_reg_write_0_04f0c000() {
    // Test INCD_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04F0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCH_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_inch_z_zs_reg_write_0_0470c000() {
    // Test INCH_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x0470C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0470C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INCW_Z.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_incw_z_zs_reg_write_0_04b0c000() {
    // Test INCW_Z.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x04B0C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04B0C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DECP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_decp_z_p_z_field_size_0_min_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_decp_z_p_z_field_size_1_poweroftwo_8000_256d8000() {
    // Encoding: 0x256D8000
    // Test DECP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_decp_z_p_z_field_size_2_poweroftwo_8000_25ad8000() {
    // Encoding: 0x25AD8000
    // Test DECP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2
    let encoding: u32 = 0x25AD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_decp_z_p_z_field_size_3_max_8000_25ed8000() {
    // Encoding: 0x25ED8000
    // Test DECP_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x25ED8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_decp_z_p_z_field_pg_0_min_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_decp_z_p_z_field_pg_1_poweroftwo_8000_252d8020() {
    // Encoding: 0x252D8020
    // Test DECP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zdn=0, size=0
    let encoding: u32 = 0x252D8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_decp_z_p_z_field_zdn_0_min_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_decp_z_p_z_field_zdn_1_poweroftwo_8000_252d8001() {
    // Encoding: 0x252D8001
    // Test DECP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, Pg=0
    let encoding: u32 = 0x252D8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_decp_z_p_z_field_zdn_15_poweroftwominusone_8000_252d800f() {
    // Encoding: 0x252D800F
    // Test DECP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=15, size=0
    let encoding: u32 = 0x252D800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_decp_z_p_z_field_zdn_31_max_8000_252d801f() {
    // Encoding: 0x252D801F
    // Test DECP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Pg=0
    let encoding: u32 = 0x252D801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_decp_z_p_z_combo_0_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_decp_z_p_z_special_size_0_size_variant_0_32768_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_decp_z_p_z_special_size_1_size_variant_1_32768_256d8000() {
    // Encoding: 0x256D8000
    // Test DECP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x256D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_decp_z_p_z_special_size_2_size_variant_2_32768_25ad8000() {
    // Encoding: 0x25AD8000
    // Test DECP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x25AD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_decp_z_p_z_special_size_3_size_variant_3_32768_25ed8000() {
    // Encoding: 0x25ED8000
    // Test DECP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x25ED8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_0_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_1_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_2_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_decp_z_p_z_invalid_3_8000_252d8000() {
    // Encoding: 0x252D8000
    // Test DECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x252D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DECP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_decp_z_p_z_reg_write_0_252d8000() {
    // Test DECP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x252D8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252D8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQINCD_R.RS_UW Tests
// ============================================================================

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincd_r_rs_uw_field_imm4_0_zero_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field imm4 = 0 (Zero)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincd_r_rs_uw_field_imm4_1_poweroftwo_f400_04e1f400() {
    // Encoding: 0x04E1F400
    // Test UQINCD_R.RS_UW field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, pattern=0, Rdn=0
    let encoding: u32 = 0x04E1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincd_r_rs_uw_field_imm4_3_poweroftwominusone_f400_04e3f400() {
    // Encoding: 0x04E3F400
    // Test UQINCD_R.RS_UW field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, pattern=0, Rdn=0
    let encoding: u32 = 0x04E3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_4_poweroftwo_f400_04e4f400() {
    // Encoding: 0x04E4F400
    // Test UQINCD_R.RS_UW field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=4
    let encoding: u32 = 0x04E4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_7_poweroftwominusone_f400_04e7f400() {
    // Encoding: 0x04E7F400
    // Test UQINCD_R.RS_UW field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=0, imm4=7
    let encoding: u32 = 0x04E7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_8_poweroftwo_f400_04e8f400() {
    // Encoding: 0x04E8F400
    // Test UQINCD_R.RS_UW field imm4 = 8 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=8
    let encoding: u32 = 0x04E8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincd_r_rs_uw_field_imm4_15_max_f400_04eff400() {
    // Encoding: 0x04EFF400
    // Test UQINCD_R.RS_UW field imm4 = 15 (Max)
    // Fields: imm4=15, Rdn=0, pattern=0
    let encoding: u32 = 0x04EFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_uw_field_pattern_0_min_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field pattern = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_uw_field_pattern_1_poweroftwo_f400_04e0f420() {
    // Encoding: 0x04E0F420
    // Test UQINCD_R.RS_UW field pattern = 1 (PowerOfTwo)
    // Fields: pattern=1, Rdn=0, imm4=0
    let encoding: u32 = 0x04E0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_uw_field_pattern_15_poweroftwominusone_f400_04e0f5e0() {
    // Encoding: 0x04E0F5E0
    // Test UQINCD_R.RS_UW field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=0, pattern=15, imm4=0
    let encoding: u32 = 0x04E0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_uw_field_pattern_31_max_f400_04e0f7e0() {
    // Encoding: 0x04E0F7E0
    // Test UQINCD_R.RS_UW field pattern = 31 (Max)
    // Fields: imm4=0, Rdn=0, pattern=31
    let encoding: u32 = 0x04E0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_uw_field_rdn_0_min_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field Rdn = 0 (Min)
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_uw_field_rdn_1_poweroftwo_f400_04e0f401() {
    // Encoding: 0x04E0F401
    // Test UQINCD_R.RS_UW field Rdn = 1 (PowerOfTwo)
    // Fields: Rdn=1, pattern=0, imm4=0
    let encoding: u32 = 0x04E0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_uw_field_rdn_15_poweroftwominusone_f400_04e0f40f() {
    // Encoding: 0x04E0F40F
    // Test UQINCD_R.RS_UW field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04E0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_uw_field_rdn_31_max_f400_04e0f41f() {
    // Encoding: 0x04E0F41F
    // Test UQINCD_R.RS_UW field Rdn = 31 (Max)
    // Fields: pattern=0, imm4=0, Rdn=31
    let encoding: u32 = 0x04E0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincd_r_rs_uw_combo_0_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW field combination: imm4=0, pattern=0, Rdn=0
    // Fields: imm4=0, pattern=0, Rdn=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_uw_invalid_0_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, imm4=0, pattern=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_uw_invalid_1_f400_04e0f400() {
    // Encoding: 0x04E0F400
    // Test UQINCD_R.RS_UW invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04E0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqincd_r_rs_x_field_imm4_0_zero_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field imm4 = 0 (Zero)
    // Fields: imm4=0, Rdn=0, pattern=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqincd_r_rs_x_field_imm4_1_poweroftwo_f400_04f1f400() {
    // Encoding: 0x04F1F400
    // Test UQINCD_R.RS_X field imm4 = 1 (PowerOfTwo)
    // Fields: Rdn=0, pattern=0, imm4=1
    let encoding: u32 = 0x04F1F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqincd_r_rs_x_field_imm4_3_poweroftwominusone_f400_04f3f400() {
    // Encoding: 0x04F3F400
    // Test UQINCD_R.RS_X field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=3
    let encoding: u32 = 0x04F3F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqincd_r_rs_x_field_imm4_4_poweroftwo_f400_04f4f400() {
    // Encoding: 0x04F4F400
    // Test UQINCD_R.RS_X field imm4 = 4 (PowerOfTwo)
    // Fields: Rdn=0, imm4=4, pattern=0
    let encoding: u32 = 0x04F4F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_uqincd_r_rs_x_field_imm4_7_poweroftwominusone_f400_04f7f400() {
    // Encoding: 0x04F7F400
    // Test UQINCD_R.RS_X field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: pattern=0, Rdn=0, imm4=7
    let encoding: u32 = 0x04F7F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqincd_r_rs_x_field_imm4_8_poweroftwo_f400_04f8f400() {
    // Encoding: 0x04F8F400
    // Test UQINCD_R.RS_X field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rdn=0, pattern=0
    let encoding: u32 = 0x04F8F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_uqincd_r_rs_x_field_imm4_15_max_f400_04fff400() {
    // Encoding: 0x04FFF400
    // Test UQINCD_R.RS_X field imm4 = 15 (Max)
    // Fields: pattern=0, imm4=15, Rdn=0
    let encoding: u32 = 0x04FFF400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_x_field_pattern_0_min_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field pattern = 0 (Min)
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_x_field_pattern_1_poweroftwo_f400_04f0f420() {
    // Encoding: 0x04F0F420
    // Test UQINCD_R.RS_X field pattern = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=1, Rdn=0
    let encoding: u32 = 0x04F0F420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_x_field_pattern_15_poweroftwominusone_f400_04f0f5e0() {
    // Encoding: 0x04F0F5E0
    // Test UQINCD_R.RS_X field pattern = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=15, Rdn=0
    let encoding: u32 = 0x04F0F5E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field pattern 5 +: 5`
/// Requirement: FieldBoundary { field: "pattern", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_x_field_pattern_31_max_f400_04f0f7e0() {
    // Encoding: 0x04F0F7E0
    // Test UQINCD_R.RS_X field pattern = 31 (Max)
    // Fields: Rdn=0, imm4=0, pattern=31
    let encoding: u32 = 0x04F0F7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqincd_r_rs_x_field_rdn_0_min_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field Rdn = 0 (Min)
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqincd_r_rs_x_field_rdn_1_poweroftwo_f400_04f0f401() {
    // Encoding: 0x04F0F401
    // Test UQINCD_R.RS_X field Rdn = 1 (PowerOfTwo)
    // Fields: imm4=0, pattern=0, Rdn=1
    let encoding: u32 = 0x04F0F401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqincd_r_rs_x_field_rdn_15_poweroftwominusone_f400_04f0f40f() {
    // Encoding: 0x04F0F40F
    // Test UQINCD_R.RS_X field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm4=0, pattern=0, Rdn=15
    let encoding: u32 = 0x04F0F40F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqincd_r_rs_x_field_rdn_31_max_f400_04f0f41f() {
    // Encoding: 0x04F0F41F
    // Test UQINCD_R.RS_X field Rdn = 31 (Max)
    // Fields: Rdn=31, pattern=0, imm4=0
    let encoding: u32 = 0x04F0F41F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_uqincd_r_rs_x_combo_0_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X field combination: imm4=0, pattern=0, Rdn=0
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_x_invalid_0_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rdn=0, pattern=0, imm4=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqincd_r_rs_x_invalid_1_f400_04f0f400() {
    // Encoding: 0x04F0F400
    // Test UQINCD_R.RS_X invalid encoding: Unconditional UNDEFINED
    // Fields: pattern=0, imm4=0, Rdn=0
    let encoding: u32 = 0x04F0F400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQINCD_R.RS_UW
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincd_r_rs_uw_reg_write_0_04e0f400() {
    // Test UQINCD_R.RS_UW register write: GpFromField("dn")
    // Encoding: 0x04E0F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04E0F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UQINCD_R.RS_X
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_uqincd_r_rs_x_reg_write_0_04f0f400() {
    // Test UQINCD_R.RS_X register write: GpFromField("dn")
    // Encoding: 0x04F0F400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04F0F400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQDECP_Z.P.Z__ Tests
// ============================================================================

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqdecp_z_p_z_field_size_0_min_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqdecp_z_p_z_field_size_1_poweroftwo_8000_256b8000() {
    // Encoding: 0x256B8000
    // Test UQDECP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqdecp_z_p_z_field_size_2_poweroftwo_8000_25ab8000() {
    // Encoding: 0x25AB8000
    // Test UQDECP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x25AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqdecp_z_p_z_field_size_3_max_8000_25eb8000() {
    // Encoding: 0x25EB8000
    // Test UQDECP_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x25EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uqdecp_z_p_z_field_pg_0_min_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Pg 5 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uqdecp_z_p_z_field_pg_1_poweroftwo_8000_252b8020() {
    // Encoding: 0x252B8020
    // Test UQDECP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zdn=0
    let encoding: u32 = 0x252B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqdecp_z_p_z_field_zdn_0_min_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field Zdn = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqdecp_z_p_z_field_zdn_1_poweroftwo_8000_252b8001() {
    // Encoding: 0x252B8001
    // Test UQDECP_Z.P.Z__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=1, size=0
    let encoding: u32 = 0x252B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqdecp_z_p_z_field_zdn_15_poweroftwominusone_8000_252b800f() {
    // Encoding: 0x252B800F
    // Test UQDECP_Z.P.Z__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=15
    let encoding: u32 = 0x252B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqdecp_z_p_z_field_zdn_31_max_8000_252b801f() {
    // Encoding: 0x252B801F
    // Test UQDECP_Z.P.Z__ field Zdn = 31 (Max)
    // Fields: Pg=0, size=0, Zdn=31
    let encoding: u32 = 0x252B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqdecp_z_p_z_combo_0_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ field combination: size=0, Pg=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqdecp_z_p_z_special_size_0_size_variant_0_32768_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqdecp_z_p_z_special_size_1_size_variant_1_32768_256b8000() {
    // Encoding: 0x256B8000
    // Test UQDECP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x256B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqdecp_z_p_z_special_size_2_size_variant_2_32768_25ab8000() {
    // Encoding: 0x25AB8000
    // Test UQDECP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, Pg=0, size=2
    let encoding: u32 = 0x25AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqdecp_z_p_z_special_size_3_size_variant_3_32768_25eb8000() {
    // Encoding: 0x25EB8000
    // Test UQDECP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zdn=0, Pg=0
    let encoding: u32 = 0x25EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_0_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_1_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_2_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqdecp_z_p_z_invalid_3_8000_252b8000() {
    // Encoding: 0x252B8000
    // Test UQDECP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x252B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQDECP_Z.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqdecp_z_p_z_reg_write_0_252b8000() {
    // Test UQDECP_Z.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x252B8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252B8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}
