//! A64 sve float tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// FMIN_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmin_z_p_zs_field_size_0_min_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ field size = 0 (Min)
    // Fields: Pg=0, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmin_z_p_zs_field_size_1_poweroftwo_8000_655f8000() {
    // Encoding: 0x655F8000
    // Test FMIN_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x655F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmin_z_p_zs_field_size_2_poweroftwo_8000_659f8000() {
    // Encoding: 0x659F8000
    // Test FMIN_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, i1=0, Pg=0, size=2
    let encoding: u32 = 0x659F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmin_z_p_zs_field_size_3_max_8000_65df8000() {
    // Encoding: 0x65DF8000
    // Test FMIN_Z.P.ZS__ field size = 3 (Max)
    // Fields: size=3, Zdn=0, i1=0, Pg=0
    let encoding: u32 = 0x65DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmin_z_p_zs_field_pg_0_min_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmin_z_p_zs_field_pg_1_poweroftwo_8000_651f8400() {
    // Encoding: 0x651F8400
    // Test FMIN_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Pg=1, i1=0
    let encoding: u32 = 0x651F8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmin_z_p_zs_field_i1_0_min_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: size=0, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmin_z_p_zs_field_i1_1_max_8000_651f8020() {
    // Encoding: 0x651F8020
    // Test FMIN_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: i1=1, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x651F8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmin_z_p_zs_field_zdn_0_min_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, i1=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmin_z_p_zs_field_zdn_1_poweroftwo_8000_651f8001() {
    // Encoding: 0x651F8001
    // Test FMIN_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, Pg=0, i1=0
    let encoding: u32 = 0x651F8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmin_z_p_zs_field_zdn_15_poweroftwominusone_8000_651f800f() {
    // Encoding: 0x651F800F
    // Test FMIN_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: i1=0, Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x651F800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmin_z_p_zs_field_zdn_31_max_8000_651f801f() {
    // Encoding: 0x651F801F
    // Test FMIN_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, i1=0, Pg=0
    let encoding: u32 = 0x651F801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmin_z_p_zs_combo_0_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: i1=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmin_z_p_zs_special_size_0_size_variant_0_32768_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: i1=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmin_z_p_zs_special_size_1_size_variant_1_32768_655f8000() {
    // Encoding: 0x655F8000
    // Test FMIN_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x655F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmin_z_p_zs_special_size_2_size_variant_2_32768_659f8000() {
    // Encoding: 0x659F8000
    // Test FMIN_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, Pg=0, size=2, i1=0
    let encoding: u32 = 0x659F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmin_z_p_zs_special_size_3_size_variant_3_32768_65df8000() {
    // Encoding: 0x65DF8000
    // Test FMIN_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x65DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zs_invalid_0_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i1=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zs_invalid_1_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zs_invalid_2_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, i1=0, size=0, Pg=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zs_invalid_3_8000_651f8000() {
    // Encoding: 0x651F8000
    // Test FMIN_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x651F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmin_z_p_zs_reg_write_0_651f8000() {
    // Test FMIN_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651F8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651F8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FCVTZS_Z.P.Z_FP162H Tests
// ============================================================================

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_pg_0_min_a000_655aa000() {
    // Encoding: 0x655AA000
    // Test FCVTZS_Z.P.Z_FP162H field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_pg_1_poweroftwo_a000_655aa400() {
    // Encoding: 0x655AA400
    // Test FCVTZS_Z.P.Z_FP162H field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0
    let encoding: u32 = 0x655AA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zn_0_min_a000_655aa000() {
    // Encoding: 0x655AA000
    // Test FCVTZS_Z.P.Z_FP162H field Zn = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x655AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zn_1_poweroftwo_a000_655aa020() {
    // Encoding: 0x655AA020
    // Test FCVTZS_Z.P.Z_FP162H field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x655AA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zn_30_poweroftwominusone_a000_655aa3c0() {
    // Encoding: 0x655AA3C0
    // Test FCVTZS_Z.P.Z_FP162H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, Zd=0
    let encoding: u32 = 0x655AA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zn_31_max_a000_655aa3e0() {
    // Encoding: 0x655AA3E0
    // Test FCVTZS_Z.P.Z_FP162H field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x655AA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zd_0_min_a000_655aa000() {
    // Encoding: 0x655AA000
    // Test FCVTZS_Z.P.Z_FP162H field Zd = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zd_1_poweroftwo_a000_655aa001() {
    // Encoding: 0x655AA001
    // Test FCVTZS_Z.P.Z_FP162H field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x655AA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zd_30_poweroftwominusone_a000_655aa01e() {
    // Encoding: 0x655AA01E
    // Test FCVTZS_Z.P.Z_FP162H field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zd=30
    let encoding: u32 = 0x655AA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_fp162h_field_zd_31_max_a000_655aa01f() {
    // Encoding: 0x655AA01F
    // Test FCVTZS_Z.P.Z_FP162H field Zd = 31 (Max)
    // Fields: Zn=0, Pg=0, Zd=31
    let encoding: u32 = 0x655AA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_fp162h_combo_0_a000_655aa000() {
    // Encoding: 0x655AA000
    // Test FCVTZS_Z.P.Z_FP162H field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_fp162h_invalid_0_a000_655aa000() {
    // Encoding: 0x655AA000
    // Test FCVTZS_Z.P.Z_FP162H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_fp162h_invalid_1_a000_655aa000() {
    // Encoding: 0x655AA000
    // Test FCVTZS_Z.P.Z_FP162H invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655AA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_pg_0_min_a000_655ca000() {
    // Encoding: 0x655CA000
    // Test FCVTZS_Z.P.Z_FP162W field Pg = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x655CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_pg_1_poweroftwo_a000_655ca400() {
    // Encoding: 0x655CA400
    // Test FCVTZS_Z.P.Z_FP162W field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zd=0, Zn=0
    let encoding: u32 = 0x655CA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zn_0_min_a000_655ca000() {
    // Encoding: 0x655CA000
    // Test FCVTZS_Z.P.Z_FP162W field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x655CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zn_1_poweroftwo_a000_655ca020() {
    // Encoding: 0x655CA020
    // Test FCVTZS_Z.P.Z_FP162W field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Pg=0, Zd=0
    let encoding: u32 = 0x655CA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zn_30_poweroftwominusone_a000_655ca3c0() {
    // Encoding: 0x655CA3C0
    // Test FCVTZS_Z.P.Z_FP162W field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=0, Zn=30
    let encoding: u32 = 0x655CA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zn_31_max_a000_655ca3e0() {
    // Encoding: 0x655CA3E0
    // Test FCVTZS_Z.P.Z_FP162W field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, Zd=0
    let encoding: u32 = 0x655CA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zd_0_min_a000_655ca000() {
    // Encoding: 0x655CA000
    // Test FCVTZS_Z.P.Z_FP162W field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x655CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zd_1_poweroftwo_a000_655ca001() {
    // Encoding: 0x655CA001
    // Test FCVTZS_Z.P.Z_FP162W field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x655CA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zd_30_poweroftwominusone_a000_655ca01e() {
    // Encoding: 0x655CA01E
    // Test FCVTZS_Z.P.Z_FP162W field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zn=0, Pg=0
    let encoding: u32 = 0x655CA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_fp162w_field_zd_31_max_a000_655ca01f() {
    // Encoding: 0x655CA01F
    // Test FCVTZS_Z.P.Z_FP162W field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, Zn=0
    let encoding: u32 = 0x655CA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_fp162w_combo_0_a000_655ca000() {
    // Encoding: 0x655CA000
    // Test FCVTZS_Z.P.Z_FP162W field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x655CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_fp162w_invalid_0_a000_655ca000() {
    // Encoding: 0x655CA000
    // Test FCVTZS_Z.P.Z_FP162W invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x655CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_fp162w_invalid_1_a000_655ca000() {
    // Encoding: 0x655CA000
    // Test FCVTZS_Z.P.Z_FP162W invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_pg_0_min_a000_655ea000() {
    // Encoding: 0x655EA000
    // Test FCVTZS_Z.P.Z_FP162X field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_pg_1_poweroftwo_a000_655ea400() {
    // Encoding: 0x655EA400
    // Test FCVTZS_Z.P.Z_FP162X field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x655EA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zn_0_min_a000_655ea000() {
    // Encoding: 0x655EA000
    // Test FCVTZS_Z.P.Z_FP162X field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zn_1_poweroftwo_a000_655ea020() {
    // Encoding: 0x655EA020
    // Test FCVTZS_Z.P.Z_FP162X field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x655EA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zn_30_poweroftwominusone_a000_655ea3c0() {
    // Encoding: 0x655EA3C0
    // Test FCVTZS_Z.P.Z_FP162X field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x655EA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zn_31_max_a000_655ea3e0() {
    // Encoding: 0x655EA3E0
    // Test FCVTZS_Z.P.Z_FP162X field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, Zd=0
    let encoding: u32 = 0x655EA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zd_0_min_a000_655ea000() {
    // Encoding: 0x655EA000
    // Test FCVTZS_Z.P.Z_FP162X field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x655EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zd_1_poweroftwo_a000_655ea001() {
    // Encoding: 0x655EA001
    // Test FCVTZS_Z.P.Z_FP162X field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x655EA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zd_30_poweroftwominusone_a000_655ea01e() {
    // Encoding: 0x655EA01E
    // Test FCVTZS_Z.P.Z_FP162X field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x655EA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_fp162x_field_zd_31_max_a000_655ea01f() {
    // Encoding: 0x655EA01F
    // Test FCVTZS_Z.P.Z_FP162X field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Pg=0
    let encoding: u32 = 0x655EA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_fp162x_combo_0_a000_655ea000() {
    // Encoding: 0x655EA000
    // Test FCVTZS_Z.P.Z_FP162X field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_fp162x_invalid_0_a000_655ea000() {
    // Encoding: 0x655EA000
    // Test FCVTZS_Z.P.Z_FP162X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_fp162x_invalid_1_a000_655ea000() {
    // Encoding: 0x655EA000
    // Test FCVTZS_Z.P.Z_FP162X invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_s2w_field_pg_0_min_a000_659ca000() {
    // Encoding: 0x659CA000
    // Test FCVTZS_Z.P.Z_S2W field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x659CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_s2w_field_pg_1_poweroftwo_a000_659ca400() {
    // Encoding: 0x659CA400
    // Test FCVTZS_Z.P.Z_S2W field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0
    let encoding: u32 = 0x659CA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zn_0_min_a000_659ca000() {
    // Encoding: 0x659CA000
    // Test FCVTZS_Z.P.Z_S2W field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x659CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zn_1_poweroftwo_a000_659ca020() {
    // Encoding: 0x659CA020
    // Test FCVTZS_Z.P.Z_S2W field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, Pg=0
    let encoding: u32 = 0x659CA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zn_30_poweroftwominusone_a000_659ca3c0() {
    // Encoding: 0x659CA3C0
    // Test FCVTZS_Z.P.Z_S2W field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x659CA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zn_31_max_a000_659ca3e0() {
    // Encoding: 0x659CA3E0
    // Test FCVTZS_Z.P.Z_S2W field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x659CA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zd_0_min_a000_659ca000() {
    // Encoding: 0x659CA000
    // Test FCVTZS_Z.P.Z_S2W field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x659CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zd_1_poweroftwo_a000_659ca001() {
    // Encoding: 0x659CA001
    // Test FCVTZS_Z.P.Z_S2W field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0
    let encoding: u32 = 0x659CA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zd_30_poweroftwominusone_a000_659ca01e() {
    // Encoding: 0x659CA01E
    // Test FCVTZS_Z.P.Z_S2W field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Pg=0
    let encoding: u32 = 0x659CA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_s2w_field_zd_31_max_a000_659ca01f() {
    // Encoding: 0x659CA01F
    // Test FCVTZS_Z.P.Z_S2W field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Pg=0
    let encoding: u32 = 0x659CA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_s2w_combo_0_a000_659ca000() {
    // Encoding: 0x659CA000
    // Test FCVTZS_Z.P.Z_S2W field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x659CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_s2w_invalid_0_a000_659ca000() {
    // Encoding: 0x659CA000
    // Test FCVTZS_Z.P.Z_S2W invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x659CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_s2w_invalid_1_a000_659ca000() {
    // Encoding: 0x659CA000
    // Test FCVTZS_Z.P.Z_S2W invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x659CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_s2x_field_pg_0_min_a000_65dca000() {
    // Encoding: 0x65DCA000
    // Test FCVTZS_Z.P.Z_S2X field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_s2x_field_pg_1_poweroftwo_a000_65dca400() {
    // Encoding: 0x65DCA400
    // Test FCVTZS_Z.P.Z_S2X field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x65DCA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zn_0_min_a000_65dca000() {
    // Encoding: 0x65DCA000
    // Test FCVTZS_Z.P.Z_S2X field Zn = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zn_1_poweroftwo_a000_65dca020() {
    // Encoding: 0x65DCA020
    // Test FCVTZS_Z.P.Z_S2X field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, Pg=0
    let encoding: u32 = 0x65DCA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zn_30_poweroftwominusone_a000_65dca3c0() {
    // Encoding: 0x65DCA3C0
    // Test FCVTZS_Z.P.Z_S2X field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x65DCA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zn_31_max_a000_65dca3e0() {
    // Encoding: 0x65DCA3E0
    // Test FCVTZS_Z.P.Z_S2X field Zn = 31 (Max)
    // Fields: Pg=0, Zd=0, Zn=31
    let encoding: u32 = 0x65DCA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zd_0_min_a000_65dca000() {
    // Encoding: 0x65DCA000
    // Test FCVTZS_Z.P.Z_S2X field Zd = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zd_1_poweroftwo_a000_65dca001() {
    // Encoding: 0x65DCA001
    // Test FCVTZS_Z.P.Z_S2X field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1, Pg=0
    let encoding: u32 = 0x65DCA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zd_30_poweroftwominusone_a000_65dca01e() {
    // Encoding: 0x65DCA01E
    // Test FCVTZS_Z.P.Z_S2X field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x65DCA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_s2x_field_zd_31_max_a000_65dca01f() {
    // Encoding: 0x65DCA01F
    // Test FCVTZS_Z.P.Z_S2X field Zd = 31 (Max)
    // Fields: Zn=0, Pg=0, Zd=31
    let encoding: u32 = 0x65DCA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_s2x_combo_0_a000_65dca000() {
    // Encoding: 0x65DCA000
    // Test FCVTZS_Z.P.Z_S2X field combination: Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_s2x_invalid_0_a000_65dca000() {
    // Encoding: 0x65DCA000
    // Test FCVTZS_Z.P.Z_S2X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_s2x_invalid_1_a000_65dca000() {
    // Encoding: 0x65DCA000
    // Test FCVTZS_Z.P.Z_S2X invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_d2w_field_pg_0_min_a000_65d8a000() {
    // Encoding: 0x65D8A000
    // Test FCVTZS_Z.P.Z_D2W field Pg = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_d2w_field_pg_1_poweroftwo_a000_65d8a400() {
    // Encoding: 0x65D8A400
    // Test FCVTZS_Z.P.Z_D2W field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x65D8A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zn_0_min_a000_65d8a000() {
    // Encoding: 0x65D8A000
    // Test FCVTZS_Z.P.Z_D2W field Zn = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zn_1_poweroftwo_a000_65d8a020() {
    // Encoding: 0x65D8A020
    // Test FCVTZS_Z.P.Z_D2W field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zd=0
    let encoding: u32 = 0x65D8A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zn_30_poweroftwominusone_a000_65d8a3c0() {
    // Encoding: 0x65D8A3C0
    // Test FCVTZS_Z.P.Z_D2W field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, Pg=0
    let encoding: u32 = 0x65D8A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zn_31_max_a000_65d8a3e0() {
    // Encoding: 0x65D8A3E0
    // Test FCVTZS_Z.P.Z_D2W field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, Zd=0
    let encoding: u32 = 0x65D8A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zd_0_min_a000_65d8a000() {
    // Encoding: 0x65D8A000
    // Test FCVTZS_Z.P.Z_D2W field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zd_1_poweroftwo_a000_65d8a001() {
    // Encoding: 0x65D8A001
    // Test FCVTZS_Z.P.Z_D2W field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1, Pg=0
    let encoding: u32 = 0x65D8A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zd_30_poweroftwominusone_a000_65d8a01e() {
    // Encoding: 0x65D8A01E
    // Test FCVTZS_Z.P.Z_D2W field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zn=0, Pg=0
    let encoding: u32 = 0x65D8A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_d2w_field_zd_31_max_a000_65d8a01f() {
    // Encoding: 0x65D8A01F
    // Test FCVTZS_Z.P.Z_D2W field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, Pg=0
    let encoding: u32 = 0x65D8A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_d2w_combo_0_a000_65d8a000() {
    // Encoding: 0x65D8A000
    // Test FCVTZS_Z.P.Z_D2W field combination: Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_d2w_invalid_0_a000_65d8a000() {
    // Encoding: 0x65D8A000
    // Test FCVTZS_Z.P.Z_D2W invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_d2w_invalid_1_a000_65d8a000() {
    // Encoding: 0x65D8A000
    // Test FCVTZS_Z.P.Z_D2W invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzs_z_p_z_d2x_field_pg_0_min_a000_65dea000() {
    // Encoding: 0x65DEA000
    // Test FCVTZS_Z.P.Z_D2X field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzs_z_p_z_d2x_field_pg_1_poweroftwo_a000_65dea400() {
    // Encoding: 0x65DEA400
    // Test FCVTZS_Z.P.Z_D2X field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x65DEA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zn_0_min_a000_65dea000() {
    // Encoding: 0x65DEA000
    // Test FCVTZS_Z.P.Z_D2X field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zn_1_poweroftwo_a000_65dea020() {
    // Encoding: 0x65DEA020
    // Test FCVTZS_Z.P.Z_D2X field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x65DEA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zn_30_poweroftwominusone_a000_65dea3c0() {
    // Encoding: 0x65DEA3C0
    // Test FCVTZS_Z.P.Z_D2X field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x65DEA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zn_31_max_a000_65dea3e0() {
    // Encoding: 0x65DEA3E0
    // Test FCVTZS_Z.P.Z_D2X field Zn = 31 (Max)
    // Fields: Pg=0, Zd=0, Zn=31
    let encoding: u32 = 0x65DEA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zd_0_min_a000_65dea000() {
    // Encoding: 0x65DEA000
    // Test FCVTZS_Z.P.Z_D2X field Zd = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zd_1_poweroftwo_a000_65dea001() {
    // Encoding: 0x65DEA001
    // Test FCVTZS_Z.P.Z_D2X field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0
    let encoding: u32 = 0x65DEA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zd_30_poweroftwominusone_a000_65dea01e() {
    // Encoding: 0x65DEA01E
    // Test FCVTZS_Z.P.Z_D2X field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Pg=0
    let encoding: u32 = 0x65DEA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzs_z_p_z_d2x_field_zd_31_max_a000_65dea01f() {
    // Encoding: 0x65DEA01F
    // Test FCVTZS_Z.P.Z_D2X field Zd = 31 (Max)
    // Fields: Pg=0, Zn=0, Zd=31
    let encoding: u32 = 0x65DEA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzs_z_p_z_d2x_combo_0_a000_65dea000() {
    // Encoding: 0x65DEA000
    // Test FCVTZS_Z.P.Z_D2X field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_d2x_invalid_0_a000_65dea000() {
    // Encoding: 0x65DEA000
    // Test FCVTZS_Z.P.Z_D2X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzs_z_p_z_d2x_invalid_1_a000_65dea000() {
    // Encoding: 0x65DEA000
    // Test FCVTZS_Z.P.Z_D2X invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65DEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZS_Z.P.Z_FP162H
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_fp162h_reg_write_0_655aa000() {
    // Test FCVTZS_Z.P.Z_FP162H register write: SimdFromField("d")
    // Encoding: 0x655AA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x655AA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZS_Z.P.Z_FP162W
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_fp162w_reg_write_0_655ca000() {
    // Test FCVTZS_Z.P.Z_FP162W register write: SimdFromField("d")
    // Encoding: 0x655CA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x655CA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZS_Z.P.Z_FP162X
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_fp162x_reg_write_0_655ea000() {
    // Test FCVTZS_Z.P.Z_FP162X register write: SimdFromField("d")
    // Encoding: 0x655EA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x655EA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZS_Z.P.Z_S2W
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_s2w_reg_write_0_659ca000() {
    // Test FCVTZS_Z.P.Z_S2W register write: SimdFromField("d")
    // Encoding: 0x659CA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x659CA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZS_Z.P.Z_S2X
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_s2x_reg_write_0_65dca000() {
    // Test FCVTZS_Z.P.Z_S2X register write: SimdFromField("d")
    // Encoding: 0x65DCA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65DCA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZS_Z.P.Z_D2W
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_d2w_reg_write_0_65d8a000() {
    // Test FCVTZS_Z.P.Z_D2W register write: SimdFromField("d")
    // Encoding: 0x65D8A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65D8A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZS_Z.P.Z_D2X
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzs_z_p_z_d2x_reg_write_0_65dea000() {
    // Test FCVTZS_Z.P.Z_D2X register write: SimdFromField("d")
    // Encoding: 0x65DEA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65DEA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FACGT_P.P.ZZ__ Tests
// ============================================================================

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_facgt_p_p_zz_field_size_0_min_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Pd=0, Zn=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_facgt_p_p_zz_field_size_1_poweroftwo_e010_6540e010() {
    // Encoding: 0x6540E010
    // Test FACGT_P.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zm=0, Zn=0, Pd=0
    let encoding: u32 = 0x6540E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_facgt_p_p_zz_field_size_2_poweroftwo_e010_6580e010() {
    // Encoding: 0x6580E010
    // Test FACGT_P.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pd=0, size=2, Pg=0, Zn=0, Zm=0
    let encoding: u32 = 0x6580E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_facgt_p_p_zz_field_size_3_max_e010_65c0e010() {
    // Encoding: 0x65C0E010
    // Test FACGT_P.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Pd=0, Zm=0, Pg=0
    let encoding: u32 = 0x65C0E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_facgt_p_p_zz_field_zm_0_min_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pd=0, Pg=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_facgt_p_p_zz_field_zm_1_poweroftwo_e010_6501e010() {
    // Encoding: 0x6501E010
    // Test FACGT_P.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, Pd=0, size=0, Pg=0, Zm=1
    let encoding: u32 = 0x6501E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_facgt_p_p_zz_field_zm_30_poweroftwominusone_e010_651ee010() {
    // Encoding: 0x651EE010
    // Test FACGT_P.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Zn=0, size=0, Pd=0
    let encoding: u32 = 0x651EE010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_facgt_p_p_zz_field_zm_31_max_e010_651fe010() {
    // Encoding: 0x651FE010
    // Test FACGT_P.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, Pg=0, Zm=31, Pd=0, size=0
    let encoding: u32 = 0x651FE010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_facgt_p_p_zz_field_pg_0_min_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, Pd=0, Zm=0, size=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_facgt_p_p_zz_field_pg_1_poweroftwo_e010_6500e410() {
    // Encoding: 0x6500E410
    // Test FACGT_P.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=1, Pd=0, Zn=0
    let encoding: u32 = 0x6500E410;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_facgt_p_p_zz_field_zn_0_min_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ field Zn = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Pd=0, Zn=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_facgt_p_p_zz_field_zn_1_poweroftwo_e010_6500e030() {
    // Encoding: 0x6500E030
    // Test FACGT_P.P.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=0, Pd=0, Zn=1
    let encoding: u32 = 0x6500E030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_facgt_p_p_zz_field_zn_30_poweroftwominusone_e010_6500e3d0() {
    // Encoding: 0x6500E3D0
    // Test FACGT_P.P.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Zm=0, Pg=0, Pd=0
    let encoding: u32 = 0x6500E3D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_facgt_p_p_zz_field_zn_31_max_e010_6500e3f0() {
    // Encoding: 0x6500E3F0
    // Test FACGT_P.P.ZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Pd=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x6500E3F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_facgt_p_p_zz_field_pd_0_min_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ field Pd = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Zn=0, Pd=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_facgt_p_p_zz_field_pd_1_poweroftwo_e010_6500e011() {
    // Encoding: 0x6500E011
    // Test FACGT_P.P.ZZ__ field Pd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Pd=1, Zn=0, Zm=0
    let encoding: u32 = 0x6500E011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_facgt_p_p_zz_combo_0_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Pd=0
    // Fields: Pg=0, size=0, Pd=0, Zn=0, Zm=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_facgt_p_p_zz_special_size_0_size_variant_0_57360_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pd=0, Zm=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_facgt_p_p_zz_special_size_1_size_variant_1_57360_6540e010() {
    // Encoding: 0x6540E010
    // Test FACGT_P.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pd=0, Pg=0, Zm=0, size=1, Zn=0
    let encoding: u32 = 0x6540E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_facgt_p_p_zz_special_size_2_size_variant_2_57360_6580e010() {
    // Encoding: 0x6580E010
    // Test FACGT_P.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Pg=0, Pd=0, Zm=0
    let encoding: u32 = 0x6580E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_facgt_p_p_zz_special_size_3_size_variant_3_57360_65c0e010() {
    // Encoding: 0x65C0E010
    // Test FACGT_P.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Zn=0, Pd=0, size=3, Pg=0
    let encoding: u32 = 0x65C0E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_facgt_p_p_zz_invalid_0_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zn=0, Zm=0, Pd=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_facgt_p_p_zz_invalid_1_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zn=0, Pd=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_facgt_p_p_zz_invalid_2_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zn=0, Zm=0, size=0, Pd=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_facgt_p_p_zz_invalid_3_e010_6500e010() {
    // Encoding: 0x6500E010
    // Test FACGT_P.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Pg=0, Zn=0, Pd=0
    let encoding: u32 = 0x6500E010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_facge_p_p_zz_field_size_0_min_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Pd=0, Pg=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_facge_p_p_zz_field_size_1_poweroftwo_c010_6540c010() {
    // Encoding: 0x6540C010
    // Test FACGE_P.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zn=0, Zm=0, Pd=0
    let encoding: u32 = 0x6540C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_facge_p_p_zz_field_size_2_poweroftwo_c010_6580c010() {
    // Encoding: 0x6580C010
    // Test FACGE_P.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Pg=0, Zn=0, Pd=0
    let encoding: u32 = 0x6580C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_facge_p_p_zz_field_size_3_max_c010_65c0c010() {
    // Encoding: 0x65C0C010
    // Test FACGE_P.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Pg=0, Pd=0, Zn=0, size=3
    let encoding: u32 = 0x65C0C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_facge_p_p_zz_field_zm_0_min_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pd=0, Zm=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_facge_p_p_zz_field_zm_1_poweroftwo_c010_6501c010() {
    // Encoding: 0x6501C010
    // Test FACGE_P.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, size=0, Zn=0, Pd=0
    let encoding: u32 = 0x6501C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_facge_p_p_zz_field_zm_30_poweroftwominusone_c010_651ec010() {
    // Encoding: 0x651EC010
    // Test FACGE_P.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zm=30, Pd=0, Zn=0
    let encoding: u32 = 0x651EC010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_facge_p_p_zz_field_zm_31_max_c010_651fc010() {
    // Encoding: 0x651FC010
    // Test FACGE_P.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Zm=31, Pd=0
    let encoding: u32 = 0x651FC010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_facge_p_p_zz_field_pg_0_min_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pd=0, Zn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_facge_p_p_zz_field_pg_1_poweroftwo_c010_6500c410() {
    // Encoding: 0x6500C410
    // Test FACGE_P.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zn=0, Pd=0, Zm=0
    let encoding: u32 = 0x6500C410;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_facge_p_p_zz_field_zn_0_min_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ field Zn = 0 (Min)
    // Fields: Pd=0, Zn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_facge_p_p_zz_field_zn_1_poweroftwo_c010_6500c030() {
    // Encoding: 0x6500C030
    // Test FACGE_P.P.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Pd=0, Zn=1, Zm=0
    let encoding: u32 = 0x6500C030;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_facge_p_p_zz_field_zn_30_poweroftwominusone_c010_6500c3d0() {
    // Encoding: 0x6500C3D0
    // Test FACGE_P.P.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pd=0, Pg=0, size=0, Zn=30, Zm=0
    let encoding: u32 = 0x6500C3D0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_facge_p_p_zz_field_zn_31_max_c010_6500c3f0() {
    // Encoding: 0x6500C3F0
    // Test FACGE_P.P.ZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zm=0, Pg=0, size=0, Pd=0
    let encoding: u32 = 0x6500C3F0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_facge_p_p_zz_field_pd_0_min_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ field Pd = 0 (Min)
    // Fields: Pg=0, size=0, Pd=0, Zm=0, Zn=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_facge_p_p_zz_field_pd_1_poweroftwo_c010_6500c011() {
    // Encoding: 0x6500C011
    // Test FACGE_P.P.ZZ__ field Pd = 1 (PowerOfTwo)
    // Fields: size=0, Pd=1, Zm=0, Pg=0, Zn=0
    let encoding: u32 = 0x6500C011;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_facge_p_p_zz_combo_0_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Pd=0
    // Fields: Pd=0, size=0, Zm=0, Pg=0, Zn=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_facge_p_p_zz_special_size_0_size_variant_0_49168_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Pg=0, size=0, Zn=0, Pd=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_facge_p_p_zz_special_size_1_size_variant_1_49168_6540c010() {
    // Encoding: 0x6540C010
    // Test FACGE_P.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zn=0, Pg=0, Pd=0, size=1
    let encoding: u32 = 0x6540C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_facge_p_p_zz_special_size_2_size_variant_2_49168_6580c010() {
    // Encoding: 0x6580C010
    // Test FACGE_P.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Pg=0, Pd=0, Zm=0
    let encoding: u32 = 0x6580C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_facge_p_p_zz_special_size_3_size_variant_3_49168_65c0c010() {
    // Encoding: 0x65C0C010
    // Test FACGE_P.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, size=3, Pg=0, Zn=0, Pd=0
    let encoding: u32 = 0x65C0C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_facge_p_p_zz_invalid_0_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zm=0, Pd=0, Zn=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_facge_p_p_zz_invalid_1_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zm=0, size=0, Pd=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_facge_p_p_zz_invalid_2_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Pg=0, size=0, Zm=0, Pd=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_facge_p_p_zz_invalid_3_c010_6500c010() {
    // Encoding: 0x6500C010
    // Test FACGE_P.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pd=0, size=0, Zm=0, Pg=0, Zn=0
    let encoding: u32 = 0x6500C010;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FACGT_P.P.ZZ__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_facgt_p_p_zz_reg_write_0_6500e010() {
    // Test FACGT_P.P.ZZ__ register write: SimdFromField("Pd")
    // Encoding: 0x6500E010
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6500E010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FACGE_P.P.ZZ__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_facge_p_p_zz_reg_write_0_6500c010() {
    // Test FACGE_P.P.ZZ__ register write: SimdFromField("Pd")
    // Encoding: 0x6500C010
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6500C010;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMLS_Z.ZZZi_H Tests
// ============================================================================

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field i3h 22 +: 1`
/// Requirement: FieldBoundary { field: "i3h", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_h_field_i3h_0_min_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H field i3h = 0 (Min)
    // Fields: Zda=0, Zm=0, i3l=0, Zn=0, i3h=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field i3h 22 +: 1`
/// Requirement: FieldBoundary { field: "i3h", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmls_z_zzzi_h_field_i3h_1_max_400_64600400() {
    // Encoding: 0x64600400
    // Test FMLS_Z.ZZZi_H field i3h = 1 (Max)
    // Fields: Zn=0, Zm=0, i3h=1, Zda=0, i3l=0
    let encoding: u32 = 0x64600400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_h_field_i3l_0_min_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H field i3l = 0 (Min)
    // Fields: Zm=0, i3l=0, i3h=0, Zn=0, Zda=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmls_z_zzzi_h_field_i3l_1_poweroftwo_400_64280400() {
    // Encoding: 0x64280400
    // Test FMLS_Z.ZZZi_H field i3l = 1 (PowerOfTwo)
    // Fields: i3l=1, Zn=0, Zm=0, Zda=0, i3h=0
    let encoding: u32 = 0x64280400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_fmls_z_zzzi_h_field_i3l_3_max_400_64380400() {
    // Encoding: 0x64380400
    // Test FMLS_Z.ZZZi_H field i3l = 3 (Max)
    // Fields: Zn=0, i3l=3, Zm=0, Zda=0, i3h=0
    let encoding: u32 = 0x64380400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_zzzi_h_field_zm_0_min_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H field Zm = 0 (Min)
    // Fields: i3h=0, i3l=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_zzzi_h_field_zm_1_poweroftwo_400_64210400() {
    // Encoding: 0x64210400
    // Test FMLS_Z.ZZZi_H field Zm = 1 (PowerOfTwo)
    // Fields: i3l=0, Zm=1, Zn=0, Zda=0, i3h=0
    let encoding: u32 = 0x64210400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_zzzi_h_field_zn_0_min_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H field Zn = 0 (Min)
    // Fields: i3h=0, Zm=0, i3l=0, Zda=0, Zn=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_zzzi_h_field_zn_1_poweroftwo_400_64200420() {
    // Encoding: 0x64200420
    // Test FMLS_Z.ZZZi_H field Zn = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=1, i3l=0, Zm=0, i3h=0
    let encoding: u32 = 0x64200420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmls_z_zzzi_h_field_zn_30_poweroftwominusone_400_642007c0() {
    // Encoding: 0x642007C0
    // Test FMLS_Z.ZZZi_H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zda=0, Zm=0, i3h=0, i3l=0
    let encoding: u32 = 0x642007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmls_z_zzzi_h_field_zn_31_max_400_642007e0() {
    // Encoding: 0x642007E0
    // Test FMLS_Z.ZZZi_H field Zn = 31 (Max)
    // Fields: i3l=0, Zn=31, Zda=0, i3h=0, Zm=0
    let encoding: u32 = 0x642007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_h_field_zda_0_min_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H field Zda = 0 (Min)
    // Fields: Zda=0, i3h=0, i3l=0, Zm=0, Zn=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmls_z_zzzi_h_field_zda_1_poweroftwo_400_64200401() {
    // Encoding: 0x64200401
    // Test FMLS_Z.ZZZi_H field Zda = 1 (PowerOfTwo)
    // Fields: Zn=0, Zda=1, i3h=0, i3l=0, Zm=0
    let encoding: u32 = 0x64200401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmls_z_zzzi_h_field_zda_15_poweroftwominusone_400_6420040f() {
    // Encoding: 0x6420040F
    // Test FMLS_Z.ZZZi_H field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zda=15, i3l=0, Zn=0, i3h=0, Zm=0
    let encoding: u32 = 0x6420040F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmls_z_zzzi_h_field_zda_31_max_400_6420041f() {
    // Encoding: 0x6420041F
    // Test FMLS_Z.ZZZi_H field Zda = 31 (Max)
    // Fields: Zn=0, i3l=0, Zm=0, Zda=31, i3h=0
    let encoding: u32 = 0x6420041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i3h=0 (minimum value)
#[test]
fn test_fmls_z_zzzi_h_combo_0_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H field combination: i3h=0, i3l=0, Zm=0, Zn=0, Zda=0
    // Fields: Zn=0, Zda=0, i3h=0, i3l=0, Zm=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmls_z_zzzi_h_invalid_0_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i3h=0, Zn=0, Zda=0, Zm=0, i3l=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmls_z_zzzi_h_invalid_1_400_64200400() {
    // Encoding: 0x64200400
    // Test FMLS_Z.ZZZi_H invalid encoding: Unconditional UNDEFINED
    // Fields: i3h=0, i3l=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_s_field_i2_0_min_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S field i2 = 0 (Min)
    // Fields: Zn=0, Zda=0, i2=0, Zm=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmls_z_zzzi_s_field_i2_1_poweroftwo_400_64a80400() {
    // Encoding: 0x64A80400
    // Test FMLS_Z.ZZZi_S field i2 = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, i2=1, Zda=0
    let encoding: u32 = 0x64A80400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_fmls_z_zzzi_s_field_i2_3_max_400_64b80400() {
    // Encoding: 0x64B80400
    // Test FMLS_Z.ZZZi_S field i2 = 3 (Max)
    // Fields: Zn=0, i2=3, Zm=0, Zda=0
    let encoding: u32 = 0x64B80400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_zzzi_s_field_zm_0_min_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S field Zm = 0 (Min)
    // Fields: Zn=0, i2=0, Zm=0, Zda=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_zzzi_s_field_zm_1_poweroftwo_400_64a10400() {
    // Encoding: 0x64A10400
    // Test FMLS_Z.ZZZi_S field Zm = 1 (PowerOfTwo)
    // Fields: i2=0, Zda=0, Zn=0, Zm=1
    let encoding: u32 = 0x64A10400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_zzzi_s_field_zn_0_min_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S field Zn = 0 (Min)
    // Fields: i2=0, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_zzzi_s_field_zn_1_poweroftwo_400_64a00420() {
    // Encoding: 0x64A00420
    // Test FMLS_Z.ZZZi_S field Zn = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=1, Zm=0, i2=0
    let encoding: u32 = 0x64A00420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmls_z_zzzi_s_field_zn_30_poweroftwominusone_400_64a007c0() {
    // Encoding: 0x64A007C0
    // Test FMLS_Z.ZZZi_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zm=0, Zda=0, i2=0
    let encoding: u32 = 0x64A007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmls_z_zzzi_s_field_zn_31_max_400_64a007e0() {
    // Encoding: 0x64A007E0
    // Test FMLS_Z.ZZZi_S field Zn = 31 (Max)
    // Fields: Zn=31, i2=0, Zm=0, Zda=0
    let encoding: u32 = 0x64A007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_s_field_zda_0_min_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S field Zda = 0 (Min)
    // Fields: Zda=0, i2=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmls_z_zzzi_s_field_zda_1_poweroftwo_400_64a00401() {
    // Encoding: 0x64A00401
    // Test FMLS_Z.ZZZi_S field Zda = 1 (PowerOfTwo)
    // Fields: Zda=1, i2=0, Zn=0, Zm=0
    let encoding: u32 = 0x64A00401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmls_z_zzzi_s_field_zda_15_poweroftwominusone_400_64a0040f() {
    // Encoding: 0x64A0040F
    // Test FMLS_Z.ZZZi_S field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zda=15, Zm=0, Zn=0, i2=0
    let encoding: u32 = 0x64A0040F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmls_z_zzzi_s_field_zda_31_max_400_64a0041f() {
    // Encoding: 0x64A0041F
    // Test FMLS_Z.ZZZi_S field Zda = 31 (Max)
    // Fields: Zda=31, i2=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A0041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i2=0 (minimum value)
#[test]
fn test_fmls_z_zzzi_s_combo_0_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S field combination: i2=0, Zm=0, Zn=0, Zda=0
    // Fields: Zm=0, Zn=0, Zda=0, i2=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmls_z_zzzi_s_invalid_0_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i2=0, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmls_z_zzzi_s_invalid_1_400_64a00400() {
    // Encoding: 0x64A00400
    // Test FMLS_Z.ZZZi_S invalid encoding: Unconditional UNDEFINED
    // Fields: i2=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_d_field_i1_0_min_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D field i1 = 0 (Min)
    // Fields: i1=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmls_z_zzzi_d_field_i1_1_max_400_64f00400() {
    // Encoding: 0x64F00400
    // Test FMLS_Z.ZZZi_D field i1 = 1 (Max)
    // Fields: Zn=0, i1=1, Zm=0, Zda=0
    let encoding: u32 = 0x64F00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_zzzi_d_field_zm_0_min_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D field Zm = 0 (Min)
    // Fields: Zm=0, Zn=0, i1=0, Zda=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_zzzi_d_field_zm_1_poweroftwo_400_64e10400() {
    // Encoding: 0x64E10400
    // Test FMLS_Z.ZZZi_D field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zda=0, Zn=0, i1=0
    let encoding: u32 = 0x64E10400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_zzzi_d_field_zn_0_min_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D field Zn = 0 (Min)
    // Fields: Zm=0, Zn=0, Zda=0, i1=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_zzzi_d_field_zn_1_poweroftwo_400_64e00420() {
    // Encoding: 0x64E00420
    // Test FMLS_Z.ZZZi_D field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zm=0, Zda=0, i1=0
    let encoding: u32 = 0x64E00420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmls_z_zzzi_d_field_zn_30_poweroftwominusone_400_64e007c0() {
    // Encoding: 0x64E007C0
    // Test FMLS_Z.ZZZi_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Zm=0, i1=0, Zn=30
    let encoding: u32 = 0x64E007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmls_z_zzzi_d_field_zn_31_max_400_64e007e0() {
    // Encoding: 0x64E007E0
    // Test FMLS_Z.ZZZi_D field Zn = 31 (Max)
    // Fields: Zm=0, i1=0, Zn=31, Zda=0
    let encoding: u32 = 0x64E007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_zzzi_d_field_zda_0_min_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D field Zda = 0 (Min)
    // Fields: Zda=0, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmls_z_zzzi_d_field_zda_1_poweroftwo_400_64e00401() {
    // Encoding: 0x64E00401
    // Test FMLS_Z.ZZZi_D field Zda = 1 (PowerOfTwo)
    // Fields: Zm=0, Zda=1, Zn=0, i1=0
    let encoding: u32 = 0x64E00401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmls_z_zzzi_d_field_zda_15_poweroftwominusone_400_64e0040f() {
    // Encoding: 0x64E0040F
    // Test FMLS_Z.ZZZi_D field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, i1=0, Zn=0, Zda=15
    let encoding: u32 = 0x64E0040F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmls_z_zzzi_d_field_zda_31_max_400_64e0041f() {
    // Encoding: 0x64E0041F
    // Test FMLS_Z.ZZZi_D field Zda = 31 (Max)
    // Fields: i1=0, Zm=0, Zn=0, Zda=31
    let encoding: u32 = 0x64E0041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_fmls_z_zzzi_d_combo_0_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D field combination: i1=0, Zm=0, Zn=0, Zda=0
    // Fields: Zn=0, i1=0, Zm=0, Zda=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmls_z_zzzi_d_invalid_0_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zda=0, i1=0, Zn=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmls_z_zzzi_d_invalid_1_400_64e00400() {
    // Encoding: 0x64E00400
    // Test FMLS_Z.ZZZi_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zn=0, i1=0, Zda=0
    let encoding: u32 = 0x64E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.ZZZi_H
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmls_z_zzzi_h_reg_write_0_64200400() {
    // Test FMLS_Z.ZZZi_H register write: SimdFromField("da")
    // Encoding: 0x64200400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64200400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FMLS_Z.ZZZi_S
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmls_z_zzzi_s_reg_write_0_64a00400() {
    // Test FMLS_Z.ZZZi_S register write: SimdFromField("da")
    // Encoding: 0x64A00400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FMLS_Z.ZZZi_D
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmls_z_zzzi_d_reg_write_0_64e00400() {
    // Test FMLS_Z.ZZZi_D register write: SimdFromField("da")
    // Encoding: 0x64E00400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64E00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSCALE_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fscale_z_p_zz_field_size_0_min_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fscale_z_p_zz_field_size_1_poweroftwo_8000_65498000() {
    // Encoding: 0x65498000
    // Test FSCALE_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65498000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fscale_z_p_zz_field_size_2_poweroftwo_8000_65898000() {
    // Encoding: 0x65898000
    // Test FSCALE_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Zm=0, Pg=0
    let encoding: u32 = 0x65898000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fscale_z_p_zz_field_size_3_max_8000_65c98000() {
    // Encoding: 0x65C98000
    // Test FSCALE_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65C98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fscale_z_p_zz_field_pg_0_min_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fscale_z_p_zz_field_pg_1_poweroftwo_8000_65098400() {
    // Encoding: 0x65098400
    // Test FSCALE_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65098400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fscale_z_p_zz_field_zm_0_min_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fscale_z_p_zz_field_zm_1_poweroftwo_8000_65098020() {
    // Encoding: 0x65098020
    // Test FSCALE_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65098020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fscale_z_p_zz_field_zm_30_poweroftwominusone_8000_650983c0() {
    // Encoding: 0x650983C0
    // Test FSCALE_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, Zm=30, Pg=0
    let encoding: u32 = 0x650983C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fscale_z_p_zz_field_zm_31_max_8000_650983e0() {
    // Encoding: 0x650983E0
    // Test FSCALE_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x650983E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fscale_z_p_zz_field_zdn_0_min_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fscale_z_p_zz_field_zdn_1_poweroftwo_8000_65098001() {
    // Encoding: 0x65098001
    // Test FSCALE_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x65098001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fscale_z_p_zz_field_zdn_15_poweroftwominusone_8000_6509800f() {
    // Encoding: 0x6509800F
    // Test FSCALE_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=15, size=0, Zm=0
    let encoding: u32 = 0x6509800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fscale_z_p_zz_field_zdn_31_max_8000_6509801f() {
    // Encoding: 0x6509801F
    // Test FSCALE_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, size=0, Zdn=31
    let encoding: u32 = 0x6509801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fscale_z_p_zz_combo_0_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fscale_z_p_zz_special_size_0_size_variant_0_32768_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fscale_z_p_zz_special_size_1_size_variant_1_32768_65498000() {
    // Encoding: 0x65498000
    // Test FSCALE_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65498000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fscale_z_p_zz_special_size_2_size_variant_2_32768_65898000() {
    // Encoding: 0x65898000
    // Test FSCALE_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x65898000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fscale_z_p_zz_special_size_3_size_variant_3_32768_65c98000() {
    // Encoding: 0x65C98000
    // Test FSCALE_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Zm=0, size=3, Pg=0
    let encoding: u32 = 0x65C98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fscale_z_p_zz_invalid_0_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fscale_z_p_zz_invalid_1_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fscale_z_p_zz_invalid_2_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fscale_z_p_zz_invalid_3_8000_65098000() {
    // Encoding: 0x65098000
    // Test FSCALE_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65098000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSCALE_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fscale_z_p_zz_reg_write_0_65098000() {
    // Test FSCALE_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65098000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65098000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSQRT_Z.P.Z__ Tests
// ============================================================================

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsqrt_z_p_z_field_size_0_min_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsqrt_z_p_z_field_size_1_poweroftwo_a000_654da000() {
    // Encoding: 0x654DA000
    // Test FSQRT_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Zn=0, Pg=0
    let encoding: u32 = 0x654DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsqrt_z_p_z_field_size_2_poweroftwo_a000_658da000() {
    // Encoding: 0x658DA000
    // Test FSQRT_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x658DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsqrt_z_p_z_field_size_3_max_a000_65cda000() {
    // Encoding: 0x65CDA000
    // Test FSQRT_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zd=0, Zn=0, size=3
    let encoding: u32 = 0x65CDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsqrt_z_p_z_field_pg_0_min_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsqrt_z_p_z_field_pg_1_poweroftwo_a000_650da400() {
    // Encoding: 0x650DA400
    // Test FSQRT_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Pg=1, Zd=0
    let encoding: u32 = 0x650DA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsqrt_z_p_z_field_zn_0_min_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsqrt_z_p_z_field_zn_1_poweroftwo_a000_650da020() {
    // Encoding: 0x650DA020
    // Test FSQRT_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Pg=0, Zn=1
    let encoding: u32 = 0x650DA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsqrt_z_p_z_field_zn_30_poweroftwominusone_a000_650da3c0() {
    // Encoding: 0x650DA3C0
    // Test FSQRT_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Pg=0, Zd=0
    let encoding: u32 = 0x650DA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsqrt_z_p_z_field_zn_31_max_a000_650da3e0() {
    // Encoding: 0x650DA3E0
    // Test FSQRT_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0, Pg=0
    let encoding: u32 = 0x650DA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsqrt_z_p_z_field_zd_0_min_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsqrt_z_p_z_field_zd_1_poweroftwo_a000_650da001() {
    // Encoding: 0x650DA001
    // Test FSQRT_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x650DA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsqrt_z_p_z_field_zd_30_poweroftwominusone_a000_650da01e() {
    // Encoding: 0x650DA01E
    // Test FSQRT_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=30, Zn=0, size=0
    let encoding: u32 = 0x650DA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsqrt_z_p_z_field_zd_31_max_a000_650da01f() {
    // Encoding: 0x650DA01F
    // Test FSQRT_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Pg=0, Zd=31
    let encoding: u32 = 0x650DA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsqrt_z_p_z_combo_0_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsqrt_z_p_z_special_size_0_size_variant_0_40960_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsqrt_z_p_z_special_size_1_size_variant_1_40960_654da000() {
    // Encoding: 0x654DA000
    // Test FSQRT_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Pg=0, Zn=0, size=1
    let encoding: u32 = 0x654DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsqrt_z_p_z_special_size_2_size_variant_2_40960_658da000() {
    // Encoding: 0x658DA000
    // Test FSQRT_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zd=0, Zn=0
    let encoding: u32 = 0x658DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsqrt_z_p_z_special_size_3_size_variant_3_40960_65cda000() {
    // Encoding: 0x65CDA000
    // Test FSQRT_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Pg=0, Zn=0, size=3
    let encoding: u32 = 0x65CDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsqrt_z_p_z_invalid_0_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsqrt_z_p_z_invalid_1_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsqrt_z_p_z_invalid_2_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsqrt_z_p_z_invalid_3_a000_650da000() {
    // Encoding: 0x650DA000
    // Test FSQRT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x650DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSQRT_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fsqrt_z_p_z_reg_write_0_650da000() {
    // Test FSQRT_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x650DA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650DA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FTMAD_Z.ZZI__ Tests
// ============================================================================

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_ftmad_z_zzi_field_size_0_min_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ field size = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, imm3=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_ftmad_z_zzi_field_size_1_poweroftwo_8000_65508000() {
    // Encoding: 0x65508000
    // Test FTMAD_Z.ZZI__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, imm3=0, size=1, Zdn=0
    let encoding: u32 = 0x65508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_ftmad_z_zzi_field_size_2_poweroftwo_8000_65908000() {
    // Encoding: 0x65908000
    // Test FTMAD_Z.ZZI__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, size=2, imm3=0, Zdn=0
    let encoding: u32 = 0x65908000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_ftmad_z_zzi_field_size_3_max_8000_65d08000() {
    // Encoding: 0x65D08000
    // Test FTMAD_Z.ZZI__ field size = 3 (Max)
    // Fields: size=3, Zdn=0, imm3=0, Zm=0
    let encoding: u32 = 0x65D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ftmad_z_zzi_field_imm3_0_zero_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ field imm3 = 0 (Zero)
    // Fields: size=0, imm3=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ftmad_z_zzi_field_imm3_1_poweroftwo_8000_65118000() {
    // Encoding: 0x65118000
    // Test FTMAD_Z.ZZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zdn=0, imm3=1
    let encoding: u32 = 0x65118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_ftmad_z_zzi_field_imm3_3_poweroftwominusone_8000_65138000() {
    // Encoding: 0x65138000
    // Test FTMAD_Z.ZZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, imm3=3, Zdn=0
    let encoding: u32 = 0x65138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_ftmad_z_zzi_field_imm3_7_max_8000_65178000() {
    // Encoding: 0x65178000
    // Test FTMAD_Z.ZZI__ field imm3 = 7 (Max)
    // Fields: imm3=7, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftmad_z_zzi_field_zm_0_min_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ field Zm = 0 (Min)
    // Fields: imm3=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftmad_z_zzi_field_zm_1_poweroftwo_8000_65108020() {
    // Encoding: 0x65108020
    // Test FTMAD_Z.ZZI__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, size=0, imm3=0
    let encoding: u32 = 0x65108020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftmad_z_zzi_field_zm_30_poweroftwominusone_8000_651083c0() {
    // Encoding: 0x651083C0
    // Test FTMAD_Z.ZZI__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm3=0, size=0, Zm=30
    let encoding: u32 = 0x651083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftmad_z_zzi_field_zm_31_max_8000_651083e0() {
    // Encoding: 0x651083E0
    // Test FTMAD_Z.ZZI__ field Zm = 31 (Max)
    // Fields: size=0, imm3=0, Zm=31, Zdn=0
    let encoding: u32 = 0x651083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ftmad_z_zzi_field_zdn_0_min_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, imm3=0, Zm=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_ftmad_z_zzi_field_zdn_1_poweroftwo_8000_65108001() {
    // Encoding: 0x65108001
    // Test FTMAD_Z.ZZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm3=0, Zm=0, size=0, Zdn=1
    let encoding: u32 = 0x65108001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_ftmad_z_zzi_field_zdn_15_poweroftwominusone_8000_6510800f() {
    // Encoding: 0x6510800F
    // Test FTMAD_Z.ZZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, imm3=0, size=0, Zdn=15
    let encoding: u32 = 0x6510800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_ftmad_z_zzi_field_zdn_31_max_8000_6510801f() {
    // Encoding: 0x6510801F
    // Test FTMAD_Z.ZZI__ field Zdn = 31 (Max)
    // Fields: imm3=0, Zm=0, size=0, Zdn=31
    let encoding: u32 = 0x6510801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_ftmad_z_zzi_combo_0_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ field combination: size=0, imm3=0, Zm=0, Zdn=0
    // Fields: Zm=0, Zdn=0, imm3=0, size=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_ftmad_z_zzi_special_size_0_size_variant_0_32768_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, imm3=0, Zdn=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_ftmad_z_zzi_special_size_1_size_variant_1_32768_65508000() {
    // Encoding: 0x65508000
    // Test FTMAD_Z.ZZI__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, imm3=0, Zdn=0
    let encoding: u32 = 0x65508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_ftmad_z_zzi_special_size_2_size_variant_2_32768_65908000() {
    // Encoding: 0x65908000
    // Test FTMAD_Z.ZZI__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, Zm=0, size=2, imm3=0
    let encoding: u32 = 0x65908000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_ftmad_z_zzi_special_size_3_size_variant_3_32768_65d08000() {
    // Encoding: 0x65D08000
    // Test FTMAD_Z.ZZI__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zdn=0, imm3=0
    let encoding: u32 = 0x65D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ftmad_z_zzi_invalid_0_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, imm3=0, Zdn=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ftmad_z_zzi_invalid_1_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm3=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_ftmad_z_zzi_invalid_2_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zdn=0, imm3=0, Zm=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ftmad_z_zzi_invalid_3_8000_65108000() {
    // Encoding: 0x65108000
    // Test FTMAD_Z.ZZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm3=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x65108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTMAD_Z.ZZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_ftmad_z_zzi_reg_write_0_65108000() {
    // Test FTMAD_Z.ZZI__ register write: SimdFromField("dn")
    // Encoding: 0x65108000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65108000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUB_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsub_z_zz_field_size_0_min_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsub_z_zz_field_size_1_poweroftwo_400_65400400() {
    // Encoding: 0x65400400
    // Test FSUB_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsub_z_zz_field_size_2_poweroftwo_400_65800400() {
    // Encoding: 0x65800400
    // Test FSUB_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, size=2, Zd=0
    let encoding: u32 = 0x65800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsub_z_zz_field_size_3_max_400_65c00400() {
    // Encoding: 0x65C00400
    // Test FSUB_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x65C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsub_z_zz_field_zm_0_min_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsub_z_zz_field_zm_1_poweroftwo_400_65010400() {
    // Encoding: 0x65010400
    // Test FSUB_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Zn=0, Zd=0
    let encoding: u32 = 0x65010400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsub_z_zz_field_zm_30_poweroftwominusone_400_651e0400() {
    // Encoding: 0x651E0400
    // Test FSUB_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zm=30, size=0, Zn=0
    let encoding: u32 = 0x651E0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsub_z_zz_field_zm_31_max_400_651f0400() {
    // Encoding: 0x651F0400
    // Test FSUB_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, Zd=0, Zm=31, size=0
    let encoding: u32 = 0x651F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsub_z_zz_field_zn_0_min_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsub_z_zz_field_zn_1_poweroftwo_400_65000420() {
    // Encoding: 0x65000420
    // Test FSUB_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, size=0, Zn=1
    let encoding: u32 = 0x65000420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsub_z_zz_field_zn_30_poweroftwominusone_400_650007c0() {
    // Encoding: 0x650007C0
    // Test FSUB_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x650007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsub_z_zz_field_zn_31_max_400_650007e0() {
    // Encoding: 0x650007E0
    // Test FSUB_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zd=0, size=0, Zm=0, Zn=31
    let encoding: u32 = 0x650007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsub_z_zz_field_zd_0_min_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsub_z_zz_field_zd_1_poweroftwo_400_65000401() {
    // Encoding: 0x65000401
    // Test FSUB_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=0, Zd=1
    let encoding: u32 = 0x65000401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsub_z_zz_field_zd_30_poweroftwominusone_400_6500041e() {
    // Encoding: 0x6500041E
    // Test FSUB_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x6500041E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsub_z_zz_field_zd_31_max_400_6500041f() {
    // Encoding: 0x6500041F
    // Test FSUB_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, size=0, Zm=0
    let encoding: u32 = 0x6500041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsub_z_zz_combo_0_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsub_z_zz_special_size_0_size_variant_0_1024_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsub_z_zz_special_size_1_size_variant_1_1024_65400400() {
    // Encoding: 0x65400400
    // Test FSUB_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsub_z_zz_special_size_2_size_variant_2_1024_65800400() {
    // Encoding: 0x65800400
    // Test FSUB_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, Zm=0, Zn=0, size=2
    let encoding: u32 = 0x65800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsub_z_zz_special_size_3_size_variant_3_1024_65c00400() {
    // Encoding: 0x65C00400
    // Test FSUB_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zm=0, size=3, Zn=0
    let encoding: u32 = 0x65C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsub_z_zz_invalid_0_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_zz_invalid_1_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsub_z_zz_invalid_2_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_zz_invalid_3_400_65000400() {
    // Encoding: 0x65000400
    // Test FSUB_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fsub_z_zz_reg_write_0_65000400() {
    // Test FSUB_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65000400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65000400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMULX_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmulx_z_p_zz_field_size_0_min_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmulx_z_p_zz_field_size_1_poweroftwo_8000_654a8000() {
    // Encoding: 0x654A8000
    // Test FMULX_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, Pg=0, size=1
    let encoding: u32 = 0x654A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmulx_z_p_zz_field_size_2_poweroftwo_8000_658a8000() {
    // Encoding: 0x658A8000
    // Test FMULX_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x658A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmulx_z_p_zz_field_size_3_max_8000_65ca8000() {
    // Encoding: 0x65CA8000
    // Test FMULX_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65CA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmulx_z_p_zz_field_pg_0_min_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmulx_z_p_zz_field_pg_1_poweroftwo_8000_650a8400() {
    // Encoding: 0x650A8400
    // Test FMULX_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zdn=0, Zm=0
    let encoding: u32 = 0x650A8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmulx_z_p_zz_field_zm_0_min_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmulx_z_p_zz_field_zm_1_poweroftwo_8000_650a8020() {
    // Encoding: 0x650A8020
    // Test FMULX_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Pg=0, Zdn=0
    let encoding: u32 = 0x650A8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmulx_z_p_zz_field_zm_30_poweroftwominusone_8000_650a83c0() {
    // Encoding: 0x650A83C0
    // Test FMULX_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x650A83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmulx_z_p_zz_field_zm_31_max_8000_650a83e0() {
    // Encoding: 0x650A83E0
    // Test FMULX_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, Pg=0, Zm=31, size=0
    let encoding: u32 = 0x650A83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmulx_z_p_zz_field_zdn_0_min_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmulx_z_p_zz_field_zdn_1_poweroftwo_8000_650a8001() {
    // Encoding: 0x650A8001
    // Test FMULX_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1, Zm=0
    let encoding: u32 = 0x650A8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmulx_z_p_zz_field_zdn_15_poweroftwominusone_8000_650a800f() {
    // Encoding: 0x650A800F
    // Test FMULX_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zdn=15, Pg=0, size=0
    let encoding: u32 = 0x650A800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmulx_z_p_zz_field_zdn_31_max_8000_650a801f() {
    // Encoding: 0x650A801F
    // Test FMULX_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x650A801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmulx_z_p_zz_combo_0_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmulx_z_p_zz_special_size_0_size_variant_0_32768_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmulx_z_p_zz_special_size_1_size_variant_1_32768_654a8000() {
    // Encoding: 0x654A8000
    // Test FMULX_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Zm=0, Pg=0, size=1
    let encoding: u32 = 0x654A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmulx_z_p_zz_special_size_2_size_variant_2_32768_658a8000() {
    // Encoding: 0x658A8000
    // Test FMULX_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x658A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmulx_z_p_zz_special_size_3_size_variant_3_32768_65ca8000() {
    // Encoding: 0x65CA8000
    // Test FMULX_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x65CA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmulx_z_p_zz_invalid_0_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmulx_z_p_zz_invalid_1_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmulx_z_p_zz_invalid_2_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmulx_z_p_zz_invalid_3_8000_650a8000() {
    // Encoding: 0x650A8000
    // Test FMULX_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x650A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMULX_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmulx_z_p_zz_reg_write_0_650a8000() {
    // Test FMULX_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x650A8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650A8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FABD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fabd_z_p_zz_field_size_0_min_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fabd_z_p_zz_field_size_1_poweroftwo_8000_65488000() {
    // Encoding: 0x65488000
    // Test FABD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65488000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fabd_z_p_zz_field_size_2_poweroftwo_8000_65888000() {
    // Encoding: 0x65888000
    // Test FABD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x65888000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fabd_z_p_zz_field_size_3_max_8000_65c88000() {
    // Encoding: 0x65C88000
    // Test FABD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x65C88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fabd_z_p_zz_field_pg_0_min_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fabd_z_p_zz_field_pg_1_poweroftwo_8000_65088400() {
    // Encoding: 0x65088400
    // Test FABD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=1, Zdn=0
    let encoding: u32 = 0x65088400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fabd_z_p_zz_field_zm_0_min_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fabd_z_p_zz_field_zm_1_poweroftwo_8000_65088020() {
    // Encoding: 0x65088020
    // Test FABD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x65088020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fabd_z_p_zz_field_zm_30_poweroftwominusone_8000_650883c0() {
    // Encoding: 0x650883C0
    // Test FABD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Zdn=0, size=0
    let encoding: u32 = 0x650883C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fabd_z_p_zz_field_zm_31_max_8000_650883e0() {
    // Encoding: 0x650883E0
    // Test FABD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zdn=0, Zm=31, size=0
    let encoding: u32 = 0x650883E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fabd_z_p_zz_field_zdn_0_min_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fabd_z_p_zz_field_zdn_1_poweroftwo_8000_65088001() {
    // Encoding: 0x65088001
    // Test FABD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=0, Zdn=1
    let encoding: u32 = 0x65088001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fabd_z_p_zz_field_zdn_15_poweroftwominusone_8000_6508800f() {
    // Encoding: 0x6508800F
    // Test FABD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x6508800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fabd_z_p_zz_field_zdn_31_max_8000_6508801f() {
    // Encoding: 0x6508801F
    // Test FABD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, Zm=0, Pg=0
    let encoding: u32 = 0x6508801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fabd_z_p_zz_combo_0_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fabd_z_p_zz_special_size_0_size_variant_0_32768_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fabd_z_p_zz_special_size_1_size_variant_1_32768_65488000() {
    // Encoding: 0x65488000
    // Test FABD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65488000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fabd_z_p_zz_special_size_2_size_variant_2_32768_65888000() {
    // Encoding: 0x65888000
    // Test FABD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65888000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fabd_z_p_zz_special_size_3_size_variant_3_32768_65c88000() {
    // Encoding: 0x65C88000
    // Test FABD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zm=0, Zdn=0
    let encoding: u32 = 0x65C88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fabd_z_p_zz_invalid_0_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fabd_z_p_zz_invalid_1_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fabd_z_p_zz_invalid_2_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fabd_z_p_zz_invalid_3_8000_65088000() {
    // Encoding: 0x65088000
    // Test FABD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65088000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fabd_z_p_zz_reg_write_0_65088000() {
    // Test FABD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65088000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65088000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUBR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsubr_z_p_zz_field_size_0_min_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsubr_z_p_zz_field_size_1_poweroftwo_8000_65438000() {
    // Encoding: 0x65438000
    // Test FSUBR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zm=0, Zdn=0
    let encoding: u32 = 0x65438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsubr_z_p_zz_field_size_2_poweroftwo_8000_65838000() {
    // Encoding: 0x65838000
    // Test FSUBR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, size=2, Zdn=0
    let encoding: u32 = 0x65838000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsubr_z_p_zz_field_size_3_max_8000_65c38000() {
    // Encoding: 0x65C38000
    // Test FSUBR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x65C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsubr_z_p_zz_field_pg_0_min_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsubr_z_p_zz_field_pg_1_poweroftwo_8000_65038400() {
    // Encoding: 0x65038400
    // Test FSUBR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zm=0, Zdn=0
    let encoding: u32 = 0x65038400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsubr_z_p_zz_field_zm_0_min_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsubr_z_p_zz_field_zm_1_poweroftwo_8000_65038020() {
    // Encoding: 0x65038020
    // Test FSUBR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, size=0, Pg=0
    let encoding: u32 = 0x65038020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsubr_z_p_zz_field_zm_30_poweroftwominusone_8000_650383c0() {
    // Encoding: 0x650383C0
    // Test FSUBR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Zdn=0, Pg=0
    let encoding: u32 = 0x650383C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsubr_z_p_zz_field_zm_31_max_8000_650383e0() {
    // Encoding: 0x650383E0
    // Test FSUBR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, size=0, Zm=31, Pg=0
    let encoding: u32 = 0x650383E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsubr_z_p_zz_field_zdn_0_min_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fsubr_z_p_zz_field_zdn_1_poweroftwo_8000_65038001() {
    // Encoding: 0x65038001
    // Test FSUBR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=0, Zdn=1
    let encoding: u32 = 0x65038001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fsubr_z_p_zz_field_zdn_15_poweroftwominusone_8000_6503800f() {
    // Encoding: 0x6503800F
    // Test FSUBR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x6503800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fsubr_z_p_zz_field_zdn_31_max_8000_6503801f() {
    // Encoding: 0x6503801F
    // Test FSUBR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31, Zm=0
    let encoding: u32 = 0x6503801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsubr_z_p_zz_combo_0_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsubr_z_p_zz_special_size_0_size_variant_0_32768_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsubr_z_p_zz_special_size_1_size_variant_1_32768_65438000() {
    // Encoding: 0x65438000
    // Test FSUBR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, size=1, Pg=0, Zm=0
    let encoding: u32 = 0x65438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsubr_z_p_zz_special_size_2_size_variant_2_32768_65838000() {
    // Encoding: 0x65838000
    // Test FSUBR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65838000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsubr_z_p_zz_special_size_3_size_variant_3_32768_65c38000() {
    // Encoding: 0x65C38000
    // Test FSUBR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x65C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zz_invalid_0_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zz_invalid_1_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zz_invalid_2_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zz_invalid_3_8000_65038000() {
    // Encoding: 0x65038000
    // Test FSUBR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fsubr_z_p_zz_reg_write_0_65038000() {
    // Test FSUBR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65038000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65038000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FCVTZU_Z.P.Z_FP162H Tests
// ============================================================================

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_pg_0_min_a000_655ba000() {
    // Encoding: 0x655BA000
    // Test FCVTZU_Z.P.Z_FP162H field Pg = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_pg_1_poweroftwo_a000_655ba400() {
    // Encoding: 0x655BA400
    // Test FCVTZU_Z.P.Z_FP162H field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x655BA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zn_0_min_a000_655ba000() {
    // Encoding: 0x655BA000
    // Test FCVTZU_Z.P.Z_FP162H field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x655BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zn_1_poweroftwo_a000_655ba020() {
    // Encoding: 0x655BA020
    // Test FCVTZU_Z.P.Z_FP162H field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, Pg=0
    let encoding: u32 = 0x655BA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zn_30_poweroftwominusone_a000_655ba3c0() {
    // Encoding: 0x655BA3C0
    // Test FCVTZU_Z.P.Z_FP162H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zd=0, Pg=0
    let encoding: u32 = 0x655BA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zn_31_max_a000_655ba3e0() {
    // Encoding: 0x655BA3E0
    // Test FCVTZU_Z.P.Z_FP162H field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, Pg=0
    let encoding: u32 = 0x655BA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zd_0_min_a000_655ba000() {
    // Encoding: 0x655BA000
    // Test FCVTZU_Z.P.Z_FP162H field Zd = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zd_1_poweroftwo_a000_655ba001() {
    // Encoding: 0x655BA001
    // Test FCVTZU_Z.P.Z_FP162H field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0
    let encoding: u32 = 0x655BA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zd_30_poweroftwominusone_a000_655ba01e() {
    // Encoding: 0x655BA01E
    // Test FCVTZU_Z.P.Z_FP162H field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Pg=0, Zn=0
    let encoding: u32 = 0x655BA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_fp162h_field_zd_31_max_a000_655ba01f() {
    // Encoding: 0x655BA01F
    // Test FCVTZU_Z.P.Z_FP162H field Zd = 31 (Max)
    // Fields: Zn=0, Pg=0, Zd=31
    let encoding: u32 = 0x655BA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_fp162h_combo_0_a000_655ba000() {
    // Encoding: 0x655BA000
    // Test FCVTZU_Z.P.Z_FP162H field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_fp162h_invalid_0_a000_655ba000() {
    // Encoding: 0x655BA000
    // Test FCVTZU_Z.P.Z_FP162H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_fp162h_invalid_1_a000_655ba000() {
    // Encoding: 0x655BA000
    // Test FCVTZU_Z.P.Z_FP162H invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_pg_0_min_a000_655da000() {
    // Encoding: 0x655DA000
    // Test FCVTZU_Z.P.Z_FP162W field Pg = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x655DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_pg_1_poweroftwo_a000_655da400() {
    // Encoding: 0x655DA400
    // Test FCVTZU_Z.P.Z_FP162W field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0
    let encoding: u32 = 0x655DA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zn_0_min_a000_655da000() {
    // Encoding: 0x655DA000
    // Test FCVTZU_Z.P.Z_FP162W field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x655DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zn_1_poweroftwo_a000_655da020() {
    // Encoding: 0x655DA020
    // Test FCVTZU_Z.P.Z_FP162W field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, Pg=0
    let encoding: u32 = 0x655DA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zn_30_poweroftwominusone_a000_655da3c0() {
    // Encoding: 0x655DA3C0
    // Test FCVTZU_Z.P.Z_FP162W field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x655DA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zn_31_max_a000_655da3e0() {
    // Encoding: 0x655DA3E0
    // Test FCVTZU_Z.P.Z_FP162W field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, Pg=0
    let encoding: u32 = 0x655DA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zd_0_min_a000_655da000() {
    // Encoding: 0x655DA000
    // Test FCVTZU_Z.P.Z_FP162W field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x655DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zd_1_poweroftwo_a000_655da001() {
    // Encoding: 0x655DA001
    // Test FCVTZU_Z.P.Z_FP162W field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x655DA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zd_30_poweroftwominusone_a000_655da01e() {
    // Encoding: 0x655DA01E
    // Test FCVTZU_Z.P.Z_FP162W field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Pg=0, Zn=0
    let encoding: u32 = 0x655DA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_fp162w_field_zd_31_max_a000_655da01f() {
    // Encoding: 0x655DA01F
    // Test FCVTZU_Z.P.Z_FP162W field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Pg=0
    let encoding: u32 = 0x655DA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_fp162w_combo_0_a000_655da000() {
    // Encoding: 0x655DA000
    // Test FCVTZU_Z.P.Z_FP162W field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_fp162w_invalid_0_a000_655da000() {
    // Encoding: 0x655DA000
    // Test FCVTZU_Z.P.Z_FP162W invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_fp162w_invalid_1_a000_655da000() {
    // Encoding: 0x655DA000
    // Test FCVTZU_Z.P.Z_FP162W invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x655DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_pg_0_min_a000_655fa000() {
    // Encoding: 0x655FA000
    // Test FCVTZU_Z.P.Z_FP162X field Pg = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_pg_1_poweroftwo_a000_655fa400() {
    // Encoding: 0x655FA400
    // Test FCVTZU_Z.P.Z_FP162X field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zd=0, Zn=0
    let encoding: u32 = 0x655FA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zn_0_min_a000_655fa000() {
    // Encoding: 0x655FA000
    // Test FCVTZU_Z.P.Z_FP162X field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x655FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zn_1_poweroftwo_a000_655fa020() {
    // Encoding: 0x655FA020
    // Test FCVTZU_Z.P.Z_FP162X field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x655FA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zn_30_poweroftwominusone_a000_655fa3c0() {
    // Encoding: 0x655FA3C0
    // Test FCVTZU_Z.P.Z_FP162X field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x655FA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zn_31_max_a000_655fa3e0() {
    // Encoding: 0x655FA3E0
    // Test FCVTZU_Z.P.Z_FP162X field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x655FA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zd_0_min_a000_655fa000() {
    // Encoding: 0x655FA000
    // Test FCVTZU_Z.P.Z_FP162X field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x655FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zd_1_poweroftwo_a000_655fa001() {
    // Encoding: 0x655FA001
    // Test FCVTZU_Z.P.Z_FP162X field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x655FA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zd_30_poweroftwominusone_a000_655fa01e() {
    // Encoding: 0x655FA01E
    // Test FCVTZU_Z.P.Z_FP162X field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x655FA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_fp162x_field_zd_31_max_a000_655fa01f() {
    // Encoding: 0x655FA01F
    // Test FCVTZU_Z.P.Z_FP162X field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Pg=0
    let encoding: u32 = 0x655FA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_fp162x_combo_0_a000_655fa000() {
    // Encoding: 0x655FA000
    // Test FCVTZU_Z.P.Z_FP162X field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x655FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_fp162x_invalid_0_a000_655fa000() {
    // Encoding: 0x655FA000
    // Test FCVTZU_Z.P.Z_FP162X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_fp162x_invalid_1_a000_655fa000() {
    // Encoding: 0x655FA000
    // Test FCVTZU_Z.P.Z_FP162X invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x655FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_s2w_field_pg_0_min_a000_659da000() {
    // Encoding: 0x659DA000
    // Test FCVTZU_Z.P.Z_S2W field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x659DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_s2w_field_pg_1_poweroftwo_a000_659da400() {
    // Encoding: 0x659DA400
    // Test FCVTZU_Z.P.Z_S2W field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0
    let encoding: u32 = 0x659DA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zn_0_min_a000_659da000() {
    // Encoding: 0x659DA000
    // Test FCVTZU_Z.P.Z_S2W field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x659DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zn_1_poweroftwo_a000_659da020() {
    // Encoding: 0x659DA020
    // Test FCVTZU_Z.P.Z_S2W field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zd=0
    let encoding: u32 = 0x659DA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zn_30_poweroftwominusone_a000_659da3c0() {
    // Encoding: 0x659DA3C0
    // Test FCVTZU_Z.P.Z_S2W field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x659DA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zn_31_max_a000_659da3e0() {
    // Encoding: 0x659DA3E0
    // Test FCVTZU_Z.P.Z_S2W field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x659DA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zd_0_min_a000_659da000() {
    // Encoding: 0x659DA000
    // Test FCVTZU_Z.P.Z_S2W field Zd = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x659DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zd_1_poweroftwo_a000_659da001() {
    // Encoding: 0x659DA001
    // Test FCVTZU_Z.P.Z_S2W field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0
    let encoding: u32 = 0x659DA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zd_30_poweroftwominusone_a000_659da01e() {
    // Encoding: 0x659DA01E
    // Test FCVTZU_Z.P.Z_S2W field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=30, Zn=0
    let encoding: u32 = 0x659DA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_s2w_field_zd_31_max_a000_659da01f() {
    // Encoding: 0x659DA01F
    // Test FCVTZU_Z.P.Z_S2W field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, Pg=0
    let encoding: u32 = 0x659DA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_s2w_combo_0_a000_659da000() {
    // Encoding: 0x659DA000
    // Test FCVTZU_Z.P.Z_S2W field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x659DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_s2w_invalid_0_a000_659da000() {
    // Encoding: 0x659DA000
    // Test FCVTZU_Z.P.Z_S2W invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x659DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_s2w_invalid_1_a000_659da000() {
    // Encoding: 0x659DA000
    // Test FCVTZU_Z.P.Z_S2W invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x659DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_s2x_field_pg_0_min_a000_65dda000() {
    // Encoding: 0x65DDA000
    // Test FCVTZU_Z.P.Z_S2X field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_s2x_field_pg_1_poweroftwo_a000_65dda400() {
    // Encoding: 0x65DDA400
    // Test FCVTZU_Z.P.Z_S2X field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zd=0
    let encoding: u32 = 0x65DDA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zn_0_min_a000_65dda000() {
    // Encoding: 0x65DDA000
    // Test FCVTZU_Z.P.Z_S2X field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zn_1_poweroftwo_a000_65dda020() {
    // Encoding: 0x65DDA020
    // Test FCVTZU_Z.P.Z_S2X field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zd=0
    let encoding: u32 = 0x65DDA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zn_30_poweroftwominusone_a000_65dda3c0() {
    // Encoding: 0x65DDA3C0
    // Test FCVTZU_Z.P.Z_S2X field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zd=0, Pg=0
    let encoding: u32 = 0x65DDA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zn_31_max_a000_65dda3e0() {
    // Encoding: 0x65DDA3E0
    // Test FCVTZU_Z.P.Z_S2X field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x65DDA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zd_0_min_a000_65dda000() {
    // Encoding: 0x65DDA000
    // Test FCVTZU_Z.P.Z_S2X field Zd = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zd_1_poweroftwo_a000_65dda001() {
    // Encoding: 0x65DDA001
    // Test FCVTZU_Z.P.Z_S2X field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0
    let encoding: u32 = 0x65DDA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zd_30_poweroftwominusone_a000_65dda01e() {
    // Encoding: 0x65DDA01E
    // Test FCVTZU_Z.P.Z_S2X field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Pg=0, Zn=0
    let encoding: u32 = 0x65DDA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_s2x_field_zd_31_max_a000_65dda01f() {
    // Encoding: 0x65DDA01F
    // Test FCVTZU_Z.P.Z_S2X field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, Zn=0
    let encoding: u32 = 0x65DDA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_s2x_combo_0_a000_65dda000() {
    // Encoding: 0x65DDA000
    // Test FCVTZU_Z.P.Z_S2X field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_s2x_invalid_0_a000_65dda000() {
    // Encoding: 0x65DDA000
    // Test FCVTZU_Z.P.Z_S2X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_s2x_invalid_1_a000_65dda000() {
    // Encoding: 0x65DDA000
    // Test FCVTZU_Z.P.Z_S2X invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_d2w_field_pg_0_min_a000_65d9a000() {
    // Encoding: 0x65D9A000
    // Test FCVTZU_Z.P.Z_D2W field Pg = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_d2w_field_pg_1_poweroftwo_a000_65d9a400() {
    // Encoding: 0x65D9A400
    // Test FCVTZU_Z.P.Z_D2W field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zd=0, Zn=0
    let encoding: u32 = 0x65D9A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zn_0_min_a000_65d9a000() {
    // Encoding: 0x65D9A000
    // Test FCVTZU_Z.P.Z_D2W field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zn_1_poweroftwo_a000_65d9a020() {
    // Encoding: 0x65D9A020
    // Test FCVTZU_Z.P.Z_D2W field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x65D9A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zn_30_poweroftwominusone_a000_65d9a3c0() {
    // Encoding: 0x65D9A3C0
    // Test FCVTZU_Z.P.Z_D2W field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x65D9A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zn_31_max_a000_65d9a3e0() {
    // Encoding: 0x65D9A3E0
    // Test FCVTZU_Z.P.Z_D2W field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x65D9A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zd_0_min_a000_65d9a000() {
    // Encoding: 0x65D9A000
    // Test FCVTZU_Z.P.Z_D2W field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zd_1_poweroftwo_a000_65d9a001() {
    // Encoding: 0x65D9A001
    // Test FCVTZU_Z.P.Z_D2W field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, Pg=0
    let encoding: u32 = 0x65D9A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zd_30_poweroftwominusone_a000_65d9a01e() {
    // Encoding: 0x65D9A01E
    // Test FCVTZU_Z.P.Z_D2W field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x65D9A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_d2w_field_zd_31_max_a000_65d9a01f() {
    // Encoding: 0x65D9A01F
    // Test FCVTZU_Z.P.Z_D2W field Zd = 31 (Max)
    // Fields: Pg=0, Zn=0, Zd=31
    let encoding: u32 = 0x65D9A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_d2w_combo_0_a000_65d9a000() {
    // Encoding: 0x65D9A000
    // Test FCVTZU_Z.P.Z_D2W field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_d2w_invalid_0_a000_65d9a000() {
    // Encoding: 0x65D9A000
    // Test FCVTZU_Z.P.Z_D2W invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_d2w_invalid_1_a000_65d9a000() {
    // Encoding: 0x65D9A000
    // Test FCVTZU_Z.P.Z_D2W invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvtzu_z_p_z_d2x_field_pg_0_min_a000_65dfa000() {
    // Encoding: 0x65DFA000
    // Test FCVTZU_Z.P.Z_D2X field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvtzu_z_p_z_d2x_field_pg_1_poweroftwo_a000_65dfa400() {
    // Encoding: 0x65DFA400
    // Test FCVTZU_Z.P.Z_D2X field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x65DFA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zn_0_min_a000_65dfa000() {
    // Encoding: 0x65DFA000
    // Test FCVTZU_Z.P.Z_D2X field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zn_1_poweroftwo_a000_65dfa020() {
    // Encoding: 0x65DFA020
    // Test FCVTZU_Z.P.Z_D2X field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x65DFA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zn_30_poweroftwominusone_a000_65dfa3c0() {
    // Encoding: 0x65DFA3C0
    // Test FCVTZU_Z.P.Z_D2X field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x65DFA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zn_31_max_a000_65dfa3e0() {
    // Encoding: 0x65DFA3E0
    // Test FCVTZU_Z.P.Z_D2X field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x65DFA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zd_0_min_a000_65dfa000() {
    // Encoding: 0x65DFA000
    // Test FCVTZU_Z.P.Z_D2X field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zd_1_poweroftwo_a000_65dfa001() {
    // Encoding: 0x65DFA001
    // Test FCVTZU_Z.P.Z_D2X field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zd=1
    let encoding: u32 = 0x65DFA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zd_30_poweroftwominusone_a000_65dfa01e() {
    // Encoding: 0x65DFA01E
    // Test FCVTZU_Z.P.Z_D2X field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Pg=0
    let encoding: u32 = 0x65DFA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvtzu_z_p_z_d2x_field_zd_31_max_a000_65dfa01f() {
    // Encoding: 0x65DFA01F
    // Test FCVTZU_Z.P.Z_D2X field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, Zn=0
    let encoding: u32 = 0x65DFA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvtzu_z_p_z_d2x_combo_0_a000_65dfa000() {
    // Encoding: 0x65DFA000
    // Test FCVTZU_Z.P.Z_D2X field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_d2x_invalid_0_a000_65dfa000() {
    // Encoding: 0x65DFA000
    // Test FCVTZU_Z.P.Z_D2X invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvtzu_z_p_z_d2x_invalid_1_a000_65dfa000() {
    // Encoding: 0x65DFA000
    // Test FCVTZU_Z.P.Z_D2X invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVTZU_Z.P.Z_FP162H
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_fp162h_reg_write_0_655ba000() {
    // Test FCVTZU_Z.P.Z_FP162H register write: SimdFromField("d")
    // Encoding: 0x655BA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x655BA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZU_Z.P.Z_FP162W
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_fp162w_reg_write_0_655da000() {
    // Test FCVTZU_Z.P.Z_FP162W register write: SimdFromField("d")
    // Encoding: 0x655DA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x655DA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZU_Z.P.Z_FP162X
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_fp162x_reg_write_0_655fa000() {
    // Test FCVTZU_Z.P.Z_FP162X register write: SimdFromField("d")
    // Encoding: 0x655FA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x655FA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZU_Z.P.Z_S2W
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_s2w_reg_write_0_659da000() {
    // Test FCVTZU_Z.P.Z_S2W register write: SimdFromField("d")
    // Encoding: 0x659DA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x659DA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZU_Z.P.Z_S2X
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_s2x_reg_write_0_65dda000() {
    // Test FCVTZU_Z.P.Z_S2X register write: SimdFromField("d")
    // Encoding: 0x65DDA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65DDA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZU_Z.P.Z_D2W
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_d2w_reg_write_0_65d9a000() {
    // Test FCVTZU_Z.P.Z_D2W register write: SimdFromField("d")
    // Encoding: 0x65D9A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65D9A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVTZU_Z.P.Z_D2X
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvtzu_z_p_z_d2x_reg_write_0_65dfa000() {
    // Test FCVTZU_Z.P.Z_D2X register write: SimdFromField("d")
    // Encoding: 0x65DFA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65DFA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FCVT_Z.P.Z_H2S Tests
// ============================================================================

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvt_z_p_z_h2s_field_pg_0_min_a000_6589a000() {
    // Encoding: 0x6589A000
    // Test FCVT_Z.P.Z_H2S field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x6589A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvt_z_p_z_h2s_field_pg_1_poweroftwo_a000_6589a400() {
    // Encoding: 0x6589A400
    // Test FCVT_Z.P.Z_H2S field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zd=0
    let encoding: u32 = 0x6589A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_h2s_field_zn_0_min_a000_6589a000() {
    // Encoding: 0x6589A000
    // Test FCVT_Z.P.Z_H2S field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6589A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_h2s_field_zn_1_poweroftwo_a000_6589a020() {
    // Encoding: 0x6589A020
    // Test FCVT_Z.P.Z_H2S field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x6589A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_h2s_field_zn_30_poweroftwominusone_a000_6589a3c0() {
    // Encoding: 0x6589A3C0
    // Test FCVT_Z.P.Z_H2S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=0, Zn=30
    let encoding: u32 = 0x6589A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_h2s_field_zn_31_max_a000_6589a3e0() {
    // Encoding: 0x6589A3E0
    // Test FCVT_Z.P.Z_H2S field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, Zd=0
    let encoding: u32 = 0x6589A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_h2s_field_zd_0_min_a000_6589a000() {
    // Encoding: 0x6589A000
    // Test FCVT_Z.P.Z_H2S field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6589A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_h2s_field_zd_1_poweroftwo_a000_6589a001() {
    // Encoding: 0x6589A001
    // Test FCVT_Z.P.Z_H2S field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x6589A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_h2s_field_zd_30_poweroftwominusone_a000_6589a01e() {
    // Encoding: 0x6589A01E
    // Test FCVT_Z.P.Z_H2S field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Pg=0
    let encoding: u32 = 0x6589A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_h2s_field_zd_31_max_a000_6589a01f() {
    // Encoding: 0x6589A01F
    // Test FCVT_Z.P.Z_H2S field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, Pg=0
    let encoding: u32 = 0x6589A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvt_z_p_z_h2s_combo_0_a000_6589a000() {
    // Encoding: 0x6589A000
    // Test FCVT_Z.P.Z_H2S field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6589A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_h2s_invalid_0_a000_6589a000() {
    // Encoding: 0x6589A000
    // Test FCVT_Z.P.Z_H2S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x6589A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_h2s_invalid_1_a000_6589a000() {
    // Encoding: 0x6589A000
    // Test FCVT_Z.P.Z_H2S invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x6589A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvt_z_p_z_h2d_field_pg_0_min_a000_65c9a000() {
    // Encoding: 0x65C9A000
    // Test FCVT_Z.P.Z_H2D field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvt_z_p_z_h2d_field_pg_1_poweroftwo_a000_65c9a400() {
    // Encoding: 0x65C9A400
    // Test FCVT_Z.P.Z_H2D field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x65C9A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_h2d_field_zn_0_min_a000_65c9a000() {
    // Encoding: 0x65C9A000
    // Test FCVT_Z.P.Z_H2D field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65C9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_h2d_field_zn_1_poweroftwo_a000_65c9a020() {
    // Encoding: 0x65C9A020
    // Test FCVT_Z.P.Z_H2D field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Pg=0, Zd=0
    let encoding: u32 = 0x65C9A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_h2d_field_zn_30_poweroftwominusone_a000_65c9a3c0() {
    // Encoding: 0x65C9A3C0
    // Test FCVT_Z.P.Z_H2D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x65C9A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_h2d_field_zn_31_max_a000_65c9a3e0() {
    // Encoding: 0x65C9A3E0
    // Test FCVT_Z.P.Z_H2D field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, Zd=0
    let encoding: u32 = 0x65C9A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_h2d_field_zd_0_min_a000_65c9a000() {
    // Encoding: 0x65C9A000
    // Test FCVT_Z.P.Z_H2D field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65C9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_h2d_field_zd_1_poweroftwo_a000_65c9a001() {
    // Encoding: 0x65C9A001
    // Test FCVT_Z.P.Z_H2D field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Pg=0, Zn=0
    let encoding: u32 = 0x65C9A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_h2d_field_zd_30_poweroftwominusone_a000_65c9a01e() {
    // Encoding: 0x65C9A01E
    // Test FCVT_Z.P.Z_H2D field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x65C9A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_h2d_field_zd_31_max_a000_65c9a01f() {
    // Encoding: 0x65C9A01F
    // Test FCVT_Z.P.Z_H2D field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Pg=0
    let encoding: u32 = 0x65C9A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvt_z_p_z_h2d_combo_0_a000_65c9a000() {
    // Encoding: 0x65C9A000
    // Test FCVT_Z.P.Z_H2D field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65C9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_h2d_invalid_0_a000_65c9a000() {
    // Encoding: 0x65C9A000
    // Test FCVT_Z.P.Z_H2D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65C9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_h2d_invalid_1_a000_65c9a000() {
    // Encoding: 0x65C9A000
    // Test FCVT_Z.P.Z_H2D invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvt_z_p_z_s2h_field_pg_0_min_a000_6588a000() {
    // Encoding: 0x6588A000
    // Test FCVT_Z.P.Z_S2H field Pg = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x6588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvt_z_p_z_s2h_field_pg_1_poweroftwo_a000_6588a400() {
    // Encoding: 0x6588A400
    // Test FCVT_Z.P.Z_S2H field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x6588A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_s2h_field_zn_0_min_a000_6588a000() {
    // Encoding: 0x6588A000
    // Test FCVT_Z.P.Z_S2H field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x6588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_s2h_field_zn_1_poweroftwo_a000_6588a020() {
    // Encoding: 0x6588A020
    // Test FCVT_Z.P.Z_S2H field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zd=0
    let encoding: u32 = 0x6588A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_s2h_field_zn_30_poweroftwominusone_a000_6588a3c0() {
    // Encoding: 0x6588A3C0
    // Test FCVT_Z.P.Z_S2H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zd=0, Pg=0
    let encoding: u32 = 0x6588A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_s2h_field_zn_31_max_a000_6588a3e0() {
    // Encoding: 0x6588A3E0
    // Test FCVT_Z.P.Z_S2H field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x6588A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_s2h_field_zd_0_min_a000_6588a000() {
    // Encoding: 0x6588A000
    // Test FCVT_Z.P.Z_S2H field Zd = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x6588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_s2h_field_zd_1_poweroftwo_a000_6588a001() {
    // Encoding: 0x6588A001
    // Test FCVT_Z.P.Z_S2H field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1, Pg=0
    let encoding: u32 = 0x6588A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_s2h_field_zd_30_poweroftwominusone_a000_6588a01e() {
    // Encoding: 0x6588A01E
    // Test FCVT_Z.P.Z_S2H field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Pg=0, Zn=0
    let encoding: u32 = 0x6588A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_s2h_field_zd_31_max_a000_6588a01f() {
    // Encoding: 0x6588A01F
    // Test FCVT_Z.P.Z_S2H field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Pg=0
    let encoding: u32 = 0x6588A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvt_z_p_z_s2h_combo_0_a000_6588a000() {
    // Encoding: 0x6588A000
    // Test FCVT_Z.P.Z_S2H field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x6588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_s2h_invalid_0_a000_6588a000() {
    // Encoding: 0x6588A000
    // Test FCVT_Z.P.Z_S2H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x6588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_s2h_invalid_1_a000_6588a000() {
    // Encoding: 0x6588A000
    // Test FCVT_Z.P.Z_S2H invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6588A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvt_z_p_z_s2d_field_pg_0_min_a000_65cba000() {
    // Encoding: 0x65CBA000
    // Test FCVT_Z.P.Z_S2D field Pg = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65CBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvt_z_p_z_s2d_field_pg_1_poweroftwo_a000_65cba400() {
    // Encoding: 0x65CBA400
    // Test FCVT_Z.P.Z_S2D field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x65CBA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_s2d_field_zn_0_min_a000_65cba000() {
    // Encoding: 0x65CBA000
    // Test FCVT_Z.P.Z_S2D field Zn = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x65CBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_s2d_field_zn_1_poweroftwo_a000_65cba020() {
    // Encoding: 0x65CBA020
    // Test FCVT_Z.P.Z_S2D field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x65CBA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_s2d_field_zn_30_poweroftwominusone_a000_65cba3c0() {
    // Encoding: 0x65CBA3C0
    // Test FCVT_Z.P.Z_S2D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x65CBA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_s2d_field_zn_31_max_a000_65cba3e0() {
    // Encoding: 0x65CBA3E0
    // Test FCVT_Z.P.Z_S2D field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, Zd=0
    let encoding: u32 = 0x65CBA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_s2d_field_zd_0_min_a000_65cba000() {
    // Encoding: 0x65CBA000
    // Test FCVT_Z.P.Z_S2D field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65CBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_s2d_field_zd_1_poweroftwo_a000_65cba001() {
    // Encoding: 0x65CBA001
    // Test FCVT_Z.P.Z_S2D field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x65CBA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_s2d_field_zd_30_poweroftwominusone_a000_65cba01e() {
    // Encoding: 0x65CBA01E
    // Test FCVT_Z.P.Z_S2D field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zd=30
    let encoding: u32 = 0x65CBA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_s2d_field_zd_31_max_a000_65cba01f() {
    // Encoding: 0x65CBA01F
    // Test FCVT_Z.P.Z_S2D field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, Zn=0
    let encoding: u32 = 0x65CBA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvt_z_p_z_s2d_combo_0_a000_65cba000() {
    // Encoding: 0x65CBA000
    // Test FCVT_Z.P.Z_S2D field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65CBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_s2d_invalid_0_a000_65cba000() {
    // Encoding: 0x65CBA000
    // Test FCVT_Z.P.Z_S2D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65CBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_s2d_invalid_1_a000_65cba000() {
    // Encoding: 0x65CBA000
    // Test FCVT_Z.P.Z_S2D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65CBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvt_z_p_z_d2h_field_pg_0_min_a000_65c8a000() {
    // Encoding: 0x65C8A000
    // Test FCVT_Z.P.Z_D2H field Pg = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvt_z_p_z_d2h_field_pg_1_poweroftwo_a000_65c8a400() {
    // Encoding: 0x65C8A400
    // Test FCVT_Z.P.Z_D2H field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x65C8A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_d2h_field_zn_0_min_a000_65c8a000() {
    // Encoding: 0x65C8A000
    // Test FCVT_Z.P.Z_D2H field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_d2h_field_zn_1_poweroftwo_a000_65c8a020() {
    // Encoding: 0x65C8A020
    // Test FCVT_Z.P.Z_D2H field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, Pg=0
    let encoding: u32 = 0x65C8A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_d2h_field_zn_30_poweroftwominusone_a000_65c8a3c0() {
    // Encoding: 0x65C8A3C0
    // Test FCVT_Z.P.Z_D2H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x65C8A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_d2h_field_zn_31_max_a000_65c8a3e0() {
    // Encoding: 0x65C8A3E0
    // Test FCVT_Z.P.Z_D2H field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, Pg=0
    let encoding: u32 = 0x65C8A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_d2h_field_zd_0_min_a000_65c8a000() {
    // Encoding: 0x65C8A000
    // Test FCVT_Z.P.Z_D2H field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_d2h_field_zd_1_poweroftwo_a000_65c8a001() {
    // Encoding: 0x65C8A001
    // Test FCVT_Z.P.Z_D2H field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x65C8A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_d2h_field_zd_30_poweroftwominusone_a000_65c8a01e() {
    // Encoding: 0x65C8A01E
    // Test FCVT_Z.P.Z_D2H field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x65C8A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_d2h_field_zd_31_max_a000_65c8a01f() {
    // Encoding: 0x65C8A01F
    // Test FCVT_Z.P.Z_D2H field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, Zn=0
    let encoding: u32 = 0x65C8A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvt_z_p_z_d2h_combo_0_a000_65c8a000() {
    // Encoding: 0x65C8A000
    // Test FCVT_Z.P.Z_D2H field combination: Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_d2h_invalid_0_a000_65c8a000() {
    // Encoding: 0x65C8A000
    // Test FCVT_Z.P.Z_D2H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_d2h_invalid_1_a000_65c8a000() {
    // Encoding: 0x65C8A000
    // Test FCVT_Z.P.Z_D2H invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcvt_z_p_z_d2s_field_pg_0_min_a000_65caa000() {
    // Encoding: 0x65CAA000
    // Test FCVT_Z.P.Z_D2S field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65CAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcvt_z_p_z_d2s_field_pg_1_poweroftwo_a000_65caa400() {
    // Encoding: 0x65CAA400
    // Test FCVT_Z.P.Z_D2S field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0
    let encoding: u32 = 0x65CAA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_d2s_field_zn_0_min_a000_65caa000() {
    // Encoding: 0x65CAA000
    // Test FCVT_Z.P.Z_D2S field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65CAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_d2s_field_zn_1_poweroftwo_a000_65caa020() {
    // Encoding: 0x65CAA020
    // Test FCVT_Z.P.Z_D2S field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x65CAA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_d2s_field_zn_30_poweroftwominusone_a000_65caa3c0() {
    // Encoding: 0x65CAA3C0
    // Test FCVT_Z.P.Z_D2S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=0, Zn=30
    let encoding: u32 = 0x65CAA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_d2s_field_zn_31_max_a000_65caa3e0() {
    // Encoding: 0x65CAA3E0
    // Test FCVT_Z.P.Z_D2S field Zn = 31 (Max)
    // Fields: Pg=0, Zd=0, Zn=31
    let encoding: u32 = 0x65CAA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcvt_z_p_z_d2s_field_zd_0_min_a000_65caa000() {
    // Encoding: 0x65CAA000
    // Test FCVT_Z.P.Z_D2S field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65CAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcvt_z_p_z_d2s_field_zd_1_poweroftwo_a000_65caa001() {
    // Encoding: 0x65CAA001
    // Test FCVT_Z.P.Z_D2S field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x65CAA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcvt_z_p_z_d2s_field_zd_30_poweroftwominusone_a000_65caa01e() {
    // Encoding: 0x65CAA01E
    // Test FCVT_Z.P.Z_D2S field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zd=30
    let encoding: u32 = 0x65CAA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcvt_z_p_z_d2s_field_zd_31_max_a000_65caa01f() {
    // Encoding: 0x65CAA01F
    // Test FCVT_Z.P.Z_D2S field Zd = 31 (Max)
    // Fields: Pg=0, Zn=0, Zd=31
    let encoding: u32 = 0x65CAA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pg=0 (register index 0 (first register))
#[test]
fn test_fcvt_z_p_z_d2s_combo_0_a000_65caa000() {
    // Encoding: 0x65CAA000
    // Test FCVT_Z.P.Z_D2S field combination: Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65CAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_d2s_invalid_0_a000_65caa000() {
    // Encoding: 0x65CAA000
    // Test FCVT_Z.P.Z_D2S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x65CAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcvt_z_p_z_d2s_invalid_1_a000_65caa000() {
    // Encoding: 0x65CAA000
    // Test FCVT_Z.P.Z_D2S invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65CAA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCVT_Z.P.Z_H2S
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvt_z_p_z_h2s_reg_write_0_6589a000() {
    // Test FCVT_Z.P.Z_H2S register write: SimdFromField("d")
    // Encoding: 0x6589A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6589A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVT_Z.P.Z_H2D
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvt_z_p_z_h2d_reg_write_0_65c9a000() {
    // Test FCVT_Z.P.Z_H2D register write: SimdFromField("d")
    // Encoding: 0x65C9A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65C9A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVT_Z.P.Z_S2H
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvt_z_p_z_s2h_reg_write_0_6588a000() {
    // Test FCVT_Z.P.Z_S2H register write: SimdFromField("d")
    // Encoding: 0x6588A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6588A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVT_Z.P.Z_S2D
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvt_z_p_z_s2d_reg_write_0_65cba000() {
    // Test FCVT_Z.P.Z_S2D register write: SimdFromField("d")
    // Encoding: 0x65CBA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65CBA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVT_Z.P.Z_D2H
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvt_z_p_z_d2h_reg_write_0_65c8a000() {
    // Test FCVT_Z.P.Z_D2H register write: SimdFromField("d")
    // Encoding: 0x65C8A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65C8A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FCVT_Z.P.Z_D2S
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcvt_z_p_z_d2s_reg_write_0_65caa000() {
    // Test FCVT_Z.P.Z_D2S register write: SimdFromField("d")
    // Encoding: 0x65CAA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65CAA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUB_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsub_z_p_zz_field_size_0_min_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsub_z_p_zz_field_size_1_poweroftwo_8000_65418000() {
    // Encoding: 0x65418000
    // Test FSUB_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, Pg=0, Zm=0
    let encoding: u32 = 0x65418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsub_z_p_zz_field_size_2_poweroftwo_8000_65818000() {
    // Encoding: 0x65818000
    // Test FSUB_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x65818000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsub_z_p_zz_field_size_3_max_8000_65c18000() {
    // Encoding: 0x65C18000
    // Test FSUB_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsub_z_p_zz_field_pg_0_min_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsub_z_p_zz_field_pg_1_poweroftwo_8000_65018400() {
    // Encoding: 0x65018400
    // Test FSUB_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, Pg=1, size=0
    let encoding: u32 = 0x65018400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fsub_z_p_zz_field_zm_0_min_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fsub_z_p_zz_field_zm_1_poweroftwo_8000_65018020() {
    // Encoding: 0x65018020
    // Test FSUB_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=1, Zdn=0, size=0
    let encoding: u32 = 0x65018020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fsub_z_p_zz_field_zm_30_poweroftwominusone_8000_650183c0() {
    // Encoding: 0x650183C0
    // Test FSUB_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Pg=0, Zm=30, size=0
    let encoding: u32 = 0x650183C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fsub_z_p_zz_field_zm_31_max_8000_650183e0() {
    // Encoding: 0x650183E0
    // Test FSUB_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, size=0, Zdn=0
    let encoding: u32 = 0x650183E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsub_z_p_zz_field_zdn_0_min_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fsub_z_p_zz_field_zdn_1_poweroftwo_8000_65018001() {
    // Encoding: 0x65018001
    // Test FSUB_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=1, size=0, Zm=0
    let encoding: u32 = 0x65018001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fsub_z_p_zz_field_zdn_15_poweroftwominusone_8000_6501800f() {
    // Encoding: 0x6501800F
    // Test FSUB_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zdn=15, Pg=0
    let encoding: u32 = 0x6501800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fsub_z_p_zz_field_zdn_31_max_8000_6501801f() {
    // Encoding: 0x6501801F
    // Test FSUB_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, Pg=0, Zm=0
    let encoding: u32 = 0x6501801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsub_z_p_zz_combo_0_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsub_z_p_zz_special_size_0_size_variant_0_32768_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsub_z_p_zz_special_size_1_size_variant_1_32768_65418000() {
    // Encoding: 0x65418000
    // Test FSUB_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x65418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsub_z_p_zz_special_size_2_size_variant_2_32768_65818000() {
    // Encoding: 0x65818000
    // Test FSUB_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x65818000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsub_z_p_zz_special_size_3_size_variant_3_32768_65c18000() {
    // Encoding: 0x65C18000
    // Test FSUB_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x65C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zz_invalid_0_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zz_invalid_1_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zz_invalid_2_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zz_invalid_3_8000_65018000() {
    // Encoding: 0x65018000
    // Test FSUB_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fsub_z_p_zz_reg_write_0_65018000() {
    // Test FSUB_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65018000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65018000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMUL_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmul_z_p_zs_field_size_0_min_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, i1=0, size=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmul_z_p_zs_field_size_1_poweroftwo_8000_655a8000() {
    // Encoding: 0x655A8000
    // Test FMUL_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: i1=0, Zdn=0, Pg=0, size=1
    let encoding: u32 = 0x655A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmul_z_p_zs_field_size_2_poweroftwo_8000_659a8000() {
    // Encoding: 0x659A8000
    // Test FMUL_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: size=2, i1=0, Pg=0, Zdn=0
    let encoding: u32 = 0x659A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmul_z_p_zs_field_size_3_max_8000_65da8000() {
    // Encoding: 0x65DA8000
    // Test FMUL_Z.P.ZS__ field size = 3 (Max)
    // Fields: i1=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x65DA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmul_z_p_zs_field_pg_0_min_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, i1=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmul_z_p_zs_field_pg_1_poweroftwo_8000_651a8400() {
    // Encoding: 0x651A8400
    // Test FMUL_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, i1=0, Zdn=0, Pg=1
    let encoding: u32 = 0x651A8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_p_zs_field_i1_0_min_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, i1=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmul_z_p_zs_field_i1_1_max_8000_651a8020() {
    // Encoding: 0x651A8020
    // Test FMUL_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: Zdn=0, size=0, Pg=0, i1=1
    let encoding: u32 = 0x651A8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_p_zs_field_zdn_0_min_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: i1=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmul_z_p_zs_field_zdn_1_poweroftwo_8000_651a8001() {
    // Encoding: 0x651A8001
    // Test FMUL_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: i1=0, size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x651A8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmul_z_p_zs_field_zdn_15_poweroftwominusone_8000_651a800f() {
    // Encoding: 0x651A800F
    // Test FMUL_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, i1=0, Zdn=15
    let encoding: u32 = 0x651A800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmul_z_p_zs_field_zdn_31_max_8000_651a801f() {
    // Encoding: 0x651A801F
    // Test FMUL_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: i1=0, size=0, Zdn=31, Pg=0
    let encoding: u32 = 0x651A801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmul_z_p_zs_combo_0_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: i1=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmul_z_p_zs_special_size_0_size_variant_0_32768_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: size=0, i1=0, Pg=0, Zdn=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmul_z_p_zs_special_size_1_size_variant_1_32768_655a8000() {
    // Encoding: 0x655A8000
    // Test FMUL_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, i1=0, Zdn=0, size=1
    let encoding: u32 = 0x655A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmul_z_p_zs_special_size_2_size_variant_2_32768_659a8000() {
    // Encoding: 0x659A8000
    // Test FMUL_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, size=2, Pg=0, i1=0
    let encoding: u32 = 0x659A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmul_z_p_zs_special_size_3_size_variant_3_32768_65da8000() {
    // Encoding: 0x65DA8000
    // Test FMUL_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Pg=0, i1=0
    let encoding: u32 = 0x65DA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zs_invalid_0_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zs_invalid_1_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zs_invalid_2_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, i1=0, Zdn=0, size=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zs_invalid_3_8000_651a8000() {
    // Encoding: 0x651A8000
    // Test FMUL_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x651A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmul_z_p_zs_reg_write_0_651a8000() {
    // Test FMUL_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651A8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651A8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMINNM_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fminnm_z_p_zs_field_size_0_min_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, i1=0, Pg=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fminnm_z_p_zs_field_size_1_poweroftwo_8000_655d8000() {
    // Encoding: 0x655D8000
    // Test FMINNM_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zdn=0, i1=0, Pg=0
    let encoding: u32 = 0x655D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fminnm_z_p_zs_field_size_2_poweroftwo_8000_659d8000() {
    // Encoding: 0x659D8000
    // Test FMINNM_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zdn=0, i1=0
    let encoding: u32 = 0x659D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fminnm_z_p_zs_field_size_3_max_8000_65dd8000() {
    // Encoding: 0x65DD8000
    // Test FMINNM_Z.P.ZS__ field size = 3 (Max)
    // Fields: size=3, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x65DD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fminnm_z_p_zs_field_pg_0_min_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, i1=0, Pg=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fminnm_z_p_zs_field_pg_1_poweroftwo_8000_651d8400() {
    // Encoding: 0x651D8400
    // Test FMINNM_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zdn=0, i1=0
    let encoding: u32 = 0x651D8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fminnm_z_p_zs_field_i1_0_min_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: size=0, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fminnm_z_p_zs_field_i1_1_max_8000_651d8020() {
    // Encoding: 0x651D8020
    // Test FMINNM_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: size=0, Zdn=0, Pg=0, i1=1
    let encoding: u32 = 0x651D8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fminnm_z_p_zs_field_zdn_0_min_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Pg=0, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fminnm_z_p_zs_field_zdn_1_poweroftwo_8000_651d8001() {
    // Encoding: 0x651D8001
    // Test FMINNM_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1, i1=0
    let encoding: u32 = 0x651D8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fminnm_z_p_zs_field_zdn_15_poweroftwominusone_8000_651d800f() {
    // Encoding: 0x651D800F
    // Test FMINNM_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=15, i1=0, Pg=0
    let encoding: u32 = 0x651D800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fminnm_z_p_zs_field_zdn_31_max_8000_651d801f() {
    // Encoding: 0x651D801F
    // Test FMINNM_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, i1=0, Pg=0, size=0
    let encoding: u32 = 0x651D801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fminnm_z_p_zs_combo_0_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: size=0, i1=0, Zdn=0, Pg=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fminnm_z_p_zs_special_size_0_size_variant_0_32768_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: i1=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fminnm_z_p_zs_special_size_1_size_variant_1_32768_655d8000() {
    // Encoding: 0x655D8000
    // Test FMINNM_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: i1=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x655D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fminnm_z_p_zs_special_size_2_size_variant_2_32768_659d8000() {
    // Encoding: 0x659D8000
    // Test FMINNM_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x659D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fminnm_z_p_zs_special_size_3_size_variant_3_32768_65dd8000() {
    // Encoding: 0x65DD8000
    // Test FMINNM_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, i1=0, size=3, Zdn=0
    let encoding: u32 = 0x65DD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zs_invalid_0_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Pg=0, size=0, i1=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zs_invalid_1_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, i1=0, Pg=0, size=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zs_invalid_2_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, i1=0, Zdn=0, size=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zs_invalid_3_8000_651d8000() {
    // Encoding: 0x651D8000
    // Test FMINNM_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Pg=0, i1=0
    let encoding: u32 = 0x651D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fminnm_z_p_zs_reg_write_0_651d8000() {
    // Test FMINNM_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651D8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651D8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAX_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmax_z_p_zz_field_size_0_min_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmax_z_p_zz_field_size_1_poweroftwo_8000_65468000() {
    // Encoding: 0x65468000
    // Test FMAX_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x65468000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmax_z_p_zz_field_size_2_poweroftwo_8000_65868000() {
    // Encoding: 0x65868000
    // Test FMAX_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65868000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmax_z_p_zz_field_size_3_max_8000_65c68000() {
    // Encoding: 0x65C68000
    // Test FMAX_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x65C68000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmax_z_p_zz_field_pg_0_min_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmax_z_p_zz_field_pg_1_poweroftwo_8000_65068400() {
    // Encoding: 0x65068400
    // Test FMAX_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65068400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmax_z_p_zz_field_zm_0_min_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmax_z_p_zz_field_zm_1_poweroftwo_8000_65068020() {
    // Encoding: 0x65068020
    // Test FMAX_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65068020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmax_z_p_zz_field_zm_30_poweroftwominusone_8000_650683c0() {
    // Encoding: 0x650683C0
    // Test FMAX_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650683C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmax_z_p_zz_field_zm_31_max_8000_650683e0() {
    // Encoding: 0x650683E0
    // Test FMAX_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Pg=0, Zdn=0
    let encoding: u32 = 0x650683E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmax_z_p_zz_field_zdn_0_min_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmax_z_p_zz_field_zdn_1_poweroftwo_8000_65068001() {
    // Encoding: 0x65068001
    // Test FMAX_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=1, Pg=0, size=0
    let encoding: u32 = 0x65068001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmax_z_p_zz_field_zdn_15_poweroftwominusone_8000_6506800f() {
    // Encoding: 0x6506800F
    // Test FMAX_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zdn=15, Pg=0
    let encoding: u32 = 0x6506800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmax_z_p_zz_field_zdn_31_max_8000_6506801f() {
    // Encoding: 0x6506801F
    // Test FMAX_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x6506801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmax_z_p_zz_combo_0_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmax_z_p_zz_special_size_0_size_variant_0_32768_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmax_z_p_zz_special_size_1_size_variant_1_32768_65468000() {
    // Encoding: 0x65468000
    // Test FMAX_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x65468000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmax_z_p_zz_special_size_2_size_variant_2_32768_65868000() {
    // Encoding: 0x65868000
    // Test FMAX_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, size=2, Zm=0, Pg=0
    let encoding: u32 = 0x65868000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmax_z_p_zz_special_size_3_size_variant_3_32768_65c68000() {
    // Encoding: 0x65C68000
    // Test FMAX_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Zm=0, Pg=0, size=3
    let encoding: u32 = 0x65C68000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zz_invalid_0_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zz_invalid_1_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zz_invalid_2_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zz_invalid_3_8000_65068000() {
    // Encoding: 0x65068000
    // Test FMAX_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x65068000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmax_z_p_zz_reg_write_0_65068000() {
    // Test FMAX_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65068000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65068000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAXNM_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmaxnm_z_p_zs_field_size_0_min_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, i1=0, Pg=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmaxnm_z_p_zs_field_size_1_poweroftwo_8000_655c8000() {
    // Encoding: 0x655C8000
    // Test FMAXNM_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, i1=0, Pg=0
    let encoding: u32 = 0x655C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmaxnm_z_p_zs_field_size_2_poweroftwo_8000_659c8000() {
    // Encoding: 0x659C8000
    // Test FMAXNM_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, i1=0, Zdn=0, size=2
    let encoding: u32 = 0x659C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmaxnm_z_p_zs_field_size_3_max_8000_65dc8000() {
    // Encoding: 0x65DC8000
    // Test FMAXNM_Z.P.ZS__ field size = 3 (Max)
    // Fields: Pg=0, i1=0, size=3, Zdn=0
    let encoding: u32 = 0x65DC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmaxnm_z_p_zs_field_pg_0_min_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: i1=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmaxnm_z_p_zs_field_pg_1_poweroftwo_8000_651c8400() {
    // Encoding: 0x651C8400
    // Test FMAXNM_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, i1=0, Pg=1
    let encoding: u32 = 0x651C8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmaxnm_z_p_zs_field_i1_0_min_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmaxnm_z_p_zs_field_i1_1_max_8000_651c8020() {
    // Encoding: 0x651C8020
    // Test FMAXNM_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: size=0, i1=1, Zdn=0, Pg=0
    let encoding: u32 = 0x651C8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmaxnm_z_p_zs_field_zdn_0_min_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Pg=0, size=0, i1=0, Zdn=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmaxnm_z_p_zs_field_zdn_1_poweroftwo_8000_651c8001() {
    // Encoding: 0x651C8001
    // Test FMAXNM_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, Pg=0, size=0, i1=0
    let encoding: u32 = 0x651C8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmaxnm_z_p_zs_field_zdn_15_poweroftwominusone_8000_651c800f() {
    // Encoding: 0x651C800F
    // Test FMAXNM_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=15, i1=0, Pg=0
    let encoding: u32 = 0x651C800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmaxnm_z_p_zs_field_zdn_31_max_8000_651c801f() {
    // Encoding: 0x651C801F
    // Test FMAXNM_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31, i1=0
    let encoding: u32 = 0x651C801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmaxnm_z_p_zs_combo_0_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmaxnm_z_p_zs_special_size_0_size_variant_0_32768_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zdn=0, size=0, i1=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmaxnm_z_p_zs_special_size_1_size_variant_1_32768_655c8000() {
    // Encoding: 0x655C8000
    // Test FMAXNM_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zdn=0, i1=0, Pg=0
    let encoding: u32 = 0x655C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmaxnm_z_p_zs_special_size_2_size_variant_2_32768_659c8000() {
    // Encoding: 0x659C8000
    // Test FMAXNM_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x659C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmaxnm_z_p_zs_special_size_3_size_variant_3_32768_65dc8000() {
    // Encoding: 0x65DC8000
    // Test FMAXNM_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: size=3, i1=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65DC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zs_invalid_0_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, i1=0, Zdn=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zs_invalid_1_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zs_invalid_2_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zdn=0, i1=0, Pg=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zs_invalid_3_8000_651c8000() {
    // Encoding: 0x651C8000
    // Test FMAXNM_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x651C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmaxnm_z_p_zs_reg_write_0_651c8000() {
    // Test FMAXNM_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651C8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651C8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FTSMUL_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_ftsmul_z_zz_field_size_0_min_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_ftsmul_z_zz_field_size_1_poweroftwo_c00_65400c00() {
    // Encoding: 0x65400C00
    // Test FTSMUL_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=0, Zn=0, size=1
    let encoding: u32 = 0x65400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_ftsmul_z_zz_field_size_2_poweroftwo_c00_65800c00() {
    // Encoding: 0x65800C00
    // Test FTSMUL_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, Zm=0, size=2
    let encoding: u32 = 0x65800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_ftsmul_z_zz_field_size_3_max_c00_65c00c00() {
    // Encoding: 0x65C00C00
    // Test FTSMUL_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65C00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftsmul_z_zz_field_zm_0_min_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftsmul_z_zz_field_zm_1_poweroftwo_c00_65010c00() {
    // Encoding: 0x65010C00
    // Test FTSMUL_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x65010C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftsmul_z_zz_field_zm_30_poweroftwominusone_c00_651e0c00() {
    // Encoding: 0x651E0C00
    // Test FTSMUL_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Zd=0, Zm=30
    let encoding: u32 = 0x651E0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftsmul_z_zz_field_zm_31_max_c00_651f0c00() {
    // Encoding: 0x651F0C00
    // Test FTSMUL_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zd=0, Zn=0, Zm=31, size=0
    let encoding: u32 = 0x651F0C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftsmul_z_zz_field_zn_0_min_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftsmul_z_zz_field_zn_1_poweroftwo_c00_65000c20() {
    // Encoding: 0x65000C20
    // Test FTSMUL_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0, Zm=0
    let encoding: u32 = 0x65000C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftsmul_z_zz_field_zn_30_poweroftwominusone_c00_65000fc0() {
    // Encoding: 0x65000FC0
    // Test FTSMUL_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, Zm=0, size=0
    let encoding: u32 = 0x65000FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftsmul_z_zz_field_zn_31_max_c00_65000fe0() {
    // Encoding: 0x65000FE0
    // Test FTSMUL_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Zn=31, Zd=0, size=0
    let encoding: u32 = 0x65000FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftsmul_z_zz_field_zd_0_min_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftsmul_z_zz_field_zd_1_poweroftwo_c00_65000c01() {
    // Encoding: 0x65000C01
    // Test FTSMUL_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=1, size=0, Zn=0
    let encoding: u32 = 0x65000C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftsmul_z_zz_field_zd_30_poweroftwominusone_c00_65000c1e() {
    // Encoding: 0x65000C1E
    // Test FTSMUL_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0, Zm=0
    let encoding: u32 = 0x65000C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftsmul_z_zz_field_zd_31_max_c00_65000c1f() {
    // Encoding: 0x65000C1F
    // Test FTSMUL_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zd=31, Zm=0
    let encoding: u32 = 0x65000C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_ftsmul_z_zz_combo_0_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_ftsmul_z_zz_special_size_0_size_variant_0_3072_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_ftsmul_z_zz_special_size_1_size_variant_1_3072_65400c00() {
    // Encoding: 0x65400C00
    // Test FTSMUL_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x65400C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_ftsmul_z_zz_special_size_2_size_variant_2_3072_65800c00() {
    // Encoding: 0x65800C00
    // Test FTSMUL_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, size=2, Zm=0
    let encoding: u32 = 0x65800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_ftsmul_z_zz_special_size_3_size_variant_3_3072_65c00c00() {
    // Encoding: 0x65C00C00
    // Test FTSMUL_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65C00C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ftsmul_z_zz_invalid_0_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ftsmul_z_zz_invalid_1_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_ftsmul_z_zz_invalid_2_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ftsmul_z_zz_invalid_3_c00_65000c00() {
    // Encoding: 0x65000C00
    // Test FTSMUL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x65000C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSMUL_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_ftsmul_z_zz_reg_write_0_65000c00() {
    // Test FTSMUL_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65000C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65000C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FADDV_V.P.Z__ Tests
// ============================================================================

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_faddv_v_p_z_field_size_0_min_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_faddv_v_p_z_field_size_1_poweroftwo_2000_65402000() {
    // Encoding: 0x65402000
    // Test FADDV_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, size=1, Pg=0, Vd=0
    let encoding: u32 = 0x65402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_faddv_v_p_z_field_size_2_poweroftwo_2000_65802000() {
    // Encoding: 0x65802000
    // Test FADDV_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zn=0, Vd=0
    let encoding: u32 = 0x65802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_faddv_v_p_z_field_size_3_max_2000_65c02000() {
    // Encoding: 0x65C02000
    // Test FADDV_V.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Pg=0, Vd=0
    let encoding: u32 = 0x65C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_faddv_v_p_z_field_pg_0_min_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_faddv_v_p_z_field_pg_1_poweroftwo_2000_65002400() {
    // Encoding: 0x65002400
    // Test FADDV_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x65002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_faddv_v_p_z_field_zn_0_min_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_faddv_v_p_z_field_zn_1_poweroftwo_2000_65002020() {
    // Encoding: 0x65002020
    // Test FADDV_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Pg=0, Vd=0
    let encoding: u32 = 0x65002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_faddv_v_p_z_field_zn_30_poweroftwominusone_2000_650023c0() {
    // Encoding: 0x650023C0
    // Test FADDV_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vd=0, Zn=30, Pg=0
    let encoding: u32 = 0x650023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_faddv_v_p_z_field_zn_31_max_2000_650023e0() {
    // Encoding: 0x650023E0
    // Test FADDV_V.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Vd=0, Pg=0, Zn=31
    let encoding: u32 = 0x650023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_faddv_v_p_z_field_vd_0_min_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ field Vd = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_faddv_v_p_z_field_vd_1_poweroftwo_2000_65002001() {
    // Encoding: 0x65002001
    // Test FADDV_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Zn=0, Vd=1, size=0, Pg=0
    let encoding: u32 = 0x65002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_faddv_v_p_z_field_vd_30_poweroftwominusone_2000_6500201e() {
    // Encoding: 0x6500201E
    // Test FADDV_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, size=0, Pg=0, Vd=30
    let encoding: u32 = 0x6500201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_faddv_v_p_z_field_vd_31_max_2000_6500201f() {
    // Encoding: 0x6500201F
    // Test FADDV_V.P.Z__ field Vd = 31 (Max)
    // Fields: size=0, Pg=0, Vd=31, Zn=0
    let encoding: u32 = 0x6500201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_faddv_v_p_z_combo_0_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_faddv_v_p_z_special_size_0_size_variant_0_8192_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_faddv_v_p_z_special_size_1_size_variant_1_8192_65402000() {
    // Encoding: 0x65402000
    // Test FADDV_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Vd=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x65402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_faddv_v_p_z_special_size_2_size_variant_2_8192_65802000() {
    // Encoding: 0x65802000
    // Test FADDV_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zn=0, Vd=0, size=2
    let encoding: u32 = 0x65802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_faddv_v_p_z_special_size_3_size_variant_3_8192_65c02000() {
    // Encoding: 0x65C02000
    // Test FADDV_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x65C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_faddv_v_p_z_invalid_0_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_faddv_v_p_z_invalid_1_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_faddv_v_p_z_invalid_2_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_faddv_v_p_z_invalid_3_2000_65002000() {
    // Encoding: 0x65002000
    // Test FADDV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDV_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_faddv_v_p_z_reg_write_0_65002000() {
    // Test FADDV_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x65002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FNMLS_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fnmls_z_p_zzz_field_size_0_min_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Pg=0, Zda=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fnmls_z_p_zzz_field_size_1_poweroftwo_6000_65606000() {
    // Encoding: 0x65606000
    // Test FNMLS_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x65606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fnmls_z_p_zzz_field_size_2_poweroftwo_6000_65a06000() {
    // Encoding: 0x65A06000
    // Test FNMLS_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zda=0, Zm=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x65A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fnmls_z_p_zzz_field_size_3_max_6000_65e06000() {
    // Encoding: 0x65E06000
    // Test FNMLS_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Zda=0, Zm=0, Pg=0, size=3, Zn=0
    let encoding: u32 = 0x65E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmls_z_p_zzz_field_zm_0_min_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zn=0, Zm=0, Pg=0, Zda=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmls_z_p_zzz_field_zm_1_poweroftwo_6000_65216000() {
    // Encoding: 0x65216000
    // Test FNMLS_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, Zda=0, Zm=1, size=0, Pg=0
    let encoding: u32 = 0x65216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmls_z_p_zzz_field_zm_30_poweroftwominusone_6000_653e6000() {
    // Encoding: 0x653E6000
    // Test FNMLS_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Zm=30, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x653E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmls_z_p_zzz_field_zm_31_max_6000_653f6000() {
    // Encoding: 0x653F6000
    // Test FNMLS_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, size=0, Zda=0, Zn=0
    let encoding: u32 = 0x653F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fnmls_z_p_zzz_field_pg_0_min_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zn=0, Zda=0, Pg=0, size=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fnmls_z_p_zzz_field_pg_1_poweroftwo_6000_65206400() {
    // Encoding: 0x65206400
    // Test FNMLS_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x65206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmls_z_p_zzz_field_zn_0_min_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ field Zn = 0 (Min)
    // Fields: Zda=0, Pg=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmls_z_p_zzz_field_zn_1_poweroftwo_6000_65206020() {
    // Encoding: 0x65206020
    // Test FNMLS_Z.P.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=0, Zda=0, Zn=1
    let encoding: u32 = 0x65206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmls_z_p_zzz_field_zn_30_poweroftwominusone_6000_652063c0() {
    // Encoding: 0x652063C0
    // Test FNMLS_Z.P.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Zm=0, Pg=0, Zn=30, size=0
    let encoding: u32 = 0x652063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmls_z_p_zzz_field_zn_31_max_6000_652063e0() {
    // Encoding: 0x652063E0
    // Test FNMLS_Z.P.ZZZ__ field Zn = 31 (Max)
    // Fields: Pg=0, size=0, Zda=0, Zn=31, Zm=0
    let encoding: u32 = 0x652063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmls_z_p_zzz_field_zda_0_min_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ field Zda = 0 (Min)
    // Fields: Zda=0, Zn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmls_z_p_zzz_field_zda_1_poweroftwo_6000_65206001() {
    // Encoding: 0x65206001
    // Test FNMLS_Z.P.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zda=1, Zn=0, Pg=0
    let encoding: u32 = 0x65206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmls_z_p_zzz_field_zda_15_poweroftwominusone_6000_6520600f() {
    // Encoding: 0x6520600F
    // Test FNMLS_Z.P.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zda=15, Zn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x6520600F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmls_z_p_zzz_field_zda_31_max_6000_6520601f() {
    // Encoding: 0x6520601F
    // Test FNMLS_Z.P.ZZZ__ field Zda = 31 (Max)
    // Fields: size=0, Pg=0, Zda=31, Zn=0, Zm=0
    let encoding: u32 = 0x6520601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fnmls_z_p_zzz_combo_0_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Pg=0, Zn=0, Zm=0, Zda=0, size=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fnmls_z_p_zzz_special_size_0_size_variant_0_24576_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, size=0, Zn=0, Zda=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fnmls_z_p_zzz_special_size_1_size_variant_1_24576_65606000() {
    // Encoding: 0x65606000
    // Test FNMLS_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zm=0, Zn=0, size=1, Zda=0
    let encoding: u32 = 0x65606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fnmls_z_p_zzz_special_size_2_size_variant_2_24576_65a06000() {
    // Encoding: 0x65A06000
    // Test FNMLS_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Pg=0, Zm=0, Zda=0
    let encoding: u32 = 0x65A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fnmls_z_p_zzz_special_size_3_size_variant_3_24576_65e06000() {
    // Encoding: 0x65E06000
    // Test FNMLS_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, Zn=0, size=3, Zda=0
    let encoding: u32 = 0x65E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fnmls_z_p_zzz_invalid_0_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zda=0, size=0, Zm=0, Pg=0, Zn=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmls_z_p_zzz_invalid_1_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zda=0, Zm=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fnmls_z_p_zzz_invalid_2_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Zda=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmls_z_p_zzz_invalid_3_6000_65206000() {
    // Encoding: 0x65206000
    // Test FNMLS_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zn=0, Zda=0, Pg=0, size=0
    let encoding: u32 = 0x65206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLS_Z.P.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fnmls_z_p_zzz_reg_write_0_65206000() {
    // Test FNMLS_Z.P.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x65206000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65206000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRECPE_Z.Z__ Tests
// ============================================================================

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frecpe_z_z_field_size_0_min_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frecpe_z_z_field_size_1_poweroftwo_3000_654e3000() {
    // Encoding: 0x654E3000
    // Test FRECPE_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Zn=0
    let encoding: u32 = 0x654E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frecpe_z_z_field_size_2_poweroftwo_3000_658e3000() {
    // Encoding: 0x658E3000
    // Test FRECPE_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, size=2, Zn=0
    let encoding: u32 = 0x658E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frecpe_z_z_field_size_3_max_3000_65ce3000() {
    // Encoding: 0x65CE3000
    // Test FRECPE_Z.Z__ field size = 3 (Max)
    // Fields: Zn=0, Zd=0, size=3
    let encoding: u32 = 0x65CE3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecpe_z_z_field_zn_0_min_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecpe_z_z_field_zn_1_poweroftwo_3000_650e3020() {
    // Encoding: 0x650E3020
    // Test FRECPE_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zn=1
    let encoding: u32 = 0x650E3020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecpe_z_z_field_zn_30_poweroftwominusone_3000_650e33c0() {
    // Encoding: 0x650E33C0
    // Test FRECPE_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0
    let encoding: u32 = 0x650E33C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecpe_z_z_field_zn_31_max_3000_650e33e0() {
    // Encoding: 0x650E33E0
    // Test FRECPE_Z.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Zd=0
    let encoding: u32 = 0x650E33E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecpe_z_z_field_zd_0_min_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecpe_z_z_field_zd_1_poweroftwo_3000_650e3001() {
    // Encoding: 0x650E3001
    // Test FRECPE_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1
    let encoding: u32 = 0x650E3001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecpe_z_z_field_zd_30_poweroftwominusone_3000_650e301e() {
    // Encoding: 0x650E301E
    // Test FRECPE_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Zn=0
    let encoding: u32 = 0x650E301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecpe_z_z_field_zd_31_max_3000_650e301f() {
    // Encoding: 0x650E301F
    // Test FRECPE_Z.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zd=31
    let encoding: u32 = 0x650E301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frecpe_z_z_combo_0_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frecpe_z_z_special_size_0_size_variant_0_12288_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frecpe_z_z_special_size_1_size_variant_1_12288_654e3000() {
    // Encoding: 0x654E3000
    // Test FRECPE_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zn=0, size=1
    let encoding: u32 = 0x654E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frecpe_z_z_special_size_2_size_variant_2_12288_658e3000() {
    // Encoding: 0x658E3000
    // Test FRECPE_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, size=2, Zn=0
    let encoding: u32 = 0x658E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frecpe_z_z_special_size_3_size_variant_3_12288_65ce3000() {
    // Encoding: 0x65CE3000
    // Test FRECPE_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Zd=0
    let encoding: u32 = 0x65CE3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frecpe_z_z_invalid_0_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frecpe_z_z_invalid_1_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frecpe_z_z_invalid_2_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frecpe_z_z_invalid_3_3000_650e3000() {
    // Encoding: 0x650E3000
    // Test FRECPE_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPE_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frecpe_z_z_reg_write_0_650e3000() {
    // Test FRECPE_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x650E3000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650E3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FADD_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fadd_z_zz_field_size_0_min_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fadd_z_zz_field_size_1_poweroftwo_0_65400000() {
    // Encoding: 0x65400000
    // Test FADD_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Zn=0, Zd=0
    let encoding: u32 = 0x65400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fadd_z_zz_field_size_2_poweroftwo_0_65800000() {
    // Encoding: 0x65800000
    // Test FADD_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x65800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fadd_z_zz_field_size_3_max_0_65c00000() {
    // Encoding: 0x65C00000
    // Test FADD_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fadd_z_zz_field_zm_0_min_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fadd_z_zz_field_zm_1_poweroftwo_0_65010000() {
    // Encoding: 0x65010000
    // Test FADD_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=0, Zm=1
    let encoding: u32 = 0x65010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fadd_z_zz_field_zm_30_poweroftwominusone_0_651e0000() {
    // Encoding: 0x651E0000
    // Test FADD_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Zn=0, Zm=30
    let encoding: u32 = 0x651E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fadd_z_zz_field_zm_31_max_0_651f0000() {
    // Encoding: 0x651F0000
    // Test FADD_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zd=0, size=0, Zm=31, Zn=0
    let encoding: u32 = 0x651F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fadd_z_zz_field_zn_0_min_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fadd_z_zz_field_zn_1_poweroftwo_0_65000020() {
    // Encoding: 0x65000020
    // Test FADD_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, Zn=1, size=0
    let encoding: u32 = 0x65000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fadd_z_zz_field_zn_30_poweroftwominusone_0_650003c0() {
    // Encoding: 0x650003C0
    // Test FADD_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zm=0, size=0, Zn=30
    let encoding: u32 = 0x650003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fadd_z_zz_field_zn_31_max_0_650003e0() {
    // Encoding: 0x650003E0
    // Test FADD_Z.ZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zd=0, Zm=0, Zn=31
    let encoding: u32 = 0x650003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fadd_z_zz_field_zd_0_min_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fadd_z_zz_field_zd_1_poweroftwo_0_65000001() {
    // Encoding: 0x65000001
    // Test FADD_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x65000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fadd_z_zz_field_zd_30_poweroftwominusone_0_6500001e() {
    // Encoding: 0x6500001E
    // Test FADD_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x6500001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fadd_z_zz_field_zd_31_max_0_6500001f() {
    // Encoding: 0x6500001F
    // Test FADD_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zm=0, Zd=31
    let encoding: u32 = 0x6500001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fadd_z_zz_combo_0_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fadd_z_zz_special_size_0_size_variant_0_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fadd_z_zz_special_size_1_size_variant_1_0_65400000() {
    // Encoding: 0x65400000
    // Test FADD_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Zd=0, size=1, Zm=0
    let encoding: u32 = 0x65400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fadd_z_zz_special_size_2_size_variant_2_0_65800000() {
    // Encoding: 0x65800000
    // Test FADD_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zm=0, Zd=0
    let encoding: u32 = 0x65800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fadd_z_zz_special_size_3_size_variant_3_0_65c00000() {
    // Encoding: 0x65C00000
    // Test FADD_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fadd_z_zz_invalid_0_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadd_z_zz_invalid_1_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fadd_z_zz_invalid_2_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadd_z_zz_invalid_3_0_65000000() {
    // Encoding: 0x65000000
    // Test FADD_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fadd_z_zz_reg_write_0_65000000() {
    // Test FADD_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRECPS_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frecps_z_zz_field_size_0_min_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frecps_z_zz_field_size_1_poweroftwo_1800_65401800() {
    // Encoding: 0x65401800
    // Test FRECPS_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Zm=0, Zn=0
    let encoding: u32 = 0x65401800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frecps_z_zz_field_size_2_poweroftwo_1800_65801800() {
    // Encoding: 0x65801800
    // Test FRECPS_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, size=2, Zn=0, Zm=0
    let encoding: u32 = 0x65801800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frecps_z_zz_field_size_3_max_1800_65c01800() {
    // Encoding: 0x65C01800
    // Test FRECPS_Z.ZZ__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, size=3, Zm=0
    let encoding: u32 = 0x65C01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecps_z_zz_field_zm_0_min_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecps_z_zz_field_zm_1_poweroftwo_1800_65011800() {
    // Encoding: 0x65011800
    // Test FRECPS_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x65011800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecps_z_zz_field_zm_30_poweroftwominusone_1800_651e1800() {
    // Encoding: 0x651E1800
    // Test FRECPS_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Zm=30, Zn=0
    let encoding: u32 = 0x651E1800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecps_z_zz_field_zm_31_max_1800_651f1800() {
    // Encoding: 0x651F1800
    // Test FRECPS_Z.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zn=0, Zd=0, Zm=31
    let encoding: u32 = 0x651F1800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecps_z_zz_field_zn_0_min_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecps_z_zz_field_zn_1_poweroftwo_1800_65001820() {
    // Encoding: 0x65001820
    // Test FRECPS_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, size=0, Zn=1
    let encoding: u32 = 0x65001820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecps_z_zz_field_zn_30_poweroftwominusone_1800_65001bc0() {
    // Encoding: 0x65001BC0
    // Test FRECPS_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Zm=0, Zn=30
    let encoding: u32 = 0x65001BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecps_z_zz_field_zn_31_max_1800_65001be0() {
    // Encoding: 0x65001BE0
    // Test FRECPS_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, size=0, Zd=0, Zn=31
    let encoding: u32 = 0x65001BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecps_z_zz_field_zd_0_min_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecps_z_zz_field_zd_1_poweroftwo_1800_65001801() {
    // Encoding: 0x65001801
    // Test FRECPS_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zn=0, Zd=1
    let encoding: u32 = 0x65001801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecps_z_zz_field_zd_30_poweroftwominusone_1800_6500181e() {
    // Encoding: 0x6500181E
    // Test FRECPS_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0, Zm=0
    let encoding: u32 = 0x6500181E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecps_z_zz_field_zd_31_max_1800_6500181f() {
    // Encoding: 0x6500181F
    // Test FRECPS_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zd=31, Zm=0
    let encoding: u32 = 0x6500181F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frecps_z_zz_combo_0_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frecps_z_zz_special_size_0_size_variant_0_6144_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frecps_z_zz_special_size_1_size_variant_1_6144_65401800() {
    // Encoding: 0x65401800
    // Test FRECPS_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, size=1, Zn=0, Zm=0
    let encoding: u32 = 0x65401800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frecps_z_zz_special_size_2_size_variant_2_6144_65801800() {
    // Encoding: 0x65801800
    // Test FRECPS_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, size=2, Zm=0, Zn=0
    let encoding: u32 = 0x65801800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frecps_z_zz_special_size_3_size_variant_3_6144_65c01800() {
    // Encoding: 0x65C01800
    // Test FRECPS_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x65C01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frecps_z_zz_invalid_0_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, Zm=0, size=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frecps_z_zz_invalid_1_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frecps_z_zz_invalid_2_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frecps_z_zz_invalid_3_1800_65001800() {
    // Encoding: 0x65001800
    // Test FRECPS_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x65001800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPS_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frecps_z_zz_reg_write_0_65001800() {
    // Test FRECPS_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65001800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65001800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FADD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fadd_z_p_zz_field_size_0_min_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fadd_z_p_zz_field_size_1_poweroftwo_8000_65408000() {
    // Encoding: 0x65408000
    // Test FADD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x65408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fadd_z_p_zz_field_size_2_poweroftwo_8000_65808000() {
    // Encoding: 0x65808000
    // Test FADD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x65808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fadd_z_p_zz_field_size_3_max_8000_65c08000() {
    // Encoding: 0x65C08000
    // Test FADD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fadd_z_p_zz_field_pg_0_min_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fadd_z_p_zz_field_pg_1_poweroftwo_8000_65008400() {
    // Encoding: 0x65008400
    // Test FADD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fadd_z_p_zz_field_zm_0_min_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fadd_z_p_zz_field_zm_1_poweroftwo_8000_65008020() {
    // Encoding: 0x65008020
    // Test FADD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x65008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fadd_z_p_zz_field_zm_30_poweroftwominusone_8000_650083c0() {
    // Encoding: 0x650083C0
    // Test FADD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Zm=30, size=0, Pg=0
    let encoding: u32 = 0x650083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fadd_z_p_zz_field_zm_31_max_8000_650083e0() {
    // Encoding: 0x650083E0
    // Test FADD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zdn=0, Pg=0
    let encoding: u32 = 0x650083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fadd_z_p_zz_field_zdn_0_min_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fadd_z_p_zz_field_zdn_1_poweroftwo_8000_65008001() {
    // Encoding: 0x65008001
    // Test FADD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=1, size=0, Pg=0
    let encoding: u32 = 0x65008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fadd_z_p_zz_field_zdn_15_poweroftwominusone_8000_6500800f() {
    // Encoding: 0x6500800F
    // Test FADD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zdn=15, Pg=0
    let encoding: u32 = 0x6500800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fadd_z_p_zz_field_zdn_31_max_8000_6500801f() {
    // Encoding: 0x6500801F
    // Test FADD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zm=0, Zdn=31
    let encoding: u32 = 0x6500801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fadd_z_p_zz_combo_0_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fadd_z_p_zz_special_size_0_size_variant_0_32768_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fadd_z_p_zz_special_size_1_size_variant_1_32768_65408000() {
    // Encoding: 0x65408000
    // Test FADD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Pg=0, size=1, Zdn=0
    let encoding: u32 = 0x65408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fadd_z_p_zz_special_size_2_size_variant_2_32768_65808000() {
    // Encoding: 0x65808000
    // Test FADD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fadd_z_p_zz_special_size_3_size_variant_3_32768_65c08000() {
    // Encoding: 0x65C08000
    // Test FADD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x65C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zz_invalid_0_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zz_invalid_1_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zz_invalid_2_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zz_invalid_3_8000_65008000() {
    // Encoding: 0x65008000
    // Test FADD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fadd_z_p_zz_reg_write_0_65008000() {
    // Test FADD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65008000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FEXPA_Z.Z__ Tests
// ============================================================================

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fexpa_z_z_field_size_0_min_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fexpa_z_z_field_size_1_poweroftwo_b800_0460b800() {
    // Encoding: 0x0460B800
    // Test FEXPA_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Zn=0
    let encoding: u32 = 0x0460B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fexpa_z_z_field_size_2_poweroftwo_b800_04a0b800() {
    // Encoding: 0x04A0B800
    // Test FEXPA_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0
    let encoding: u32 = 0x04A0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fexpa_z_z_field_size_3_max_b800_04e0b800() {
    // Encoding: 0x04E0B800
    // Test FEXPA_Z.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Zn=0
    let encoding: u32 = 0x04E0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fexpa_z_z_field_zn_0_min_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fexpa_z_z_field_zn_1_poweroftwo_b800_0420b820() {
    // Encoding: 0x0420B820
    // Test FEXPA_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zn=1
    let encoding: u32 = 0x0420B820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fexpa_z_z_field_zn_30_poweroftwominusone_b800_0420bbc0() {
    // Encoding: 0x0420BBC0
    // Test FEXPA_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0
    let encoding: u32 = 0x0420BBC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fexpa_z_z_field_zn_31_max_b800_0420bbe0() {
    // Encoding: 0x0420BBE0
    // Test FEXPA_Z.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Zd=0
    let encoding: u32 = 0x0420BBE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fexpa_z_z_field_zd_0_min_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fexpa_z_z_field_zd_1_poweroftwo_b800_0420b801() {
    // Encoding: 0x0420B801
    // Test FEXPA_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zd=1, Zn=0
    let encoding: u32 = 0x0420B801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fexpa_z_z_field_zd_30_poweroftwominusone_b800_0420b81e() {
    // Encoding: 0x0420B81E
    // Test FEXPA_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Zn=0
    let encoding: u32 = 0x0420B81E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fexpa_z_z_field_zd_31_max_b800_0420b81f() {
    // Encoding: 0x0420B81F
    // Test FEXPA_Z.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, size=0
    let encoding: u32 = 0x0420B81F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fexpa_z_z_combo_0_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fexpa_z_z_special_size_0_size_variant_0_47104_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fexpa_z_z_special_size_1_size_variant_1_47104_0460b800() {
    // Encoding: 0x0460B800
    // Test FEXPA_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zd=0
    let encoding: u32 = 0x0460B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fexpa_z_z_special_size_2_size_variant_2_47104_04a0b800() {
    // Encoding: 0x04A0B800
    // Test FEXPA_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zd=0
    let encoding: u32 = 0x04A0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fexpa_z_z_special_size_3_size_variant_3_47104_04e0b800() {
    // Encoding: 0x04E0B800
    // Test FEXPA_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Zd=0
    let encoding: u32 = 0x04E0B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fexpa_z_z_invalid_0_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fexpa_z_z_invalid_1_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fexpa_z_z_invalid_2_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fexpa_z_z_invalid_3_b800_0420b800() {
    // Encoding: 0x0420B800
    // Test FEXPA_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0420B800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FEXPA_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fexpa_z_z_reg_write_0_0420b800() {
    // Test FEXPA_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x0420B800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420B800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAXV_V.P.Z__ Tests
// ============================================================================

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmaxv_v_p_z_field_size_0_min_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmaxv_v_p_z_field_size_1_poweroftwo_2000_65462000() {
    // Encoding: 0x65462000
    // Test FMAXV_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Vd=0, size=1, Pg=0
    let encoding: u32 = 0x65462000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmaxv_v_p_z_field_size_2_poweroftwo_2000_65862000() {
    // Encoding: 0x65862000
    // Test FMAXV_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65862000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmaxv_v_p_z_field_size_3_max_2000_65c62000() {
    // Encoding: 0x65C62000
    // Test FMAXV_V.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Zn=0, Vd=0
    let encoding: u32 = 0x65C62000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmaxv_v_p_z_field_pg_0_min_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmaxv_v_p_z_field_pg_1_poweroftwo_2000_65062400() {
    // Encoding: 0x65062400
    // Test FMAXV_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Vd=0, size=0, Zn=0, Pg=1
    let encoding: u32 = 0x65062400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmaxv_v_p_z_field_zn_0_min_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmaxv_v_p_z_field_zn_1_poweroftwo_2000_65062020() {
    // Encoding: 0x65062020
    // Test FMAXV_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x65062020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmaxv_v_p_z_field_zn_30_poweroftwominusone_2000_650623c0() {
    // Encoding: 0x650623C0
    // Test FMAXV_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x650623C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmaxv_v_p_z_field_zn_31_max_2000_650623e0() {
    // Encoding: 0x650623E0
    // Test FMAXV_V.P.Z__ field Zn = 31 (Max)
    // Fields: Vd=0, size=0, Zn=31, Pg=0
    let encoding: u32 = 0x650623E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmaxv_v_p_z_field_vd_0_min_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ field Vd = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmaxv_v_p_z_field_vd_1_poweroftwo_2000_65062001() {
    // Encoding: 0x65062001
    // Test FMAXV_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=0, Vd=1
    let encoding: u32 = 0x65062001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmaxv_v_p_z_field_vd_30_poweroftwominusone_2000_6506201e() {
    // Encoding: 0x6506201E
    // Test FMAXV_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Vd=30, size=0, Zn=0
    let encoding: u32 = 0x6506201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmaxv_v_p_z_field_vd_31_max_2000_6506201f() {
    // Encoding: 0x6506201F
    // Test FMAXV_V.P.Z__ field Vd = 31 (Max)
    // Fields: Zn=0, Pg=0, size=0, Vd=31
    let encoding: u32 = 0x6506201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmaxv_v_p_z_combo_0_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmaxv_v_p_z_special_size_0_size_variant_0_8192_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmaxv_v_p_z_special_size_1_size_variant_1_8192_65462000() {
    // Encoding: 0x65462000
    // Test FMAXV_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65462000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmaxv_v_p_z_special_size_2_size_variant_2_8192_65862000() {
    // Encoding: 0x65862000
    // Test FMAXV_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Vd=0, size=2, Pg=0, Zn=0
    let encoding: u32 = 0x65862000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmaxv_v_p_z_special_size_3_size_variant_3_8192_65c62000() {
    // Encoding: 0x65C62000
    // Test FMAXV_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65C62000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmaxv_v_p_z_invalid_0_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxv_v_p_z_invalid_1_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmaxv_v_p_z_invalid_2_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxv_v_p_z_invalid_3_2000_65062000() {
    // Encoding: 0x65062000
    // Test FMAXV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65062000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXV_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmaxv_v_p_z_reg_write_0_65062000() {
    // Test FMAXV_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x65062000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65062000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMLS_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmls_z_p_zzz_field_size_0_min_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Pg=0, Zda=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmls_z_p_zzz_field_size_1_poweroftwo_2000_65602000() {
    // Encoding: 0x65602000
    // Test FMLS_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x65602000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmls_z_p_zzz_field_size_2_poweroftwo_2000_65a02000() {
    // Encoding: 0x65A02000
    // Test FMLS_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, Zda=0, size=2, Pg=0
    let encoding: u32 = 0x65A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmls_z_p_zzz_field_size_3_max_2000_65e02000() {
    // Encoding: 0x65E02000
    // Test FMLS_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Zm=0, Zn=0, Zda=0, size=3, Pg=0
    let encoding: u32 = 0x65E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_p_zzz_field_zm_0_min_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zda=0, Zn=0, Zm=0, size=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_p_zzz_field_zm_1_poweroftwo_2000_65212000() {
    // Encoding: 0x65212000
    // Test FMLS_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zda=0, size=0, Zn=0, Pg=0, Zm=1
    let encoding: u32 = 0x65212000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmls_z_p_zzz_field_zm_30_poweroftwominusone_2000_653e2000() {
    // Encoding: 0x653E2000
    // Test FMLS_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Zda=0, Zn=0, Pg=0
    let encoding: u32 = 0x653E2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmls_z_p_zzz_field_zm_31_max_2000_653f2000() {
    // Encoding: 0x653F2000
    // Test FMLS_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zn=0, Pg=0, Zda=0
    let encoding: u32 = 0x653F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmls_z_p_zzz_field_pg_0_min_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, size=0, Zda=0, Zn=0, Pg=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmls_z_p_zzz_field_pg_1_poweroftwo_2000_65202400() {
    // Encoding: 0x65202400
    // Test FMLS_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zda=0, Zm=0, Pg=1, size=0
    let encoding: u32 = 0x65202400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmls_z_p_zzz_field_zn_0_min_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zm=0, Zda=0, Pg=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmls_z_p_zzz_field_zn_1_poweroftwo_2000_65202020() {
    // Encoding: 0x65202020
    // Test FMLS_Z.P.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zda=0, Zn=1, size=0
    let encoding: u32 = 0x65202020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmls_z_p_zzz_field_zn_30_poweroftwominusone_2000_652023c0() {
    // Encoding: 0x652023C0
    // Test FMLS_Z.P.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=0, Zda=0, Zn=30
    let encoding: u32 = 0x652023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmls_z_p_zzz_field_zn_31_max_2000_652023e0() {
    // Encoding: 0x652023E0
    // Test FMLS_Z.P.ZZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zm=0, Pg=0, size=0, Zda=0
    let encoding: u32 = 0x652023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmls_z_p_zzz_field_zda_0_min_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ field Zda = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zda=0, Pg=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmls_z_p_zzz_field_zda_1_poweroftwo_2000_65202001() {
    // Encoding: 0x65202001
    // Test FMLS_Z.P.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: Pg=0, Zda=1, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x65202001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmls_z_p_zzz_field_zda_15_poweroftwominusone_2000_6520200f() {
    // Encoding: 0x6520200F
    // Test FMLS_Z.P.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Pg=0, Zn=0, Zda=15
    let encoding: u32 = 0x6520200F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmls_z_p_zzz_field_zda_31_max_2000_6520201f() {
    // Encoding: 0x6520201F
    // Test FMLS_Z.P.ZZZ__ field Zda = 31 (Max)
    // Fields: size=0, Pg=0, Zda=31, Zm=0, Zn=0
    let encoding: u32 = 0x6520201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmls_z_p_zzz_combo_0_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Zm=0, size=0, Zn=0, Pg=0, Zda=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmls_z_p_zzz_special_size_0_size_variant_0_8192_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zm=0, Zda=0, Zn=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmls_z_p_zzz_special_size_1_size_variant_1_8192_65602000() {
    // Encoding: 0x65602000
    // Test FMLS_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Zda=0, Zn=0, size=1, Zm=0, Pg=0
    let encoding: u32 = 0x65602000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmls_z_p_zzz_special_size_2_size_variant_2_8192_65a02000() {
    // Encoding: 0x65A02000
    // Test FMLS_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Pg=0, Zda=0, Zn=0, size=2
    let encoding: u32 = 0x65A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmls_z_p_zzz_special_size_3_size_variant_3_8192_65e02000() {
    // Encoding: 0x65E02000
    // Test FMLS_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zda=0, Zn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x65E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmls_z_p_zzz_invalid_0_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zda=0, Zm=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmls_z_p_zzz_invalid_1_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Pg=0, Zda=0, Zn=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmls_z_p_zzz_invalid_2_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Pg=0, Zda=0, size=0, Zn=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmls_z_p_zzz_invalid_3_2000_65202000() {
    // Encoding: 0x65202000
    // Test FMLS_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Pg=0, Zm=0, Zda=0
    let encoding: u32 = 0x65202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLS_Z.P.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmls_z_p_zzz_reg_write_0_65202000() {
    // Test FMLS_Z.P.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x65202000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65202000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMUL_Z.ZZi_H Tests
// ============================================================================

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field i3h 22 +: 1`
/// Requirement: FieldBoundary { field: "i3h", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_zzi_h_field_i3h_0_min_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H field i3h = 0 (Min)
    // Fields: Zm=0, Zn=0, i3l=0, i3h=0, Zd=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field i3h 22 +: 1`
/// Requirement: FieldBoundary { field: "i3h", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmul_z_zzi_h_field_i3h_1_max_2000_64602000() {
    // Encoding: 0x64602000
    // Test FMUL_Z.ZZi_H field i3h = 1 (Max)
    // Fields: Zm=0, i3l=0, Zn=0, i3h=1, Zd=0
    let encoding: u32 = 0x64602000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_zzi_h_field_i3l_0_min_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H field i3l = 0 (Min)
    // Fields: Zd=0, i3h=0, i3l=0, Zn=0, Zm=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmul_z_zzi_h_field_i3l_1_poweroftwo_2000_64282000() {
    // Encoding: 0x64282000
    // Test FMUL_Z.ZZi_H field i3l = 1 (PowerOfTwo)
    // Fields: i3h=0, i3l=1, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x64282000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_fmul_z_zzi_h_field_i3l_3_max_2000_64382000() {
    // Encoding: 0x64382000
    // Test FMUL_Z.ZZi_H field i3l = 3 (Max)
    // Fields: i3l=3, Zd=0, Zm=0, i3h=0, Zn=0
    let encoding: u32 = 0x64382000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_h_field_zm_0_min_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H field Zm = 0 (Min)
    // Fields: i3l=0, Zn=0, i3h=0, Zd=0, Zm=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_h_field_zm_1_poweroftwo_2000_64212000() {
    // Encoding: 0x64212000
    // Test FMUL_Z.ZZi_H field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, i3h=0, i3l=0, Zm=1, Zn=0
    let encoding: u32 = 0x64212000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_h_field_zn_0_min_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H field Zn = 0 (Min)
    // Fields: Zn=0, i3l=0, i3h=0, Zd=0, Zm=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_h_field_zn_1_poweroftwo_2000_64202020() {
    // Encoding: 0x64202020
    // Test FMUL_Z.ZZi_H field Zn = 1 (PowerOfTwo)
    // Fields: i3l=0, Zm=0, Zd=0, Zn=1, i3h=0
    let encoding: u32 = 0x64202020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zzi_h_field_zn_30_poweroftwominusone_2000_642023c0() {
    // Encoding: 0x642023C0
    // Test FMUL_Z.ZZi_H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: i3h=0, i3l=0, Zm=0, Zn=30, Zd=0
    let encoding: u32 = 0x642023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zzi_h_field_zn_31_max_2000_642023e0() {
    // Encoding: 0x642023E0
    // Test FMUL_Z.ZZi_H field Zn = 31 (Max)
    // Fields: Zn=31, i3h=0, Zm=0, i3l=0, Zd=0
    let encoding: u32 = 0x642023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_h_field_zd_0_min_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H field Zd = 0 (Min)
    // Fields: Zm=0, i3l=0, Zn=0, Zd=0, i3h=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_h_field_zd_1_poweroftwo_2000_64202001() {
    // Encoding: 0x64202001
    // Test FMUL_Z.ZZi_H field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=1, i3h=0, i3l=0, Zn=0
    let encoding: u32 = 0x64202001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zzi_h_field_zd_30_poweroftwominusone_2000_6420201e() {
    // Encoding: 0x6420201E
    // Test FMUL_Z.ZZi_H field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, i3h=0, i3l=0, Zn=0, Zm=0
    let encoding: u32 = 0x6420201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zzi_h_field_zd_31_max_2000_6420201f() {
    // Encoding: 0x6420201F
    // Test FMUL_Z.ZZi_H field Zd = 31 (Max)
    // Fields: Zd=31, i3h=0, Zm=0, Zn=0, i3l=0
    let encoding: u32 = 0x6420201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i3h=0 (minimum value)
#[test]
fn test_fmul_z_zzi_h_combo_0_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H field combination: i3h=0, i3l=0, Zm=0, Zn=0, Zd=0
    // Fields: i3h=0, Zn=0, Zd=0, Zm=0, i3l=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zzi_h_invalid_0_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, i3l=0, Zd=0, Zm=0, i3h=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zzi_h_invalid_1_2000_64202000() {
    // Encoding: 0x64202000
    // Test FMUL_Z.ZZi_H invalid encoding: Unconditional UNDEFINED
    // Fields: i3h=0, i3l=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x64202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_zzi_s_field_i2_0_min_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S field i2 = 0 (Min)
    // Fields: Zn=0, Zm=0, i2=0, Zd=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmul_z_zzi_s_field_i2_1_poweroftwo_2000_64a82000() {
    // Encoding: 0x64A82000
    // Test FMUL_Z.ZZi_S field i2 = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=0, Zn=0, i2=1
    let encoding: u32 = 0x64A82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_fmul_z_zzi_s_field_i2_3_max_2000_64b82000() {
    // Encoding: 0x64B82000
    // Test FMUL_Z.ZZi_S field i2 = 3 (Max)
    // Fields: i2=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x64B82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_s_field_zm_0_min_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S field Zm = 0 (Min)
    // Fields: i2=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_s_field_zm_1_poweroftwo_2000_64a12000() {
    // Encoding: 0x64A12000
    // Test FMUL_Z.ZZi_S field Zm = 1 (PowerOfTwo)
    // Fields: i2=0, Zm=1, Zd=0, Zn=0
    let encoding: u32 = 0x64A12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_s_field_zn_0_min_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S field Zn = 0 (Min)
    // Fields: i2=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_s_field_zn_1_poweroftwo_2000_64a02020() {
    // Encoding: 0x64A02020
    // Test FMUL_Z.ZZi_S field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, Zm=0, i2=0
    let encoding: u32 = 0x64A02020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zzi_s_field_zn_30_poweroftwominusone_2000_64a023c0() {
    // Encoding: 0x64A023C0
    // Test FMUL_Z.ZZi_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zm=0, i2=0, Zn=30
    let encoding: u32 = 0x64A023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zzi_s_field_zn_31_max_2000_64a023e0() {
    // Encoding: 0x64A023E0
    // Test FMUL_Z.ZZi_S field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, i2=0, Zm=0
    let encoding: u32 = 0x64A023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_s_field_zd_0_min_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S field Zd = 0 (Min)
    // Fields: i2=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_s_field_zd_1_poweroftwo_2000_64a02001() {
    // Encoding: 0x64A02001
    // Test FMUL_Z.ZZi_S field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, i2=0, Zm=0, Zd=1
    let encoding: u32 = 0x64A02001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zzi_s_field_zd_30_poweroftwominusone_2000_64a0201e() {
    // Encoding: 0x64A0201E
    // Test FMUL_Z.ZZi_S field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, Zd=30, i2=0
    let encoding: u32 = 0x64A0201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zzi_s_field_zd_31_max_2000_64a0201f() {
    // Encoding: 0x64A0201F
    // Test FMUL_Z.ZZi_S field Zd = 31 (Max)
    // Fields: i2=0, Zm=0, Zd=31, Zn=0
    let encoding: u32 = 0x64A0201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i2=0 (minimum value)
#[test]
fn test_fmul_z_zzi_s_combo_0_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S field combination: i2=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zd=0, Zn=0, i2=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zzi_s_invalid_0_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zm=0, i2=0, Zd=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zzi_s_invalid_1_2000_64a02000() {
    // Encoding: 0x64A02000
    // Test FMUL_Z.ZZi_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zd=0, i2=0, Zn=0
    let encoding: u32 = 0x64A02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_zzi_d_field_i1_0_min_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D field i1 = 0 (Min)
    // Fields: i1=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmul_z_zzi_d_field_i1_1_max_2000_64f02000() {
    // Encoding: 0x64F02000
    // Test FMUL_Z.ZZi_D field i1 = 1 (Max)
    // Fields: Zd=0, Zm=0, i1=1, Zn=0
    let encoding: u32 = 0x64F02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_d_field_zm_0_min_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D field Zm = 0 (Min)
    // Fields: Zd=0, Zn=0, Zm=0, i1=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_d_field_zm_1_poweroftwo_2000_64e12000() {
    // Encoding: 0x64E12000
    // Test FMUL_Z.ZZi_D field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=1, i1=0, Zd=0
    let encoding: u32 = 0x64E12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_d_field_zn_0_min_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D field Zn = 0 (Min)
    // Fields: Zm=0, i1=0, Zd=0, Zn=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_d_field_zn_1_poweroftwo_2000_64e02020() {
    // Encoding: 0x64E02020
    // Test FMUL_Z.ZZi_D field Zn = 1 (PowerOfTwo)
    // Fields: i1=0, Zd=0, Zm=0, Zn=1
    let encoding: u32 = 0x64E02020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zzi_d_field_zn_30_poweroftwominusone_2000_64e023c0() {
    // Encoding: 0x64E023C0
    // Test FMUL_Z.ZZi_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, i1=0, Zd=0, Zn=30
    let encoding: u32 = 0x64E023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zzi_d_field_zn_31_max_2000_64e023e0() {
    // Encoding: 0x64E023E0
    // Test FMUL_Z.ZZi_D field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, Zm=0, i1=0
    let encoding: u32 = 0x64E023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zzi_d_field_zd_0_min_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D field Zd = 0 (Min)
    // Fields: Zm=0, Zd=0, Zn=0, i1=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zzi_d_field_zd_1_poweroftwo_2000_64e02001() {
    // Encoding: 0x64E02001
    // Test FMUL_Z.ZZi_D field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, i1=0, Zn=0, Zd=1
    let encoding: u32 = 0x64E02001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zzi_d_field_zd_30_poweroftwominusone_2000_64e0201e() {
    // Encoding: 0x64E0201E
    // Test FMUL_Z.ZZi_D field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zd=30, Zn=0, i1=0
    let encoding: u32 = 0x64E0201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zzi_d_field_zd_31_max_2000_64e0201f() {
    // Encoding: 0x64E0201F
    // Test FMUL_Z.ZZi_D field Zd = 31 (Max)
    // Fields: i1=0, Zn=0, Zm=0, Zd=31
    let encoding: u32 = 0x64E0201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_fmul_z_zzi_d_combo_0_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D field combination: i1=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, i1=0, Zm=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zzi_d_invalid_0_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i1=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zzi_d_invalid_1_2000_64e02000() {
    // Encoding: 0x64E02000
    // Test FMUL_Z.ZZi_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, i1=0, Zn=0, Zm=0
    let encoding: u32 = 0x64E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZi_H
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmul_z_zzi_h_reg_write_0_64202000() {
    // Test FMUL_Z.ZZi_H register write: SimdFromField("d")
    // Encoding: 0x64202000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64202000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FMUL_Z.ZZi_S
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmul_z_zzi_s_reg_write_0_64a02000() {
    // Test FMUL_Z.ZZi_S register write: SimdFromField("d")
    // Encoding: 0x64A02000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64A02000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FMUL_Z.ZZi_D
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmul_z_zzi_d_reg_write_0_64e02000() {
    // Test FMUL_Z.ZZi_D register write: SimdFromField("d")
    // Encoding: 0x64E02000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64E02000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMSB_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmsb_z_p_zzz_field_size_0_min_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Za=0, Zdn=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmsb_z_p_zzz_field_size_1_poweroftwo_a000_6560a000() {
    // Encoding: 0x6560A000
    // Test FMSB_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zdn=0, size=1, Za=0
    let encoding: u32 = 0x6560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmsb_z_p_zzz_field_size_2_poweroftwo_a000_65a0a000() {
    // Encoding: 0x65A0A000
    // Test FMSB_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, Za=0, Zm=0
    let encoding: u32 = 0x65A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmsb_z_p_zzz_field_size_3_max_a000_65e0a000() {
    // Encoding: 0x65E0A000
    // Test FMSB_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Za=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmsb_z_p_zzz_field_za_0_min_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: size=0, Zdn=0, Za=0, Pg=0, Zm=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmsb_z_p_zzz_field_za_1_poweroftwo_a000_6521a000() {
    // Encoding: 0x6521A000
    // Test FMSB_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: Za=1, size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x6521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmsb_z_p_zzz_field_za_15_poweroftwominusone_a000_652fa000() {
    // Encoding: 0x652FA000
    // Test FMSB_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: Za=15, Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x652FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmsb_z_p_zzz_field_za_31_max_a000_653fa000() {
    // Encoding: 0x653FA000
    // Test FMSB_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0, Za=31
    let encoding: u32 = 0x653FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmsb_z_p_zzz_field_pg_0_min_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, Za=0, Pg=0, Zm=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmsb_z_p_zzz_field_pg_1_poweroftwo_a000_6520a400() {
    // Encoding: 0x6520A400
    // Test FMSB_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Za=0, Zm=0, Zdn=0
    let encoding: u32 = 0x6520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmsb_z_p_zzz_field_zm_0_min_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0, Za=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmsb_z_p_zzz_field_zm_1_poweroftwo_a000_6520a020() {
    // Encoding: 0x6520A020
    // Test FMSB_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Za=0, size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x6520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmsb_z_p_zzz_field_zm_30_poweroftwominusone_a000_6520a3c0() {
    // Encoding: 0x6520A3C0
    // Test FMSB_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Za=0, Zm=30, Zdn=0, Pg=0
    let encoding: u32 = 0x6520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmsb_z_p_zzz_field_zm_31_max_a000_6520a3e0() {
    // Encoding: 0x6520A3E0
    // Test FMSB_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: size=0, Za=0, Zm=31, Pg=0, Zdn=0
    let encoding: u32 = 0x6520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmsb_z_p_zzz_field_zdn_0_min_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, Za=0, size=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmsb_z_p_zzz_field_zdn_1_poweroftwo_a000_6520a001() {
    // Encoding: 0x6520A001
    // Test FMSB_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=0, Zdn=1, Za=0
    let encoding: u32 = 0x6520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmsb_z_p_zzz_field_zdn_15_poweroftwominusone_a000_6520a00f() {
    // Encoding: 0x6520A00F
    // Test FMSB_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zdn=15, Za=0, size=0
    let encoding: u32 = 0x6520A00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmsb_z_p_zzz_field_zdn_31_max_a000_6520a01f() {
    // Encoding: 0x6520A01F
    // Test FMSB_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, size=0, Zdn=31, Za=0
    let encoding: u32 = 0x6520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmsb_z_p_zzz_combo_0_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ field combination: size=0, Za=0, Pg=0, Zm=0, Zdn=0
    // Fields: Za=0, Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmsb_z_p_zzz_special_size_0_size_variant_0_40960_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Za=0, Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmsb_z_p_zzz_special_size_1_size_variant_1_40960_6560a000() {
    // Encoding: 0x6560A000
    // Test FMSB_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zdn=0, Zm=0, Za=0
    let encoding: u32 = 0x6560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmsb_z_p_zzz_special_size_2_size_variant_2_40960_65a0a000() {
    // Encoding: 0x65A0A000
    // Test FMSB_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zm=0, Zdn=0, Za=0
    let encoding: u32 = 0x65A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmsb_z_p_zzz_special_size_3_size_variant_3_40960_65e0a000() {
    // Encoding: 0x65E0A000
    // Test FMSB_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Za=0, Pg=0, Zm=0, size=3, Zdn=0
    let encoding: u32 = 0x65E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmsb_z_p_zzz_invalid_0_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zdn=0, size=0, Za=0, Pg=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmsb_z_p_zzz_invalid_1_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Za=0, Zdn=0, Pg=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmsb_z_p_zzz_invalid_2_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Zm=0, Pg=0, Za=0, size=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmsb_z_p_zzz_invalid_3_a000_6520a000() {
    // Encoding: 0x6520A000
    // Test FMSB_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Za=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x6520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMSB_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmsb_z_p_zzz_reg_write_0_6520a000() {
    // Test FMSB_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x6520A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6520A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMINNM_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fminnm_z_p_zz_field_size_0_min_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fminnm_z_p_zz_field_size_1_poweroftwo_8000_65458000() {
    // Encoding: 0x65458000
    // Test FMINNM_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x65458000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fminnm_z_p_zz_field_size_2_poweroftwo_8000_65858000() {
    // Encoding: 0x65858000
    // Test FMINNM_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, Pg=0, size=2
    let encoding: u32 = 0x65858000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fminnm_z_p_zz_field_size_3_max_8000_65c58000() {
    // Encoding: 0x65C58000
    // Test FMINNM_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65C58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fminnm_z_p_zz_field_pg_0_min_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fminnm_z_p_zz_field_pg_1_poweroftwo_8000_65058400() {
    // Encoding: 0x65058400
    // Test FMINNM_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65058400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminnm_z_p_zz_field_zm_0_min_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminnm_z_p_zz_field_zm_1_poweroftwo_8000_65058020() {
    // Encoding: 0x65058020
    // Test FMINNM_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=0, Zm=1
    let encoding: u32 = 0x65058020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminnm_z_p_zz_field_zm_30_poweroftwominusone_8000_650583c0() {
    // Encoding: 0x650583C0
    // Test FMINNM_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, Zm=30, Pg=0
    let encoding: u32 = 0x650583C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminnm_z_p_zz_field_zm_31_max_8000_650583e0() {
    // Encoding: 0x650583E0
    // Test FMINNM_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zdn=0, Zm=31, Pg=0
    let encoding: u32 = 0x650583E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fminnm_z_p_zz_field_zdn_0_min_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fminnm_z_p_zz_field_zdn_1_poweroftwo_8000_65058001() {
    // Encoding: 0x65058001
    // Test FMINNM_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x65058001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fminnm_z_p_zz_field_zdn_15_poweroftwominusone_8000_6505800f() {
    // Encoding: 0x6505800F
    // Test FMINNM_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x6505800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fminnm_z_p_zz_field_zdn_31_max_8000_6505801f() {
    // Encoding: 0x6505801F
    // Test FMINNM_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x6505801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fminnm_z_p_zz_combo_0_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fminnm_z_p_zz_special_size_0_size_variant_0_32768_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fminnm_z_p_zz_special_size_1_size_variant_1_32768_65458000() {
    // Encoding: 0x65458000
    // Test FMINNM_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Zdn=0, Pg=0
    let encoding: u32 = 0x65458000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fminnm_z_p_zz_special_size_2_size_variant_2_32768_65858000() {
    // Encoding: 0x65858000
    // Test FMINNM_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Pg=0, size=2, Zdn=0
    let encoding: u32 = 0x65858000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fminnm_z_p_zz_special_size_3_size_variant_3_32768_65c58000() {
    // Encoding: 0x65C58000
    // Test FMINNM_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x65C58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zz_invalid_0_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zz_invalid_1_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zz_invalid_2_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminnm_z_p_zz_invalid_3_8000_65058000() {
    // Encoding: 0x65058000
    // Test FMINNM_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65058000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNM_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fminnm_z_p_zz_reg_write_0_65058000() {
    // Test FMINNM_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65058000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65058000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAXNM_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmaxnm_z_p_zz_field_size_0_min_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmaxnm_z_p_zz_field_size_1_poweroftwo_8000_65448000() {
    // Encoding: 0x65448000
    // Test FMAXNM_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65448000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmaxnm_z_p_zz_field_size_2_poweroftwo_8000_65848000() {
    // Encoding: 0x65848000
    // Test FMAXNM_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65848000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmaxnm_z_p_zz_field_size_3_max_8000_65c48000() {
    // Encoding: 0x65C48000
    // Test FMAXNM_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x65C48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmaxnm_z_p_zz_field_pg_0_min_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmaxnm_z_p_zz_field_pg_1_poweroftwo_8000_65048400() {
    // Encoding: 0x65048400
    // Test FMAXNM_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, size=0, Zdn=0
    let encoding: u32 = 0x65048400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmaxnm_z_p_zz_field_zm_0_min_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmaxnm_z_p_zz_field_zm_1_poweroftwo_8000_65048020() {
    // Encoding: 0x65048020
    // Test FMAXNM_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, size=0, Pg=0
    let encoding: u32 = 0x65048020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmaxnm_z_p_zz_field_zm_30_poweroftwominusone_8000_650483c0() {
    // Encoding: 0x650483C0
    // Test FMAXNM_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Pg=0, size=0, Zm=30
    let encoding: u32 = 0x650483C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmaxnm_z_p_zz_field_zm_31_max_8000_650483e0() {
    // Encoding: 0x650483E0
    // Test FMAXNM_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, Pg=0, size=0, Zm=31
    let encoding: u32 = 0x650483E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmaxnm_z_p_zz_field_zdn_0_min_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmaxnm_z_p_zz_field_zdn_1_poweroftwo_8000_65048001() {
    // Encoding: 0x65048001
    // Test FMAXNM_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=1, size=0, Zm=0
    let encoding: u32 = 0x65048001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmaxnm_z_p_zz_field_zdn_15_poweroftwominusone_8000_6504800f() {
    // Encoding: 0x6504800F
    // Test FMAXNM_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, size=0, Zdn=15
    let encoding: u32 = 0x6504800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmaxnm_z_p_zz_field_zdn_31_max_8000_6504801f() {
    // Encoding: 0x6504801F
    // Test FMAXNM_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zdn=31, size=0
    let encoding: u32 = 0x6504801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmaxnm_z_p_zz_combo_0_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmaxnm_z_p_zz_special_size_0_size_variant_0_32768_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmaxnm_z_p_zz_special_size_1_size_variant_1_32768_65448000() {
    // Encoding: 0x65448000
    // Test FMAXNM_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zdn=0, Zm=0
    let encoding: u32 = 0x65448000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmaxnm_z_p_zz_special_size_2_size_variant_2_32768_65848000() {
    // Encoding: 0x65848000
    // Test FMAXNM_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x65848000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmaxnm_z_p_zz_special_size_3_size_variant_3_32768_65c48000() {
    // Encoding: 0x65C48000
    // Test FMAXNM_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zdn=0, Zm=0, size=3
    let encoding: u32 = 0x65C48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zz_invalid_0_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zz_invalid_1_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zz_invalid_2_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxnm_z_p_zz_invalid_3_8000_65048000() {
    // Encoding: 0x65048000
    // Test FMAXNM_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x65048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNM_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmaxnm_z_p_zz_reg_write_0_65048000() {
    // Test FMAXNM_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65048000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65048000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAX_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmax_z_p_zs_field_size_0_min_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ field size = 0 (Min)
    // Fields: Pg=0, size=0, i1=0, Zdn=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmax_z_p_zs_field_size_1_poweroftwo_8000_655e8000() {
    // Encoding: 0x655E8000
    // Test FMAX_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=1, i1=0
    let encoding: u32 = 0x655E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmax_z_p_zs_field_size_2_poweroftwo_8000_659e8000() {
    // Encoding: 0x659E8000
    // Test FMAX_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: i1=0, Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x659E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmax_z_p_zs_field_size_3_max_8000_65de8000() {
    // Encoding: 0x65DE8000
    // Test FMAX_Z.P.ZS__ field size = 3 (Max)
    // Fields: size=3, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x65DE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmax_z_p_zs_field_pg_0_min_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmax_z_p_zs_field_pg_1_poweroftwo_8000_651e8400() {
    // Encoding: 0x651E8400
    // Test FMAX_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: i1=0, Pg=1, size=0, Zdn=0
    let encoding: u32 = 0x651E8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmax_z_p_zs_field_i1_0_min_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0, i1=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmax_z_p_zs_field_i1_1_max_8000_651e8020() {
    // Encoding: 0x651E8020
    // Test FMAX_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: Zdn=0, Pg=0, size=0, i1=1
    let encoding: u32 = 0x651E8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmax_z_p_zs_field_zdn_0_min_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, i1=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmax_z_p_zs_field_zdn_1_poweroftwo_8000_651e8001() {
    // Encoding: 0x651E8001
    // Test FMAX_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: i1=0, Zdn=1, size=0, Pg=0
    let encoding: u32 = 0x651E8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmax_z_p_zs_field_zdn_15_poweroftwominusone_8000_651e800f() {
    // Encoding: 0x651E800F
    // Test FMAX_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=15, i1=0
    let encoding: u32 = 0x651E800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmax_z_p_zs_field_zdn_31_max_8000_651e801f() {
    // Encoding: 0x651E801F
    // Test FMAX_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, i1=0, Zdn=31
    let encoding: u32 = 0x651E801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmax_z_p_zs_combo_0_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: size=0, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmax_z_p_zs_special_size_0_size_variant_0_32768_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmax_z_p_zs_special_size_1_size_variant_1_32768_655e8000() {
    // Encoding: 0x655E8000
    // Test FMAX_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, i1=0, Zdn=0, size=1
    let encoding: u32 = 0x655E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmax_z_p_zs_special_size_2_size_variant_2_32768_659e8000() {
    // Encoding: 0x659E8000
    // Test FMAX_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, i1=0, size=2, Pg=0
    let encoding: u32 = 0x659E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmax_z_p_zs_special_size_3_size_variant_3_32768_65de8000() {
    // Encoding: 0x65DE8000
    // Test FMAX_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: i1=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x65DE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zs_invalid_0_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Pg=0, size=0, i1=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zs_invalid_1_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zs_invalid_2_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: i1=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmax_z_p_zs_invalid_3_8000_651e8000() {
    // Encoding: 0x651E8000
    // Test FMAX_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x651E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAX_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmax_z_p_zs_reg_write_0_651e8000() {
    // Test FMAX_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651E8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651E8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FNMAD_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fnmad_z_p_zzz_field_size_0_min_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: size=0, Za=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fnmad_z_p_zzz_field_size_1_poweroftwo_c000_6560c000() {
    // Encoding: 0x6560C000
    // Test FNMAD_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, Zm=0, Pg=0, Za=0
    let encoding: u32 = 0x6560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fnmad_z_p_zzz_field_size_2_poweroftwo_c000_65a0c000() {
    // Encoding: 0x65A0C000
    // Test FNMAD_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=2, Za=0, Zm=0
    let encoding: u32 = 0x65A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fnmad_z_p_zzz_field_size_3_max_c000_65e0c000() {
    // Encoding: 0x65E0C000
    // Test FNMAD_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Za=0, Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x65E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmad_z_p_zzz_field_za_0_min_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Za=0, Pg=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmad_z_p_zzz_field_za_1_poweroftwo_c000_6521c000() {
    // Encoding: 0x6521C000
    // Test FNMAD_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: Za=1, Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x6521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmad_z_p_zzz_field_za_15_poweroftwominusone_c000_652fc000() {
    // Encoding: 0x652FC000
    // Test FNMAD_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zm=0, Za=15, Zdn=0
    let encoding: u32 = 0x652FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmad_z_p_zzz_field_za_31_max_c000_653fc000() {
    // Encoding: 0x653FC000
    // Test FNMAD_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0, Za=31
    let encoding: u32 = 0x653FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fnmad_z_p_zzz_field_pg_0_min_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Za=0, Zdn=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fnmad_z_p_zzz_field_pg_1_poweroftwo_c000_6520c400() {
    // Encoding: 0x6520C400
    // Test FNMAD_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=1, Zm=0, Za=0
    let encoding: u32 = 0x6520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmad_z_p_zzz_field_zm_0_min_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Za=0, size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmad_z_p_zzz_field_zm_1_poweroftwo_c000_6520c020() {
    // Encoding: 0x6520C020
    // Test FNMAD_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Za=0, Pg=0, Zm=1
    let encoding: u32 = 0x6520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmad_z_p_zzz_field_zm_30_poweroftwominusone_c000_6520c3c0() {
    // Encoding: 0x6520C3C0
    // Test FNMAD_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Za=0, Zm=30, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x6520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmad_z_p_zzz_field_zm_31_max_c000_6520c3e0() {
    // Encoding: 0x6520C3E0
    // Test FNMAD_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Za=0, Zm=31, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x6520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmad_z_p_zzz_field_zdn_0_min_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: Zdn=0, Za=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmad_z_p_zzz_field_zdn_1_poweroftwo_c000_6520c001() {
    // Encoding: 0x6520C001
    // Test FNMAD_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, Zm=0, Pg=0, Za=0
    let encoding: u32 = 0x6520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmad_z_p_zzz_field_zdn_15_poweroftwominusone_c000_6520c00f() {
    // Encoding: 0x6520C00F
    // Test FNMAD_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, Za=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x6520C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmad_z_p_zzz_field_zdn_31_max_c000_6520c01f() {
    // Encoding: 0x6520C01F
    // Test FNMAD_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: Za=0, Zm=0, Pg=0, Zdn=31, size=0
    let encoding: u32 = 0x6520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fnmad_z_p_zzz_combo_0_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ field combination: size=0, Za=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zm=0, Zdn=0, Pg=0, Za=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fnmad_z_p_zzz_special_size_0_size_variant_0_49152_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zm=0, Za=0, Zdn=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fnmad_z_p_zzz_special_size_1_size_variant_1_49152_6560c000() {
    // Encoding: 0x6560C000
    // Test FNMAD_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Pg=0, Za=0, size=1, Zm=0
    let encoding: u32 = 0x6560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fnmad_z_p_zzz_special_size_2_size_variant_2_49152_65a0c000() {
    // Encoding: 0x65A0C000
    // Test FNMAD_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Za=0, Zm=0, Zdn=0, Pg=0, size=2
    let encoding: u32 = 0x65A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fnmad_z_p_zzz_special_size_3_size_variant_3_49152_65e0c000() {
    // Encoding: 0x65E0C000
    // Test FNMAD_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zm=0, Za=0, Zdn=0
    let encoding: u32 = 0x65E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fnmad_z_p_zzz_invalid_0_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Za=0, Zm=0, Pg=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmad_z_p_zzz_invalid_1_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, size=0, Za=0, Zdn=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fnmad_z_p_zzz_invalid_2_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, Pg=0, Za=0, size=0, Zm=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmad_z_p_zzz_invalid_3_c000_6520c000() {
    // Encoding: 0x6520C000
    // Test FNMAD_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Za=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x6520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMAD_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fnmad_z_p_zzz_reg_write_0_6520c000() {
    // Test FNMAD_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x6520C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6520C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FNEG_Z.P.Z__ Tests
// ============================================================================

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fneg_z_p_z_field_size_0_min_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fneg_z_p_z_field_size_1_poweroftwo_a000_045da000() {
    // Encoding: 0x045DA000
    // Test FNEG_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x045DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fneg_z_p_z_field_size_2_poweroftwo_a000_049da000() {
    // Encoding: 0x049DA000
    // Test FNEG_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x049DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fneg_z_p_z_field_size_3_max_a000_04dda000() {
    // Encoding: 0x04DDA000
    // Test FNEG_Z.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, Pg=0, Zd=0, size=3
    let encoding: u32 = 0x04DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fneg_z_p_z_field_pg_0_min_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fneg_z_p_z_field_pg_1_poweroftwo_a000_041da400() {
    // Encoding: 0x041DA400
    // Test FNEG_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zn=0, Pg=1
    let encoding: u32 = 0x041DA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fneg_z_p_z_field_zn_0_min_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fneg_z_p_z_field_zn_1_poweroftwo_a000_041da020() {
    // Encoding: 0x041DA020
    // Test FNEG_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x041DA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fneg_z_p_z_field_zn_30_poweroftwominusone_a000_041da3c0() {
    // Encoding: 0x041DA3C0
    // Test FNEG_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zd=0, Zn=30
    let encoding: u32 = 0x041DA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fneg_z_p_z_field_zn_31_max_a000_041da3e0() {
    // Encoding: 0x041DA3E0
    // Test FNEG_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x041DA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fneg_z_p_z_field_zd_0_min_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fneg_z_p_z_field_zd_1_poweroftwo_a000_041da001() {
    // Encoding: 0x041DA001
    // Test FNEG_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, size=0, Zd=1
    let encoding: u32 = 0x041DA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fneg_z_p_z_field_zd_30_poweroftwominusone_a000_041da01e() {
    // Encoding: 0x041DA01E
    // Test FNEG_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zd=30, size=0
    let encoding: u32 = 0x041DA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fneg_z_p_z_field_zd_31_max_a000_041da01f() {
    // Encoding: 0x041DA01F
    // Test FNEG_Z.P.Z__ field Zd = 31 (Max)
    // Fields: size=0, Pg=0, Zn=0, Zd=31
    let encoding: u32 = 0x041DA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fneg_z_p_z_combo_0_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fneg_z_p_z_special_size_0_size_variant_0_40960_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fneg_z_p_z_special_size_1_size_variant_1_40960_045da000() {
    // Encoding: 0x045DA000
    // Test FNEG_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x045DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fneg_z_p_z_special_size_2_size_variant_2_40960_049da000() {
    // Encoding: 0x049DA000
    // Test FNEG_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x049DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fneg_z_p_z_special_size_3_size_variant_3_40960_04dda000() {
    // Encoding: 0x04DDA000
    // Test FNEG_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x04DDA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fneg_z_p_z_invalid_0_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fneg_z_p_z_invalid_1_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fneg_z_p_z_invalid_2_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fneg_z_p_z_invalid_3_a000_041da000() {
    // Encoding: 0x041DA000
    // Test FNEG_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x041DA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNEG_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fneg_z_p_z_reg_write_0_041da000() {
    // Test FNEG_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x041DA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041DA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FDUP_Z.I__ Tests
// ============================================================================

/// Provenance: FDUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fdup_z_i_field_size_0_min_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ field size = 0 (Min)
    // Fields: size=0, imm8=0, Zd=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fdup_z_i_field_size_1_poweroftwo_c000_2579c000() {
    // Encoding: 0x2579C000
    // Test FDUP_Z.I__ field size = 1 (PowerOfTwo)
    // Fields: imm8=0, Zd=0, size=1
    let encoding: u32 = 0x2579C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fdup_z_i_field_size_2_poweroftwo_c000_25b9c000() {
    // Encoding: 0x25B9C000
    // Test FDUP_Z.I__ field size = 2 (PowerOfTwo)
    // Fields: imm8=0, Zd=0, size=2
    let encoding: u32 = 0x25B9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fdup_z_i_field_size_3_max_c000_25f9c000() {
    // Encoding: 0x25F9C000
    // Test FDUP_Z.I__ field size = 3 (Max)
    // Fields: Zd=0, imm8=0, size=3
    let encoding: u32 = 0x25F9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_fdup_z_i_field_imm8_0_zero_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ field imm8 = 0 (Zero)
    // Fields: size=0, imm8=0, Zd=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_fdup_z_i_field_imm8_1_poweroftwo_c000_2539c020() {
    // Encoding: 0x2539C020
    // Test FDUP_Z.I__ field imm8 = 1 (PowerOfTwo)
    // Fields: imm8=1, size=0, Zd=0
    let encoding: u32 = 0x2539C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_fdup_z_i_field_imm8_3_poweroftwominusone_c000_2539c060() {
    // Encoding: 0x2539C060
    // Test FDUP_Z.I__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: imm8=3, Zd=0, size=0
    let encoding: u32 = 0x2539C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_fdup_z_i_field_imm8_4_poweroftwo_c000_2539c080() {
    // Encoding: 0x2539C080
    // Test FDUP_Z.I__ field imm8 = 4 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm8=4
    let encoding: u32 = 0x2539C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_fdup_z_i_field_imm8_7_poweroftwominusone_c000_2539c0e0() {
    // Encoding: 0x2539C0E0
    // Test FDUP_Z.I__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: imm8=7, Zd=0, size=0
    let encoding: u32 = 0x2539C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_fdup_z_i_field_imm8_8_poweroftwo_c000_2539c100() {
    // Encoding: 0x2539C100
    // Test FDUP_Z.I__ field imm8 = 8 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm8=8
    let encoding: u32 = 0x2539C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_fdup_z_i_field_imm8_15_poweroftwominusone_c000_2539c1e0() {
    // Encoding: 0x2539C1E0
    // Test FDUP_Z.I__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=15, Zd=0
    let encoding: u32 = 0x2539C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_fdup_z_i_field_imm8_16_poweroftwo_c000_2539c200() {
    // Encoding: 0x2539C200
    // Test FDUP_Z.I__ field imm8 = 16 (PowerOfTwo)
    // Fields: imm8=16, Zd=0, size=0
    let encoding: u32 = 0x2539C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_fdup_z_i_field_imm8_31_poweroftwominusone_c000_2539c3e0() {
    // Encoding: 0x2539C3E0
    // Test FDUP_Z.I__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, imm8=31
    let encoding: u32 = 0x2539C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_fdup_z_i_field_imm8_32_poweroftwo_c000_2539c400() {
    // Encoding: 0x2539C400
    // Test FDUP_Z.I__ field imm8 = 32 (PowerOfTwo)
    // Fields: imm8=32, Zd=0, size=0
    let encoding: u32 = 0x2539C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_fdup_z_i_field_imm8_63_poweroftwominusone_c000_2539c7e0() {
    // Encoding: 0x2539C7E0
    // Test FDUP_Z.I__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: imm8=63, size=0, Zd=0
    let encoding: u32 = 0x2539C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_fdup_z_i_field_imm8_64_poweroftwo_c000_2539c800() {
    // Encoding: 0x2539C800
    // Test FDUP_Z.I__ field imm8 = 64 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm8=64
    let encoding: u32 = 0x2539C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_fdup_z_i_field_imm8_127_poweroftwominusone_c000_2539cfe0() {
    // Encoding: 0x2539CFE0
    // Test FDUP_Z.I__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: imm8=127, size=0, Zd=0
    let encoding: u32 = 0x2539CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_fdup_z_i_field_imm8_128_poweroftwo_c000_2539d000() {
    // Encoding: 0x2539D000
    // Test FDUP_Z.I__ field imm8 = 128 (PowerOfTwo)
    // Fields: size=0, imm8=128, Zd=0
    let encoding: u32 = 0x2539D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_fdup_z_i_field_imm8_255_max_c000_2539dfe0() {
    // Encoding: 0x2539DFE0
    // Test FDUP_Z.I__ field imm8 = 255 (Max)
    // Fields: imm8=255, size=0, Zd=0
    let encoding: u32 = 0x2539DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fdup_z_i_field_zd_0_min_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, imm8=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fdup_z_i_field_zd_1_poweroftwo_c000_2539c001() {
    // Encoding: 0x2539C001
    // Test FDUP_Z.I__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, imm8=0, Zd=1
    let encoding: u32 = 0x2539C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fdup_z_i_field_zd_30_poweroftwominusone_c000_2539c01e() {
    // Encoding: 0x2539C01E
    // Test FDUP_Z.I__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=0, Zd=30
    let encoding: u32 = 0x2539C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fdup_z_i_field_zd_31_max_c000_2539c01f() {
    // Encoding: 0x2539C01F
    // Test FDUP_Z.I__ field Zd = 31 (Max)
    // Fields: imm8=0, Zd=31, size=0
    let encoding: u32 = 0x2539C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fdup_z_i_combo_0_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ field combination: size=0, imm8=0, Zd=0
    // Fields: Zd=0, size=0, imm8=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fdup_z_i_special_size_0_size_variant_0_49152_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ special value size = 0 (Size variant 0)
    // Fields: size=0, imm8=0, Zd=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fdup_z_i_special_size_1_size_variant_1_49152_2579c000() {
    // Encoding: 0x2579C000
    // Test FDUP_Z.I__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, size=1, imm8=0
    let encoding: u32 = 0x2579C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fdup_z_i_special_size_2_size_variant_2_49152_25b9c000() {
    // Encoding: 0x25B9C000
    // Test FDUP_Z.I__ special value size = 2 (Size variant 2)
    // Fields: imm8=0, size=2, Zd=0
    let encoding: u32 = 0x25B9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fdup_z_i_special_size_3_size_variant_3_49152_25f9c000() {
    // Encoding: 0x25F9C000
    // Test FDUP_Z.I__ special value size = 3 (Size variant 3)
    // Fields: size=3, imm8=0, Zd=0
    let encoding: u32 = 0x25F9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fdup_z_i_invalid_0_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm8=0, Zd=0, size=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdup_z_i_invalid_1_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, imm8=0, size=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fdup_z_i_invalid_2_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: imm8=0, size=0, Zd=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdup_z_i_invalid_3_c000_2539c000() {
    // Encoding: 0x2539C000
    // Test FDUP_Z.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, imm8=0, size=0
    let encoding: u32 = 0x2539C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDUP_Z.I__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fdup_z_i_reg_write_0_2539c000() {
    // Test FDUP_Z.I__ register write: SimdFromField("d")
    // Encoding: 0x2539C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2539C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRINTI_Z.P.Z__ Tests
// ============================================================================

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frinti_z_p_z_field_size_0_min_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frinti_z_p_z_field_size_1_poweroftwo_a000_6547a000() {
    // Encoding: 0x6547A000
    // Test FRINTI_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x6547A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frinti_z_p_z_field_size_2_poweroftwo_a000_6587a000() {
    // Encoding: 0x6587A000
    // Test FRINTI_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, Zn=0, size=2
    let encoding: u32 = 0x6587A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frinti_z_p_z_field_size_3_max_a000_65c7a000() {
    // Encoding: 0x65C7A000
    // Test FRINTI_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frinti_z_p_z_field_pg_0_min_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frinti_z_p_z_field_pg_1_poweroftwo_a000_6507a400() {
    // Encoding: 0x6507A400
    // Test FRINTI_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x6507A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frinti_z_p_z_field_zn_0_min_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frinti_z_p_z_field_zn_1_poweroftwo_a000_6507a020() {
    // Encoding: 0x6507A020
    // Test FRINTI_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x6507A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frinti_z_p_z_field_zn_30_poweroftwominusone_a000_6507a3c0() {
    // Encoding: 0x6507A3C0
    // Test FRINTI_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30, size=0
    let encoding: u32 = 0x6507A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frinti_z_p_z_field_zn_31_max_a000_6507a3e0() {
    // Encoding: 0x6507A3E0
    // Test FRINTI_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0, Pg=0
    let encoding: u32 = 0x6507A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frinti_z_p_z_field_zd_0_min_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frinti_z_p_z_field_zd_1_poweroftwo_a000_6507a001() {
    // Encoding: 0x6507A001
    // Test FRINTI_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x6507A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frinti_z_p_z_field_zd_30_poweroftwominusone_a000_6507a01e() {
    // Encoding: 0x6507A01E
    // Test FRINTI_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x6507A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frinti_z_p_z_field_zd_31_max_a000_6507a01f() {
    // Encoding: 0x6507A01F
    // Test FRINTI_Z.P.Z__ field Zd = 31 (Max)
    // Fields: size=0, Pg=0, Zd=31, Zn=0
    let encoding: u32 = 0x6507A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frinti_z_p_z_combo_0_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frinti_z_p_z_special_size_0_size_variant_0_40960_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frinti_z_p_z_special_size_1_size_variant_1_40960_6547a000() {
    // Encoding: 0x6547A000
    // Test FRINTI_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Pg=0, size=1, Zd=0
    let encoding: u32 = 0x6547A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frinti_z_p_z_special_size_2_size_variant_2_40960_6587a000() {
    // Encoding: 0x6587A000
    // Test FRINTI_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, size=2, Pg=0, Zn=0
    let encoding: u32 = 0x6587A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frinti_z_p_z_special_size_3_size_variant_3_40960_65c7a000() {
    // Encoding: 0x65C7A000
    // Test FRINTI_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frinti_z_p_z_invalid_0_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frinti_z_p_z_invalid_1_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frinti_z_p_z_invalid_2_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frinti_z_p_z_invalid_3_a000_6507a000() {
    // Encoding: 0x6507A000
    // Test FRINTI_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x6507A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frintx_z_p_z_field_size_0_min_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frintx_z_p_z_field_size_1_poweroftwo_a000_6546a000() {
    // Encoding: 0x6546A000
    // Test FRINTX_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x6546A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frintx_z_p_z_field_size_2_poweroftwo_a000_6586a000() {
    // Encoding: 0x6586A000
    // Test FRINTX_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6586A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frintx_z_p_z_field_size_3_max_a000_65c6a000() {
    // Encoding: 0x65C6A000
    // Test FRINTX_Z.P.Z__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, Pg=0, size=3
    let encoding: u32 = 0x65C6A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frintx_z_p_z_field_pg_0_min_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frintx_z_p_z_field_pg_1_poweroftwo_a000_6506a400() {
    // Encoding: 0x6506A400
    // Test FRINTX_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x6506A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintx_z_p_z_field_zn_0_min_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintx_z_p_z_field_zn_1_poweroftwo_a000_6506a020() {
    // Encoding: 0x6506A020
    // Test FRINTX_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, size=0, Zn=1
    let encoding: u32 = 0x6506A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintx_z_p_z_field_zn_30_poweroftwominusone_a000_6506a3c0() {
    // Encoding: 0x6506A3C0
    // Test FRINTX_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x6506A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintx_z_p_z_field_zn_31_max_a000_6506a3e0() {
    // Encoding: 0x6506A3E0
    // Test FRINTX_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Pg=0, Zd=0, Zn=31
    let encoding: u32 = 0x6506A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintx_z_p_z_field_zd_0_min_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintx_z_p_z_field_zd_1_poweroftwo_a000_6506a001() {
    // Encoding: 0x6506A001
    // Test FRINTX_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Pg=0, Zd=1
    let encoding: u32 = 0x6506A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintx_z_p_z_field_zd_30_poweroftwominusone_a000_6506a01e() {
    // Encoding: 0x6506A01E
    // Test FRINTX_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, size=0, Zd=30, Pg=0
    let encoding: u32 = 0x6506A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintx_z_p_z_field_zd_31_max_a000_6506a01f() {
    // Encoding: 0x6506A01F
    // Test FRINTX_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6506A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frintx_z_p_z_combo_0_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frintx_z_p_z_special_size_0_size_variant_0_40960_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frintx_z_p_z_special_size_1_size_variant_1_40960_6546a000() {
    // Encoding: 0x6546A000
    // Test FRINTX_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x6546A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frintx_z_p_z_special_size_2_size_variant_2_40960_6586a000() {
    // Encoding: 0x6586A000
    // Test FRINTX_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6586A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frintx_z_p_z_special_size_3_size_variant_3_40960_65c6a000() {
    // Encoding: 0x65C6A000
    // Test FRINTX_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Zd=0, Pg=0
    let encoding: u32 = 0x65C6A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frintx_z_p_z_invalid_0_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintx_z_p_z_invalid_1_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frintx_z_p_z_invalid_2_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintx_z_p_z_invalid_3_a000_6506a000() {
    // Encoding: 0x6506A000
    // Test FRINTX_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x6506A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frinta_z_p_z_field_size_0_min_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frinta_z_p_z_field_size_1_poweroftwo_a000_6544a000() {
    // Encoding: 0x6544A000
    // Test FRINTA_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6544A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frinta_z_p_z_field_size_2_poweroftwo_a000_6584a000() {
    // Encoding: 0x6584A000
    // Test FRINTA_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=2, Pg=0
    let encoding: u32 = 0x6584A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frinta_z_p_z_field_size_3_max_a000_65c4a000() {
    // Encoding: 0x65C4A000
    // Test FRINTA_Z.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Pg=0, Zd=0
    let encoding: u32 = 0x65C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frinta_z_p_z_field_pg_0_min_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frinta_z_p_z_field_pg_1_poweroftwo_a000_6504a400() {
    // Encoding: 0x6504A400
    // Test FRINTA_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x6504A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frinta_z_p_z_field_zn_0_min_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frinta_z_p_z_field_zn_1_poweroftwo_a000_6504a020() {
    // Encoding: 0x6504A020
    // Test FRINTA_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0, Pg=0
    let encoding: u32 = 0x6504A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frinta_z_p_z_field_zn_30_poweroftwominusone_a000_6504a3c0() {
    // Encoding: 0x6504A3C0
    // Test FRINTA_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=30, Zd=0
    let encoding: u32 = 0x6504A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frinta_z_p_z_field_zn_31_max_a000_6504a3e0() {
    // Encoding: 0x6504A3E0
    // Test FRINTA_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, size=0, Zn=31
    let encoding: u32 = 0x6504A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frinta_z_p_z_field_zd_0_min_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frinta_z_p_z_field_zd_1_poweroftwo_a000_6504a001() {
    // Encoding: 0x6504A001
    // Test FRINTA_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6504A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frinta_z_p_z_field_zd_30_poweroftwominusone_a000_6504a01e() {
    // Encoding: 0x6504A01E
    // Test FRINTA_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, size=0, Pg=0, Zd=30
    let encoding: u32 = 0x6504A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frinta_z_p_z_field_zd_31_max_a000_6504a01f() {
    // Encoding: 0x6504A01F
    // Test FRINTA_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Pg=0, Zd=31
    let encoding: u32 = 0x6504A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frinta_z_p_z_combo_0_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frinta_z_p_z_special_size_0_size_variant_0_40960_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frinta_z_p_z_special_size_1_size_variant_1_40960_6544a000() {
    // Encoding: 0x6544A000
    // Test FRINTA_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x6544A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frinta_z_p_z_special_size_2_size_variant_2_40960_6584a000() {
    // Encoding: 0x6584A000
    // Test FRINTA_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zn=0, size=2, Zd=0
    let encoding: u32 = 0x6584A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frinta_z_p_z_special_size_3_size_variant_3_40960_65c4a000() {
    // Encoding: 0x65C4A000
    // Test FRINTA_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zd=0, size=3, Zn=0
    let encoding: u32 = 0x65C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frinta_z_p_z_invalid_0_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frinta_z_p_z_invalid_1_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frinta_z_p_z_invalid_2_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frinta_z_p_z_invalid_3_a000_6504a000() {
    // Encoding: 0x6504A000
    // Test FRINTA_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x6504A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frintn_z_p_z_field_size_0_min_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frintn_z_p_z_field_size_1_poweroftwo_a000_6540a000() {
    // Encoding: 0x6540A000
    // Test FRINTN_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frintn_z_p_z_field_size_2_poweroftwo_a000_6580a000() {
    // Encoding: 0x6580A000
    // Test FRINTN_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x6580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frintn_z_p_z_field_size_3_max_a000_65c0a000() {
    // Encoding: 0x65C0A000
    // Test FRINTN_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x65C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frintn_z_p_z_field_pg_0_min_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frintn_z_p_z_field_pg_1_poweroftwo_a000_6500a400() {
    // Encoding: 0x6500A400
    // Test FRINTN_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6500A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintn_z_p_z_field_zn_0_min_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintn_z_p_z_field_zn_1_poweroftwo_a000_6500a020() {
    // Encoding: 0x6500A020
    // Test FRINTN_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=1, Zd=0
    let encoding: u32 = 0x6500A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintn_z_p_z_field_zn_30_poweroftwominusone_a000_6500a3c0() {
    // Encoding: 0x6500A3C0
    // Test FRINTN_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x6500A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintn_z_p_z_field_zn_31_max_a000_6500a3e0() {
    // Encoding: 0x6500A3E0
    // Test FRINTN_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Pg=0, Zn=31, Zd=0
    let encoding: u32 = 0x6500A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintn_z_p_z_field_zd_0_min_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintn_z_p_z_field_zd_1_poweroftwo_a000_6500a001() {
    // Encoding: 0x6500A001
    // Test FRINTN_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x6500A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintn_z_p_z_field_zd_30_poweroftwominusone_a000_6500a01e() {
    // Encoding: 0x6500A01E
    // Test FRINTN_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, Zd=30, size=0
    let encoding: u32 = 0x6500A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintn_z_p_z_field_zd_31_max_a000_6500a01f() {
    // Encoding: 0x6500A01F
    // Test FRINTN_Z.P.Z__ field Zd = 31 (Max)
    // Fields: size=0, Pg=0, Zn=0, Zd=31
    let encoding: u32 = 0x6500A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frintn_z_p_z_combo_0_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frintn_z_p_z_special_size_0_size_variant_0_40960_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frintn_z_p_z_special_size_1_size_variant_1_40960_6540a000() {
    // Encoding: 0x6540A000
    // Test FRINTN_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Zd=0, Pg=0
    let encoding: u32 = 0x6540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frintn_z_p_z_special_size_2_size_variant_2_40960_6580a000() {
    // Encoding: 0x6580A000
    // Test FRINTN_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frintn_z_p_z_special_size_3_size_variant_3_40960_65c0a000() {
    // Encoding: 0x65C0A000
    // Test FRINTN_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zn=0, Zd=0, size=3
    let encoding: u32 = 0x65C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frintn_z_p_z_invalid_0_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintn_z_p_z_invalid_1_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frintn_z_p_z_invalid_2_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintn_z_p_z_invalid_3_a000_6500a000() {
    // Encoding: 0x6500A000
    // Test FRINTN_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x6500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frintz_z_p_z_field_size_0_min_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frintz_z_p_z_field_size_1_poweroftwo_a000_6543a000() {
    // Encoding: 0x6543A000
    // Test FRINTZ_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x6543A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frintz_z_p_z_field_size_2_poweroftwo_a000_6583a000() {
    // Encoding: 0x6583A000
    // Test FRINTZ_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, size=2, Pg=0, Zn=0
    let encoding: u32 = 0x6583A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frintz_z_p_z_field_size_3_max_a000_65c3a000() {
    // Encoding: 0x65C3A000
    // Test FRINTZ_Z.P.Z__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x65C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frintz_z_p_z_field_pg_0_min_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frintz_z_p_z_field_pg_1_poweroftwo_a000_6503a400() {
    // Encoding: 0x6503A400
    // Test FRINTZ_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zn=0, Pg=1
    let encoding: u32 = 0x6503A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintz_z_p_z_field_zn_0_min_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintz_z_p_z_field_zn_1_poweroftwo_a000_6503a020() {
    // Encoding: 0x6503A020
    // Test FRINTZ_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, size=0, Pg=0
    let encoding: u32 = 0x6503A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintz_z_p_z_field_zn_30_poweroftwominusone_a000_6503a3c0() {
    // Encoding: 0x6503A3C0
    // Test FRINTZ_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0, Pg=0
    let encoding: u32 = 0x6503A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintz_z_p_z_field_zn_31_max_a000_6503a3e0() {
    // Encoding: 0x6503A3E0
    // Test FRINTZ_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zd=0, Pg=0, Zn=31
    let encoding: u32 = 0x6503A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintz_z_p_z_field_zd_0_min_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintz_z_p_z_field_zd_1_poweroftwo_a000_6503a001() {
    // Encoding: 0x6503A001
    // Test FRINTZ_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0, size=0
    let encoding: u32 = 0x6503A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintz_z_p_z_field_zd_30_poweroftwominusone_a000_6503a01e() {
    // Encoding: 0x6503A01E
    // Test FRINTZ_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x6503A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintz_z_p_z_field_zd_31_max_a000_6503a01f() {
    // Encoding: 0x6503A01F
    // Test FRINTZ_Z.P.Z__ field Zd = 31 (Max)
    // Fields: size=0, Pg=0, Zn=0, Zd=31
    let encoding: u32 = 0x6503A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frintz_z_p_z_combo_0_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frintz_z_p_z_special_size_0_size_variant_0_40960_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frintz_z_p_z_special_size_1_size_variant_1_40960_6543a000() {
    // Encoding: 0x6543A000
    // Test FRINTZ_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6543A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frintz_z_p_z_special_size_2_size_variant_2_40960_6583a000() {
    // Encoding: 0x6583A000
    // Test FRINTZ_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x6583A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frintz_z_p_z_special_size_3_size_variant_3_40960_65c3a000() {
    // Encoding: 0x65C3A000
    // Test FRINTZ_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Pg=0, Zd=0
    let encoding: u32 = 0x65C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frintz_z_p_z_invalid_0_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintz_z_p_z_invalid_1_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frintz_z_p_z_invalid_2_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintz_z_p_z_invalid_3_a000_6503a000() {
    // Encoding: 0x6503A000
    // Test FRINTZ_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6503A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frintm_z_p_z_field_size_0_min_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frintm_z_p_z_field_size_1_poweroftwo_a000_6542a000() {
    // Encoding: 0x6542A000
    // Test FRINTM_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x6542A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frintm_z_p_z_field_size_2_poweroftwo_a000_6582a000() {
    // Encoding: 0x6582A000
    // Test FRINTM_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=2, Pg=0
    let encoding: u32 = 0x6582A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frintm_z_p_z_field_size_3_max_a000_65c2a000() {
    // Encoding: 0x65C2A000
    // Test FRINTM_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x65C2A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frintm_z_p_z_field_pg_0_min_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frintm_z_p_z_field_pg_1_poweroftwo_a000_6502a400() {
    // Encoding: 0x6502A400
    // Test FRINTM_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zd=0, size=0
    let encoding: u32 = 0x6502A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintm_z_p_z_field_zn_0_min_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintm_z_p_z_field_zn_1_poweroftwo_a000_6502a020() {
    // Encoding: 0x6502A020
    // Test FRINTM_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zn=1, Pg=0
    let encoding: u32 = 0x6502A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintm_z_p_z_field_zn_30_poweroftwominusone_a000_6502a3c0() {
    // Encoding: 0x6502A3C0
    // Test FRINTM_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=0, Zn=30, size=0
    let encoding: u32 = 0x6502A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintm_z_p_z_field_zn_31_max_a000_6502a3e0() {
    // Encoding: 0x6502A3E0
    // Test FRINTM_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, size=0, Zn=31, Pg=0
    let encoding: u32 = 0x6502A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintm_z_p_z_field_zd_0_min_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintm_z_p_z_field_zd_1_poweroftwo_a000_6502a001() {
    // Encoding: 0x6502A001
    // Test FRINTM_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zd=1, Zn=0, Pg=0
    let encoding: u32 = 0x6502A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintm_z_p_z_field_zd_30_poweroftwominusone_a000_6502a01e() {
    // Encoding: 0x6502A01E
    // Test FRINTM_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, size=0, Zd=30
    let encoding: u32 = 0x6502A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintm_z_p_z_field_zd_31_max_a000_6502a01f() {
    // Encoding: 0x6502A01F
    // Test FRINTM_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Pg=0, size=0, Zd=31
    let encoding: u32 = 0x6502A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frintm_z_p_z_combo_0_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frintm_z_p_z_special_size_0_size_variant_0_40960_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frintm_z_p_z_special_size_1_size_variant_1_40960_6542a000() {
    // Encoding: 0x6542A000
    // Test FRINTM_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x6542A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frintm_z_p_z_special_size_2_size_variant_2_40960_6582a000() {
    // Encoding: 0x6582A000
    // Test FRINTM_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zn=0, Zd=0
    let encoding: u32 = 0x6582A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frintm_z_p_z_special_size_3_size_variant_3_40960_65c2a000() {
    // Encoding: 0x65C2A000
    // Test FRINTM_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C2A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frintm_z_p_z_invalid_0_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintm_z_p_z_invalid_1_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frintm_z_p_z_invalid_2_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintm_z_p_z_invalid_3_a000_6502a000() {
    // Encoding: 0x6502A000
    // Test FRINTM_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x6502A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frintp_z_p_z_field_size_0_min_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frintp_z_p_z_field_size_1_poweroftwo_a000_6541a000() {
    // Encoding: 0x6541A000
    // Test FRINTP_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x6541A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frintp_z_p_z_field_size_2_poweroftwo_a000_6581a000() {
    // Encoding: 0x6581A000
    // Test FRINTP_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=2, Pg=0
    let encoding: u32 = 0x6581A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frintp_z_p_z_field_size_3_max_a000_65c1a000() {
    // Encoding: 0x65C1A000
    // Test FRINTP_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frintp_z_p_z_field_pg_0_min_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frintp_z_p_z_field_pg_1_poweroftwo_a000_6501a400() {
    // Encoding: 0x6501A400
    // Test FRINTP_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x6501A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintp_z_p_z_field_zn_0_min_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintp_z_p_z_field_zn_1_poweroftwo_a000_6501a020() {
    // Encoding: 0x6501A020
    // Test FRINTP_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, size=0, Zd=0
    let encoding: u32 = 0x6501A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintp_z_p_z_field_zn_30_poweroftwominusone_a000_6501a3c0() {
    // Encoding: 0x6501A3C0
    // Test FRINTP_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, size=0, Pg=0
    let encoding: u32 = 0x6501A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintp_z_p_z_field_zn_31_max_a000_6501a3e0() {
    // Encoding: 0x6501A3E0
    // Test FRINTP_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x6501A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frintp_z_p_z_field_zd_0_min_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frintp_z_p_z_field_zd_1_poweroftwo_a000_6501a001() {
    // Encoding: 0x6501A001
    // Test FRINTP_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x6501A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frintp_z_p_z_field_zd_30_poweroftwominusone_a000_6501a01e() {
    // Encoding: 0x6501A01E
    // Test FRINTP_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Pg=0, Zn=0
    let encoding: u32 = 0x6501A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frintp_z_p_z_field_zd_31_max_a000_6501a01f() {
    // Encoding: 0x6501A01F
    // Test FRINTP_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, Zn=0, Zd=31, size=0
    let encoding: u32 = 0x6501A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frintp_z_p_z_combo_0_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frintp_z_p_z_special_size_0_size_variant_0_40960_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frintp_z_p_z_special_size_1_size_variant_1_40960_6541a000() {
    // Encoding: 0x6541A000
    // Test FRINTP_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Pg=0, Zd=0
    let encoding: u32 = 0x6541A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frintp_z_p_z_special_size_2_size_variant_2_40960_6581a000() {
    // Encoding: 0x6581A000
    // Test FRINTP_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Pg=0, Zd=0
    let encoding: u32 = 0x6581A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frintp_z_p_z_special_size_3_size_variant_3_40960_65c1a000() {
    // Encoding: 0x65C1A000
    // Test FRINTP_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zn=0, Zd=0
    let encoding: u32 = 0x65C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frintp_z_p_z_invalid_0_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintp_z_p_z_invalid_1_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frintp_z_p_z_invalid_2_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frintp_z_p_z_invalid_3_a000_6501a000() {
    // Encoding: 0x6501A000
    // Test FRINTP_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x6501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRINTI_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frinti_z_p_z_reg_write_0_6507a000() {
    // Test FRINTI_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6507A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6507A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FRINTX_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frintx_z_p_z_reg_write_0_6506a000() {
    // Test FRINTX_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6506A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6506A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FRINTA_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frinta_z_p_z_reg_write_0_6504a000() {
    // Test FRINTA_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6504A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6504A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FRINTN_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frintn_z_p_z_reg_write_0_6500a000() {
    // Test FRINTN_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6500A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6500A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FRINTZ_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frintz_z_p_z_reg_write_0_6503a000() {
    // Test FRINTZ_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6503A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6503A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FRINTM_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frintm_z_p_z_reg_write_0_6502a000() {
    // Test FRINTM_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6502A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6502A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FRINTP_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frintp_z_p_z_reg_write_0_6501a000() {
    // Test FRINTP_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x6501A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6501A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRECPX_Z.P.Z__ Tests
// ============================================================================

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frecpx_z_p_z_field_size_0_min_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frecpx_z_p_z_field_size_1_poweroftwo_a000_654ca000() {
    // Encoding: 0x654CA000
    // Test FRECPX_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=0, size=1
    let encoding: u32 = 0x654CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frecpx_z_p_z_field_size_2_poweroftwo_a000_658ca000() {
    // Encoding: 0x658CA000
    // Test FRECPX_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Pg=0, Zd=0
    let encoding: u32 = 0x658CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frecpx_z_p_z_field_size_3_max_a000_65cca000() {
    // Encoding: 0x65CCA000
    // Test FRECPX_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65CCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_frecpx_z_p_z_field_pg_0_min_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_frecpx_z_p_z_field_pg_1_poweroftwo_a000_650ca400() {
    // Encoding: 0x650CA400
    // Test FRECPX_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=0, Pg=1
    let encoding: u32 = 0x650CA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecpx_z_p_z_field_zn_0_min_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecpx_z_p_z_field_zn_1_poweroftwo_a000_650ca020() {
    // Encoding: 0x650CA020
    // Test FRECPX_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zn=1, size=0
    let encoding: u32 = 0x650CA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecpx_z_p_z_field_zn_30_poweroftwominusone_a000_650ca3c0() {
    // Encoding: 0x650CA3C0
    // Test FRECPX_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0, Pg=0
    let encoding: u32 = 0x650CA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecpx_z_p_z_field_zn_31_max_a000_650ca3e0() {
    // Encoding: 0x650CA3E0
    // Test FRECPX_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Pg=0, Zd=0, Zn=31
    let encoding: u32 = 0x650CA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frecpx_z_p_z_field_zd_0_min_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frecpx_z_p_z_field_zd_1_poweroftwo_a000_650ca001() {
    // Encoding: 0x650CA001
    // Test FRECPX_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=0, Zd=1
    let encoding: u32 = 0x650CA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frecpx_z_p_z_field_zd_30_poweroftwominusone_a000_650ca01e() {
    // Encoding: 0x650CA01E
    // Test FRECPX_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x650CA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frecpx_z_p_z_field_zd_31_max_a000_650ca01f() {
    // Encoding: 0x650CA01F
    // Test FRECPX_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Pg=0, Zd=31, size=0
    let encoding: u32 = 0x650CA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frecpx_z_p_z_combo_0_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frecpx_z_p_z_special_size_0_size_variant_0_40960_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frecpx_z_p_z_special_size_1_size_variant_1_40960_654ca000() {
    // Encoding: 0x654CA000
    // Test FRECPX_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x654CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frecpx_z_p_z_special_size_2_size_variant_2_40960_658ca000() {
    // Encoding: 0x658CA000
    // Test FRECPX_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x658CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frecpx_z_p_z_special_size_3_size_variant_3_40960_65cca000() {
    // Encoding: 0x65CCA000
    // Test FRECPX_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zn=0, Zd=0, size=3
    let encoding: u32 = 0x65CCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frecpx_z_p_z_invalid_0_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frecpx_z_p_z_invalid_1_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frecpx_z_p_z_invalid_2_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frecpx_z_p_z_invalid_3_a000_650ca000() {
    // Encoding: 0x650CA000
    // Test FRECPX_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x650CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRECPX_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frecpx_z_p_z_reg_write_0_650ca000() {
    // Test FRECPX_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x650CA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650CA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FDIV_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fdiv_z_p_zz_field_size_0_min_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fdiv_z_p_zz_field_size_1_poweroftwo_8000_654d8000() {
    // Encoding: 0x654D8000
    // Test FDIV_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x654D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fdiv_z_p_zz_field_size_2_poweroftwo_8000_658d8000() {
    // Encoding: 0x658D8000
    // Test FDIV_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x658D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fdiv_z_p_zz_field_size_3_max_8000_65cd8000() {
    // Encoding: 0x65CD8000
    // Test FDIV_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, Zm=0, size=3, Pg=0
    let encoding: u32 = 0x65CD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fdiv_z_p_zz_field_pg_0_min_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fdiv_z_p_zz_field_pg_1_poweroftwo_8000_650d8400() {
    // Encoding: 0x650D8400
    // Test FDIV_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=1, Zm=0
    let encoding: u32 = 0x650D8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fdiv_z_p_zz_field_zm_0_min_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fdiv_z_p_zz_field_zm_1_poweroftwo_8000_650d8020() {
    // Encoding: 0x650D8020
    // Test FDIV_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=0, Zm=1
    let encoding: u32 = 0x650D8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fdiv_z_p_zz_field_zm_30_poweroftwominusone_8000_650d83c0() {
    // Encoding: 0x650D83C0
    // Test FDIV_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, Pg=0, Zm=30
    let encoding: u32 = 0x650D83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fdiv_z_p_zz_field_zm_31_max_8000_650d83e0() {
    // Encoding: 0x650D83E0
    // Test FDIV_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Pg=0, Zdn=0
    let encoding: u32 = 0x650D83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fdiv_z_p_zz_field_zdn_0_min_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fdiv_z_p_zz_field_zdn_1_poweroftwo_8000_650d8001() {
    // Encoding: 0x650D8001
    // Test FDIV_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x650D8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fdiv_z_p_zz_field_zdn_15_poweroftwominusone_8000_650d800f() {
    // Encoding: 0x650D800F
    // Test FDIV_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=0, Zdn=15
    let encoding: u32 = 0x650D800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fdiv_z_p_zz_field_zdn_31_max_8000_650d801f() {
    // Encoding: 0x650D801F
    // Test FDIV_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zm=0, Zdn=31
    let encoding: u32 = 0x650D801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fdiv_z_p_zz_combo_0_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fdiv_z_p_zz_special_size_0_size_variant_0_32768_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fdiv_z_p_zz_special_size_1_size_variant_1_32768_654d8000() {
    // Encoding: 0x654D8000
    // Test FDIV_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Pg=0, size=1, Zdn=0
    let encoding: u32 = 0x654D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fdiv_z_p_zz_special_size_2_size_variant_2_32768_658d8000() {
    // Encoding: 0x658D8000
    // Test FDIV_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, size=2, Zm=0, Pg=0
    let encoding: u32 = 0x658D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fdiv_z_p_zz_special_size_3_size_variant_3_32768_65cd8000() {
    // Encoding: 0x65CD8000
    // Test FDIV_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zm=0, Zdn=0, size=3
    let encoding: u32 = 0x65CD8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fdiv_z_p_zz_invalid_0_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdiv_z_p_zz_invalid_1_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fdiv_z_p_zz_invalid_2_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdiv_z_p_zz_invalid_3_8000_650d8000() {
    // Encoding: 0x650D8000
    // Test FDIV_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x650D8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIV_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fdiv_z_p_zz_reg_write_0_650d8000() {
    // Test FDIV_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x650D8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650D8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAD_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmad_z_p_zzz_field_size_0_min_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: size=0, Za=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmad_z_p_zzz_field_size_1_poweroftwo_8000_65608000() {
    // Encoding: 0x65608000
    // Test FMAD_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, Za=0, size=1
    let encoding: u32 = 0x65608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmad_z_p_zzz_field_size_2_poweroftwo_8000_65a08000() {
    // Encoding: 0x65A08000
    // Test FMAD_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zm=0, Zdn=0, Za=0
    let encoding: u32 = 0x65A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmad_z_p_zzz_field_size_3_max_8000_65e08000() {
    // Encoding: 0x65E08000
    // Test FMAD_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Pg=0, Zdn=0, Za=0, size=3, Zm=0
    let encoding: u32 = 0x65E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmad_z_p_zzz_field_za_0_min_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: size=0, Zdn=0, Za=0, Zm=0, Pg=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmad_z_p_zzz_field_za_1_poweroftwo_8000_65218000() {
    // Encoding: 0x65218000
    // Test FMAD_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Za=1, Pg=0, Zm=0
    let encoding: u32 = 0x65218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmad_z_p_zzz_field_za_15_poweroftwominusone_8000_652f8000() {
    // Encoding: 0x652F8000
    // Test FMAD_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Za=15, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x652F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmad_z_p_zzz_field_za_31_max_8000_653f8000() {
    // Encoding: 0x653F8000
    // Test FMAD_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: Pg=0, size=0, Za=31, Zdn=0, Zm=0
    let encoding: u32 = 0x653F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmad_z_p_zzz_field_pg_0_min_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0, Za=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmad_z_p_zzz_field_pg_1_poweroftwo_8000_65208400() {
    // Encoding: 0x65208400
    // Test FMAD_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Za=0, Pg=1, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmad_z_p_zzz_field_zm_0_min_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Za=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmad_z_p_zzz_field_zm_1_poweroftwo_8000_65208020() {
    // Encoding: 0x65208020
    // Test FMAD_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Za=0, Zdn=0, size=0, Zm=1
    let encoding: u32 = 0x65208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmad_z_p_zzz_field_zm_30_poweroftwominusone_8000_652083c0() {
    // Encoding: 0x652083C0
    // Test FMAD_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Za=0, Pg=0, size=0, Zm=30
    let encoding: u32 = 0x652083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmad_z_p_zzz_field_zm_31_max_8000_652083e0() {
    // Encoding: 0x652083E0
    // Test FMAD_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Za=0, Pg=0, size=0, Zm=31, Zdn=0
    let encoding: u32 = 0x652083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmad_z_p_zzz_field_zdn_0_min_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Za=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmad_z_p_zzz_field_zdn_1_poweroftwo_8000_65208001() {
    // Encoding: 0x65208001
    // Test FMAD_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, Za=0, Zm=0, Pg=0
    let encoding: u32 = 0x65208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmad_z_p_zzz_field_zdn_15_poweroftwominusone_8000_6520800f() {
    // Encoding: 0x6520800F
    // Test FMAD_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Za=0, Pg=0, Zdn=15
    let encoding: u32 = 0x6520800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmad_z_p_zzz_field_zdn_31_max_8000_6520801f() {
    // Encoding: 0x6520801F
    // Test FMAD_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: Za=0, Zm=0, Pg=0, size=0, Zdn=31
    let encoding: u32 = 0x6520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmad_z_p_zzz_combo_0_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ field combination: size=0, Za=0, Pg=0, Zm=0, Zdn=0
    // Fields: Za=0, Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmad_z_p_zzz_special_size_0_size_variant_0_32768_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Za=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmad_z_p_zzz_special_size_1_size_variant_1_32768_65608000() {
    // Encoding: 0x65608000
    // Test FMAD_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Pg=0, Za=0, size=1, Zm=0
    let encoding: u32 = 0x65608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmad_z_p_zzz_special_size_2_size_variant_2_32768_65a08000() {
    // Encoding: 0x65A08000
    // Test FMAD_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Za=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmad_z_p_zzz_special_size_3_size_variant_3_32768_65e08000() {
    // Encoding: 0x65E08000
    // Test FMAD_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Za=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x65E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmad_z_p_zzz_invalid_0_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Za=0, size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmad_z_p_zzz_invalid_1_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Pg=0, Za=0, Zm=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmad_z_p_zzz_invalid_2_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Zdn=0, Zm=0, Za=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmad_z_p_zzz_invalid_3_8000_65208000() {
    // Encoding: 0x65208000
    // Test FMAD_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Za=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAD_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmad_z_p_zzz_reg_write_0_65208000() {
    // Test FMAD_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FADD_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fadd_z_p_zs_field_size_0_min_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, i1=0, Pg=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fadd_z_p_zs_field_size_1_poweroftwo_8000_65588000() {
    // Encoding: 0x65588000
    // Test FADD_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x65588000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fadd_z_p_zs_field_size_2_poweroftwo_8000_65988000() {
    // Encoding: 0x65988000
    // Test FADD_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: i1=0, size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x65988000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fadd_z_p_zs_field_size_3_max_8000_65d88000() {
    // Encoding: 0x65D88000
    // Test FADD_Z.P.ZS__ field size = 3 (Max)
    // Fields: Zdn=0, Pg=0, size=3, i1=0
    let encoding: u32 = 0x65D88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fadd_z_p_zs_field_pg_0_min_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: Pg=0, i1=0, Zdn=0, size=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fadd_z_p_zs_field_pg_1_poweroftwo_8000_65188400() {
    // Encoding: 0x65188400
    // Test FADD_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x65188400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fadd_z_p_zs_field_i1_0_min_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fadd_z_p_zs_field_i1_1_max_8000_65188020() {
    // Encoding: 0x65188020
    // Test FADD_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: Zdn=0, i1=1, size=0, Pg=0
    let encoding: u32 = 0x65188020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fadd_z_p_zs_field_zdn_0_min_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: i1=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fadd_z_p_zs_field_zdn_1_poweroftwo_8000_65188001() {
    // Encoding: 0x65188001
    // Test FADD_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: i1=0, Zdn=1, size=0, Pg=0
    let encoding: u32 = 0x65188001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fadd_z_p_zs_field_zdn_15_poweroftwominusone_8000_6518800f() {
    // Encoding: 0x6518800F
    // Test FADD_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: i1=0, Pg=0, size=0, Zdn=15
    let encoding: u32 = 0x6518800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fadd_z_p_zs_field_zdn_31_max_8000_6518801f() {
    // Encoding: 0x6518801F
    // Test FADD_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: Pg=0, size=0, i1=0, Zdn=31
    let encoding: u32 = 0x6518801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fadd_z_p_zs_combo_0_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: size=0, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fadd_z_p_zs_special_size_0_size_variant_0_32768_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fadd_z_p_zs_special_size_1_size_variant_1_32768_65588000() {
    // Encoding: 0x65588000
    // Test FADD_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: i1=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x65588000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fadd_z_p_zs_special_size_2_size_variant_2_32768_65988000() {
    // Encoding: 0x65988000
    // Test FADD_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, i1=0, size=2, Pg=0
    let encoding: u32 = 0x65988000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fadd_z_p_zs_special_size_3_size_variant_3_32768_65d88000() {
    // Encoding: 0x65D88000
    // Test FADD_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x65D88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zs_invalid_0_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zdn=0, i1=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zs_invalid_1_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zs_invalid_2_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: i1=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadd_z_p_zs_invalid_3_8000_65188000() {
    // Encoding: 0x65188000
    // Test FADD_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADD_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fadd_z_p_zs_reg_write_0_65188000() {
    // Test FADD_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x65188000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65188000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMINNMV_V.P.Z__ Tests
// ============================================================================

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fminnmv_v_p_z_field_size_0_min_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fminnmv_v_p_z_field_size_1_poweroftwo_2000_65452000() {
    // Encoding: 0x65452000
    // Test FMINNMV_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Vd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x65452000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fminnmv_v_p_z_field_size_2_poweroftwo_2000_65852000() {
    // Encoding: 0x65852000
    // Test FMINNMV_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zn=0, Vd=0
    let encoding: u32 = 0x65852000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fminnmv_v_p_z_field_size_3_max_2000_65c52000() {
    // Encoding: 0x65C52000
    // Test FMINNMV_V.P.Z__ field size = 3 (Max)
    // Fields: Vd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x65C52000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fminnmv_v_p_z_field_pg_0_min_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Vd=0, size=0, Zn=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fminnmv_v_p_z_field_pg_1_poweroftwo_2000_65052400() {
    // Encoding: 0x65052400
    // Test FMINNMV_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Vd=0, Zn=0, Pg=1, size=0
    let encoding: u32 = 0x65052400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminnmv_v_p_z_field_zn_0_min_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminnmv_v_p_z_field_zn_1_poweroftwo_2000_65052020() {
    // Encoding: 0x65052020
    // Test FMINNMV_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Vd=0, size=0
    let encoding: u32 = 0x65052020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminnmv_v_p_z_field_zn_30_poweroftwominusone_2000_650523c0() {
    // Encoding: 0x650523C0
    // Test FMINNMV_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vd=0, Pg=0, Zn=30
    let encoding: u32 = 0x650523C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminnmv_v_p_z_field_zn_31_max_2000_650523e0() {
    // Encoding: 0x650523E0
    // Test FMINNMV_V.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Vd=0, Zn=31, Pg=0
    let encoding: u32 = 0x650523E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminnmv_v_p_z_field_vd_0_min_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ field Vd = 0 (Min)
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminnmv_v_p_z_field_vd_1_poweroftwo_2000_65052001() {
    // Encoding: 0x65052001
    // Test FMINNMV_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Pg=0, Vd=1
    let encoding: u32 = 0x65052001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminnmv_v_p_z_field_vd_30_poweroftwominusone_2000_6505201e() {
    // Encoding: 0x6505201E
    // Test FMINNMV_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, size=0, Vd=30
    let encoding: u32 = 0x6505201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminnmv_v_p_z_field_vd_31_max_2000_6505201f() {
    // Encoding: 0x6505201F
    // Test FMINNMV_V.P.Z__ field Vd = 31 (Max)
    // Fields: size=0, Pg=0, Zn=0, Vd=31
    let encoding: u32 = 0x6505201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fminnmv_v_p_z_combo_0_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Vd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fminnmv_v_p_z_special_size_0_size_variant_0_8192_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fminnmv_v_p_z_special_size_1_size_variant_1_8192_65452000() {
    // Encoding: 0x65452000
    // Test FMINNMV_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Vd=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x65452000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fminnmv_v_p_z_special_size_2_size_variant_2_8192_65852000() {
    // Encoding: 0x65852000
    // Test FMINNMV_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65852000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fminnmv_v_p_z_special_size_3_size_variant_3_8192_65c52000() {
    // Encoding: 0x65C52000
    // Test FMINNMV_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zn=0, Vd=0, size=3
    let encoding: u32 = 0x65C52000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fminnmv_v_p_z_invalid_0_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminnmv_v_p_z_invalid_1_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fminnmv_v_p_z_invalid_2_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminnmv_v_p_z_invalid_3_2000_65052000() {
    // Encoding: 0x65052000
    // Test FMINNMV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x65052000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINNMV_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fminnmv_v_p_z_reg_write_0_65052000() {
    // Test FMINNMV_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x65052000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65052000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FTSSEL_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_ftssel_z_zz_field_size_0_min_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_ftssel_z_zz_field_size_1_poweroftwo_b000_0460b000() {
    // Encoding: 0x0460B000
    // Test FTSSEL_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=0, size=1
    let encoding: u32 = 0x0460B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_ftssel_z_zz_field_size_2_poweroftwo_b000_04a0b000() {
    // Encoding: 0x04A0B000
    // Test FTSSEL_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, Zn=0, size=2
    let encoding: u32 = 0x04A0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_ftssel_z_zz_field_size_3_max_b000_04e0b000() {
    // Encoding: 0x04E0B000
    // Test FTSSEL_Z.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Zn=0, Zd=0, size=3
    let encoding: u32 = 0x04E0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftssel_z_zz_field_zm_0_min_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftssel_z_zz_field_zm_1_poweroftwo_b000_0421b000() {
    // Encoding: 0x0421B000
    // Test FTSSEL_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=0, Zm=1
    let encoding: u32 = 0x0421B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftssel_z_zz_field_zm_30_poweroftwominusone_b000_043eb000() {
    // Encoding: 0x043EB000
    // Test FTSSEL_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=0, Zm=30, size=0
    let encoding: u32 = 0x043EB000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftssel_z_zz_field_zm_31_max_b000_043fb000() {
    // Encoding: 0x043FB000
    // Test FTSSEL_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zd=0, size=0, Zm=31, Zn=0
    let encoding: u32 = 0x043FB000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftssel_z_zz_field_zn_0_min_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ field Zn = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftssel_z_zz_field_zn_1_poweroftwo_b000_0420b020() {
    // Encoding: 0x0420B020
    // Test FTSSEL_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x0420B020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftssel_z_zz_field_zn_30_poweroftwominusone_b000_0420b3c0() {
    // Encoding: 0x0420B3C0
    // Test FTSSEL_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=30, size=0, Zd=0
    let encoding: u32 = 0x0420B3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftssel_z_zz_field_zn_31_max_b000_0420b3e0() {
    // Encoding: 0x0420B3E0
    // Test FTSSEL_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0, Zm=0
    let encoding: u32 = 0x0420B3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ftssel_z_zz_field_zd_0_min_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ftssel_z_zz_field_zd_1_poweroftwo_b000_0420b001() {
    // Encoding: 0x0420B001
    // Test FTSSEL_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x0420B001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ftssel_z_zz_field_zd_30_poweroftwominusone_b000_0420b01e() {
    // Encoding: 0x0420B01E
    // Test FTSSEL_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x0420B01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ftssel_z_zz_field_zd_31_max_b000_0420b01f() {
    // Encoding: 0x0420B01F
    // Test FTSSEL_Z.ZZ__ field Zd = 31 (Max)
    // Fields: size=0, Zd=31, Zn=0, Zm=0
    let encoding: u32 = 0x0420B01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_ftssel_z_zz_combo_0_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_ftssel_z_zz_special_size_0_size_variant_0_45056_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_ftssel_z_zz_special_size_1_size_variant_1_45056_0460b000() {
    // Encoding: 0x0460B000
    // Test FTSSEL_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x0460B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_ftssel_z_zz_special_size_2_size_variant_2_45056_04a0b000() {
    // Encoding: 0x04A0B000
    // Test FTSSEL_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Zn=0, Zd=0
    let encoding: u32 = 0x04A0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_ftssel_z_zz_special_size_3_size_variant_3_45056_04e0b000() {
    // Encoding: 0x04E0B000
    // Test FTSSEL_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04E0B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ftssel_z_zz_invalid_0_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ftssel_z_zz_invalid_1_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_ftssel_z_zz_invalid_2_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ftssel_z_zz_invalid_3_b000_0420b000() {
    // Encoding: 0x0420B000
    // Test FTSSEL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x0420B000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FTSSEL_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_ftssel_z_zz_reg_write_0_0420b000() {
    // Test FTSSEL_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x0420B000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420B000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMAXNMV_V.P.Z__ Tests
// ============================================================================

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmaxnmv_v_p_z_field_size_0_min_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmaxnmv_v_p_z_field_size_1_poweroftwo_2000_65442000() {
    // Encoding: 0x65442000
    // Test FMAXNMV_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x65442000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmaxnmv_v_p_z_field_size_2_poweroftwo_2000_65842000() {
    // Encoding: 0x65842000
    // Test FMAXNMV_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vd=0, Pg=0, size=2, Zn=0
    let encoding: u32 = 0x65842000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmaxnmv_v_p_z_field_size_3_max_2000_65c42000() {
    // Encoding: 0x65C42000
    // Test FMAXNMV_V.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Vd=0, Pg=0
    let encoding: u32 = 0x65C42000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmaxnmv_v_p_z_field_pg_0_min_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmaxnmv_v_p_z_field_pg_1_poweroftwo_2000_65042400() {
    // Encoding: 0x65042400
    // Test FMAXNMV_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Vd=0, Zn=0, Pg=1
    let encoding: u32 = 0x65042400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmaxnmv_v_p_z_field_zn_0_min_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmaxnmv_v_p_z_field_zn_1_poweroftwo_2000_65042020() {
    // Encoding: 0x65042020
    // Test FMAXNMV_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Vd=0, Zn=1
    let encoding: u32 = 0x65042020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmaxnmv_v_p_z_field_zn_30_poweroftwominusone_2000_650423c0() {
    // Encoding: 0x650423C0
    // Test FMAXNMV_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Vd=0
    let encoding: u32 = 0x650423C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmaxnmv_v_p_z_field_zn_31_max_2000_650423e0() {
    // Encoding: 0x650423E0
    // Test FMAXNMV_V.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x650423E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmaxnmv_v_p_z_field_vd_0_min_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ field Vd = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmaxnmv_v_p_z_field_vd_1_poweroftwo_2000_65042001() {
    // Encoding: 0x65042001
    // Test FMAXNMV_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=0, Vd=1
    let encoding: u32 = 0x65042001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmaxnmv_v_p_z_field_vd_30_poweroftwominusone_2000_6504201e() {
    // Encoding: 0x6504201E
    // Test FMAXNMV_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Vd=30
    let encoding: u32 = 0x6504201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmaxnmv_v_p_z_field_vd_31_max_2000_6504201f() {
    // Encoding: 0x6504201F
    // Test FMAXNMV_V.P.Z__ field Vd = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Vd=31
    let encoding: u32 = 0x6504201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmaxnmv_v_p_z_combo_0_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmaxnmv_v_p_z_special_size_0_size_variant_0_8192_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmaxnmv_v_p_z_special_size_1_size_variant_1_8192_65442000() {
    // Encoding: 0x65442000
    // Test FMAXNMV_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zn=0, Vd=0, size=1
    let encoding: u32 = 0x65442000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmaxnmv_v_p_z_special_size_2_size_variant_2_8192_65842000() {
    // Encoding: 0x65842000
    // Test FMAXNMV_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zn=0, Vd=0, size=2
    let encoding: u32 = 0x65842000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmaxnmv_v_p_z_special_size_3_size_variant_3_8192_65c42000() {
    // Encoding: 0x65C42000
    // Test FMAXNMV_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65C42000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmaxnmv_v_p_z_invalid_0_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxnmv_v_p_z_invalid_1_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmaxnmv_v_p_z_invalid_2_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmaxnmv_v_p_z_invalid_3_2000_65042000() {
    // Encoding: 0x65042000
    // Test FMAXNMV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x65042000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMAXNMV_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmaxnmv_v_p_z_reg_write_0_65042000() {
    // Test FMAXNMV_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x65042000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65042000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FNMSB_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fnmsb_z_p_zzz_field_size_0_min_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: size=0, Zm=0, Za=0, Pg=0, Zdn=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fnmsb_z_p_zzz_field_size_1_poweroftwo_e000_6560e000() {
    // Encoding: 0x6560E000
    // Test FNMSB_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Za=0, Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x6560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fnmsb_z_p_zzz_field_size_2_poweroftwo_e000_65a0e000() {
    // Encoding: 0x65A0E000
    // Test FNMSB_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Za=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fnmsb_z_p_zzz_field_size_3_max_e000_65e0e000() {
    // Encoding: 0x65E0E000
    // Test FNMSB_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Za=0, Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x65E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmsb_z_p_zzz_field_za_0_min_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, Za=0, size=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmsb_z_p_zzz_field_za_1_poweroftwo_e000_6521e000() {
    // Encoding: 0x6521E000
    // Test FNMSB_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Za=1, Pg=0, Zm=0
    let encoding: u32 = 0x6521E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmsb_z_p_zzz_field_za_15_poweroftwominusone_e000_652fe000() {
    // Encoding: 0x652FE000
    // Test FNMSB_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zdn=0, Za=15, Pg=0
    let encoding: u32 = 0x652FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Za 16 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmsb_z_p_zzz_field_za_31_max_e000_653fe000() {
    // Encoding: 0x653FE000
    // Test FNMSB_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: Zm=0, Pg=0, Za=31, size=0, Zdn=0
    let encoding: u32 = 0x653FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fnmsb_z_p_zzz_field_pg_0_min_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Za=0, Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fnmsb_z_p_zzz_field_pg_1_poweroftwo_e000_6520e400() {
    // Encoding: 0x6520E400
    // Test FNMSB_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zdn=0, Za=0, Pg=1
    let encoding: u32 = 0x6520E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmsb_z_p_zzz_field_zm_0_min_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Za=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmsb_z_p_zzz_field_zm_1_poweroftwo_e000_6520e020() {
    // Encoding: 0x6520E020
    // Test FNMSB_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Za=0, Pg=0, Zm=1, size=0, Zdn=0
    let encoding: u32 = 0x6520E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmsb_z_p_zzz_field_zm_30_poweroftwominusone_e000_6520e3c0() {
    // Encoding: 0x6520E3C0
    // Test FNMSB_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Za=0, Zdn=0, Zm=30, size=0
    let encoding: u32 = 0x6520E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmsb_z_p_zzz_field_zm_31_max_e000_6520e3e0() {
    // Encoding: 0x6520E3E0
    // Test FNMSB_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: size=0, Za=0, Pg=0, Zm=31, Zdn=0
    let encoding: u32 = 0x6520E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmsb_z_p_zzz_field_zdn_0_min_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Za=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmsb_z_p_zzz_field_zdn_1_poweroftwo_e000_6520e001() {
    // Encoding: 0x6520E001
    // Test FNMSB_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Za=0, Zm=0, Pg=0, Zdn=1
    let encoding: u32 = 0x6520E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmsb_z_p_zzz_field_zdn_15_poweroftwominusone_e000_6520e00f() {
    // Encoding: 0x6520E00F
    // Test FNMSB_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Za=0, Zdn=15, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x6520E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmsb_z_p_zzz_field_zdn_31_max_e000_6520e01f() {
    // Encoding: 0x6520E01F
    // Test FNMSB_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zm=0, Za=0, Pg=0, Zdn=31
    let encoding: u32 = 0x6520E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fnmsb_z_p_zzz_combo_0_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ field combination: size=0, Za=0, Pg=0, Zm=0, Zdn=0
    // Fields: Za=0, size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fnmsb_z_p_zzz_special_size_0_size_variant_0_57344_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Za=0, Zdn=0, Zm=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fnmsb_z_p_zzz_special_size_1_size_variant_1_57344_6560e000() {
    // Encoding: 0x6560E000
    // Test FNMSB_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Za=0, size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x6560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fnmsb_z_p_zzz_special_size_2_size_variant_2_57344_65a0e000() {
    // Encoding: 0x65A0E000
    // Test FNMSB_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Za=0, size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x65A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fnmsb_z_p_zzz_special_size_3_size_variant_3_57344_65e0e000() {
    // Encoding: 0x65E0E000
    // Test FNMSB_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Zdn=0, Za=0, Pg=0, size=3
    let encoding: u32 = 0x65E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fnmsb_z_p_zzz_invalid_0_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zdn=0, Za=0, Pg=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmsb_z_p_zzz_invalid_1_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Za=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fnmsb_z_p_zzz_invalid_2_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Zdn=0, size=0, Za=0, Pg=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmsb_z_p_zzz_invalid_3_e000_6520e000() {
    // Encoding: 0x6520E000
    // Test FNMSB_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Za=0, Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x6520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMSB_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fnmsb_z_p_zzz_reg_write_0_6520e000() {
    // Test FNMSB_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x6520E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x6520E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMLA_Z.ZZZi_H Tests
// ============================================================================

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field i3h 22 +: 1`
/// Requirement: FieldBoundary { field: "i3h", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_h_field_i3h_0_min_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H field i3h = 0 (Min)
    // Fields: Zn=0, Zda=0, Zm=0, i3h=0, i3l=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field i3h 22 +: 1`
/// Requirement: FieldBoundary { field: "i3h", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmla_z_zzzi_h_field_i3h_1_max_0_64600000() {
    // Encoding: 0x64600000
    // Test FMLA_Z.ZZZi_H field i3h = 1 (Max)
    // Fields: i3h=1, i3l=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x64600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_h_field_i3l_0_min_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H field i3l = 0 (Min)
    // Fields: Zda=0, i3l=0, Zm=0, i3h=0, Zn=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_zzzi_h_field_i3l_1_poweroftwo_0_64280000() {
    // Encoding: 0x64280000
    // Test FMLA_Z.ZZZi_H field i3l = 1 (PowerOfTwo)
    // Fields: i3l=1, Zn=0, i3h=0, Zda=0, Zm=0
    let encoding: u32 = 0x64280000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field i3l 19 +: 2`
/// Requirement: FieldBoundary { field: "i3l", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_fmla_z_zzzi_h_field_i3l_3_max_0_64380000() {
    // Encoding: 0x64380000
    // Test FMLA_Z.ZZZi_H field i3l = 3 (Max)
    // Fields: Zn=0, Zda=0, i3l=3, Zm=0, i3h=0
    let encoding: u32 = 0x64380000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_zzzi_h_field_zm_0_min_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H field Zm = 0 (Min)
    // Fields: i3h=0, i3l=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_zzzi_h_field_zm_1_poweroftwo_0_64210000() {
    // Encoding: 0x64210000
    // Test FMLA_Z.ZZZi_H field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, Zda=0, Zm=1, i3h=0, i3l=0
    let encoding: u32 = 0x64210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_zzzi_h_field_zn_0_min_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H field Zn = 0 (Min)
    // Fields: i3l=0, Zn=0, Zda=0, i3h=0, Zm=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_zzzi_h_field_zn_1_poweroftwo_0_64200020() {
    // Encoding: 0x64200020
    // Test FMLA_Z.ZZZi_H field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, i3h=0, i3l=0, Zn=1, Zda=0
    let encoding: u32 = 0x64200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_zzzi_h_field_zn_30_poweroftwominusone_0_642003c0() {
    // Encoding: 0x642003C0
    // Test FMLA_Z.ZZZi_H field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, i3h=0, Zm=0, Zn=30, i3l=0
    let encoding: u32 = 0x642003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_zzzi_h_field_zn_31_max_0_642003e0() {
    // Encoding: 0x642003E0
    // Test FMLA_Z.ZZZi_H field Zn = 31 (Max)
    // Fields: Zm=0, Zn=31, Zda=0, i3l=0, i3h=0
    let encoding: u32 = 0x642003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_h_field_zda_0_min_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H field Zda = 0 (Min)
    // Fields: Zn=0, i3h=0, Zm=0, i3l=0, Zda=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_zzzi_h_field_zda_1_poweroftwo_0_64200001() {
    // Encoding: 0x64200001
    // Test FMLA_Z.ZZZi_H field Zda = 1 (PowerOfTwo)
    // Fields: i3l=0, Zn=0, Zda=1, i3h=0, Zm=0
    let encoding: u32 = 0x64200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmla_z_zzzi_h_field_zda_15_poweroftwominusone_0_6420000f() {
    // Encoding: 0x6420000F
    // Test FMLA_Z.ZZZi_H field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: i3h=0, i3l=0, Zm=0, Zn=0, Zda=15
    let encoding: u32 = 0x6420000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmla_z_zzzi_h_field_zda_31_max_0_6420001f() {
    // Encoding: 0x6420001F
    // Test FMLA_Z.ZZZi_H field Zda = 31 (Max)
    // Fields: Zm=0, i3l=0, Zn=0, Zda=31, i3h=0
    let encoding: u32 = 0x6420001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i3h=0 (minimum value)
#[test]
fn test_fmla_z_zzzi_h_combo_0_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H field combination: i3h=0, i3l=0, Zm=0, Zn=0, Zda=0
    // Fields: Zda=0, Zm=0, i3h=0, i3l=0, Zn=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmla_z_zzzi_h_invalid_0_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i3h=0, i3l=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_zzzi_h_invalid_1_0_64200000() {
    // Encoding: 0x64200000
    // Test FMLA_Z.ZZZi_H invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, i3h=0, Zm=0, i3l=0, Zda=0
    let encoding: u32 = 0x64200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_s_field_i2_0_min_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S field i2 = 0 (Min)
    // Fields: i2=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_zzzi_s_field_i2_1_poweroftwo_0_64a80000() {
    // Encoding: 0x64A80000
    // Test FMLA_Z.ZZZi_S field i2 = 1 (PowerOfTwo)
    // Fields: i2=1, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A80000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_fmla_z_zzzi_s_field_i2_3_max_0_64b80000() {
    // Encoding: 0x64B80000
    // Test FMLA_Z.ZZZi_S field i2 = 3 (Max)
    // Fields: Zm=0, Zn=0, i2=3, Zda=0
    let encoding: u32 = 0x64B80000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_zzzi_s_field_zm_0_min_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S field Zm = 0 (Min)
    // Fields: Zda=0, Zn=0, i2=0, Zm=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_zzzi_s_field_zm_1_poweroftwo_0_64a10000() {
    // Encoding: 0x64A10000
    // Test FMLA_Z.ZZZi_S field Zm = 1 (PowerOfTwo)
    // Fields: i2=0, Zn=0, Zm=1, Zda=0
    let encoding: u32 = 0x64A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_zzzi_s_field_zn_0_min_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S field Zn = 0 (Min)
    // Fields: Zda=0, i2=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_zzzi_s_field_zn_1_poweroftwo_0_64a00020() {
    // Encoding: 0x64A00020
    // Test FMLA_Z.ZZZi_S field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zm=0, Zda=0, i2=0
    let encoding: u32 = 0x64A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_zzzi_s_field_zn_30_poweroftwominusone_0_64a003c0() {
    // Encoding: 0x64A003C0
    // Test FMLA_Z.ZZZi_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, i2=0, Zm=0, Zda=0
    let encoding: u32 = 0x64A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_zzzi_s_field_zn_31_max_0_64a003e0() {
    // Encoding: 0x64A003E0
    // Test FMLA_Z.ZZZi_S field Zn = 31 (Max)
    // Fields: Zm=0, Zda=0, i2=0, Zn=31
    let encoding: u32 = 0x64A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_s_field_zda_0_min_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S field Zda = 0 (Min)
    // Fields: Zn=0, i2=0, Zm=0, Zda=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_zzzi_s_field_zda_1_poweroftwo_0_64a00001() {
    // Encoding: 0x64A00001
    // Test FMLA_Z.ZZZi_S field Zda = 1 (PowerOfTwo)
    // Fields: i2=0, Zm=0, Zn=0, Zda=1
    let encoding: u32 = 0x64A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmla_z_zzzi_s_field_zda_15_poweroftwominusone_0_64a0000f() {
    // Encoding: 0x64A0000F
    // Test FMLA_Z.ZZZi_S field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, i2=0, Zda=15
    let encoding: u32 = 0x64A0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmla_z_zzzi_s_field_zda_31_max_0_64a0001f() {
    // Encoding: 0x64A0001F
    // Test FMLA_Z.ZZZi_S field Zda = 31 (Max)
    // Fields: i2=0, Zm=0, Zda=31, Zn=0
    let encoding: u32 = 0x64A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i2=0 (minimum value)
#[test]
fn test_fmla_z_zzzi_s_combo_0_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S field combination: i2=0, Zm=0, Zn=0, Zda=0
    // Fields: Zm=0, Zda=0, Zn=0, i2=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmla_z_zzzi_s_invalid_0_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i2=0, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_zzzi_s_invalid_1_0_64a00000() {
    // Encoding: 0x64A00000
    // Test FMLA_Z.ZZZi_S invalid encoding: Unconditional UNDEFINED
    // Fields: i2=0, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x64A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_d_field_i1_0_min_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D field i1 = 0 (Min)
    // Fields: i1=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fmla_z_zzzi_d_field_i1_1_max_0_64f00000() {
    // Encoding: 0x64F00000
    // Test FMLA_Z.ZZZi_D field i1 = 1 (Max)
    // Fields: i1=1, Zm=0, Zda=0, Zn=0
    let encoding: u32 = 0x64F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_zzzi_d_field_zm_0_min_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D field Zm = 0 (Min)
    // Fields: Zda=0, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_zzzi_d_field_zm_1_poweroftwo_0_64e10000() {
    // Encoding: 0x64E10000
    // Test FMLA_Z.ZZZi_D field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, i1=0, Zda=0, Zm=1
    let encoding: u32 = 0x64E10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_zzzi_d_field_zn_0_min_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D field Zn = 0 (Min)
    // Fields: i1=0, Zn=0, Zm=0, Zda=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_zzzi_d_field_zn_1_poweroftwo_0_64e00020() {
    // Encoding: 0x64E00020
    // Test FMLA_Z.ZZZi_D field Zn = 1 (PowerOfTwo)
    // Fields: i1=0, Zda=0, Zn=1, Zm=0
    let encoding: u32 = 0x64E00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_zzzi_d_field_zn_30_poweroftwominusone_0_64e003c0() {
    // Encoding: 0x64E003C0
    // Test FMLA_Z.ZZZi_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Zm=0, Zn=30, i1=0
    let encoding: u32 = 0x64E003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_zzzi_d_field_zn_31_max_0_64e003e0() {
    // Encoding: 0x64E003E0
    // Test FMLA_Z.ZZZi_D field Zn = 31 (Max)
    // Fields: Zn=31, i1=0, Zda=0, Zm=0
    let encoding: u32 = 0x64E003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_zzzi_d_field_zda_0_min_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D field Zda = 0 (Min)
    // Fields: i1=0, Zm=0, Zda=0, Zn=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_zzzi_d_field_zda_1_poweroftwo_0_64e00001() {
    // Encoding: 0x64E00001
    // Test FMLA_Z.ZZZi_D field Zda = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, i1=0, Zda=1
    let encoding: u32 = 0x64E00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmla_z_zzzi_d_field_zda_15_poweroftwominusone_0_64e0000f() {
    // Encoding: 0x64E0000F
    // Test FMLA_Z.ZZZi_D field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, i1=0, Zm=0, Zda=15
    let encoding: u32 = 0x64E0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmla_z_zzzi_d_field_zda_31_max_0_64e0001f() {
    // Encoding: 0x64E0001F
    // Test FMLA_Z.ZZZi_D field Zda = 31 (Max)
    // Fields: i1=0, Zda=31, Zm=0, Zn=0
    let encoding: u32 = 0x64E0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_fmla_z_zzzi_d_combo_0_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D field combination: i1=0, Zm=0, Zn=0, Zda=0
    // Fields: i1=0, Zn=0, Zm=0, Zda=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmla_z_zzzi_d_invalid_0_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zda=0, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_zzzi_d_invalid_1_0_64e00000() {
    // Encoding: 0x64E00000
    // Test FMLA_Z.ZZZi_D invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Zn=0, Zm=0, Zda=0
    let encoding: u32 = 0x64E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.ZZZi_H
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmla_z_zzzi_h_reg_write_0_64200000() {
    // Test FMLA_Z.ZZZi_H register write: SimdFromField("da")
    // Encoding: 0x64200000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FMLA_Z.ZZZi_S
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmla_z_zzzi_s_reg_write_0_64a00000() {
    // Test FMLA_Z.ZZZi_S register write: SimdFromField("da")
    // Encoding: 0x64A00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: FMLA_Z.ZZZi_D
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmla_z_zzzi_d_reg_write_0_64e00000() {
    // Test FMLA_Z.ZZZi_D register write: SimdFromField("da")
    // Encoding: 0x64E00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMIN_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmin_z_p_zz_field_size_0_min_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmin_z_p_zz_field_size_1_poweroftwo_8000_65478000() {
    // Encoding: 0x65478000
    // Test FMIN_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65478000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmin_z_p_zz_field_size_2_poweroftwo_8000_65878000() {
    // Encoding: 0x65878000
    // Test FMIN_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x65878000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmin_z_p_zz_field_size_3_max_8000_65c78000() {
    // Encoding: 0x65C78000
    // Test FMIN_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x65C78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmin_z_p_zz_field_pg_0_min_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmin_z_p_zz_field_pg_1_poweroftwo_8000_65078400() {
    // Encoding: 0x65078400
    // Test FMIN_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, size=0, Zdn=0
    let encoding: u32 = 0x65078400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmin_z_p_zz_field_zm_0_min_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmin_z_p_zz_field_zm_1_poweroftwo_8000_65078020() {
    // Encoding: 0x65078020
    // Test FMIN_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Pg=0, Zdn=0
    let encoding: u32 = 0x65078020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmin_z_p_zz_field_zm_30_poweroftwominusone_8000_650783c0() {
    // Encoding: 0x650783C0
    // Test FMIN_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x650783C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmin_z_p_zz_field_zm_31_max_8000_650783e0() {
    // Encoding: 0x650783E0
    // Test FMIN_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=0, Zm=31
    let encoding: u32 = 0x650783E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmin_z_p_zz_field_zdn_0_min_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmin_z_p_zz_field_zdn_1_poweroftwo_8000_65078001() {
    // Encoding: 0x65078001
    // Test FMIN_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=1, Zm=0, size=0
    let encoding: u32 = 0x65078001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmin_z_p_zz_field_zdn_15_poweroftwominusone_8000_6507800f() {
    // Encoding: 0x6507800F
    // Test FMIN_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Pg=0, Zdn=15
    let encoding: u32 = 0x6507800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmin_z_p_zz_field_zdn_31_max_8000_6507801f() {
    // Encoding: 0x6507801F
    // Test FMIN_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zdn=31, size=0, Zm=0
    let encoding: u32 = 0x6507801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmin_z_p_zz_combo_0_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmin_z_p_zz_special_size_0_size_variant_0_32768_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmin_z_p_zz_special_size_1_size_variant_1_32768_65478000() {
    // Encoding: 0x65478000
    // Test FMIN_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65478000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmin_z_p_zz_special_size_2_size_variant_2_32768_65878000() {
    // Encoding: 0x65878000
    // Test FMIN_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65878000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmin_z_p_zz_special_size_3_size_variant_3_32768_65c78000() {
    // Encoding: 0x65C78000
    // Test FMIN_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x65C78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zz_invalid_0_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zz_invalid_1_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zz_invalid_2_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmin_z_p_zz_invalid_3_8000_65078000() {
    // Encoding: 0x65078000
    // Test FMIN_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x65078000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMIN_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmin_z_p_zz_reg_write_0_65078000() {
    // Test FMIN_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65078000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65078000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FCPY_Z.P.I__ Tests
// ============================================================================

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fcpy_z_p_i_field_size_0_min_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ field size = 0 (Min)
    // Fields: Pg=0, size=0, imm8=0, Zd=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fcpy_z_p_i_field_size_1_poweroftwo_c000_0550c000() {
    // Encoding: 0x0550C000
    // Test FCPY_Z.P.I__ field size = 1 (PowerOfTwo)
    // Fields: imm8=0, Pg=0, Zd=0, size=1
    let encoding: u32 = 0x0550C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fcpy_z_p_i_field_size_2_poweroftwo_c000_0590c000() {
    // Encoding: 0x0590C000
    // Test FCPY_Z.P.I__ field size = 2 (PowerOfTwo)
    // Fields: size=2, imm8=0, Zd=0, Pg=0
    let encoding: u32 = 0x0590C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fcpy_z_p_i_field_size_3_max_c000_05d0c000() {
    // Encoding: 0x05D0C000
    // Test FCPY_Z.P.I__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Pg=0, imm8=0
    let encoding: u32 = 0x05D0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field Pg 16 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcpy_z_p_i_field_pg_0_min_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zd=0, imm8=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field Pg 16 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcpy_z_p_i_field_pg_1_poweroftwo_c000_0511c000() {
    // Encoding: 0x0511C000
    // Test FCPY_Z.P.I__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Pg=1, imm8=0
    let encoding: u32 = 0x0511C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_fcpy_z_p_i_field_imm8_0_zero_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ field imm8 = 0 (Zero)
    // Fields: size=0, Pg=0, imm8=0, Zd=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_fcpy_z_p_i_field_imm8_1_poweroftwo_c000_0510c020() {
    // Encoding: 0x0510C020
    // Test FCPY_Z.P.I__ field imm8 = 1 (PowerOfTwo)
    // Fields: size=0, imm8=1, Zd=0, Pg=0
    let encoding: u32 = 0x0510C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_fcpy_z_p_i_field_imm8_3_poweroftwominusone_c000_0510c060() {
    // Encoding: 0x0510C060
    // Test FCPY_Z.P.I__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Pg=0, imm8=3
    let encoding: u32 = 0x0510C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_fcpy_z_p_i_field_imm8_4_poweroftwo_c000_0510c080() {
    // Encoding: 0x0510C080
    // Test FCPY_Z.P.I__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, imm8=4, Pg=0, Zd=0
    let encoding: u32 = 0x0510C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_fcpy_z_p_i_field_imm8_7_poweroftwominusone_c000_0510c0e0() {
    // Encoding: 0x0510C0E0
    // Test FCPY_Z.P.I__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=0, Pg=0, imm8=7
    let encoding: u32 = 0x0510C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_fcpy_z_p_i_field_imm8_8_poweroftwo_c000_0510c100() {
    // Encoding: 0x0510C100
    // Test FCPY_Z.P.I__ field imm8 = 8 (PowerOfTwo)
    // Fields: size=0, Zd=0, Pg=0, imm8=8
    let encoding: u32 = 0x0510C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_fcpy_z_p_i_field_imm8_15_poweroftwominusone_c000_0510c1e0() {
    // Encoding: 0x0510C1E0
    // Test FCPY_Z.P.I__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zd=0, imm8=15
    let encoding: u32 = 0x0510C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_fcpy_z_p_i_field_imm8_16_poweroftwo_c000_0510c200() {
    // Encoding: 0x0510C200
    // Test FCPY_Z.P.I__ field imm8 = 16 (PowerOfTwo)
    // Fields: Pg=0, imm8=16, Zd=0, size=0
    let encoding: u32 = 0x0510C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_fcpy_z_p_i_field_imm8_31_poweroftwominusone_c000_0510c3e0() {
    // Encoding: 0x0510C3E0
    // Test FCPY_Z.P.I__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: imm8=31, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x0510C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_fcpy_z_p_i_field_imm8_32_poweroftwo_c000_0510c400() {
    // Encoding: 0x0510C400
    // Test FCPY_Z.P.I__ field imm8 = 32 (PowerOfTwo)
    // Fields: Pg=0, size=0, imm8=32, Zd=0
    let encoding: u32 = 0x0510C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_fcpy_z_p_i_field_imm8_63_poweroftwominusone_c000_0510c7e0() {
    // Encoding: 0x0510C7E0
    // Test FCPY_Z.P.I__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: imm8=63, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x0510C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_fcpy_z_p_i_field_imm8_64_poweroftwo_c000_0510c800() {
    // Encoding: 0x0510C800
    // Test FCPY_Z.P.I__ field imm8 = 64 (PowerOfTwo)
    // Fields: Pg=0, imm8=64, Zd=0, size=0
    let encoding: u32 = 0x0510C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_fcpy_z_p_i_field_imm8_127_poweroftwominusone_c000_0510cfe0() {
    // Encoding: 0x0510CFE0
    // Test FCPY_Z.P.I__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, imm8=127, Zd=0
    let encoding: u32 = 0x0510CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_fcpy_z_p_i_field_imm8_128_poweroftwo_c000_0510d000() {
    // Encoding: 0x0510D000
    // Test FCPY_Z.P.I__ field imm8 = 128 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm8=128, Pg=0
    let encoding: u32 = 0x0510D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_fcpy_z_p_i_field_imm8_255_max_c000_0510dfe0() {
    // Encoding: 0x0510DFE0
    // Test FCPY_Z.P.I__ field imm8 = 255 (Max)
    // Fields: imm8=255, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0510DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcpy_z_p_i_field_zd_0_min_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ field Zd = 0 (Min)
    // Fields: Pg=0, imm8=0, size=0, Zd=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcpy_z_p_i_field_zd_1_poweroftwo_c000_0510c001() {
    // Encoding: 0x0510C001
    // Test FCPY_Z.P.I__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Pg=0, size=0, imm8=0
    let encoding: u32 = 0x0510C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcpy_z_p_i_field_zd_30_poweroftwominusone_c000_0510c01e() {
    // Encoding: 0x0510C01E
    // Test FCPY_Z.P.I__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, imm8=0, Pg=0
    let encoding: u32 = 0x0510C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcpy_z_p_i_field_zd_31_max_c000_0510c01f() {
    // Encoding: 0x0510C01F
    // Test FCPY_Z.P.I__ field Zd = 31 (Max)
    // Fields: Zd=31, imm8=0, size=0, Pg=0
    let encoding: u32 = 0x0510C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fcpy_z_p_i_combo_0_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ field combination: size=0, Pg=0, imm8=0, Zd=0
    // Fields: Zd=0, imm8=0, size=0, Pg=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fcpy_z_p_i_special_size_0_size_variant_0_49152_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zd=0, imm8=0, Pg=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fcpy_z_p_i_special_size_1_size_variant_1_49152_0550c000() {
    // Encoding: 0x0550C000
    // Test FCPY_Z.P.I__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, imm8=0, size=1, Zd=0
    let encoding: u32 = 0x0550C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fcpy_z_p_i_special_size_2_size_variant_2_49152_0590c000() {
    // Encoding: 0x0590C000
    // Test FCPY_Z.P.I__ special value size = 2 (Size variant 2)
    // Fields: size=2, imm8=0, Pg=0, Zd=0
    let encoding: u32 = 0x0590C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fcpy_z_p_i_special_size_3_size_variant_3_49152_05d0c000() {
    // Encoding: 0x05D0C000
    // Test FCPY_Z.P.I__ special value size = 3 (Size variant 3)
    // Fields: imm8=0, Zd=0, Pg=0, size=3
    let encoding: u32 = 0x05D0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcpy_z_p_i_invalid_0_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm8=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcpy_z_p_i_invalid_1_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm8=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fcpy_z_p_i_invalid_2_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, imm8=0, Zd=0, Pg=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcpy_z_p_i_invalid_3_c000_0510c000() {
    // Encoding: 0x0510C000
    // Test FCPY_Z.P.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, imm8=0, size=0
    let encoding: u32 = 0x0510C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCPY_Z.P.I__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fcpy_z_p_i_reg_write_0_0510c000() {
    // Test FCPY_Z.P.I__ register write: SimdFromField("d")
    // Encoding: 0x0510C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0510C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FADDA_V.P.Z__ Tests
// ============================================================================

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fadda_v_p_z_field_size_0_min_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Vdn=0, Zm=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fadda_v_p_z_field_size_1_poweroftwo_2000_65582000() {
    // Encoding: 0x65582000
    // Test FADDA_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Vdn=0, Pg=0
    let encoding: u32 = 0x65582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fadda_v_p_z_field_size_2_poweroftwo_2000_65982000() {
    // Encoding: 0x65982000
    // Test FADDA_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Vdn=0, Pg=0
    let encoding: u32 = 0x65982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fadda_v_p_z_field_size_3_max_2000_65d82000() {
    // Encoding: 0x65D82000
    // Test FADDA_V.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Zm=0, Vdn=0
    let encoding: u32 = 0x65D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fadda_v_p_z_field_pg_0_min_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ field Pg = 0 (Min)
    // Fields: Vdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fadda_v_p_z_field_pg_1_poweroftwo_2000_65182400() {
    // Encoding: 0x65182400
    // Test FADDA_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=1, Vdn=0
    let encoding: u32 = 0x65182400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fadda_v_p_z_field_zm_0_min_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Vdn=0, size=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fadda_v_p_z_field_zm_1_poweroftwo_2000_65182020() {
    // Encoding: 0x65182020
    // Test FADDA_V.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: Vdn=0, Pg=0, size=0, Zm=1
    let encoding: u32 = 0x65182020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fadda_v_p_z_field_zm_30_poweroftwominusone_2000_651823c0() {
    // Encoding: 0x651823C0
    // Test FADDA_V.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vdn=0, Zm=30, Pg=0
    let encoding: u32 = 0x651823C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fadda_v_p_z_field_zm_31_max_2000_651823e0() {
    // Encoding: 0x651823E0
    // Test FADDA_V.P.Z__ field Zm = 31 (Max)
    // Fields: Pg=0, size=0, Vdn=0, Zm=31
    let encoding: u32 = 0x651823E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fadda_v_p_z_field_vdn_0_min_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ field Vdn = 0 (Min)
    // Fields: Pg=0, Vdn=0, size=0, Zm=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fadda_v_p_z_field_vdn_1_poweroftwo_2000_65182001() {
    // Encoding: 0x65182001
    // Test FADDA_V.P.Z__ field Vdn = 1 (PowerOfTwo)
    // Fields: Vdn=1, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65182001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fadda_v_p_z_field_vdn_15_poweroftwominusone_2000_6518200f() {
    // Encoding: 0x6518200F
    // Test FADDA_V.P.Z__ field Vdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, size=0, Vdn=15
    let encoding: u32 = 0x6518200F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fadda_v_p_z_field_vdn_31_max_2000_6518201f() {
    // Encoding: 0x6518201F
    // Test FADDA_V.P.Z__ field Vdn = 31 (Max)
    // Fields: Pg=0, size=0, Vdn=31, Zm=0
    let encoding: u32 = 0x6518201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fadda_v_p_z_combo_0_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: size=0, Zm=0, Vdn=0, Pg=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fadda_v_p_z_special_size_0_size_variant_0_8192_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Pg=0, size=0, Vdn=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fadda_v_p_z_special_size_1_size_variant_1_8192_65582000() {
    // Encoding: 0x65582000
    // Test FADDA_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zm=0, Vdn=0, size=1
    let encoding: u32 = 0x65582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fadda_v_p_z_special_size_2_size_variant_2_8192_65982000() {
    // Encoding: 0x65982000
    // Test FADDA_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, size=2, Vdn=0
    let encoding: u32 = 0x65982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fadda_v_p_z_special_size_3_size_variant_3_8192_65d82000() {
    // Encoding: 0x65D82000
    // Test FADDA_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x65D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fadda_v_p_z_invalid_0_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Vdn=0, Zm=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadda_v_p_z_invalid_1_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fadda_v_p_z_invalid_2_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Vdn=0, size=0, Zm=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fadda_v_p_z_invalid_3_2000_65182000() {
    // Encoding: 0x65182000
    // Test FADDA_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, Vdn=0, size=0
    let encoding: u32 = 0x65182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FADDA_V.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fadda_v_p_z_reg_write_0_65182000() {
    // Test FADDA_V.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x65182000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65182000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FNMLA_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fnmla_z_p_zzz_field_size_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Zm=0, Pg=0, Zn=0, Zda=0, size=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fnmla_z_p_zzz_field_size_1_poweroftwo_4000_65604000() {
    // Encoding: 0x65604000
    // Test FNMLA_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Zn=0, Zda=0, Pg=0
    let encoding: u32 = 0x65604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fnmla_z_p_zzz_field_size_2_poweroftwo_4000_65a04000() {
    // Encoding: 0x65A04000
    // Test FNMLA_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x65A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fnmla_z_p_zzz_field_size_3_max_4000_65e04000() {
    // Encoding: 0x65E04000
    // Test FNMLA_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Pg=0, Zn=0, Zda=0
    let encoding: u32 = 0x65E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmla_z_p_zzz_field_zm_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zda=0, Pg=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmla_z_p_zzz_field_zm_1_poweroftwo_4000_65214000() {
    // Encoding: 0x65214000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zda=0, Zn=0, Zm=1
    let encoding: u32 = 0x65214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmla_z_p_zzz_field_zm_30_poweroftwominusone_4000_653e4000() {
    // Encoding: 0x653E4000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, size=0, Zm=30, Pg=0, Zn=0
    let encoding: u32 = 0x653E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmla_z_p_zzz_field_zm_31_max_4000_653f4000() {
    // Encoding: 0x653F4000
    // Test FNMLA_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zn=0, size=0, Zm=31, Zda=0
    let encoding: u32 = 0x653F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fnmla_z_p_zzz_field_pg_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zn=0, size=0, Pg=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fnmla_z_p_zzz_field_pg_1_poweroftwo_4000_65204400() {
    // Encoding: 0x65204400
    // Test FNMLA_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, size=0, Zda=0, Zn=0
    let encoding: u32 = 0x65204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fnmla_z_p_zzz_field_zn_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zm=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fnmla_z_p_zzz_field_zn_1_poweroftwo_4000_65204020() {
    // Encoding: 0x65204020
    // Test FNMLA_Z.P.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zn=1, Zda=0, Zm=0
    let encoding: u32 = 0x65204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fnmla_z_p_zzz_field_zn_30_poweroftwominusone_4000_652043c0() {
    // Encoding: 0x652043C0
    // Test FNMLA_Z.P.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Zm=0, Pg=0, Zn=30, size=0
    let encoding: u32 = 0x652043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fnmla_z_p_zzz_field_zn_31_max_4000_652043e0() {
    // Encoding: 0x652043E0
    // Test FNMLA_Z.P.ZZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zda=0, Zn=31, size=0
    let encoding: u32 = 0x652043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fnmla_z_p_zzz_field_zda_0_min_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field Zda = 0 (Min)
    // Fields: Zn=0, Zda=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fnmla_z_p_zzz_field_zda_1_poweroftwo_4000_65204001() {
    // Encoding: 0x65204001
    // Test FNMLA_Z.P.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zda=1, Pg=0, Zm=0
    let encoding: u32 = 0x65204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fnmla_z_p_zzz_field_zda_15_poweroftwominusone_4000_6520400f() {
    // Encoding: 0x6520400F
    // Test FNMLA_Z.P.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zda=15, Zn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x6520400F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fnmla_z_p_zzz_field_zda_31_max_4000_6520401f() {
    // Encoding: 0x6520401F
    // Test FNMLA_Z.P.ZZZ__ field Zda = 31 (Max)
    // Fields: Zn=0, size=0, Zm=0, Pg=0, Zda=31
    let encoding: u32 = 0x6520401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fnmla_z_p_zzz_combo_0_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: size=0, Pg=0, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fnmla_z_p_zzz_special_size_0_size_variant_0_16384_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Zda=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fnmla_z_p_zzz_special_size_1_size_variant_1_16384_65604000() {
    // Encoding: 0x65604000
    // Test FNMLA_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Zm=0, size=1, Zda=0, Pg=0
    let encoding: u32 = 0x65604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fnmla_z_p_zzz_special_size_2_size_variant_2_16384_65a04000() {
    // Encoding: 0x65A04000
    // Test FNMLA_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Zda=0, Pg=0, size=2, Zm=0, Zn=0
    let encoding: u32 = 0x65A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fnmla_z_p_zzz_special_size_3_size_variant_3_16384_65e04000() {
    // Encoding: 0x65E04000
    // Test FNMLA_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x65E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_0_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Pg=0, size=0, Zda=0, Zm=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_1_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zda=0, Zm=0, size=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_2_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Pg=0, Zm=0, size=0, Zda=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fnmla_z_p_zzz_invalid_3_4000_65204000() {
    // Encoding: 0x65204000
    // Test FNMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, size=0, Zda=0, Zn=0
    let encoding: u32 = 0x65204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FNMLA_Z.P.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fnmla_z_p_zzz_reg_write_0_65204000() {
    // Test FNMLA_Z.P.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x65204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRSQRTS_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frsqrts_z_zz_field_size_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frsqrts_z_zz_field_size_1_poweroftwo_1c00_65401c00() {
    // Encoding: 0x65401C00
    // Test FRSQRTS_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, Zd=0, size=1
    let encoding: u32 = 0x65401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frsqrts_z_zz_field_size_2_poweroftwo_1c00_65801c00() {
    // Encoding: 0x65801C00
    // Test FRSQRTS_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=2, Zm=0
    let encoding: u32 = 0x65801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frsqrts_z_zz_field_size_3_max_1c00_65c01c00() {
    // Encoding: 0x65C01C00
    // Test FRSQRTS_Z.ZZ__ field size = 3 (Max)
    // Fields: Zn=0, Zd=0, Zm=0, size=3
    let encoding: u32 = 0x65C01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrts_z_zz_field_zm_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrts_z_zz_field_zm_1_poweroftwo_1c00_65011c00() {
    // Encoding: 0x65011C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, Zm=1, size=0
    let encoding: u32 = 0x65011C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrts_z_zz_field_zm_30_poweroftwominusone_1c00_651e1c00() {
    // Encoding: 0x651E1C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=0, Zm=30, Zn=0
    let encoding: u32 = 0x651E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrts_z_zz_field_zm_31_max_1c00_651f1c00() {
    // Encoding: 0x651F1C00
    // Test FRSQRTS_Z.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zn=0, Zd=0
    let encoding: u32 = 0x651F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrts_z_zz_field_zn_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrts_z_zz_field_zn_1_poweroftwo_1c00_65001c20() {
    // Encoding: 0x65001C20
    // Test FRSQRTS_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=1, size=0, Zd=0
    let encoding: u32 = 0x65001C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrts_z_zz_field_zn_30_poweroftwominusone_1c00_65001fc0() {
    // Encoding: 0x65001FC0
    // Test FRSQRTS_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=30, size=0, Zd=0
    let encoding: u32 = 0x65001FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrts_z_zz_field_zn_31_max_1c00_65001fe0() {
    // Encoding: 0x65001FE0
    // Test FRSQRTS_Z.ZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zd=0, Zm=0, Zn=31
    let encoding: u32 = 0x65001FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrts_z_zz_field_zd_0_min_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrts_z_zz_field_zd_1_poweroftwo_1c00_65001c01() {
    // Encoding: 0x65001C01
    // Test FRSQRTS_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=0, Zd=1
    let encoding: u32 = 0x65001C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrts_z_zz_field_zd_30_poweroftwominusone_1c00_65001c1e() {
    // Encoding: 0x65001C1E
    // Test FRSQRTS_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Zn=0, Zm=0
    let encoding: u32 = 0x65001C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrts_z_zz_field_zd_31_max_1c00_65001c1f() {
    // Encoding: 0x65001C1F
    // Test FRSQRTS_Z.ZZ__ field Zd = 31 (Max)
    // Fields: size=0, Zd=31, Zm=0, Zn=0
    let encoding: u32 = 0x65001C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frsqrts_z_zz_combo_0_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frsqrts_z_zz_special_size_0_size_variant_0_7168_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frsqrts_z_zz_special_size_1_size_variant_1_7168_65401c00() {
    // Encoding: 0x65401C00
    // Test FRSQRTS_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Zd=0, Zn=0
    let encoding: u32 = 0x65401C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frsqrts_z_zz_special_size_2_size_variant_2_7168_65801c00() {
    // Encoding: 0x65801C00
    // Test FRSQRTS_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zn=0, size=2, Zd=0
    let encoding: u32 = 0x65801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frsqrts_z_zz_special_size_3_size_variant_3_7168_65c01c00() {
    // Encoding: 0x65C01C00
    // Test FRSQRTS_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x65C01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_0_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_1_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_2_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrts_z_zz_invalid_3_1c00_65001c00() {
    // Encoding: 0x65001C00
    // Test FRSQRTS_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x65001C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTS_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frsqrts_z_zz_reg_write_0_65001c00() {
    // Test FRSQRTS_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65001C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65001C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMUL_Z.ZZ__ Tests
// ============================================================================

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmul_z_zz_field_size_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmul_z_zz_field_size_1_poweroftwo_800_65400800() {
    // Encoding: 0x65400800
    // Test FMUL_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmul_z_zz_field_size_2_poweroftwo_800_65800800() {
    // Encoding: 0x65800800
    // Test FMUL_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Zm=0, Zd=0
    let encoding: u32 = 0x65800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmul_z_zz_field_size_3_max_800_65c00800() {
    // Encoding: 0x65C00800
    // Test FMUL_Z.ZZ__ field size = 3 (Max)
    // Fields: Zn=0, Zm=0, Zd=0, size=3
    let encoding: u32 = 0x65C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zz_field_zm_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zz_field_zm_1_poweroftwo_800_65010800() {
    // Encoding: 0x65010800
    // Test FMUL_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, Zm=1, size=0, Zn=0
    let encoding: u32 = 0x65010800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zz_field_zm_30_poweroftwominusone_800_651e0800() {
    // Encoding: 0x651E0800
    // Test FMUL_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x651E0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zz_field_zm_31_max_800_651f0800() {
    // Encoding: 0x651F0800
    // Test FMUL_Z.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zd=0, Zn=0
    let encoding: u32 = 0x651F0800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zz_field_zn_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zz_field_zn_1_poweroftwo_800_65000820() {
    // Encoding: 0x65000820
    // Test FMUL_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x65000820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zz_field_zn_30_poweroftwominusone_800_65000bc0() {
    // Encoding: 0x65000BC0
    // Test FMUL_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zn=30, Zd=0
    let encoding: u32 = 0x65000BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zz_field_zn_31_max_800_65000be0() {
    // Encoding: 0x65000BE0
    // Test FMUL_Z.ZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zm=0, Zn=31, Zd=0
    let encoding: u32 = 0x65000BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_zz_field_zd_0_min_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_zz_field_zd_1_poweroftwo_800_65000801() {
    // Encoding: 0x65000801
    // Test FMUL_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, size=0, Zd=1
    let encoding: u32 = 0x65000801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_zz_field_zd_30_poweroftwominusone_800_6500081e() {
    // Encoding: 0x6500081E
    // Test FMUL_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zn=0, Zd=30
    let encoding: u32 = 0x6500081E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_zz_field_zd_31_max_800_6500081f() {
    // Encoding: 0x6500081F
    // Test FMUL_Z.ZZ__ field Zd = 31 (Max)
    // Fields: size=0, Zn=0, Zd=31, Zm=0
    let encoding: u32 = 0x6500081F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmul_z_zz_combo_0_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmul_z_zz_special_size_0_size_variant_0_2048_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmul_z_zz_special_size_1_size_variant_1_2048_65400800() {
    // Encoding: 0x65400800
    // Test FMUL_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x65400800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmul_z_zz_special_size_2_size_variant_2_2048_65800800() {
    // Encoding: 0x65800800
    // Test FMUL_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x65800800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmul_z_zz_special_size_3_size_variant_3_2048_65c00800() {
    // Encoding: 0x65C00800
    // Test FMUL_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x65C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_0_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_1_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_2_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_zz_invalid_3_800_65000800() {
    // Encoding: 0x65000800
    // Test FMUL_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x65000800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fmul_z_zz_reg_write_0_65000800() {
    // Test FMUL_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x65000800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65000800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FRSQRTE_Z.Z__ Tests
// ============================================================================

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_frsqrte_z_z_field_size_0_min_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_frsqrte_z_z_field_size_1_poweroftwo_3000_654f3000() {
    // Encoding: 0x654F3000
    // Test FRSQRTE_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Zn=0
    let encoding: u32 = 0x654F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_frsqrte_z_z_field_size_2_poweroftwo_3000_658f3000() {
    // Encoding: 0x658F3000
    // Test FRSQRTE_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0
    let encoding: u32 = 0x658F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_frsqrte_z_z_field_size_3_max_3000_65cf3000() {
    // Encoding: 0x65CF3000
    // Test FRSQRTE_Z.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Zd=0
    let encoding: u32 = 0x65CF3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrte_z_z_field_zn_0_min_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrte_z_z_field_zn_1_poweroftwo_3000_650f3020() {
    // Encoding: 0x650F3020
    // Test FRSQRTE_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0
    let encoding: u32 = 0x650F3020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrte_z_z_field_zn_30_poweroftwominusone_3000_650f33c0() {
    // Encoding: 0x650F33C0
    // Test FRSQRTE_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Zd=0
    let encoding: u32 = 0x650F33C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrte_z_z_field_zn_31_max_3000_650f33e0() {
    // Encoding: 0x650F33E0
    // Test FRSQRTE_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0
    let encoding: u32 = 0x650F33E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_frsqrte_z_z_field_zd_0_min_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_frsqrte_z_z_field_zd_1_poweroftwo_3000_650f3001() {
    // Encoding: 0x650F3001
    // Test FRSQRTE_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, Zn=0
    let encoding: u32 = 0x650F3001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_frsqrte_z_z_field_zd_30_poweroftwominusone_3000_650f301e() {
    // Encoding: 0x650F301E
    // Test FRSQRTE_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0
    let encoding: u32 = 0x650F301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_frsqrte_z_z_field_zd_31_max_3000_650f301f() {
    // Encoding: 0x650F301F
    // Test FRSQRTE_Z.Z__ field Zd = 31 (Max)
    // Fields: size=0, Zn=0, Zd=31
    let encoding: u32 = 0x650F301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_frsqrte_z_z_combo_0_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_frsqrte_z_z_special_size_0_size_variant_0_12288_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_frsqrte_z_z_special_size_1_size_variant_1_12288_654f3000() {
    // Encoding: 0x654F3000
    // Test FRSQRTE_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zn=0, size=1
    let encoding: u32 = 0x654F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_frsqrte_z_z_special_size_2_size_variant_2_12288_658f3000() {
    // Encoding: 0x658F3000
    // Test FRSQRTE_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zd=0
    let encoding: u32 = 0x658F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_frsqrte_z_z_special_size_3_size_variant_3_12288_65cf3000() {
    // Encoding: 0x65CF3000
    // Test FRSQRTE_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x65CF3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_0_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zd=0, Zn=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_1_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_2_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_frsqrte_z_z_invalid_3_3000_650f3000() {
    // Encoding: 0x650F3000
    // Test FRSQRTE_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x650F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FRSQRTE_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_frsqrte_z_z_reg_write_0_650f3000() {
    // Test FRSQRTE_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x650F3000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650F3000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMLA_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmla_z_p_zzz_field_size_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zda=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmla_z_p_zzz_field_size_1_poweroftwo_0_65600000() {
    // Encoding: 0x65600000
    // Test FMLA_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zn=0, Zda=0, Pg=0
    let encoding: u32 = 0x65600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmla_z_p_zzz_field_size_2_poweroftwo_0_65a00000() {
    // Encoding: 0x65A00000
    // Test FMLA_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zda=0, Zn=0, size=2
    let encoding: u32 = 0x65A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmla_z_p_zzz_field_size_3_max_0_65e00000() {
    // Encoding: 0x65E00000
    // Test FMLA_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x65E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_p_zzz_field_zm_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Zn=0, Zda=0, size=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_p_zzz_field_zm_1_poweroftwo_0_65210000() {
    // Encoding: 0x65210000
    // Test FMLA_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zda=0, size=0, Pg=0, Zm=1, Zn=0
    let encoding: u32 = 0x65210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_p_zzz_field_zm_30_poweroftwominusone_0_653e0000() {
    // Encoding: 0x653E0000
    // Test FMLA_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, size=0, Zn=0, Zda=0
    let encoding: u32 = 0x653E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_p_zzz_field_zm_31_max_0_653f0000() {
    // Encoding: 0x653F0000
    // Test FMLA_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Zn=0, Zda=0, size=0
    let encoding: u32 = 0x653F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmla_z_p_zzz_field_pg_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zda=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmla_z_p_zzz_field_pg_1_poweroftwo_0_65200400() {
    // Encoding: 0x65200400
    // Test FMLA_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zda=0, size=0, Pg=1, Zm=0
    let encoding: u32 = 0x65200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmla_z_p_zzz_field_zn_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Zn = 0 (Min)
    // Fields: Zn=0, Zda=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmla_z_p_zzz_field_zn_1_poweroftwo_0_65200020() {
    // Encoding: 0x65200020
    // Test FMLA_Z.P.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zda=0, Zn=1, Pg=0
    let encoding: u32 = 0x65200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmla_z_p_zzz_field_zn_30_poweroftwominusone_0_652003c0() {
    // Encoding: 0x652003C0
    // Test FMLA_Z.P.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Pg=0, Zn=30, Zda=0
    let encoding: u32 = 0x652003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmla_z_p_zzz_field_zn_31_max_0_652003e0() {
    // Encoding: 0x652003E0
    // Test FMLA_Z.P.ZZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zda=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x652003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmla_z_p_zzz_field_zda_0_min_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field Zda = 0 (Min)
    // Fields: Zn=0, size=0, Zda=0, Pg=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmla_z_p_zzz_field_zda_1_poweroftwo_0_65200001() {
    // Encoding: 0x65200001
    // Test FMLA_Z.P.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=0, Zn=0, Zda=1
    let encoding: u32 = 0x65200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmla_z_p_zzz_field_zda_15_poweroftwominusone_0_6520000f() {
    // Encoding: 0x6520000F
    // Test FMLA_Z.P.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zda=15, Zm=0, Zn=0
    let encoding: u32 = 0x6520000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmla_z_p_zzz_field_zda_31_max_0_6520001f() {
    // Encoding: 0x6520001F
    // Test FMLA_Z.P.ZZZ__ field Zda = 31 (Max)
    // Fields: Zda=31, Pg=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x6520001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmla_z_p_zzz_combo_0_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zda=0
    // Fields: Pg=0, size=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmla_z_p_zzz_special_size_0_size_variant_0_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zda=0, Zn=0, Pg=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmla_z_p_zzz_special_size_1_size_variant_1_0_65600000() {
    // Encoding: 0x65600000
    // Test FMLA_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zn=0, Zm=0, Zda=0
    let encoding: u32 = 0x65600000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmla_z_p_zzz_special_size_2_size_variant_2_0_65a00000() {
    // Encoding: 0x65A00000
    // Test FMLA_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zda=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x65A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmla_z_p_zzz_special_size_3_size_variant_3_0_65e00000() {
    // Encoding: 0x65E00000
    // Test FMLA_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Pg=0, Zda=0, Zm=0
    let encoding: u32 = 0x65E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_0_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zda=0, size=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_1_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zn=0, Zda=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_2_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zda=0, size=0, Pg=0, Zm=0, Zn=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmla_z_p_zzz_invalid_3_0_65200000() {
    // Encoding: 0x65200000
    // Test FMLA_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zda=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x65200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMLA_Z.P.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_fmla_z_p_zzz_reg_write_0_65200000() {
    // Test FMLA_Z.P.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x65200000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMINV_V.P.Z__ Tests
// ============================================================================

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fminv_v_p_z_field_size_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Vd=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fminv_v_p_z_field_size_1_poweroftwo_2000_65472000() {
    // Encoding: 0x65472000
    // Test FMINV_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Vd=0, Zn=0
    let encoding: u32 = 0x65472000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fminv_v_p_z_field_size_2_poweroftwo_2000_65872000() {
    // Encoding: 0x65872000
    // Test FMINV_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Vd=0, Pg=0
    let encoding: u32 = 0x65872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fminv_v_p_z_field_size_3_max_2000_65c72000() {
    // Encoding: 0x65C72000
    // Test FMINV_V.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x65C72000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fminv_v_p_z_field_pg_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field Pg = 0 (Min)
    // Fields: Vd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fminv_v_p_z_field_pg_1_poweroftwo_2000_65072400() {
    // Encoding: 0x65072400
    // Test FMINV_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Vd=0, size=0, Pg=1
    let encoding: u32 = 0x65072400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminv_v_p_z_field_zn_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminv_v_p_z_field_zn_1_poweroftwo_2000_65072020() {
    // Encoding: 0x65072020
    // Test FMINV_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Vd=0, size=0, Zn=1, Pg=0
    let encoding: u32 = 0x65072020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminv_v_p_z_field_zn_30_poweroftwominusone_2000_650723c0() {
    // Encoding: 0x650723C0
    // Test FMINV_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x650723C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminv_v_p_z_field_zn_31_max_2000_650723e0() {
    // Encoding: 0x650723E0
    // Test FMINV_V.P.Z__ field Zn = 31 (Max)
    // Fields: Vd=0, Zn=31, Pg=0, size=0
    let encoding: u32 = 0x650723E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fminv_v_p_z_field_vd_0_min_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field Vd = 0 (Min)
    // Fields: Pg=0, Vd=0, size=0, Zn=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fminv_v_p_z_field_vd_1_poweroftwo_2000_65072001() {
    // Encoding: 0x65072001
    // Test FMINV_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Vd=1, size=0
    let encoding: u32 = 0x65072001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fminv_v_p_z_field_vd_30_poweroftwominusone_2000_6507201e() {
    // Encoding: 0x6507201E
    // Test FMINV_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=30, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x6507201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fminv_v_p_z_field_vd_31_max_2000_6507201f() {
    // Encoding: 0x6507201F
    // Test FMINV_V.P.Z__ field Vd = 31 (Max)
    // Fields: Pg=0, Zn=0, Vd=31, size=0
    let encoding: u32 = 0x6507201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fminv_v_p_z_combo_0_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fminv_v_p_z_special_size_0_size_variant_0_8192_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fminv_v_p_z_special_size_1_size_variant_1_8192_65472000() {
    // Encoding: 0x65472000
    // Test FMINV_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zn=0, Vd=0
    let encoding: u32 = 0x65472000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fminv_v_p_z_special_size_2_size_variant_2_8192_65872000() {
    // Encoding: 0x65872000
    // Test FMINV_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Vd=0, Pg=0, size=2
    let encoding: u32 = 0x65872000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fminv_v_p_z_special_size_3_size_variant_3_8192_65c72000() {
    // Encoding: 0x65C72000
    // Test FMINV_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vd=0, Pg=0, size=3, Zn=0
    let encoding: u32 = 0x65C72000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_0_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_1_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_2_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, size=0, Vd=0, Zn=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fminv_v_p_z_invalid_3_2000_65072000() {
    // Encoding: 0x65072000
    // Test FMINV_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x65072000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMINV_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fminv_v_p_z_reg_write_0_65072000() {
    // Test FMINV_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x65072000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65072000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUBR_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsubr_z_p_zs_field_size_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field size = 0 (Min)
    // Fields: i1=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsubr_z_p_zs_field_size_1_poweroftwo_8000_655b8000() {
    // Encoding: 0x655B8000
    // Test FSUBR_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, i1=0, Zdn=0, size=1
    let encoding: u32 = 0x655B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsubr_z_p_zs_field_size_2_poweroftwo_8000_659b8000() {
    // Encoding: 0x659B8000
    // Test FSUBR_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, i1=0
    let encoding: u32 = 0x659B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsubr_z_p_zs_field_size_3_max_8000_65db8000() {
    // Encoding: 0x65DB8000
    // Test FSUBR_Z.P.ZS__ field size = 3 (Max)
    // Fields: Zdn=0, Pg=0, i1=0, size=3
    let encoding: u32 = 0x65DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsubr_z_p_zs_field_pg_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, i1=0, Pg=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsubr_z_p_zs_field_pg_1_poweroftwo_8000_651b8400() {
    // Encoding: 0x651B8400
    // Test FSUBR_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Pg=1, i1=0
    let encoding: u32 = 0x651B8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsubr_z_p_zs_field_i1_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fsubr_z_p_zs_field_i1_1_max_8000_651b8020() {
    // Encoding: 0x651B8020
    // Test FSUBR_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: Pg=0, i1=1, size=0, Zdn=0
    let encoding: u32 = 0x651B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsubr_z_p_zs_field_zdn_0_min_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: Pg=0, size=0, i1=0, Zdn=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fsubr_z_p_zs_field_zdn_1_poweroftwo_8000_651b8001() {
    // Encoding: 0x651B8001
    // Test FSUBR_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zdn=1, i1=0
    let encoding: u32 = 0x651B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fsubr_z_p_zs_field_zdn_15_poweroftwominusone_8000_651b800f() {
    // Encoding: 0x651B800F
    // Test FSUBR_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=15, i1=0
    let encoding: u32 = 0x651B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fsubr_z_p_zs_field_zdn_31_max_8000_651b801f() {
    // Encoding: 0x651B801F
    // Test FSUBR_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, Pg=0, i1=0
    let encoding: u32 = 0x651B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsubr_z_p_zs_combo_0_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: Pg=0, Zdn=0, i1=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsubr_z_p_zs_special_size_0_size_variant_0_32768_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, i1=0, Zdn=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsubr_z_p_zs_special_size_1_size_variant_1_32768_655b8000() {
    // Encoding: 0x655B8000
    // Test FSUBR_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, size=1, Pg=0, i1=0
    let encoding: u32 = 0x655B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsubr_z_p_zs_special_size_2_size_variant_2_32768_659b8000() {
    // Encoding: 0x659B8000
    // Test FSUBR_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: i1=0, Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x659B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsubr_z_p_zs_special_size_3_size_variant_3_32768_65db8000() {
    // Encoding: 0x65DB8000
    // Test FSUBR_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Pg=0, i1=0
    let encoding: u32 = 0x65DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_0_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, Pg=0, i1=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_1_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zdn=0, i1=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_2_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zdn=0, size=0, Pg=0, i1=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsubr_z_p_zs_invalid_3_8000_651b8000() {
    // Encoding: 0x651B8000
    // Test FSUBR_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x651B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUBR_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fsubr_z_p_zs_reg_write_0_651b8000() {
    // Test FSUBR_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x651B8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x651B8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FDIVR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fdivr_z_p_zz_field_size_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fdivr_z_p_zz_field_size_1_poweroftwo_8000_654c8000() {
    // Encoding: 0x654C8000
    // Test FDIVR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x654C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fdivr_z_p_zz_field_size_2_poweroftwo_8000_658c8000() {
    // Encoding: 0x658C8000
    // Test FDIVR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x658C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fdivr_z_p_zz_field_size_3_max_8000_65cc8000() {
    // Encoding: 0x65CC8000
    // Test FDIVR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, Pg=0, Zm=0, size=3
    let encoding: u32 = 0x65CC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fdivr_z_p_zz_field_pg_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fdivr_z_p_zz_field_pg_1_poweroftwo_8000_650c8400() {
    // Encoding: 0x650C8400
    // Test FDIVR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Zm=0, Pg=1
    let encoding: u32 = 0x650C8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fdivr_z_p_zz_field_zm_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fdivr_z_p_zz_field_zm_1_poweroftwo_8000_650c8020() {
    // Encoding: 0x650C8020
    // Test FDIVR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x650C8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fdivr_z_p_zz_field_zm_30_poweroftwominusone_8000_650c83c0() {
    // Encoding: 0x650C83C0
    // Test FDIVR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x650C83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fdivr_z_p_zz_field_zm_31_max_8000_650c83e0() {
    // Encoding: 0x650C83E0
    // Test FDIVR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=0, Zm=31
    let encoding: u32 = 0x650C83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fdivr_z_p_zz_field_zdn_0_min_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fdivr_z_p_zz_field_zdn_1_poweroftwo_8000_650c8001() {
    // Encoding: 0x650C8001
    // Test FDIVR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1, Zm=0
    let encoding: u32 = 0x650C8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fdivr_z_p_zz_field_zdn_15_poweroftwominusone_8000_650c800f() {
    // Encoding: 0x650C800F
    // Test FDIVR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zdn=15, size=0
    let encoding: u32 = 0x650C800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fdivr_z_p_zz_field_zdn_31_max_8000_650c801f() {
    // Encoding: 0x650C801F
    // Test FDIVR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x650C801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fdivr_z_p_zz_combo_0_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fdivr_z_p_zz_special_size_0_size_variant_0_32768_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fdivr_z_p_zz_special_size_1_size_variant_1_32768_654c8000() {
    // Encoding: 0x654C8000
    // Test FDIVR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x654C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fdivr_z_p_zz_special_size_2_size_variant_2_32768_658c8000() {
    // Encoding: 0x658C8000
    // Test FDIVR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x658C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fdivr_z_p_zz_special_size_3_size_variant_3_32768_65cc8000() {
    // Encoding: 0x65CC8000
    // Test FDIVR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65CC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_0_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_1_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_2_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fdivr_z_p_zz_invalid_3_8000_650c8000() {
    // Encoding: 0x650C8000
    // Test FDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x650C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FDIVR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fdivr_z_p_zz_reg_write_0_650c8000() {
    // Test FDIVR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x650C8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x650C8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FCADD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fcadd_z_p_zz_field_size_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, rot=0, Zdn=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fcadd_z_p_zz_field_size_1_poweroftwo_8000_64408000() {
    // Encoding: 0x64408000
    // Test FCADD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, rot=0, Zm=0, size=1, Zdn=0
    let encoding: u32 = 0x64408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fcadd_z_p_zz_field_size_2_poweroftwo_8000_64808000() {
    // Encoding: 0x64808000
    // Test FCADD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=2, rot=0, Zdn=0
    let encoding: u32 = 0x64808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fcadd_z_p_zz_field_size_3_max_8000_64c08000() {
    // Encoding: 0x64C08000
    // Test FCADD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, rot=0, Pg=0, Zdn=0
    let encoding: u32 = 0x64C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field rot 16 +: 1`
/// Requirement: FieldBoundary { field: "rot", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fcadd_z_p_zz_field_rot_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field rot = 0 (Min)
    // Fields: rot=0, Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field rot 16 +: 1`
/// Requirement: FieldBoundary { field: "rot", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fcadd_z_p_zz_field_rot_1_max_8000_64018000() {
    // Encoding: 0x64018000
    // Test FCADD_Z.P.ZZ__ field rot = 1 (Max)
    // Fields: Zdn=0, Pg=0, size=0, Zm=0, rot=1
    let encoding: u32 = 0x64018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fcadd_z_p_zz_field_pg_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, rot=0, size=0, Zm=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fcadd_z_p_zz_field_pg_1_poweroftwo_8000_64008400() {
    // Encoding: 0x64008400
    // Test FCADD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, rot=0, Zm=0, Pg=1, Zdn=0
    let encoding: u32 = 0x64008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fcadd_z_p_zz_field_zm_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0, rot=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fcadd_z_p_zz_field_zm_1_poweroftwo_8000_64008020() {
    // Encoding: 0x64008020
    // Test FCADD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, rot=0, size=0, Pg=0
    let encoding: u32 = 0x64008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fcadd_z_p_zz_field_zm_30_poweroftwominusone_8000_640083c0() {
    // Encoding: 0x640083C0
    // Test FCADD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, size=0, Zdn=0, rot=0
    let encoding: u32 = 0x640083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fcadd_z_p_zz_field_zm_31_max_8000_640083e0() {
    // Encoding: 0x640083E0
    // Test FCADD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, Zm=31, rot=0, Pg=0, size=0
    let encoding: u32 = 0x640083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fcadd_z_p_zz_field_zdn_0_min_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fcadd_z_p_zz_field_zdn_1_poweroftwo_8000_64008001() {
    // Encoding: 0x64008001
    // Test FCADD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, rot=0, Zdn=1, size=0, Zm=0
    let encoding: u32 = 0x64008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fcadd_z_p_zz_field_zdn_15_poweroftwominusone_8000_6400800f() {
    // Encoding: 0x6400800F
    // Test FCADD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, rot=0, Zm=0, Zdn=15
    let encoding: u32 = 0x6400800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fcadd_z_p_zz_field_zdn_31_max_8000_6400801f() {
    // Encoding: 0x6400801F
    // Test FCADD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: rot=0, Zdn=31, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x6400801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fcadd_z_p_zz_combo_0_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ field combination: size=0, rot=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Zm=0, rot=0, Pg=0, size=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fcadd_z_p_zz_special_size_0_size_variant_0_32768_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zdn=0, rot=0, size=0, Pg=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fcadd_z_p_zz_special_size_1_size_variant_1_32768_64408000() {
    // Encoding: 0x64408000
    // Test FCADD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: rot=0, Pg=0, size=1, Zm=0, Zdn=0
    let encoding: u32 = 0x64408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fcadd_z_p_zz_special_size_2_size_variant_2_32768_64808000() {
    // Encoding: 0x64808000
    // Test FCADD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: rot=0, size=2, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x64808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fcadd_z_p_zz_special_size_3_size_variant_3_32768_64c08000() {
    // Encoding: 0x64C08000
    // Test FCADD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Pg=0, rot=0, Zdn=0
    let encoding: u32 = 0x64C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_0_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, rot=0, Zm=0, Zdn=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_1_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, rot=0, size=0, Zm=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_2_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zdn=0, Zm=0, size=0, rot=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fcadd_z_p_zz_invalid_3_8000_64008000() {
    // Encoding: 0x64008000
    // Test FCADD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, size=0, rot=0, Zdn=0
    let encoding: u32 = 0x64008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FCADD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fcadd_z_p_zz_reg_write_0_64008000() {
    // Test FCADD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x64008000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x64008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FABS_Z.P.Z__ Tests
// ============================================================================

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fabs_z_p_z_field_size_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fabs_z_p_z_field_size_1_poweroftwo_a000_045ca000() {
    // Encoding: 0x045CA000
    // Test FABS_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, size=1, Zd=0
    let encoding: u32 = 0x045CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fabs_z_p_z_field_size_2_poweroftwo_a000_049ca000() {
    // Encoding: 0x049CA000
    // Test FABS_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, size=2, Zn=0, Pg=0
    let encoding: u32 = 0x049CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fabs_z_p_z_field_size_3_max_a000_04dca000() {
    // Encoding: 0x04DCA000
    // Test FABS_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x04DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fabs_z_p_z_field_pg_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fabs_z_p_z_field_pg_1_poweroftwo_a000_041ca400() {
    // Encoding: 0x041CA400
    // Test FABS_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zd=0, Pg=1
    let encoding: u32 = 0x041CA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fabs_z_p_z_field_zn_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fabs_z_p_z_field_zn_1_poweroftwo_a000_041ca020() {
    // Encoding: 0x041CA020
    // Test FABS_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, Zn=1, size=0
    let encoding: u32 = 0x041CA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fabs_z_p_z_field_zn_30_poweroftwominusone_a000_041ca3c0() {
    // Encoding: 0x041CA3C0
    // Test FABS_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x041CA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fabs_z_p_z_field_zn_31_max_a000_041ca3e0() {
    // Encoding: 0x041CA3E0
    // Test FABS_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, size=0, Zd=0, Zn=31
    let encoding: u32 = 0x041CA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fabs_z_p_z_field_zd_0_min_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fabs_z_p_z_field_zd_1_poweroftwo_a000_041ca001() {
    // Encoding: 0x041CA001
    // Test FABS_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1, size=0
    let encoding: u32 = 0x041CA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fabs_z_p_z_field_zd_30_poweroftwominusone_a000_041ca01e() {
    // Encoding: 0x041CA01E
    // Test FABS_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x041CA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fabs_z_p_z_field_zd_31_max_a000_041ca01f() {
    // Encoding: 0x041CA01F
    // Test FABS_Z.P.Z__ field Zd = 31 (Max)
    // Fields: size=0, Zn=0, Pg=0, Zd=31
    let encoding: u32 = 0x041CA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fabs_z_p_z_combo_0_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fabs_z_p_z_special_size_0_size_variant_0_40960_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fabs_z_p_z_special_size_1_size_variant_1_40960_045ca000() {
    // Encoding: 0x045CA000
    // Test FABS_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Zd=0, Pg=0, size=1
    let encoding: u32 = 0x045CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fabs_z_p_z_special_size_2_size_variant_2_40960_049ca000() {
    // Encoding: 0x049CA000
    // Test FABS_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x049CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fabs_z_p_z_special_size_3_size_variant_3_40960_04dca000() {
    // Encoding: 0x04DCA000
    // Test FABS_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x04DCA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_0_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_1_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_2_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fabs_z_p_z_invalid_3_a000_041ca000() {
    // Encoding: 0x041CA000
    // Test FABS_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x041CA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FABS_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_fabs_z_p_z_reg_write_0_041ca000() {
    // Test FABS_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x041CA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041CA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FSUB_Z.P.ZS__ Tests
// ============================================================================

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fsub_z_p_zs_field_size_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field size = 0 (Min)
    // Fields: size=0, Pg=0, i1=0, Zdn=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fsub_z_p_zs_field_size_1_poweroftwo_8000_65598000() {
    // Encoding: 0x65598000
    // Test FSUB_Z.P.ZS__ field size = 1 (PowerOfTwo)
    // Fields: i1=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x65598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fsub_z_p_zs_field_size_2_poweroftwo_8000_65998000() {
    // Encoding: 0x65998000
    // Test FSUB_Z.P.ZS__ field size = 2 (PowerOfTwo)
    // Fields: i1=0, size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x65998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fsub_z_p_zs_field_size_3_max_8000_65d98000() {
    // Encoding: 0x65D98000
    // Test FSUB_Z.P.ZS__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0, i1=0
    let encoding: u32 = 0x65D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fsub_z_p_zs_field_pg_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field Pg = 0 (Min)
    // Fields: i1=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fsub_z_p_zs_field_pg_1_poweroftwo_8000_65198400() {
    // Encoding: 0x65198400
    // Test FSUB_Z.P.ZS__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, i1=0, size=0, Zdn=0
    let encoding: u32 = 0x65198400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsub_z_p_zs_field_i1_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field i1 = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field i1 5 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_fsub_z_p_zs_field_i1_1_max_8000_65198020() {
    // Encoding: 0x65198020
    // Test FSUB_Z.P.ZS__ field i1 = 1 (Max)
    // Fields: Zdn=0, i1=1, Pg=0, size=0
    let encoding: u32 = 0x65198020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fsub_z_p_zs_field_zdn_0_min_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field Zdn = 0 (Min)
    // Fields: i1=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fsub_z_p_zs_field_zdn_1_poweroftwo_8000_65198001() {
    // Encoding: 0x65198001
    // Test FSUB_Z.P.ZS__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, i1=0, Zdn=1
    let encoding: u32 = 0x65198001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fsub_z_p_zs_field_zdn_15_poweroftwominusone_8000_6519800f() {
    // Encoding: 0x6519800F
    // Test FSUB_Z.P.ZS__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=15, size=0, i1=0
    let encoding: u32 = 0x6519800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fsub_z_p_zs_field_zdn_31_max_8000_6519801f() {
    // Encoding: 0x6519801F
    // Test FSUB_Z.P.ZS__ field Zdn = 31 (Max)
    // Fields: Zdn=31, i1=0, size=0, Pg=0
    let encoding: u32 = 0x6519801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fsub_z_p_zs_combo_0_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ field combination: size=0, Pg=0, i1=0, Zdn=0
    // Fields: i1=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fsub_z_p_zs_special_size_0_size_variant_0_32768_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fsub_z_p_zs_special_size_1_size_variant_1_32768_65598000() {
    // Encoding: 0x65598000
    // Test FSUB_Z.P.ZS__ special value size = 1 (Size variant 1)
    // Fields: size=1, i1=0, Pg=0, Zdn=0
    let encoding: u32 = 0x65598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fsub_z_p_zs_special_size_2_size_variant_2_32768_65998000() {
    // Encoding: 0x65998000
    // Test FSUB_Z.P.ZS__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zdn=0, size=2, i1=0
    let encoding: u32 = 0x65998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fsub_z_p_zs_special_size_3_size_variant_3_32768_65d98000() {
    // Encoding: 0x65D98000
    // Test FSUB_Z.P.ZS__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, i1=0, Pg=0
    let encoding: u32 = 0x65D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_0_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, size=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_1_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_2_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, i1=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fsub_z_p_zs_invalid_3_8000_65198000() {
    // Encoding: 0x65198000
    // Test FSUB_Z.P.ZS__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zdn=0, i1=0
    let encoding: u32 = 0x65198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FSUB_Z.P.ZS__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fsub_z_p_zs_reg_write_0_65198000() {
    // Test FSUB_Z.P.ZS__ register write: SimdFromField("dn")
    // Encoding: 0x65198000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65198000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// FMUL_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_fmul_z_p_zz_field_size_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_fmul_z_p_zz_field_size_1_poweroftwo_8000_65428000() {
    // Encoding: 0x65428000
    // Test FMUL_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, Pg=0, size=1
    let encoding: u32 = 0x65428000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_fmul_z_p_zz_field_size_2_poweroftwo_8000_65828000() {
    // Encoding: 0x65828000
    // Test FMUL_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x65828000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_fmul_z_p_zz_field_size_3_max_8000_65c28000() {
    // Encoding: 0x65C28000
    // Test FMUL_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x65C28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_fmul_z_p_zz_field_pg_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_fmul_z_p_zz_field_pg_1_poweroftwo_8000_65028400() {
    // Encoding: 0x65028400
    // Test FMUL_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65028400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_fmul_z_p_zz_field_zm_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_fmul_z_p_zz_field_zm_1_poweroftwo_8000_65028020() {
    // Encoding: 0x65028020
    // Test FMUL_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x65028020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_fmul_z_p_zz_field_zm_30_poweroftwominusone_8000_650283c0() {
    // Encoding: 0x650283C0
    // Test FMUL_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Pg=0, Zm=30, size=0
    let encoding: u32 = 0x650283C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_fmul_z_p_zz_field_zm_31_max_8000_650283e0() {
    // Encoding: 0x650283E0
    // Test FMUL_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Pg=0, Zm=31, Zdn=0
    let encoding: u32 = 0x650283E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_fmul_z_p_zz_field_zdn_0_min_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_fmul_z_p_zz_field_zdn_1_poweroftwo_8000_65028001() {
    // Encoding: 0x65028001
    // Test FMUL_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=0, Zdn=1
    let encoding: u32 = 0x65028001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_fmul_z_p_zz_field_zdn_15_poweroftwominusone_8000_6502800f() {
    // Encoding: 0x6502800F
    // Test FMUL_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, size=0, Zdn=15
    let encoding: u32 = 0x6502800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_fmul_z_p_zz_field_zdn_31_max_8000_6502801f() {
    // Encoding: 0x6502801F
    // Test FMUL_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, Pg=0, Zm=0
    let encoding: u32 = 0x6502801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_fmul_z_p_zz_combo_0_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_fmul_z_p_zz_special_size_0_size_variant_0_32768_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_fmul_z_p_zz_special_size_1_size_variant_1_32768_65428000() {
    // Encoding: 0x65428000
    // Test FMUL_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x65428000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_fmul_z_p_zz_special_size_2_size_variant_2_32768_65828000() {
    // Encoding: 0x65828000
    // Test FMUL_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x65828000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_fmul_z_p_zz_special_size_3_size_variant_3_32768_65c28000() {
    // Encoding: 0x65C28000
    // Test FMUL_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zdn=0, Zm=0, size=3
    let encoding: u32 = 0x65C28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_0_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_1_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_2_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_fmul_z_p_zz_invalid_3_8000_65028000() {
    // Encoding: 0x65028000
    // Test FMUL_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x65028000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: FMUL_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_fmul_z_p_zz_reg_write_0_65028000() {
    // Test FMUL_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x65028000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x65028000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}
