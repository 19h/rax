//! A64 sve store tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// ST2W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_br_contiguous_field_rm_0_min_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5216000() {
    // Encoding: 0xE5216000
    // Test ST2W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2w_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e53e6000() {
    // Encoding: 0xE53E6000
    // Test ST2W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE53E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st2w_z_p_br_contiguous_field_rm_31_max_6000_e53f6000() {
    // Encoding: 0xE53F6000
    // Test ST2W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE53F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_br_contiguous_field_pg_0_min_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5206400() {
    // Encoding: 0xE5206400
    // Test ST2W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_br_contiguous_field_rn_0_min_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5206020() {
    // Encoding: 0xE5206020
    // Test ST2W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=1, Pg=0, Zt=0
    let encoding: u32 = 0xE5206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2w_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e52063c0() {
    // Encoding: 0xE52063C0
    // Test ST2W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Rm=0
    let encoding: u32 = 0xE52063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2w_z_p_br_contiguous_field_rn_31_max_6000_e52063e0() {
    // Encoding: 0xE52063E0
    // Test ST2W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE52063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2w_z_p_br_contiguous_field_zt_0_min_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2w_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5206001() {
    // Encoding: 0xE5206001
    // Test ST2W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=1
    let encoding: u32 = 0xE5206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2w_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e520601e() {
    // Encoding: 0xE520601E
    // Test ST2W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xE520601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2w_z_p_br_contiguous_field_zt_31_max_6000_e520601f() {
    // Encoding: 0xE520601F
    // Test ST2W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Rm=0
    let encoding: u32 = 0xE520601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st2w_z_p_br_contiguous_combo_0_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e52063e0() {
    // Encoding: 0xE52063E0
    // Test ST2W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE52063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_br_contiguous_invalid_0_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_br_contiguous_invalid_1_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_br_contiguous_invalid_2_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_br_contiguous_invalid_3_6000_e5206000() {
    // Encoding: 0xE5206000
    // Test ST2W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2w_z_p_br_contiguous_sp_rn_e52063e0() {
    // Test ST2W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE52063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE52063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2W_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2w_z_p_br_contiguous_store_0_e5206020() {
    // Test ST2W_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5206020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5206020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_0_zero_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e491e000() {
    // Encoding: 0xE491E000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=1, Rn=0
    let encoding: u32 = 0xE491E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e493e000() {
    // Encoding: 0xE493E000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=3, Zt=0, Pg=0
    let encoding: u32 = 0xE493E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e494e000() {
    // Encoding: 0xE494E000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=4
    let encoding: u32 = 0xE494E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e497e000() {
    // Encoding: 0xE497E000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE497E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e498e000() {
    // Encoding: 0xE498E000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE498E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_imm4_15_max_e000_e49fe000() {
    // Encoding: 0xE49FE000
    // Test STNT1H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=15
    let encoding: u32 = 0xE49FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_pg_0_min_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e490e400() {
    // Encoding: 0xE490E400
    // Test STNT1H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE490E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_rn_0_min_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e490e020() {
    // Encoding: 0xE490E020
    // Test STNT1H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE490E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e490e3c0() {
    // Encoding: 0xE490E3C0
    // Test STNT1H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xE490E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_rn_31_max_e000_e490e3e0() {
    // Encoding: 0xE490E3E0
    // Test STNT1H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Pg=0, Zt=0
    let encoding: u32 = 0xE490E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_zt_0_min_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e490e001() {
    // Encoding: 0xE490E001
    // Test STNT1H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, imm4=0, Pg=0
    let encoding: u32 = 0xE490E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e490e01e() {
    // Encoding: 0xE490E01E
    // Test STNT1H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE490E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1h_z_p_bi_contiguous_field_zt_31_max_e000_e490e01f() {
    // Encoding: 0xE490E01F
    // Test STNT1H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, imm4=0, Zt=31, Rn=0
    let encoding: u32 = 0xE490E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_stnt1h_z_p_bi_contiguous_combo_0_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e490e3e0() {
    // Encoding: 0xE490E3E0
    // Test STNT1H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE490E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_bi_contiguous_invalid_0_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_bi_contiguous_invalid_1_e000_e490e000() {
    // Encoding: 0xE490E000
    // Test STNT1H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE490E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1h_z_p_bi_contiguous_sp_rn_e490e3e0() {
    // Test STNT1H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE490E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE490E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1H_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1h_z_p_bi_contiguous_store_0_e490e020() {
    // Test STNT1H_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE490E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE490E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1H_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zm_0_min_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_8000_e4e18000() {
    // Encoding: 0xE4E18000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=1, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_8000_e4fe8000() {
    // Encoding: 0xE4FE8000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, xs=0, Zt=0, Pg=0, Zm=30
    let encoding: u32 = 0xE4FE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zm_31_max_8000_e4ff8000() {
    // Encoding: 0xE4FF8000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: xs=0, Zt=0, Pg=0, Rn=0, Zm=31
    let encoding: u32 = 0xE4FF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_xs_0_min_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_xs_1_max_8000_e4e0c000() {
    // Encoding: 0xE4E0C000
    // Test ST1H_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: xs=1, Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_pg_0_min_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_8000_e4e08400() {
    // Encoding: 0xE4E08400
    // Test ST1H_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, xs=0, Pg=1, Zm=0
    let encoding: u32 = 0xE4E08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_rn_0_min_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_8000_e4e08020() {
    // Encoding: 0xE4E08020
    // Test ST1H_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zm=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xE4E08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_8000_e4e083c0() {
    // Encoding: 0xE4E083C0
    // Test ST1H_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Rn=30, Zm=0, Zt=0
    let encoding: u32 = 0xE4E083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_rn_31_max_8000_e4e083e0() {
    // Encoding: 0xE4E083E0
    // Test ST1H_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xE4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zt_0_min_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_8000_e4e08001() {
    // Encoding: 0xE4E08001
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Zm=0, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0xE4E08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_8000_e4e0801e() {
    // Encoding: 0xE4E0801E
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=30, xs=0
    let encoding: u32 = 0xE4E0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_field_zt_31_max_8000_e4e0801f() {
    // Encoding: 0xE4E0801F
    // Test ST1H_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31, xs=0
    let encoding: u32 = 0xE4E0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_combo_0_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e4e083e0() {
    // Encoding: 0xE4E083E0
    // Test ST1H_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Rn=31, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_invalid_0_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, xs=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_invalid_1_8000_e4e08000() {
    // Encoding: 0xE4E08000
    // Test ST1H_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zm_0_min_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_8000_e4a18000() {
    // Encoding: 0xE4A18000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=1, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xE4A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_8000_e4be8000() {
    // Encoding: 0xE4BE8000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xE4BE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zm_31_max_8000_e4bf8000() {
    // Encoding: 0xE4BF8000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4BF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_xs_0_min_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Zm=0, Pg=0, xs=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_xs_1_max_8000_e4a0c000() {
    // Encoding: 0xE4A0C000
    // Test ST1H_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0, xs=1
    let encoding: u32 = 0xE4A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_pg_0_min_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_8000_e4a08400() {
    // Encoding: 0xE4A08400
    // Test ST1H_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xE4A08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_rn_0_min_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_8000_e4a08020() {
    // Encoding: 0xE4A08020
    // Test ST1H_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, xs=0, Rn=1, Pg=0
    let encoding: u32 = 0xE4A08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_8000_e4a083c0() {
    // Encoding: 0xE4A083C0
    // Test ST1H_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=0, xs=0, Pg=0, Rn=30
    let encoding: u32 = 0xE4A083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_rn_31_max_8000_e4a083e0() {
    // Encoding: 0xE4A083E0
    // Test ST1H_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, xs=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4A083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zt_0_min_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, xs=0, Zm=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_8000_e4a08001() {
    // Encoding: 0xE4A08001
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=1
    let encoding: u32 = 0xE4A08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_8000_e4a0801e() {
    // Encoding: 0xE4A0801E
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, xs=0, Pg=0, Zt=30
    let encoding: u32 = 0xE4A0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_field_zt_31_max_8000_e4a0801f() {
    // Encoding: 0xE4A0801F
    // Test ST1H_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=31, xs=0
    let encoding: u32 = 0xE4A0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_combo_0_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e4a083e0() {
    // Encoding: 0xE4A083E0
    // Test ST1H_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0, xs=0
    let encoding: u32 = 0xE4A083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_invalid_0_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_invalid_1_8000_e4a08000() {
    // Encoding: 0xE4A08000
    // Test ST1H_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xE4A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zm_0_min_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_8000_e4818000() {
    // Encoding: 0xE4818000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=1
    let encoding: u32 = 0xE4818000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_8000_e49e8000() {
    // Encoding: 0xE49E8000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, xs=0, Zm=30
    let encoding: u32 = 0xE49E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zm_31_max_8000_e49f8000() {
    // Encoding: 0xE49F8000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Zt=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xE49F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_xs_0_min_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_xs_1_max_8000_e480c000() {
    // Encoding: 0xE480C000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, xs=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_pg_0_min_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Rn=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_8000_e4808400() {
    // Encoding: 0xE4808400
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, xs=0, Pg=1, Zm=0, Zt=0
    let encoding: u32 = 0xE4808400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_rn_0_min_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_8000_e4808020() {
    // Encoding: 0xE4808020
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, xs=0, Rn=1, Zm=0
    let encoding: u32 = 0xE4808020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_8000_e48083c0() {
    // Encoding: 0xE48083C0
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE48083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_rn_31_max_8000_e48083e0() {
    // Encoding: 0xE48083E0
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, xs=0, Rn=31, Zt=0
    let encoding: u32 = 0xE48083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zt_0_min_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_8000_e4808001() {
    // Encoding: 0xE4808001
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zm=0, xs=0, Zt=1
    let encoding: u32 = 0xE4808001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_8000_e480801e() {
    // Encoding: 0xE480801E
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=30
    let encoding: u32 = 0xE480801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_field_zt_31_max_8000_e480801f() {
    // Encoding: 0xE480801F
    // Test ST1H_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xE480801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_combo_0_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e48083e0() {
    // Encoding: 0xE48083E0
    // Test ST1H_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xE48083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_invalid_0_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, xs=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_invalid_1_8000_e4808000() {
    // Encoding: 0xE4808000
    // Test ST1H_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xE4808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zm_0_min_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_8000_e4c18000() {
    // Encoding: 0xE4C18000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, xs=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_8000_e4de8000() {
    // Encoding: 0xE4DE8000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Rn=0, Zm=30, Zt=0
    let encoding: u32 = 0xE4DE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zm_31_max_8000_e4df8000() {
    // Encoding: 0xE4DF8000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, xs=0, Zt=0, Rn=0, Zm=31
    let encoding: u32 = 0xE4DF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_xs_0_min_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_xs_1_max_8000_e4c0c000() {
    // Encoding: 0xE4C0C000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Zm=0, xs=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_pg_0_min_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_8000_e4c08400() {
    // Encoding: 0xE4C08400
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, xs=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xE4C08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_rn_0_min_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_8000_e4c08020() {
    // Encoding: 0xE4C08020
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=1, Zm=0, xs=0
    let encoding: u32 = 0xE4C08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_8000_e4c083c0() {
    // Encoding: 0xE4C083C0
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, xs=0, Zm=0
    let encoding: u32 = 0xE4C083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_rn_31_max_8000_e4c083e0() {
    // Encoding: 0xE4C083E0
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0, xs=0
    let encoding: u32 = 0xE4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zt_0_min_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_8000_e4c08001() {
    // Encoding: 0xE4C08001
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Zm=0, Zt=1, Rn=0
    let encoding: u32 = 0xE4C08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_8000_e4c0801e() {
    // Encoding: 0xE4C0801E
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=30
    let encoding: u32 = 0xE4C0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_field_zt_31_max_8000_e4c0801f() {
    // Encoding: 0xE4C0801F
    // Test ST1H_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=31, xs=0
    let encoding: u32 = 0xE4C0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_combo_0_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e4c083e0() {
    // Encoding: 0xE4C083E0
    // Test ST1H_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xE4C083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_invalid_0_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zm=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_invalid_1_8000_e4c08000() {
    // Encoding: 0xE4C08000
    // Test ST1H_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE4C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zm_0_min_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_a000_e4a1a000() {
    // Encoding: 0xE4A1A000
    // Test ST1H_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_a000_e4bea000() {
    // Encoding: 0xE4BEA000
    // Test ST1H_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=30
    let encoding: u32 = 0xE4BEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zm_31_max_a000_e4bfa000() {
    // Encoding: 0xE4BFA000
    // Test ST1H_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_pg_0_min_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_a000_e4a0a400() {
    // Encoding: 0xE4A0A400
    // Test ST1H_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Zm=0, Pg=1
    let encoding: u32 = 0xE4A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_rn_0_min_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_a000_e4a0a020() {
    // Encoding: 0xE4A0A020
    // Test ST1H_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_a000_e4a0a3c0() {
    // Encoding: 0xE4A0A3C0
    // Test ST1H_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, Zm=0
    let encoding: u32 = 0xE4A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_rn_31_max_a000_e4a0a3e0() {
    // Encoding: 0xE4A0A3E0
    // Test ST1H_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE4A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zt_0_min_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_a000_e4a0a001() {
    // Encoding: 0xE4A0A001
    // Test ST1H_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xE4A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_a000_e4a0a01e() {
    // Encoding: 0xE4A0A01E
    // Test ST1H_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xE4A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_64_scaled_field_zt_31_max_a000_e4a0a01f() {
    // Encoding: 0xE4A0A01F
    // Test ST1H_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=31
    let encoding: u32 = 0xE4A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_combo_0_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e4a0a3e0() {
    // Encoding: 0xE4A0A3E0
    // Test ST1H_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rn=31, Pg=0, Zm=0
    let encoding: u32 = 0xE4A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_64_scaled_invalid_0_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_64_scaled_invalid_1_a000_e4a0a000() {
    // Encoding: 0xE4A0A000
    // Test ST1H_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zm_0_min_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_e481a000() {
    // Encoding: 0xE481A000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE481A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_e49ea000() {
    // Encoding: 0xE49EA000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Zm=30, Pg=0
    let encoding: u32 = 0xE49EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zm_31_max_a000_e49fa000() {
    // Encoding: 0xE49FA000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zm=31, Zt=0
    let encoding: u32 = 0xE49FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_pg_0_min_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_e480a400() {
    // Encoding: 0xE480A400
    // Test ST1H_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=1
    let encoding: u32 = 0xE480A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_rn_0_min_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_e480a020() {
    // Encoding: 0xE480A020
    // Test ST1H_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zm=0, Zt=0
    let encoding: u32 = 0xE480A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_e480a3c0() {
    // Encoding: 0xE480A3C0
    // Test ST1H_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xE480A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_rn_31_max_a000_e480a3e0() {
    // Encoding: 0xE480A3E0
    // Test ST1H_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE480A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zt_0_min_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_e480a001() {
    // Encoding: 0xE480A001
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xE480A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_e480a01e() {
    // Encoding: 0xE480A01E
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xE480A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_field_zt_31_max_a000_e480a01f() {
    // Encoding: 0xE480A01F
    // Test ST1H_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE480A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_combo_0_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e480a3e0() {
    // Encoding: 0xE480A3E0
    // Test ST1H_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE480A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_invalid_0_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_invalid_1_a000_e480a000() {
    // Encoding: 0xE480A000
    // Test ST1H_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE480A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_sp_rn_e4e083e0() {
    // Test ST1H_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0xE4E083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4E083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_S.x32.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bz_s_x32_scaled_store_0_e4e08020() {
    // Test ST1H_Z.P.BZ_S.x32.scaled memory store: 8 bytes
    // Encoding: 0xE4E08020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4E08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_sp_rn_e4a083e0() {
    // Test ST1H_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xE4A083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4A083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.x32.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bz_d_x32_scaled_store_0_e4a08020() {
    // Test ST1H_Z.P.BZ_D.x32.scaled memory store: 8 bytes
    // Encoding: 0xE4A08020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4A08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_sp_rn_e48083e0() {
    // Test ST1H_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE48083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE48083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bz_d_x32_unscaled_store_0_e4808020() {
    // Test ST1H_Z.P.BZ_D.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE4808020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_sp_rn_e4c083e0() {
    // Test ST1H_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE4C083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4C083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_S.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bz_s_x32_unscaled_store_0_e4c08020() {
    // Test ST1H_Z.P.BZ_S.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE4C08020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4C08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bz_d_64_scaled_sp_rn_e4a0a3e0() {
    // Test ST1H_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xE4A0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4A0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.64.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bz_d_64_scaled_store_0_e4a0a020() {
    // Test ST1H_Z.P.BZ_D.64.scaled memory store: 8 bytes
    // Encoding: 0xE4A0A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4A0A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_sp_rn_e480a3e0() {
    // Test ST1H_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xE480A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE480A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BZ_D.64.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bz_d_64_unscaled_store_0_e480a020() {
    // Test ST1H_Z.P.BZ_D.64.unscaled memory store: 8 bytes
    // Encoding: 0xE480A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE480A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_br_contiguous_field_rm_0_min_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5a16000() {
    // Encoding: 0xE5A16000
    // Test ST2D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2d_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e5be6000() {
    // Encoding: 0xE5BE6000
    // Test ST2D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Zt=0, Pg=0
    let encoding: u32 = 0xE5BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st2d_z_p_br_contiguous_field_rm_31_max_6000_e5bf6000() {
    // Encoding: 0xE5BF6000
    // Test ST2D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Rn=0, Zt=0
    let encoding: u32 = 0xE5BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_br_contiguous_field_pg_0_min_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5a06400() {
    // Encoding: 0xE5A06400
    // Test ST2D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_br_contiguous_field_rn_0_min_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5a06020() {
    // Encoding: 0xE5A06020
    // Test ST2D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Rm=0, Zt=0
    let encoding: u32 = 0xE5A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2d_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e5a063c0() {
    // Encoding: 0xE5A063C0
    // Test ST2D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Rm=0
    let encoding: u32 = 0xE5A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2d_z_p_br_contiguous_field_rn_31_max_6000_e5a063e0() {
    // Encoding: 0xE5A063E0
    // Test ST2D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xE5A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2d_z_p_br_contiguous_field_zt_0_min_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2d_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5a06001() {
    // Encoding: 0xE5A06001
    // Test ST2D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2d_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e5a0601e() {
    // Encoding: 0xE5A0601E
    // Test ST2D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xE5A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2d_z_p_br_contiguous_field_zt_31_max_6000_e5a0601f() {
    // Encoding: 0xE5A0601F
    // Test ST2D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE5A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st2d_z_p_br_contiguous_combo_0_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e5a063e0() {
    // Encoding: 0xE5A063E0
    // Test ST2D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_br_contiguous_invalid_0_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_br_contiguous_invalid_1_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_br_contiguous_invalid_2_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_br_contiguous_invalid_3_6000_e5a06000() {
    // Encoding: 0xE5A06000
    // Test ST2D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2d_z_p_br_contiguous_sp_rn_e5a063e0() {
    // Test ST2D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE5A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2D_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2d_z_p_br_contiguous_store_0_e5a06020() {
    // Test ST2D_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5A06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE5A06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_0_zero_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e4f1e000() {
    // Encoding: 0xE4F1E000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=1, Zt=0
    let encoding: u32 = 0xE4F1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e4f3e000() {
    // Encoding: 0xE4F3E000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xE4F3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e4f4e000() {
    // Encoding: 0xE4F4E000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=4, Zt=0
    let encoding: u32 = 0xE4F4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e4f7e000() {
    // Encoding: 0xE4F7E000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, imm4=7, Pg=0
    let encoding: u32 = 0xE4F7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e4f8e000() {
    // Encoding: 0xE4F8E000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, imm4=8, Zt=0
    let encoding: u32 = 0xE4F8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st4h_z_p_bi_contiguous_field_imm4_15_max_e000_e4ffe000() {
    // Encoding: 0xE4FFE000
    // Test ST4H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=15
    let encoding: u32 = 0xE4FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_bi_contiguous_field_pg_0_min_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e4f0e400() {
    // Encoding: 0xE4F0E400
    // Test ST4H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_bi_contiguous_field_rn_0_min_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e4f0e020() {
    // Encoding: 0xE4F0E020
    // Test ST4H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, imm4=0, Zt=0
    let encoding: u32 = 0xE4F0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e4f0e3c0() {
    // Encoding: 0xE4F0E3C0
    // Test ST4H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xE4F0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4h_z_p_bi_contiguous_field_rn_31_max_e000_e4f0e3e0() {
    // Encoding: 0xE4F0E3E0
    // Test ST4H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xE4F0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4h_z_p_bi_contiguous_field_zt_0_min_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e4f0e001() {
    // Encoding: 0xE4F0E001
    // Test ST4H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, imm4=0
    let encoding: u32 = 0xE4F0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e4f0e01e() {
    // Encoding: 0xE4F0E01E
    // Test ST4H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xE4F0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4h_z_p_bi_contiguous_field_zt_31_max_e000_e4f0e01f() {
    // Encoding: 0xE4F0E01F
    // Test ST4H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, imm4=0
    let encoding: u32 = 0xE4F0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st4h_z_p_bi_contiguous_combo_0_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e4f0e3e0() {
    // Encoding: 0xE4F0E3E0
    // Test ST4H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4F0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_bi_contiguous_invalid_0_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_bi_contiguous_invalid_1_e000_e4f0e000() {
    // Encoding: 0xE4F0E000
    // Test ST4H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE4F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4h_z_p_bi_contiguous_sp_rn_e4f0e3e0() {
    // Test ST4H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE4F0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4F0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4H_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4h_z_p_bi_contiguous_store_0_e4f0e020() {
    // Test ST4H_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE4F0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4F0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_br_contiguous_field_rm_0_min_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4c16000() {
    // Encoding: 0xE4C16000
    // Test ST3H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=1, Rn=0, Zt=0
    let encoding: u32 = 0xE4C16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3h_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e4de6000() {
    // Encoding: 0xE4DE6000
    // Test ST3H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=30, Pg=0, Rn=0
    let encoding: u32 = 0xE4DE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st3h_z_p_br_contiguous_field_rm_31_max_6000_e4df6000() {
    // Encoding: 0xE4DF6000
    // Test ST3H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=31, Rn=0
    let encoding: u32 = 0xE4DF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_br_contiguous_field_pg_0_min_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4c06400() {
    // Encoding: 0xE4C06400
    // Test ST3H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=1, Rn=0
    let encoding: u32 = 0xE4C06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_br_contiguous_field_rn_0_min_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4c06020() {
    // Encoding: 0xE4C06020
    // Test ST3H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Rm=0, Pg=0
    let encoding: u32 = 0xE4C06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3h_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e4c063c0() {
    // Encoding: 0xE4C063C0
    // Test ST3H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4C063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3h_z_p_br_contiguous_field_rn_31_max_6000_e4c063e0() {
    // Encoding: 0xE4C063E0
    // Test ST3H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE4C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3h_z_p_br_contiguous_field_zt_0_min_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3h_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4c06001() {
    // Encoding: 0xE4C06001
    // Test ST3H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xE4C06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3h_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e4c0601e() {
    // Encoding: 0xE4C0601E
    // Test ST3H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=30
    let encoding: u32 = 0xE4C0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3h_z_p_br_contiguous_field_zt_31_max_6000_e4c0601f() {
    // Encoding: 0xE4C0601F
    // Test ST3H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xE4C0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st3h_z_p_br_contiguous_combo_0_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e4c063e0() {
    // Encoding: 0xE4C063E0
    // Test ST3H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xE4C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_br_contiguous_invalid_0_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_br_contiguous_invalid_1_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_br_contiguous_invalid_2_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_br_contiguous_invalid_3_6000_e4c06000() {
    // Encoding: 0xE4C06000
    // Test ST3H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, Rm=0
    let encoding: u32 = 0xE4C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3h_z_p_br_contiguous_sp_rn_e4c063e0() {
    // Test ST3H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE4C063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4C063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3H_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3h_z_p_br_contiguous_store_0_e4c06020() {
    // Test ST3H_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4C06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4C06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1H_Z.P.BI__ Tests
// ============================================================================

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1h_z_p_bi_field_size_0_min_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ field size = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, size=0, Pg=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1h_z_p_bi_field_size_1_poweroftwo_e000_e4a0e000() {
    // Encoding: 0xE4A0E000
    // Test ST1H_Z.P.BI__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, imm4=0, size=1, Rn=0
    let encoding: u32 = 0xE4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1h_z_p_bi_field_size_2_poweroftwo_e000_e4c0e000() {
    // Encoding: 0xE4C0E000
    // Test ST1H_Z.P.BI__ field size = 2 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0, size=2
    let encoding: u32 = 0xE4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1h_z_p_bi_field_size_3_max_e000_e4e0e000() {
    // Encoding: 0xE4E0E000
    // Test ST1H_Z.P.BI__ field size = 3 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0, size=3
    let encoding: u32 = 0xE4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1h_z_p_bi_field_imm4_0_zero_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ field imm4 = 0 (Zero)
    // Fields: Pg=0, size=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1h_z_p_bi_field_imm4_1_poweroftwo_e000_e481e000() {
    // Encoding: 0xE481E000
    // Test ST1H_Z.P.BI__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, size=0, Rn=0
    let encoding: u32 = 0xE481E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1h_z_p_bi_field_imm4_3_poweroftwominusone_e000_e483e000() {
    // Encoding: 0xE483E000
    // Test ST1H_Z.P.BI__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=3, Rn=0, size=0
    let encoding: u32 = 0xE483E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1h_z_p_bi_field_imm4_4_poweroftwo_e000_e484e000() {
    // Encoding: 0xE484E000
    // Test ST1H_Z.P.BI__ field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, size=0, imm4=4, Zt=0
    let encoding: u32 = 0xE484E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st1h_z_p_bi_field_imm4_7_poweroftwominusone_e000_e487e000() {
    // Encoding: 0xE487E000
    // Test ST1H_Z.P.BI__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=0, Pg=0, Zt=0, imm4=7
    let encoding: u32 = 0xE487E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1h_z_p_bi_field_imm4_8_poweroftwo_e000_e488e000() {
    // Encoding: 0xE488E000
    // Test ST1H_Z.P.BI__ field imm4 = 8 (PowerOfTwo)
    // Fields: size=0, imm4=8, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE488E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st1h_z_p_bi_field_imm4_15_max_e000_e48fe000() {
    // Encoding: 0xE48FE000
    // Test ST1H_Z.P.BI__ field imm4 = 15 (Max)
    // Fields: Rn=0, imm4=15, Pg=0, Zt=0, size=0
    let encoding: u32 = 0xE48FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bi_field_pg_0_min_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bi_field_pg_1_poweroftwo_e000_e480e400() {
    // Encoding: 0xE480E400
    // Test ST1H_Z.P.BI__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE480E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_bi_field_rn_0_min_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ field Rn = 0 (Min)
    // Fields: imm4=0, size=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_bi_field_rn_1_poweroftwo_e000_e480e020() {
    // Encoding: 0xE480E020
    // Test ST1H_Z.P.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: size=0, imm4=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xE480E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_bi_field_rn_30_poweroftwominusone_e000_e480e3c0() {
    // Encoding: 0xE480E3C0
    // Test ST1H_Z.P.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, size=0, imm4=0
    let encoding: u32 = 0xE480E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_bi_field_rn_31_max_e000_e480e3e0() {
    // Encoding: 0xE480E3E0
    // Test ST1H_Z.P.BI__ field Rn = 31 (Max)
    // Fields: imm4=0, size=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xE480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_bi_field_zt_0_min_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ field Zt = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, size=0, Zt=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_bi_field_zt_1_poweroftwo_e000_e480e001() {
    // Encoding: 0xE480E001
    // Test ST1H_Z.P.BI__ field Zt = 1 (PowerOfTwo)
    // Fields: size=0, imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xE480E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_bi_field_zt_30_poweroftwominusone_e000_e480e01e() {
    // Encoding: 0xE480E01E
    // Test ST1H_Z.P.BI__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zt=30, imm4=0, Rn=0
    let encoding: u32 = 0xE480E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_bi_field_zt_31_max_e000_e480e01f() {
    // Encoding: 0xE480E01F
    // Test ST1H_Z.P.BI__ field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Zt=31, size=0, Rn=0
    let encoding: u32 = 0xE480E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1h_z_p_bi_combo_0_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ field combination: size=0, imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: size=0, Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1h_z_p_bi_special_size_0_size_variant_0_57344_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ special value size = 0 (Size variant 0)
    // Fields: imm4=0, Rn=0, Zt=0, size=0, Pg=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1h_z_p_bi_special_size_1_size_variant_1_57344_e4a0e000() {
    // Encoding: 0xE4A0E000
    // Test ST1H_Z.P.BI__ special value size = 1 (Size variant 1)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0, size=1
    let encoding: u32 = 0xE4A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1h_z_p_bi_special_size_2_size_variant_2_57344_e4c0e000() {
    // Encoding: 0xE4C0E000
    // Test ST1H_Z.P.BI__ special value size = 2 (Size variant 2)
    // Fields: Rn=0, Pg=0, size=2, imm4=0, Zt=0
    let encoding: u32 = 0xE4C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1h_z_p_bi_special_size_3_size_variant_3_57344_e4e0e000() {
    // Encoding: 0xE4E0E000
    // Test ST1H_Z.P.BI__ special value size = 3 (Size variant 3)
    // Fields: size=3, imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_bi_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e480e3e0() {
    // Encoding: 0xE480E3E0
    // Test ST1H_Z.P.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rn=31, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE480E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bi_invalid_0_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bi_invalid_1_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0, size=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bi_invalid_2_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_bi_invalid_3_e000_e480e000() {
    // Encoding: 0xE480E000
    // Test ST1H_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, size=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_bi_sp_rn_e480e3e0() {
    // Test ST1H_Z.P.BI__ with Rn = SP (31)
    // Encoding: 0xE480E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE480E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BI__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_bi_store_0_e480e020() {
    // Test ST1H_Z.P.BI__ memory store: 8 bytes
    // Encoding: 0xE480E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE480E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STR_Z.BI__ Tests
// ============================================================================

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_str_z_bi_field_imm9h_0_zero_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ field imm9h = 0 (Zero)
    // Fields: Rn=0, imm9h=0, imm9l=0, Zt=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_str_z_bi_field_imm9h_1_poweroftwo_4000_e5814000() {
    // Encoding: 0xE5814000
    // Test STR_Z.BI__ field imm9h = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm9h=1, imm9l=0
    let encoding: u32 = 0xE5814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_str_z_bi_field_imm9h_3_poweroftwominusone_4000_e5834000() {
    // Encoding: 0xE5834000
    // Test STR_Z.BI__ field imm9h = 3 (PowerOfTwoMinusOne)
    // Fields: imm9h=3, Zt=0, imm9l=0, Rn=0
    let encoding: u32 = 0xE5834000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_str_z_bi_field_imm9h_4_poweroftwo_4000_e5844000() {
    // Encoding: 0xE5844000
    // Test STR_Z.BI__ field imm9h = 4 (PowerOfTwo)
    // Fields: imm9h=4, imm9l=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5844000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_str_z_bi_field_imm9h_7_poweroftwominusone_4000_e5874000() {
    // Encoding: 0xE5874000
    // Test STR_Z.BI__ field imm9h = 7 (PowerOfTwoMinusOne)
    // Fields: imm9h=7, imm9l=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5874000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_str_z_bi_field_imm9h_8_poweroftwo_4000_e5884000() {
    // Encoding: 0xE5884000
    // Test STR_Z.BI__ field imm9h = 8 (PowerOfTwo)
    // Fields: imm9h=8, Zt=0, Rn=0, imm9l=0
    let encoding: u32 = 0xE5884000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_str_z_bi_field_imm9h_15_poweroftwominusone_4000_e58f4000() {
    // Encoding: 0xE58F4000
    // Test STR_Z.BI__ field imm9h = 15 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm9h=15, imm9l=0, Zt=0
    let encoding: u32 = 0xE58F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_str_z_bi_field_imm9h_16_poweroftwo_4000_e5904000() {
    // Encoding: 0xE5904000
    // Test STR_Z.BI__ field imm9h = 16 (PowerOfTwo)
    // Fields: imm9h=16, Zt=0, Rn=0, imm9l=0
    let encoding: u32 = 0xE5904000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_str_z_bi_field_imm9h_31_poweroftwominusone_4000_e59f4000() {
    // Encoding: 0xE59F4000
    // Test STR_Z.BI__ field imm9h = 31 (PowerOfTwoMinusOne)
    // Fields: imm9h=31, imm9l=0, Rn=0, Zt=0
    let encoding: u32 = 0xE59F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_str_z_bi_field_imm9h_32_poweroftwo_4000_e5a04000() {
    // Encoding: 0xE5A04000
    // Test STR_Z.BI__ field imm9h = 32 (PowerOfTwo)
    // Fields: imm9l=0, Zt=0, Rn=0, imm9h=32
    let encoding: u32 = 0xE5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_str_z_bi_field_imm9h_63_max_4000_e5bf4000() {
    // Encoding: 0xE5BF4000
    // Test STR_Z.BI__ field imm9h = 63 (Max)
    // Fields: Zt=0, imm9h=63, Rn=0, imm9l=0
    let encoding: u32 = 0xE5BF4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_str_z_bi_field_imm9l_0_zero_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ field imm9l = 0 (Zero)
    // Fields: imm9l=0, imm9h=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_str_z_bi_field_imm9l_1_poweroftwo_4000_e5804400() {
    // Encoding: 0xE5804400
    // Test STR_Z.BI__ field imm9l = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm9h=0, imm9l=1
    let encoding: u32 = 0xE5804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_str_z_bi_field_imm9l_3_poweroftwominusone_4000_e5804c00() {
    // Encoding: 0xE5804C00
    // Test STR_Z.BI__ field imm9l = 3 (PowerOfTwoMinusOne)
    // Fields: imm9h=0, imm9l=3, Zt=0, Rn=0
    let encoding: u32 = 0xE5804C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_str_z_bi_field_imm9l_7_max_4000_e5805c00() {
    // Encoding: 0xE5805C00
    // Test STR_Z.BI__ field imm9l = 7 (Max)
    // Fields: imm9h=0, imm9l=7, Zt=0, Rn=0
    let encoding: u32 = 0xE5805C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_str_z_bi_field_rn_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ field Rn = 0 (Min)
    // Fields: imm9h=0, Rn=0, Zt=0, imm9l=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_str_z_bi_field_rn_1_poweroftwo_4000_e5804020() {
    // Encoding: 0xE5804020
    // Test STR_Z.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: imm9h=0, Rn=1, imm9l=0, Zt=0
    let encoding: u32 = 0xE5804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_str_z_bi_field_rn_30_poweroftwominusone_4000_e58043c0() {
    // Encoding: 0xE58043C0
    // Test STR_Z.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Zt=0, imm9h=0, Rn=30
    let encoding: u32 = 0xE58043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_str_z_bi_field_rn_31_max_4000_e58043e0() {
    // Encoding: 0xE58043E0
    // Test STR_Z.BI__ field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, imm9h=0, imm9l=0
    let encoding: u32 = 0xE58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_str_z_bi_field_zt_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ field Zt = 0 (Min)
    // Fields: Zt=0, imm9l=0, imm9h=0, Rn=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_str_z_bi_field_zt_1_poweroftwo_4000_e5804001() {
    // Encoding: 0xE5804001
    // Test STR_Z.BI__ field Zt = 1 (PowerOfTwo)
    // Fields: imm9l=0, Zt=1, imm9h=0, Rn=0
    let encoding: u32 = 0xE5804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_str_z_bi_field_zt_30_poweroftwominusone_4000_e580401e() {
    // Encoding: 0xE580401E
    // Test STR_Z.BI__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Rn=0, imm9h=0, Zt=30
    let encoding: u32 = 0xE580401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_str_z_bi_field_zt_31_max_4000_e580401f() {
    // Encoding: 0xE580401F
    // Test STR_Z.BI__ field Zt = 31 (Max)
    // Fields: Rn=0, imm9l=0, Zt=31, imm9h=0
    let encoding: u32 = 0xE580401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm9h=0 (immediate value 0)
#[test]
fn test_str_z_bi_combo_0_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ field combination: imm9h=0, imm9l=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm9l=0, imm9h=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_str_z_bi_special_rn_31_stack_pointer_sp_may_require_alignment_16384_e58043e0() {
    // Encoding: 0xE58043E0
    // Test STR_Z.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, imm9l=0, imm9h=0, Rn=31
    let encoding: u32 = 0xE58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_str_z_bi_invalid_0_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm9l=0, Rn=0, Zt=0, imm9h=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_str_z_bi_invalid_1_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test STR_Z.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm9h=0, Rn=0, Zt=0, imm9l=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STR_Z.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_str_z_bi_sp_rn_e58043e0() {
    // Test STR_Z.BI__ with Rn = SP (31)
    // Encoding: 0xE58043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE58043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_0_zero_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e431e000() {
    // Encoding: 0xE431E000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=1
    let encoding: u32 = 0xE431E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e433e000() {
    // Encoding: 0xE433E000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, imm4=3, Zt=0
    let encoding: u32 = 0xE433E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e434e000() {
    // Encoding: 0xE434E000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE434E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e437e000() {
    // Encoding: 0xE437E000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xE437E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e438e000() {
    // Encoding: 0xE438E000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE438E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st2b_z_p_bi_contiguous_field_imm4_15_max_e000_e43fe000() {
    // Encoding: 0xE43FE000
    // Test ST2B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE43FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2b_z_p_bi_contiguous_field_pg_0_min_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e430e400() {
    // Encoding: 0xE430E400
    // Test ST2B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xE430E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2b_z_p_bi_contiguous_field_rn_0_min_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e430e020() {
    // Encoding: 0xE430E020
    // Test ST2B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Rn=1, Pg=0
    let encoding: u32 = 0xE430E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e430e3c0() {
    // Encoding: 0xE430E3C0
    // Test ST2B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=30
    let encoding: u32 = 0xE430E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2b_z_p_bi_contiguous_field_rn_31_max_e000_e430e3e0() {
    // Encoding: 0xE430E3E0
    // Test ST2B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xE430E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2b_z_p_bi_contiguous_field_zt_0_min_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e430e001() {
    // Encoding: 0xE430E001
    // Test ST2B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE430E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e430e01e() {
    // Encoding: 0xE430E01E
    // Test ST2B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=30
    let encoding: u32 = 0xE430E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2b_z_p_bi_contiguous_field_zt_31_max_e000_e430e01f() {
    // Encoding: 0xE430E01F
    // Test ST2B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Pg=0, imm4=0
    let encoding: u32 = 0xE430E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st2b_z_p_bi_contiguous_combo_0_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e430e3e0() {
    // Encoding: 0xE430E3E0
    // Test ST2B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE430E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2b_z_p_bi_contiguous_invalid_0_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2b_z_p_bi_contiguous_invalid_1_e000_e430e000() {
    // Encoding: 0xE430E000
    // Test ST2B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE430E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2b_z_p_bi_contiguous_sp_rn_e430e3e0() {
    // Test ST2B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE430E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE430E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2B_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2b_z_p_bi_contiguous_store_0_e430e020() {
    // Test ST2B_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE430E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE430E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1B_Z.P.BI__ Tests
// ============================================================================

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1b_z_p_bi_field_size_0_min_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ field size = 0 (Min)
    // Fields: size=0, Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1b_z_p_bi_field_size_1_poweroftwo_e000_e420e000() {
    // Encoding: 0xE420E000
    // Test ST1B_Z.P.BI__ field size = 1 (PowerOfTwo)
    // Fields: Zt=0, size=1, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1b_z_p_bi_field_size_2_poweroftwo_e000_e440e000() {
    // Encoding: 0xE440E000
    // Test ST1B_Z.P.BI__ field size = 2 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, size=2, Pg=0, Zt=0
    let encoding: u32 = 0xE440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1b_z_p_bi_field_size_3_max_e000_e460e000() {
    // Encoding: 0xE460E000
    // Test ST1B_Z.P.BI__ field size = 3 (Max)
    // Fields: Pg=0, size=3, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1b_z_p_bi_field_imm4_0_zero_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0, size=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1b_z_p_bi_field_imm4_1_poweroftwo_e000_e401e000() {
    // Encoding: 0xE401E000
    // Test ST1B_Z.P.BI__ field imm4 = 1 (PowerOfTwo)
    // Fields: size=0, Zt=0, imm4=1, Pg=0, Rn=0
    let encoding: u32 = 0xE401E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1b_z_p_bi_field_imm4_3_poweroftwominusone_e000_e403e000() {
    // Encoding: 0xE403E000
    // Test ST1B_Z.P.BI__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, size=0, Zt=0, Rn=0
    let encoding: u32 = 0xE403E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1b_z_p_bi_field_imm4_4_poweroftwo_e000_e404e000() {
    // Encoding: 0xE404E000
    // Test ST1B_Z.P.BI__ field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=4, size=0
    let encoding: u32 = 0xE404E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st1b_z_p_bi_field_imm4_7_poweroftwominusone_e000_e407e000() {
    // Encoding: 0xE407E000
    // Test ST1B_Z.P.BI__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0, size=0
    let encoding: u32 = 0xE407E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1b_z_p_bi_field_imm4_8_poweroftwo_e000_e408e000() {
    // Encoding: 0xE408E000
    // Test ST1B_Z.P.BI__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, size=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE408E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st1b_z_p_bi_field_imm4_15_max_e000_e40fe000() {
    // Encoding: 0xE40FE000
    // Test ST1B_Z.P.BI__ field imm4 = 15 (Max)
    // Fields: Zt=0, Pg=0, size=0, imm4=15, Rn=0
    let encoding: u32 = 0xE40FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bi_field_pg_0_min_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, size=0, Zt=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bi_field_pg_1_poweroftwo_e000_e400e400() {
    // Encoding: 0xE400E400
    // Test ST1B_Z.P.BI__ field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=1, size=0, imm4=0, Rn=0
    let encoding: u32 = 0xE400E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bi_field_rn_0_min_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, size=0, imm4=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bi_field_rn_1_poweroftwo_e000_e400e020() {
    // Encoding: 0xE400E020
    // Test ST1B_Z.P.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=1, size=0, imm4=0
    let encoding: u32 = 0xE400E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1b_z_p_bi_field_rn_30_poweroftwominusone_e000_e400e3c0() {
    // Encoding: 0xE400E3C0
    // Test ST1B_Z.P.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Pg=0, imm4=0, size=0
    let encoding: u32 = 0xE400E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1b_z_p_bi_field_rn_31_max_e000_e400e3e0() {
    // Encoding: 0xE400E3E0
    // Test ST1B_Z.P.BI__ field Rn = 31 (Max)
    // Fields: imm4=0, Rn=31, Zt=0, size=0, Pg=0
    let encoding: u32 = 0xE400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bi_field_zt_0_min_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0, size=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bi_field_zt_1_poweroftwo_e000_e400e001() {
    // Encoding: 0xE400E001
    // Test ST1B_Z.P.BI__ field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, imm4=0, Zt=1, Rn=0
    let encoding: u32 = 0xE400E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bi_field_zt_30_poweroftwominusone_e000_e400e01e() {
    // Encoding: 0xE400E01E
    // Test ST1B_Z.P.BI__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, size=0, Zt=30, Rn=0, Pg=0
    let encoding: u32 = 0xE400E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bi_field_zt_31_max_e000_e400e01f() {
    // Encoding: 0xE400E01F
    // Test ST1B_Z.P.BI__ field Zt = 31 (Max)
    // Fields: Pg=0, size=0, imm4=0, Rn=0, Zt=31
    let encoding: u32 = 0xE400E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1b_z_p_bi_combo_0_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ field combination: size=0, imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, size=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1b_z_p_bi_special_size_0_size_variant_0_57344_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1b_z_p_bi_special_size_1_size_variant_1_57344_e420e000() {
    // Encoding: 0xE420E000
    // Test ST1B_Z.P.BI__ special value size = 1 (Size variant 1)
    // Fields: imm4=0, Rn=0, Pg=0, size=1, Zt=0
    let encoding: u32 = 0xE420E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1b_z_p_bi_special_size_2_size_variant_2_57344_e440e000() {
    // Encoding: 0xE440E000
    // Test ST1B_Z.P.BI__ special value size = 2 (Size variant 2)
    // Fields: imm4=0, Pg=0, Zt=0, size=2, Rn=0
    let encoding: u32 = 0xE440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1b_z_p_bi_special_size_3_size_variant_3_57344_e460e000() {
    // Encoding: 0xE460E000
    // Test ST1B_Z.P.BI__ special value size = 3 (Size variant 3)
    // Fields: Rn=0, Pg=0, Zt=0, size=3, imm4=0
    let encoding: u32 = 0xE460E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1b_z_p_bi_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e400e3e0() {
    // Encoding: 0xE400E3E0
    // Test ST1B_Z.P.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, size=0, imm4=0, Rn=31
    let encoding: u32 = 0xE400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bi_invalid_0_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0, size=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bi_invalid_1_e000_e400e000() {
    // Encoding: 0xE400E000
    // Test ST1B_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1b_z_p_bi_sp_rn_e400e3e0() {
    // Test ST1B_Z.P.BI__ with Rn = SP (31)
    // Encoding: 0xE400E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE400E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BI__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_bi_store_0_e400e020() {
    // Test ST1B_Z.P.BI__ memory store: 8 bytes
    // Encoding: 0xE400E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE400E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4w_z_p_br_contiguous_field_rm_0_min_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4w_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5616000() {
    // Encoding: 0xE5616000
    // Test ST4W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5616000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4w_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e57e6000() {
    // Encoding: 0xE57E6000
    // Test ST4W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Rm=30, Zt=0
    let encoding: u32 = 0xE57E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st4w_z_p_br_contiguous_field_rm_31_max_6000_e57f6000() {
    // Encoding: 0xE57F6000
    // Test ST4W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE57F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4w_z_p_br_contiguous_field_pg_0_min_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4w_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5606400() {
    // Encoding: 0xE5606400
    // Test ST4W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xE5606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4w_z_p_br_contiguous_field_rn_0_min_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4w_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5606020() {
    // Encoding: 0xE5606020
    // Test ST4W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xE5606020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4w_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e56063c0() {
    // Encoding: 0xE56063C0
    // Test ST4W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30
    let encoding: u32 = 0xE56063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4w_z_p_br_contiguous_field_rn_31_max_6000_e56063e0() {
    // Encoding: 0xE56063E0
    // Test ST4W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE56063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4w_z_p_br_contiguous_field_zt_0_min_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4w_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5606001() {
    // Encoding: 0xE5606001
    // Test ST4W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5606001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4w_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e560601e() {
    // Encoding: 0xE560601E
    // Test ST4W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=30
    let encoding: u32 = 0xE560601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4w_z_p_br_contiguous_field_zt_31_max_6000_e560601f() {
    // Encoding: 0xE560601F
    // Test ST4W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xE560601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st4w_z_p_br_contiguous_combo_0_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e56063e0() {
    // Encoding: 0xE56063E0
    // Test ST4W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE56063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4w_z_p_br_contiguous_invalid_0_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4w_z_p_br_contiguous_invalid_1_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st4w_z_p_br_contiguous_invalid_2_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4w_z_p_br_contiguous_invalid_3_6000_e5606000() {
    // Encoding: 0xE5606000
    // Test ST4W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4w_z_p_br_contiguous_sp_rn_e56063e0() {
    // Test ST4W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE56063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE56063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4W_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4w_z_p_br_contiguous_store_0_e5606020() {
    // Test ST4W_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5606020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5606020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_0_zero_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e551e000() {
    // Encoding: 0xE551E000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=1, Pg=0, Rn=0
    let encoding: u32 = 0xE551E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e553e000() {
    // Encoding: 0xE553E000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE553E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e554e000() {
    // Encoding: 0xE554E000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Rn=0, Zt=0
    let encoding: u32 = 0xE554E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e557e000() {
    // Encoding: 0xE557E000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=7, Rn=0, Zt=0
    let encoding: u32 = 0xE557E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e558e000() {
    // Encoding: 0xE558E000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, imm4=8, Pg=0
    let encoding: u32 = 0xE558E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st3w_z_p_bi_contiguous_field_imm4_15_max_e000_e55fe000() {
    // Encoding: 0xE55FE000
    // Test ST3W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE55FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3w_z_p_bi_contiguous_field_pg_0_min_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e550e400() {
    // Encoding: 0xE550E400
    // Test ST3W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xE550E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3w_z_p_bi_contiguous_field_rn_0_min_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e550e020() {
    // Encoding: 0xE550E020
    // Test ST3W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Rn=1, Zt=0
    let encoding: u32 = 0xE550E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e550e3c0() {
    // Encoding: 0xE550E3C0
    // Test ST3W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xE550E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3w_z_p_bi_contiguous_field_rn_31_max_e000_e550e3e0() {
    // Encoding: 0xE550E3E0
    // Test ST3W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, imm4=0
    let encoding: u32 = 0xE550E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3w_z_p_bi_contiguous_field_zt_0_min_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e550e001() {
    // Encoding: 0xE550E001
    // Test ST3W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xE550E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e550e01e() {
    // Encoding: 0xE550E01E
    // Test ST3W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, imm4=0
    let encoding: u32 = 0xE550E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3w_z_p_bi_contiguous_field_zt_31_max_e000_e550e01f() {
    // Encoding: 0xE550E01F
    // Test ST3W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xE550E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st3w_z_p_bi_contiguous_combo_0_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e550e3e0() {
    // Encoding: 0xE550E3E0
    // Test ST3W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE550E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3w_z_p_bi_contiguous_invalid_0_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3w_z_p_bi_contiguous_invalid_1_e000_e550e000() {
    // Encoding: 0xE550E000
    // Test ST3W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE550E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3w_z_p_bi_contiguous_sp_rn_e550e3e0() {
    // Test ST3W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE550E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE550E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3W_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3w_z_p_bi_contiguous_store_0_e550e020() {
    // Test ST3W_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE550E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE550E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rm_0_min_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5816000() {
    // Encoding: 0xE5816000
    // Test STNT1D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e59e6000() {
    // Encoding: 0xE59E6000
    // Test STNT1D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Zt=0, Pg=0
    let encoding: u32 = 0xE59E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rm_31_max_6000_e59f6000() {
    // Encoding: 0xE59F6000
    // Test STNT1D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rm=31, Pg=0, Rn=0
    let encoding: u32 = 0xE59F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_pg_0_min_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5806400() {
    // Encoding: 0xE5806400
    // Test STNT1D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rn_0_min_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5806020() {
    // Encoding: 0xE5806020
    // Test STNT1D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=1
    let encoding: u32 = 0xE5806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e58063c0() {
    // Encoding: 0xE58063C0
    // Test STNT1D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xE58063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1d_z_p_br_contiguous_field_rn_31_max_6000_e58063e0() {
    // Encoding: 0xE58063E0
    // Test STNT1D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE58063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1d_z_p_br_contiguous_field_zt_0_min_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1d_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5806001() {
    // Encoding: 0xE5806001
    // Test STNT1D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xE5806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1d_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e580601e() {
    // Encoding: 0xE580601E
    // Test STNT1D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xE580601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1d_z_p_br_contiguous_field_zt_31_max_6000_e580601f() {
    // Encoding: 0xE580601F
    // Test STNT1D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xE580601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_stnt1d_z_p_br_contiguous_combo_0_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e58063e0() {
    // Encoding: 0xE58063E0
    // Test STNT1D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE58063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1d_z_p_br_contiguous_invalid_0_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1d_z_p_br_contiguous_invalid_1_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_stnt1d_z_p_br_contiguous_invalid_2_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1d_z_p_br_contiguous_invalid_3_6000_e5806000() {
    // Encoding: 0xE5806000
    // Test STNT1D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1d_z_p_br_contiguous_sp_rn_e58063e0() {
    // Test STNT1D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE58063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE58063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1D_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1d_z_p_br_contiguous_store_0_e5806020() {
    // Test STNT1D_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5806020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE5806020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_0_zero_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e4b1e000() {
    // Encoding: 0xE4B1E000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4B1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e4b3e000() {
    // Encoding: 0xE4B3E000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm4=3, Rn=0
    let encoding: u32 = 0xE4B3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e4b4e000() {
    // Encoding: 0xE4B4E000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xE4B4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e4b7e000() {
    // Encoding: 0xE4B7E000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4B7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e4b8e000() {
    // Encoding: 0xE4B8E000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4B8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st2h_z_p_bi_contiguous_field_imm4_15_max_e000_e4bfe000() {
    // Encoding: 0xE4BFE000
    // Test ST2H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2h_z_p_bi_contiguous_field_pg_0_min_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e4b0e400() {
    // Encoding: 0xE4B0E400
    // Test ST2H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=1, imm4=0
    let encoding: u32 = 0xE4B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2h_z_p_bi_contiguous_field_rn_0_min_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e4b0e020() {
    // Encoding: 0xE4B0E020
    // Test ST2H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE4B0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e4b0e3c0() {
    // Encoding: 0xE4B0E3C0
    // Test ST2H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xE4B0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2h_z_p_bi_contiguous_field_rn_31_max_e000_e4b0e3e0() {
    // Encoding: 0xE4B0E3E0
    // Test ST2H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xE4B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2h_z_p_bi_contiguous_field_zt_0_min_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e4b0e001() {
    // Encoding: 0xE4B0E001
    // Test ST2H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xE4B0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e4b0e01e() {
    // Encoding: 0xE4B0E01E
    // Test ST2H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=30, imm4=0
    let encoding: u32 = 0xE4B0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2h_z_p_bi_contiguous_field_zt_31_max_e000_e4b0e01f() {
    // Encoding: 0xE4B0E01F
    // Test ST2H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE4B0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st2h_z_p_bi_contiguous_combo_0_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e4b0e3e0() {
    // Encoding: 0xE4B0E3E0
    // Test ST2H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE4B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2h_z_p_bi_contiguous_invalid_0_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2h_z_p_bi_contiguous_invalid_1_e000_e4b0e000() {
    // Encoding: 0xE4B0E000
    // Test ST2H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2h_z_p_bi_contiguous_sp_rn_e4b0e3e0() {
    // Test ST2H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE4B0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4B0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2H_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2h_z_p_bi_contiguous_store_0_e4b0e020() {
    // Test ST2H_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE4B0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4B0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rm_0_min_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5016000() {
    // Encoding: 0xE5016000
    // Test STNT1W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=1, Zt=0, Rn=0
    let encoding: u32 = 0xE5016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e51e6000() {
    // Encoding: 0xE51E6000
    // Test STNT1W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rm=30, Rn=0
    let encoding: u32 = 0xE51E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rm_31_max_6000_e51f6000() {
    // Encoding: 0xE51F6000
    // Test STNT1W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=31
    let encoding: u32 = 0xE51F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_pg_0_min_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5006400() {
    // Encoding: 0xE5006400
    // Test STNT1W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rn_0_min_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5006020() {
    // Encoding: 0xE5006020
    // Test STNT1W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e50063c0() {
    // Encoding: 0xE50063C0
    // Test STNT1W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, Rm=0
    let encoding: u32 = 0xE50063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1w_z_p_br_contiguous_field_rn_31_max_6000_e50063e0() {
    // Encoding: 0xE50063E0
    // Test STNT1W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE50063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1w_z_p_br_contiguous_field_zt_0_min_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1w_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5006001() {
    // Encoding: 0xE5006001
    // Test STNT1W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xE5006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1w_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e500601e() {
    // Encoding: 0xE500601E
    // Test STNT1W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=30, Rn=0
    let encoding: u32 = 0xE500601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1w_z_p_br_contiguous_field_zt_31_max_6000_e500601f() {
    // Encoding: 0xE500601F
    // Test STNT1W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, Rm=0
    let encoding: u32 = 0xE500601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_stnt1w_z_p_br_contiguous_combo_0_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e50063e0() {
    // Encoding: 0xE50063E0
    // Test STNT1W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=31
    let encoding: u32 = 0xE50063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1w_z_p_br_contiguous_invalid_0_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1w_z_p_br_contiguous_invalid_1_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_stnt1w_z_p_br_contiguous_invalid_2_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1w_z_p_br_contiguous_invalid_3_6000_e5006000() {
    // Encoding: 0xE5006000
    // Test STNT1W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1w_z_p_br_contiguous_sp_rn_e50063e0() {
    // Test STNT1W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE50063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE50063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1W_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1w_z_p_br_contiguous_store_0_e5006020() {
    // Test STNT1W_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5006020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5006020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4d_z_p_br_contiguous_field_rm_0_min_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4d_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5e16000() {
    // Encoding: 0xE5E16000
    // Test ST4D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=1
    let encoding: u32 = 0xE5E16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4d_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e5fe6000() {
    // Encoding: 0xE5FE6000
    // Test ST4D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=30
    let encoding: u32 = 0xE5FE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st4d_z_p_br_contiguous_field_rm_31_max_6000_e5ff6000() {
    // Encoding: 0xE5FF6000
    // Test ST4D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Zt=0, Rm=31, Pg=0
    let encoding: u32 = 0xE5FF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4d_z_p_br_contiguous_field_pg_0_min_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4d_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5e06400() {
    // Encoding: 0xE5E06400
    // Test ST4D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=1
    let encoding: u32 = 0xE5E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4d_z_p_br_contiguous_field_rn_0_min_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4d_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5e06020() {
    // Encoding: 0xE5E06020
    // Test ST4D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5E06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4d_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e5e063c0() {
    // Encoding: 0xE5E063C0
    // Test ST4D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5E063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4d_z_p_br_contiguous_field_rn_31_max_6000_e5e063e0() {
    // Encoding: 0xE5E063E0
    // Test ST4D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xE5E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4d_z_p_br_contiguous_field_zt_0_min_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4d_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5e06001() {
    // Encoding: 0xE5E06001
    // Test ST4D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5E06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4d_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e5e0601e() {
    // Encoding: 0xE5E0601E
    // Test ST4D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xE5E0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4d_z_p_br_contiguous_field_zt_31_max_6000_e5e0601f() {
    // Encoding: 0xE5E0601F
    // Test ST4D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xE5E0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st4d_z_p_br_contiguous_combo_0_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e5e063e0() {
    // Encoding: 0xE5E063E0
    // Test ST4D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Rn=31, Zt=0, Pg=0
    let encoding: u32 = 0xE5E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4d_z_p_br_contiguous_invalid_0_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4d_z_p_br_contiguous_invalid_1_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st4d_z_p_br_contiguous_invalid_2_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4d_z_p_br_contiguous_invalid_3_6000_e5e06000() {
    // Encoding: 0xE5E06000
    // Test ST4D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xE5E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4d_z_p_br_contiguous_sp_rn_e5e063e0() {
    // Test ST4D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE5E063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5E063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4D_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4d_z_p_br_contiguous_store_0_e5e06020() {
    // Test ST4D_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5E06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5E06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_0_zero_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e5d1e000() {
    // Encoding: 0xE5D1E000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=1, Pg=0, Rn=0
    let encoding: u32 = 0xE5D1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e5d3e000() {
    // Encoding: 0xE5D3E000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5D3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e5d4e000() {
    // Encoding: 0xE5D4E000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm4=4, Zt=0, Rn=0
    let encoding: u32 = 0xE5D4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e5d7e000() {
    // Encoding: 0xE5D7E000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xE5D7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e5d8e000() {
    // Encoding: 0xE5D8E000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=8, Pg=0
    let encoding: u32 = 0xE5D8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st3d_z_p_bi_contiguous_field_imm4_15_max_e000_e5dfe000() {
    // Encoding: 0xE5DFE000
    // Test ST3D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Pg=0, Rn=0
    let encoding: u32 = 0xE5DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3d_z_p_bi_contiguous_field_pg_0_min_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e5d0e400() {
    // Encoding: 0xE5D0E400
    // Test ST3D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xE5D0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3d_z_p_bi_contiguous_field_rn_0_min_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e5d0e020() {
    // Encoding: 0xE5D0E020
    // Test ST3D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=1, imm4=0
    let encoding: u32 = 0xE5D0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e5d0e3c0() {
    // Encoding: 0xE5D0E3C0
    // Test ST3D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE5D0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3d_z_p_bi_contiguous_field_rn_31_max_e000_e5d0e3e0() {
    // Encoding: 0xE5D0E3E0
    // Test ST3D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE5D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3d_z_p_bi_contiguous_field_zt_0_min_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e5d0e001() {
    // Encoding: 0xE5D0E001
    // Test ST3D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xE5D0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e5d0e01e() {
    // Encoding: 0xE5D0E01E
    // Test ST3D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5D0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3d_z_p_bi_contiguous_field_zt_31_max_e000_e5d0e01f() {
    // Encoding: 0xE5D0E01F
    // Test ST3D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, imm4=0, Pg=0
    let encoding: u32 = 0xE5D0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st3d_z_p_bi_contiguous_combo_0_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e5d0e3e0() {
    // Encoding: 0xE5D0E3E0
    // Test ST3D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3d_z_p_bi_contiguous_invalid_0_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3d_z_p_bi_contiguous_invalid_1_e000_e5d0e000() {
    // Encoding: 0xE5D0E000
    // Test ST3D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3d_z_p_bi_contiguous_sp_rn_e5d0e3e0() {
    // Test ST3D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE5D0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5D0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3D_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3d_z_p_bi_contiguous_store_0_e5d0e020() {
    // Test ST3D_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE5D0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5D0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STR_P.BI__ Tests
// ============================================================================

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_str_p_bi_field_imm9h_0_zero_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ field imm9h = 0 (Zero)
    // Fields: imm9h=0, Pt=0, Rn=0, imm9l=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_str_p_bi_field_imm9h_1_poweroftwo_0_e5810000() {
    // Encoding: 0xE5810000
    // Test STR_P.BI__ field imm9h = 1 (PowerOfTwo)
    // Fields: imm9h=1, Pt=0, imm9l=0, Rn=0
    let encoding: u32 = 0xE5810000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_str_p_bi_field_imm9h_3_poweroftwominusone_0_e5830000() {
    // Encoding: 0xE5830000
    // Test STR_P.BI__ field imm9h = 3 (PowerOfTwoMinusOne)
    // Fields: imm9h=3, Rn=0, imm9l=0, Pt=0
    let encoding: u32 = 0xE5830000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_str_p_bi_field_imm9h_4_poweroftwo_0_e5840000() {
    // Encoding: 0xE5840000
    // Test STR_P.BI__ field imm9h = 4 (PowerOfTwo)
    // Fields: imm9l=0, Pt=0, imm9h=4, Rn=0
    let encoding: u32 = 0xE5840000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_str_p_bi_field_imm9h_7_poweroftwominusone_0_e5870000() {
    // Encoding: 0xE5870000
    // Test STR_P.BI__ field imm9h = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pt=0, imm9l=0, imm9h=7
    let encoding: u32 = 0xE5870000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_str_p_bi_field_imm9h_8_poweroftwo_0_e5880000() {
    // Encoding: 0xE5880000
    // Test STR_P.BI__ field imm9h = 8 (PowerOfTwo)
    // Fields: Pt=0, imm9l=0, imm9h=8, Rn=0
    let encoding: u32 = 0xE5880000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_str_p_bi_field_imm9h_15_poweroftwominusone_0_e58f0000() {
    // Encoding: 0xE58F0000
    // Test STR_P.BI__ field imm9h = 15 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Rn=0, Pt=0, imm9h=15
    let encoding: u32 = 0xE58F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_str_p_bi_field_imm9h_16_poweroftwo_0_e5900000() {
    // Encoding: 0xE5900000
    // Test STR_P.BI__ field imm9h = 16 (PowerOfTwo)
    // Fields: Rn=0, Pt=0, imm9l=0, imm9h=16
    let encoding: u32 = 0xE5900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 31, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (31)
#[test]
fn test_str_p_bi_field_imm9h_31_poweroftwominusone_0_e59f0000() {
    // Encoding: 0xE59F0000
    // Test STR_P.BI__ field imm9h = 31 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, Rn=0, Pt=0, imm9h=31
    let encoding: u32 = 0xE59F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_str_p_bi_field_imm9h_32_poweroftwo_0_e5a00000() {
    // Encoding: 0xE5A00000
    // Test STR_P.BI__ field imm9h = 32 (PowerOfTwo)
    // Fields: imm9h=32, Pt=0, imm9l=0, Rn=0
    let encoding: u32 = 0xE5A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9h 16 +: 6`
/// Requirement: FieldBoundary { field: "imm9h", value: 63, boundary: Max }
/// maximum immediate (63)
#[test]
fn test_str_p_bi_field_imm9h_63_max_0_e5bf0000() {
    // Encoding: 0xE5BF0000
    // Test STR_P.BI__ field imm9h = 63 (Max)
    // Fields: Pt=0, Rn=0, imm9h=63, imm9l=0
    let encoding: u32 = 0xE5BF0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_str_p_bi_field_imm9l_0_zero_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ field imm9l = 0 (Zero)
    // Fields: imm9h=0, Pt=0, Rn=0, imm9l=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_str_p_bi_field_imm9l_1_poweroftwo_0_e5800400() {
    // Encoding: 0xE5800400
    // Test STR_P.BI__ field imm9l = 1 (PowerOfTwo)
    // Fields: Pt=0, imm9l=1, imm9h=0, Rn=0
    let encoding: u32 = 0xE5800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_str_p_bi_field_imm9l_3_poweroftwominusone_0_e5800c00() {
    // Encoding: 0xE5800C00
    // Test STR_P.BI__ field imm9l = 3 (PowerOfTwoMinusOne)
    // Fields: Pt=0, Rn=0, imm9h=0, imm9l=3
    let encoding: u32 = 0xE5800C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field imm9l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm9l", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_str_p_bi_field_imm9l_7_max_0_e5801c00() {
    // Encoding: 0xE5801C00
    // Test STR_P.BI__ field imm9l = 7 (Max)
    // Fields: imm9h=0, Pt=0, imm9l=7, Rn=0
    let encoding: u32 = 0xE5801C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_str_p_bi_field_rn_0_min_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ field Rn = 0 (Min)
    // Fields: Rn=0, imm9h=0, imm9l=0, Pt=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_str_p_bi_field_rn_1_poweroftwo_0_e5800020() {
    // Encoding: 0xE5800020
    // Test STR_P.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm9h=0, imm9l=0, Pt=0
    let encoding: u32 = 0xE5800020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_str_p_bi_field_rn_30_poweroftwominusone_0_e58003c0() {
    // Encoding: 0xE58003C0
    // Test STR_P.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm9l=0, imm9h=0, Pt=0, Rn=30
    let encoding: u32 = 0xE58003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_str_p_bi_field_rn_31_max_0_e58003e0() {
    // Encoding: 0xE58003E0
    // Test STR_P.BI__ field Rn = 31 (Max)
    // Fields: imm9l=0, Rn=31, Pt=0, imm9h=0
    let encoding: u32 = 0xE58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_str_p_bi_field_pt_0_min_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ field Pt = 0 (Min)
    // Fields: Rn=0, imm9h=0, imm9l=0, Pt=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_str_p_bi_field_pt_1_poweroftwo_0_e5800001() {
    // Encoding: 0xE5800001
    // Test STR_P.BI__ field Pt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pt=1, imm9l=0, imm9h=0
    let encoding: u32 = 0xE5800001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 7, boundary: PowerOfTwoMinusOne }
/// midpoint (7)
#[test]
fn test_str_p_bi_field_pt_7_poweroftwominusone_0_e5800007() {
    // Encoding: 0xE5800007
    // Test STR_P.BI__ field Pt = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm9h=0, Pt=7, imm9l=0
    let encoding: u32 = 0xE5800007;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Pt 0 +: 4`
/// Requirement: FieldBoundary { field: "Pt", value: 15, boundary: Max }
/// maximum value (15)
#[test]
fn test_str_p_bi_field_pt_15_max_0_e580000f() {
    // Encoding: 0xE580000F
    // Test STR_P.BI__ field Pt = 15 (Max)
    // Fields: imm9h=0, Rn=0, imm9l=0, Pt=15
    let encoding: u32 = 0xE580000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm9h=0 (immediate value 0)
#[test]
fn test_str_p_bi_combo_0_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ field combination: imm9h=0, imm9l=0, Rn=0, Pt=0
    // Fields: Pt=0, imm9l=0, imm9h=0, Rn=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_str_p_bi_special_rn_31_stack_pointer_sp_may_require_alignment_0_e58003e0() {
    // Encoding: 0xE58003E0
    // Test STR_P.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm9h=0, Pt=0, imm9l=0, Rn=31
    let encoding: u32 = 0xE58003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_str_p_bi_invalid_0_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pt=0, Rn=0, imm9l=0, imm9h=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_str_p_bi_invalid_1_0_e5800000() {
    // Encoding: 0xE5800000
    // Test STR_P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm9h=0, imm9l=0, Pt=0
    let encoding: u32 = 0xE5800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STR_P.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_str_p_bi_sp_rn_e58003e0() {
    // Test STR_P.BI__ with Rn = SP (31)
    // Encoding: 0xE58003E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE58003E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_0_zero_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e411e000() {
    // Encoding: 0xE411E000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=1
    let encoding: u32 = 0xE411E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e413e000() {
    // Encoding: 0xE413E000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, imm4=3, Zt=0
    let encoding: u32 = 0xE413E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e414e000() {
    // Encoding: 0xE414E000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=4, Zt=0
    let encoding: u32 = 0xE414E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e417e000() {
    // Encoding: 0xE417E000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=7
    let encoding: u32 = 0xE417E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e418e000() {
    // Encoding: 0xE418E000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=8
    let encoding: u32 = 0xE418E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_imm4_15_max_e000_e41fe000() {
    // Encoding: 0xE41FE000
    // Test STNT1B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE41FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_pg_0_min_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e410e400() {
    // Encoding: 0xE410E400
    // Test STNT1B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=1, Rn=0
    let encoding: u32 = 0xE410E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_rn_0_min_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e410e020() {
    // Encoding: 0xE410E020
    // Test STNT1B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=1
    let encoding: u32 = 0xE410E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e410e3c0() {
    // Encoding: 0xE410E3C0
    // Test STNT1B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=0, Rn=30, Pg=0
    let encoding: u32 = 0xE410E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_rn_31_max_e000_e410e3e0() {
    // Encoding: 0xE410E3E0
    // Test STNT1B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, imm4=0, Zt=0
    let encoding: u32 = 0xE410E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_zt_0_min_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e410e001() {
    // Encoding: 0xE410E001
    // Test STNT1B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, imm4=0, Pg=0
    let encoding: u32 = 0xE410E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e410e01e() {
    // Encoding: 0xE410E01E
    // Test STNT1B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xE410E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1b_z_p_bi_contiguous_field_zt_31_max_e000_e410e01f() {
    // Encoding: 0xE410E01F
    // Test STNT1B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xE410E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_stnt1b_z_p_bi_contiguous_combo_0_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e410e3e0() {
    // Encoding: 0xE410E3E0
    // Test STNT1B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xE410E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1b_z_p_bi_contiguous_invalid_0_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1b_z_p_bi_contiguous_invalid_1_e000_e410e000() {
    // Encoding: 0xE410E000
    // Test STNT1B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xE410E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1b_z_p_bi_contiguous_sp_rn_e410e3e0() {
    // Test STNT1B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE410E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE410E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1B_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1b_z_p_bi_contiguous_store_0_e410e020() {
    // Test STNT1B_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE410E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE410E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1D_Z.P.AI_D Tests
// ============================================================================

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1d_z_p_ai_d_field_imm5_0_zero_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1d_z_p_ai_d_field_imm5_1_poweroftwo_a000_e5c1a000() {
    // Encoding: 0xE5C1A000
    // Test ST1D_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: imm5=1, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1d_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_e5c3a000() {
    // Encoding: 0xE5C3A000
    // Test ST1D_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1d_z_p_ai_d_field_imm5_4_poweroftwo_a000_e5c4a000() {
    // Encoding: 0xE5C4A000
    // Test ST1D_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=4, Pg=0
    let encoding: u32 = 0xE5C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1d_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_e5c7a000() {
    // Encoding: 0xE5C7A000
    // Test ST1D_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=7, Pg=0, Zn=0
    let encoding: u32 = 0xE5C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1d_z_p_ai_d_field_imm5_8_poweroftwo_a000_e5c8a000() {
    // Encoding: 0xE5C8A000
    // Test ST1D_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm5=8, Zn=0, Zt=0
    let encoding: u32 = 0xE5C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1d_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_e5cfa000() {
    // Encoding: 0xE5CFA000
    // Test ST1D_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, imm5=15, Zt=0
    let encoding: u32 = 0xE5CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1d_z_p_ai_d_field_imm5_16_poweroftwo_a000_e5d0a000() {
    // Encoding: 0xE5D0A000
    // Test ST1D_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=16
    let encoding: u32 = 0xE5D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1d_z_p_ai_d_field_imm5_31_max_a000_e5dfa000() {
    // Encoding: 0xE5DFA000
    // Test ST1D_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Zn=0, Pg=0
    let encoding: u32 = 0xE5DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_ai_d_field_pg_0_min_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_ai_d_field_pg_1_poweroftwo_a000_e5c0a400() {
    // Encoding: 0xE5C0A400
    // Test ST1D_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=0, Pg=1
    let encoding: u32 = 0xE5C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_ai_d_field_zn_0_min_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_ai_d_field_zn_1_poweroftwo_a000_e5c0a020() {
    // Encoding: 0xE5C0A020
    // Test ST1D_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=0, Zn=1, Zt=0
    let encoding: u32 = 0xE5C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_ai_d_field_zn_30_poweroftwominusone_a000_e5c0a3c0() {
    // Encoding: 0xE5C0A3C0
    // Test ST1D_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=30
    let encoding: u32 = 0xE5C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_ai_d_field_zn_31_max_a000_e5c0a3e0() {
    // Encoding: 0xE5C0A3E0
    // Test ST1D_Z.P.AI_D field Zn = 31 (Max)
    // Fields: imm5=0, Zn=31, Pg=0, Zt=0
    let encoding: u32 = 0xE5C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_ai_d_field_zt_0_min_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_ai_d_field_zt_1_poweroftwo_a000_e5c0a001() {
    // Encoding: 0xE5C0A001
    // Test ST1D_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=1
    let encoding: u32 = 0xE5C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_ai_d_field_zt_30_poweroftwominusone_a000_e5c0a01e() {
    // Encoding: 0xE5C0A01E
    // Test ST1D_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zt=30, imm5=0
    let encoding: u32 = 0xE5C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_ai_d_field_zt_31_max_a000_e5c0a01f() {
    // Encoding: 0xE5C0A01F
    // Test ST1D_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=31
    let encoding: u32 = 0xE5C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1d_z_p_ai_d_combo_0_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_ai_d_invalid_0_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_ai_d_invalid_1_a000_e5c0a000() {
    // Encoding: 0xE5C0A000
    // Test ST1D_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xE5C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.AI_D
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_ai_d_store_0_e5c0a000() {
    // Test ST1D_Z.P.AI_D memory store: 8 bytes
    // Encoding: 0xE5C0A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1D_Z.P.BR__ Tests
// ============================================================================

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1d_z_p_br_field_size_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ field size = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0, size=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1d_z_p_br_field_size_1_poweroftwo_4000_e5a04000() {
    // Encoding: 0xE5A04000
    // Test ST1D_Z.P.BR__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1d_z_p_br_field_size_2_poweroftwo_4000_e5c04000() {
    // Encoding: 0xE5C04000
    // Test ST1D_Z.P.BR__ field size = 2 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=0, size=2, Pg=0
    let encoding: u32 = 0xE5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1d_z_p_br_field_size_3_max_4000_e5e04000() {
    // Encoding: 0xE5E04000
    // Test ST1D_Z.P.BR__ field size = 3 (Max)
    // Fields: size=3, Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_br_field_rm_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ field Rm = 0 (Min)
    // Fields: size=0, Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_br_field_rm_1_poweroftwo_4000_e5814000() {
    // Encoding: 0xE5814000
    // Test ST1D_Z.P.BR__ field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Rm=1, Rn=0, Zt=0
    let encoding: u32 = 0xE5814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_br_field_rm_30_poweroftwominusone_4000_e59e4000() {
    // Encoding: 0xE59E4000
    // Test ST1D_Z.P.BR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, size=0, Pg=0, Rn=0, Rm=30
    let encoding: u32 = 0xE59E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st1d_z_p_br_field_rm_31_max_4000_e59f4000() {
    // Encoding: 0xE59F4000
    // Test ST1D_Z.P.BR__ field Rm = 31 (Max)
    // Fields: Rn=0, Zt=0, Rm=31, Pg=0, size=0
    let encoding: u32 = 0xE59F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_br_field_pg_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ field Pg = 0 (Min)
    // Fields: Rm=0, size=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_br_field_pg_1_poweroftwo_4000_e5804400() {
    // Encoding: 0xE5804400
    // Test ST1D_Z.P.BR__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, size=0, Zt=0
    let encoding: u32 = 0xE5804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_br_field_rn_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ field Rn = 0 (Min)
    // Fields: Rn=0, Rm=0, size=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_br_field_rn_1_poweroftwo_4000_e5804020() {
    // Encoding: 0xE5804020
    // Test ST1D_Z.P.BR__ field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=1, size=0
    let encoding: u32 = 0xE5804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_br_field_rn_30_poweroftwominusone_4000_e58043c0() {
    // Encoding: 0xE58043C0
    // Test ST1D_Z.P.BR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, size=0, Pg=0, Rn=30, Rm=0
    let encoding: u32 = 0xE58043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1d_z_p_br_field_rn_31_max_4000_e58043e0() {
    // Encoding: 0xE58043E0
    // Test ST1D_Z.P.BR__ field Rn = 31 (Max)
    // Fields: size=0, Zt=0, Rn=31, Rm=0, Pg=0
    let encoding: u32 = 0xE58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_br_field_zt_0_min_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ field Zt = 0 (Min)
    // Fields: size=0, Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_br_field_zt_1_poweroftwo_4000_e5804001() {
    // Encoding: 0xE5804001
    // Test ST1D_Z.P.BR__ field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=1, size=0
    let encoding: u32 = 0xE5804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_br_field_zt_30_poweroftwominusone_4000_e580401e() {
    // Encoding: 0xE580401E
    // Test ST1D_Z.P.BR__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zt=30, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE580401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_br_field_zt_31_max_4000_e580401f() {
    // Encoding: 0xE580401F
    // Test ST1D_Z.P.BR__ field Zt = 31 (Max)
    // Fields: Pg=0, size=0, Rm=0, Zt=31, Rn=0
    let encoding: u32 = 0xE580401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1d_z_p_br_combo_0_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: size=0, Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1d_z_p_br_special_size_0_size_variant_0_16384_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Rm=0, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1d_z_p_br_special_size_1_size_variant_1_16384_e5a04000() {
    // Encoding: 0xE5A04000
    // Test ST1D_Z.P.BR__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1d_z_p_br_special_size_2_size_variant_2_16384_e5c04000() {
    // Encoding: 0xE5C04000
    // Test ST1D_Z.P.BR__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Rn=0, Zt=0, size=2, Rm=0
    let encoding: u32 = 0xE5C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1d_z_p_br_special_size_3_size_variant_3_16384_e5e04000() {
    // Encoding: 0xE5E04000
    // Test ST1D_Z.P.BR__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE5E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1d_z_p_br_special_rn_31_stack_pointer_sp_may_require_alignment_16384_e58043e0() {
    // Encoding: 0xE58043E0
    // Test ST1D_Z.P.BR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE58043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_br_invalid_0_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, size=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_br_invalid_1_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, size=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, false]) }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_br_invalid_2_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, false]) }
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0, size=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_br_invalid_3_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_br_invalid_4_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0, size=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_br_invalid_5_4000_e5804000() {
    // Encoding: 0xE5804000
    // Test ST1D_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, size=0, Rm=0
    let encoding: u32 = 0xE5804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1d_z_p_br_sp_rn_e58043e0() {
    // Test ST1D_Z.P.BR__ with Rn = SP (31)
    // Encoding: 0xE58043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE58043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BR__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_br_store_0_e5804020() {
    // Test ST1D_Z.P.BR__ memory store: 8 bytes
    // Encoding: 0xE5804020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5804020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1W_Z.P.AI_S Tests
// ============================================================================

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1w_z_p_ai_s_field_imm5_0_zero_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: imm5=0, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1w_z_p_ai_s_field_imm5_1_poweroftwo_a000_e561a000() {
    // Encoding: 0xE561A000
    // Test ST1W_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=1, Zt=0
    let encoding: u32 = 0xE561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1w_z_p_ai_s_field_imm5_3_poweroftwominusone_a000_e563a000() {
    // Encoding: 0xE563A000
    // Test ST1W_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, imm5=3, Pg=0
    let encoding: u32 = 0xE563A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1w_z_p_ai_s_field_imm5_4_poweroftwo_a000_e564a000() {
    // Encoding: 0xE564A000
    // Test ST1W_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, imm5=4, Zn=0, Zt=0
    let encoding: u32 = 0xE564A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1w_z_p_ai_s_field_imm5_7_poweroftwominusone_a000_e567a000() {
    // Encoding: 0xE567A000
    // Test ST1W_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE567A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1w_z_p_ai_s_field_imm5_8_poweroftwo_a000_e568a000() {
    // Encoding: 0xE568A000
    // Test ST1W_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, Pg=0, imm5=8
    let encoding: u32 = 0xE568A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1w_z_p_ai_s_field_imm5_15_poweroftwominusone_a000_e56fa000() {
    // Encoding: 0xE56FA000
    // Test ST1W_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xE56FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1w_z_p_ai_s_field_imm5_16_poweroftwo_a000_e570a000() {
    // Encoding: 0xE570A000
    // Test ST1W_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=16, Zn=0
    let encoding: u32 = 0xE570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1w_z_p_ai_s_field_imm5_31_max_a000_e57fa000() {
    // Encoding: 0xE57FA000
    // Test ST1W_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=31
    let encoding: u32 = 0xE57FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_ai_s_field_pg_0_min_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S field Pg = 0 (Min)
    // Fields: imm5=0, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_ai_s_field_pg_1_poweroftwo_a000_e560a400() {
    // Encoding: 0xE560A400
    // Test ST1W_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Pg=1, Zt=0, Zn=0
    let encoding: u32 = 0xE560A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_ai_s_field_zn_0_min_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_ai_s_field_zn_1_poweroftwo_a000_e560a020() {
    // Encoding: 0xE560A020
    // Test ST1W_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Zn=1, Pg=0
    let encoding: u32 = 0xE560A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_ai_s_field_zn_30_poweroftwominusone_a000_e560a3c0() {
    // Encoding: 0xE560A3C0
    // Test ST1W_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=30
    let encoding: u32 = 0xE560A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_ai_s_field_zn_31_max_a000_e560a3e0() {
    // Encoding: 0xE560A3E0
    // Test ST1W_Z.P.AI_S field Zn = 31 (Max)
    // Fields: Zn=31, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xE560A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_ai_s_field_zt_0_min_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_ai_s_field_zt_1_poweroftwo_a000_e560a001() {
    // Encoding: 0xE560A001
    // Test ST1W_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=1, imm5=0, Pg=0
    let encoding: u32 = 0xE560A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_ai_s_field_zt_30_poweroftwominusone_a000_e560a01e() {
    // Encoding: 0xE560A01E
    // Test ST1W_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zt=30, Zn=0
    let encoding: u32 = 0xE560A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_ai_s_field_zt_31_max_a000_e560a01f() {
    // Encoding: 0xE560A01F
    // Test ST1W_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xE560A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1w_z_p_ai_s_combo_0_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_ai_s_invalid_0_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_ai_s_invalid_1_a000_e560a000() {
    // Encoding: 0xE560A000
    // Test ST1W_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1w_z_p_ai_d_field_imm5_0_zero_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1w_z_p_ai_d_field_imm5_1_poweroftwo_a000_e541a000() {
    // Encoding: 0xE541A000
    // Test ST1W_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=1
    let encoding: u32 = 0xE541A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1w_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_e543a000() {
    // Encoding: 0xE543A000
    // Test ST1W_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE543A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1w_z_p_ai_d_field_imm5_4_poweroftwo_a000_e544a000() {
    // Encoding: 0xE544A000
    // Test ST1W_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE544A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1w_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_e547a000() {
    // Encoding: 0xE547A000
    // Test ST1W_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=7
    let encoding: u32 = 0xE547A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1w_z_p_ai_d_field_imm5_8_poweroftwo_a000_e548a000() {
    // Encoding: 0xE548A000
    // Test ST1W_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=8
    let encoding: u32 = 0xE548A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1w_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_e54fa000() {
    // Encoding: 0xE54FA000
    // Test ST1W_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=15
    let encoding: u32 = 0xE54FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1w_z_p_ai_d_field_imm5_16_poweroftwo_a000_e550a000() {
    // Encoding: 0xE550A000
    // Test ST1W_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xE550A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1w_z_p_ai_d_field_imm5_31_max_a000_e55fa000() {
    // Encoding: 0xE55FA000
    // Test ST1W_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Zn=0, Pg=0
    let encoding: u32 = 0xE55FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_ai_d_field_pg_0_min_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_ai_d_field_pg_1_poweroftwo_a000_e540a400() {
    // Encoding: 0xE540A400
    // Test ST1W_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Pg=1, Zn=0
    let encoding: u32 = 0xE540A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_ai_d_field_zn_0_min_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Zt=0, imm5=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_ai_d_field_zn_1_poweroftwo_a000_e540a020() {
    // Encoding: 0xE540A020
    // Test ST1W_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=1
    let encoding: u32 = 0xE540A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_ai_d_field_zn_30_poweroftwominusone_a000_e540a3c0() {
    // Encoding: 0xE540A3C0
    // Test ST1W_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Zn=30, Zt=0, Pg=0
    let encoding: u32 = 0xE540A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_ai_d_field_zn_31_max_a000_e540a3e0() {
    // Encoding: 0xE540A3E0
    // Test ST1W_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, imm5=0, Zt=0
    let encoding: u32 = 0xE540A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_ai_d_field_zt_0_min_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_ai_d_field_zt_1_poweroftwo_a000_e540a001() {
    // Encoding: 0xE540A001
    // Test ST1W_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=1, imm5=0
    let encoding: u32 = 0xE540A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_ai_d_field_zt_30_poweroftwominusone_a000_e540a01e() {
    // Encoding: 0xE540A01E
    // Test ST1W_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zt=30, Zn=0
    let encoding: u32 = 0xE540A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_ai_d_field_zt_31_max_a000_e540a01f() {
    // Encoding: 0xE540A01F
    // Test ST1W_Z.P.AI_D field Zt = 31 (Max)
    // Fields: imm5=0, Zn=0, Zt=31, Pg=0
    let encoding: u32 = 0xE540A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1w_z_p_ai_d_combo_0_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_ai_d_invalid_0_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zt=0, Pg=0, imm5=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_ai_d_invalid_1_a000_e540a000() {
    // Encoding: 0xE540A000
    // Test ST1W_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xE540A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.AI_S
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_ai_s_store_0_e560a000() {
    // Test ST1W_Z.P.AI_S memory store: 8 bytes
    // Encoding: 0xE560A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE560A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.AI_D
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_ai_d_store_0_e540a000() {
    // Test ST1W_Z.P.AI_D memory store: 8 bytes
    // Encoding: 0xE540A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE540A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1W_Z.P.BR__ Tests
// ============================================================================

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1w_z_p_br_field_size_0_min_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1w_z_p_br_field_size_1_poweroftwo_4000_e5204000() {
    // Encoding: 0xE5204000
    // Test ST1W_Z.P.BR__ field size = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, size=1, Pg=0, Rn=0
    let encoding: u32 = 0xE5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1w_z_p_br_field_size_2_poweroftwo_4000_e5404000() {
    // Encoding: 0xE5404000
    // Test ST1W_Z.P.BR__ field size = 2 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0, size=2
    let encoding: u32 = 0xE5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1w_z_p_br_field_size_3_max_4000_e5604000() {
    // Encoding: 0xE5604000
    // Test ST1W_Z.P.BR__ field size = 3 (Max)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0, size=3
    let encoding: u32 = 0xE5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_br_field_rm_0_min_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ field Rm = 0 (Min)
    // Fields: Pg=0, Rn=0, size=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_br_field_rm_1_poweroftwo_4000_e5014000() {
    // Encoding: 0xE5014000
    // Test ST1W_Z.P.BR__ field Rm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xE5014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_br_field_rm_30_poweroftwominusone_4000_e51e4000() {
    // Encoding: 0xE51E4000
    // Test ST1W_Z.P.BR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Pg=0, size=0, Rn=0
    let encoding: u32 = 0xE51E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st1w_z_p_br_field_rm_31_max_4000_e51f4000() {
    // Encoding: 0xE51F4000
    // Test ST1W_Z.P.BR__ field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, size=0, Pg=0, Zt=0
    let encoding: u32 = 0xE51F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_br_field_pg_0_min_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, size=0, Rn=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_br_field_pg_1_poweroftwo_4000_e5004400() {
    // Encoding: 0xE5004400
    // Test ST1W_Z.P.BR__ field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, size=0, Pg=1, Rm=0
    let encoding: u32 = 0xE5004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_br_field_rn_0_min_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ field Rn = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, size=0, Rn=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_br_field_rn_1_poweroftwo_4000_e5004020() {
    // Encoding: 0xE5004020
    // Test ST1W_Z.P.BR__ field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rm=0, size=0, Rn=1
    let encoding: u32 = 0xE5004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_br_field_rn_30_poweroftwominusone_4000_e50043c0() {
    // Encoding: 0xE50043C0
    // Test ST1W_Z.P.BR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=30, size=0
    let encoding: u32 = 0xE50043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_br_field_rn_31_max_4000_e50043e0() {
    // Encoding: 0xE50043E0
    // Test ST1W_Z.P.BR__ field Rn = 31 (Max)
    // Fields: Zt=0, size=0, Pg=0, Rm=0, Rn=31
    let encoding: u32 = 0xE50043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_br_field_zt_0_min_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, size=0, Rn=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_br_field_zt_1_poweroftwo_4000_e5004001() {
    // Encoding: 0xE5004001
    // Test ST1W_Z.P.BR__ field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, size=0, Zt=1, Pg=0, Rn=0
    let encoding: u32 = 0xE5004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_br_field_zt_30_poweroftwominusone_4000_e500401e() {
    // Encoding: 0xE500401E
    // Test ST1W_Z.P.BR__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0xE500401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_br_field_zt_31_max_4000_e500401f() {
    // Encoding: 0xE500401F
    // Test ST1W_Z.P.BR__ field Zt = 31 (Max)
    // Fields: Zt=31, Rm=0, Pg=0, Rn=0, size=0
    let encoding: u32 = 0xE500401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1w_z_p_br_combo_0_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: size=0, Rn=0, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1w_z_p_br_special_size_0_size_variant_0_16384_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1w_z_p_br_special_size_1_size_variant_1_16384_e5204000() {
    // Encoding: 0xE5204000
    // Test ST1W_Z.P.BR__ special value size = 1 (Size variant 1)
    // Fields: size=1, Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1w_z_p_br_special_size_2_size_variant_2_16384_e5404000() {
    // Encoding: 0xE5404000
    // Test ST1W_Z.P.BR__ special value size = 2 (Size variant 2)
    // Fields: Rm=0, Pg=0, size=2, Zt=0, Rn=0
    let encoding: u32 = 0xE5404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1w_z_p_br_special_size_3_size_variant_3_16384_e5604000() {
    // Encoding: 0xE5604000
    // Test ST1W_Z.P.BR__ special value size = 3 (Size variant 3)
    // Fields: Rn=0, size=3, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_br_special_rn_31_stack_pointer_sp_may_require_alignment_16384_e50043e0() {
    // Encoding: 0xE50043E0
    // Test ST1W_Z.P.BR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Rm=0, size=0, Zt=0
    let encoding: u32 = 0xE50043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_br_invalid_0_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, size=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_br_invalid_1_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([One, Either]) }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_br_invalid_2_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }
    // Fields: Pg=0, Rm=0, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_br_invalid_3_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_br_invalid_4_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0, size=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_br_invalid_5_4000_e5004000() {
    // Encoding: 0xE5004000
    // Test ST1W_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Pg=0, size=0, Rn=0
    let encoding: u32 = 0xE5004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_br_sp_rn_e50043e0() {
    // Test ST1W_Z.P.BR__ with Rn = SP (31)
    // Encoding: 0xE50043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE50043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BR__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_br_store_0_e5004020() {
    // Test ST1W_Z.P.BR__ memory store: 8 bytes
    // Encoding: 0xE5004020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5004020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3b_z_p_br_contiguous_field_rm_0_min_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3b_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4416000() {
    // Encoding: 0xE4416000
    // Test ST3B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4416000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3b_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e45e6000() {
    // Encoding: 0xE45E6000
    // Test ST3B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Rm=30, Pg=0
    let encoding: u32 = 0xE45E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st3b_z_p_br_contiguous_field_rm_31_max_6000_e45f6000() {
    // Encoding: 0xE45F6000
    // Test ST3B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=31
    let encoding: u32 = 0xE45F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3b_z_p_br_contiguous_field_pg_0_min_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3b_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4406400() {
    // Encoding: 0xE4406400
    // Test ST3B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xE4406400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3b_z_p_br_contiguous_field_rn_0_min_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3b_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4406020() {
    // Encoding: 0xE4406020
    // Test ST3B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=1
    let encoding: u32 = 0xE4406020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3b_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e44063c0() {
    // Encoding: 0xE44063C0
    // Test ST3B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Rm=0, Pg=0
    let encoding: u32 = 0xE44063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3b_z_p_br_contiguous_field_rn_31_max_6000_e44063e0() {
    // Encoding: 0xE44063E0
    // Test ST3B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Rm=0
    let encoding: u32 = 0xE44063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3b_z_p_br_contiguous_field_zt_0_min_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3b_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4406001() {
    // Encoding: 0xE4406001
    // Test ST3B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xE4406001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3b_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e440601e() {
    // Encoding: 0xE440601E
    // Test ST3B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xE440601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3b_z_p_br_contiguous_field_zt_31_max_6000_e440601f() {
    // Encoding: 0xE440601F
    // Test ST3B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=31
    let encoding: u32 = 0xE440601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st3b_z_p_br_contiguous_combo_0_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e44063e0() {
    // Encoding: 0xE44063E0
    // Test ST3B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE44063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3b_z_p_br_contiguous_invalid_0_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3b_z_p_br_contiguous_invalid_1_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st3b_z_p_br_contiguous_invalid_2_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3b_z_p_br_contiguous_invalid_3_6000_e4406000() {
    // Encoding: 0xE4406000
    // Test ST3B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3b_z_p_br_contiguous_sp_rn_e44063e0() {
    // Test ST3B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE44063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE44063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3B_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3b_z_p_br_contiguous_store_0_e4406020() {
    // Test ST3B_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4406020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4406020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_0_zero_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e471e000() {
    // Encoding: 0xE471E000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE471E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e473e000() {
    // Encoding: 0xE473E000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE473E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e474e000() {
    // Encoding: 0xE474E000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE474E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e477e000() {
    // Encoding: 0xE477E000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE477E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e478e000() {
    // Encoding: 0xE478E000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE478E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st4b_z_p_bi_contiguous_field_imm4_15_max_e000_e47fe000() {
    // Encoding: 0xE47FE000
    // Test ST4B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Pg=0, Zt=0, imm4=15, Rn=0
    let encoding: u32 = 0xE47FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4b_z_p_bi_contiguous_field_pg_0_min_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e470e400() {
    // Encoding: 0xE470E400
    // Test ST4B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE470E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4b_z_p_bi_contiguous_field_rn_0_min_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e470e020() {
    // Encoding: 0xE470E020
    // Test ST4B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE470E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e470e3c0() {
    // Encoding: 0xE470E3C0
    // Test ST4B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xE470E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4b_z_p_bi_contiguous_field_rn_31_max_e000_e470e3e0() {
    // Encoding: 0xE470E3E0
    // Test ST4B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE470E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4b_z_p_bi_contiguous_field_zt_0_min_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e470e001() {
    // Encoding: 0xE470E001
    // Test ST4B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=1, Pg=0, Rn=0
    let encoding: u32 = 0xE470E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e470e01e() {
    // Encoding: 0xE470E01E
    // Test ST4B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, imm4=0
    let encoding: u32 = 0xE470E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4b_z_p_bi_contiguous_field_zt_31_max_e000_e470e01f() {
    // Encoding: 0xE470E01F
    // Test ST4B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=31
    let encoding: u32 = 0xE470E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st4b_z_p_bi_contiguous_combo_0_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e470e3e0() {
    // Encoding: 0xE470E3E0
    // Test ST4B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE470E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4b_z_p_bi_contiguous_invalid_0_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4b_z_p_bi_contiguous_invalid_1_e000_e470e000() {
    // Encoding: 0xE470E000
    // Test ST4B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE470E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4b_z_p_bi_contiguous_sp_rn_e470e3e0() {
    // Test ST4B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE470E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE470E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4B_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4b_z_p_bi_contiguous_store_0_e470e020() {
    // Test ST4B_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE470E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE470E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1B_Z.P.BZ_D.x32.unscaled Tests
// ============================================================================

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zm_0_min_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_8000_e4018000() {
    // Encoding: 0xE4018000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xE4018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_8000_e41e8000() {
    // Encoding: 0xE41E8000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE41E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zm_31_max_8000_e41f8000() {
    // Encoding: 0xE41F8000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Zt=0, Pg=0, Zm=31, Rn=0, xs=0
    let encoding: u32 = 0xE41F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_xs_0_min_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_xs_1_max_8000_e400c000() {
    // Encoding: 0xE400C000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, xs=1, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_pg_0_min_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_8000_e4008400() {
    // Encoding: 0xE4008400
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xE4008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_rn_0_min_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_8000_e4008020() {
    // Encoding: 0xE4008020
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=1, xs=0
    let encoding: u32 = 0xE4008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_8000_e40083c0() {
    // Encoding: 0xE40083C0
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, xs=0, Rn=30, Zt=0
    let encoding: u32 = 0xE40083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_rn_31_max_8000_e40083e0() {
    // Encoding: 0xE40083E0
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0, xs=0
    let encoding: u32 = 0xE40083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zt_0_min_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_8000_e4008001() {
    // Encoding: 0xE4008001
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, xs=0, Rn=0, Zt=1
    let encoding: u32 = 0xE4008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_8000_e400801e() {
    // Encoding: 0xE400801E
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Zm=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xE400801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_field_zt_31_max_8000_e400801f() {
    // Encoding: 0xE400801F
    // Test ST1B_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Rn=0, Zm=0, Pg=0, Zt=31
    let encoding: u32 = 0xE400801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_combo_0_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e40083e0() {
    // Encoding: 0xE40083E0
    // Test ST1B_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31, xs=0
    let encoding: u32 = 0xE40083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_invalid_0_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_invalid_1_8000_e4008000() {
    // Encoding: 0xE4008000
    // Test ST1B_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zm_0_min_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_8000_e4418000() {
    // Encoding: 0xE4418000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=1, xs=0, Pg=0
    let encoding: u32 = 0xE4418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_8000_e45e8000() {
    // Encoding: 0xE45E8000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Zt=0, Zm=30, Rn=0
    let encoding: u32 = 0xE45E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zm_31_max_8000_e45f8000() {
    // Encoding: 0xE45F8000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Zm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE45F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_xs_0_min_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Zm=0, xs=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_xs_1_max_8000_e440c000() {
    // Encoding: 0xE440C000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Zm=0, xs=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_pg_0_min_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0, xs=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_8000_e4408400() {
    // Encoding: 0xE4408400
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=1, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xE4408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_rn_0_min_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_8000_e4408020() {
    // Encoding: 0xE4408020
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Zt=0, xs=0, Pg=0
    let encoding: u32 = 0xE4408020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_8000_e44083c0() {
    // Encoding: 0xE44083C0
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xE44083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_rn_31_max_8000_e44083e0() {
    // Encoding: 0xE44083E0
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Rn=31, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xE44083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zt_0_min_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_8000_e4408001() {
    // Encoding: 0xE4408001
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Zm=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4408001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_8000_e440801e() {
    // Encoding: 0xE440801E
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xE440801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_field_zt_31_max_8000_e440801f() {
    // Encoding: 0xE440801F
    // Test ST1B_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Zm=0, xs=0, Zt=31, Rn=0
    let encoding: u32 = 0xE440801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_combo_0_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Zm=0, xs=0, Pg=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e44083e0() {
    // Encoding: 0xE44083E0
    // Test ST1B_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE44083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_invalid_0_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_invalid_1_8000_e4408000() {
    // Encoding: 0xE4408000
    // Test ST1B_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, xs=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE4408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zm_0_min_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_e401a000() {
    // Encoding: 0xE401A000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=1
    let encoding: u32 = 0xE401A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_e41ea000() {
    // Encoding: 0xE41EA000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zm=30, Rn=0
    let encoding: u32 = 0xE41EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zm_31_max_a000_e41fa000() {
    // Encoding: 0xE41FA000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=31
    let encoding: u32 = 0xE41FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_pg_0_min_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_e400a400() {
    // Encoding: 0xE400A400
    // Test ST1B_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xE400A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_rn_0_min_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_e400a020() {
    // Encoding: 0xE400A020
    // Test ST1B_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=1, Zm=0
    let encoding: u32 = 0xE400A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_e400a3c0() {
    // Encoding: 0xE400A3C0
    // Test ST1B_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE400A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_rn_31_max_a000_e400a3e0() {
    // Encoding: 0xE400A3E0
    // Test ST1B_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xE400A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zt_0_min_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_e400a001() {
    // Encoding: 0xE400A001
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xE400A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_e400a01e() {
    // Encoding: 0xE400A01E
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xE400A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_field_zt_31_max_a000_e400a01f() {
    // Encoding: 0xE400A01F
    // Test ST1B_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xE400A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_combo_0_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e400a3e0() {
    // Encoding: 0xE400A3E0
    // Test ST1B_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Rn=31, Pg=0
    let encoding: u32 = 0xE400A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_invalid_0_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_invalid_1_a000_e400a000() {
    // Encoding: 0xE400A000
    // Test ST1B_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE400A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_sp_rn_e40083e0() {
    // Test ST1B_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE40083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE40083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BZ_D.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_bz_d_x32_unscaled_store_0_e4008020() {
    // Test ST1B_Z.P.BZ_D.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE4008020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4008020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_sp_rn_e44083e0() {
    // Test ST1B_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE44083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE44083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BZ_S.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_bz_s_x32_unscaled_store_0_e4408020() {
    // Test ST1B_Z.P.BZ_S.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE4408020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4408020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_sp_rn_e400a3e0() {
    // Test ST1B_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xE400A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE400A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BZ_D.64.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_bz_d_64_unscaled_store_0_e400a020() {
    // Test ST1B_Z.P.BZ_D.64.unscaled memory store: 8 bytes
    // Encoding: 0xE400A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE400A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1W_Z.P.BI__ Tests
// ============================================================================

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1w_z_p_bi_field_size_0_min_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ field size = 0 (Min)
    // Fields: size=0, Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1w_z_p_bi_field_size_1_poweroftwo_e000_e520e000() {
    // Encoding: 0xE520E000
    // Test ST1W_Z.P.BI__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, size=1, imm4=0, Zt=0
    let encoding: u32 = 0xE520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1w_z_p_bi_field_size_2_poweroftwo_e000_e540e000() {
    // Encoding: 0xE540E000
    // Test ST1W_Z.P.BI__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, size=2, Rn=0, Zt=0
    let encoding: u32 = 0xE540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1w_z_p_bi_field_size_3_max_e000_e560e000() {
    // Encoding: 0xE560E000
    // Test ST1W_Z.P.BI__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1w_z_p_bi_field_imm4_0_zero_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ field imm4 = 0 (Zero)
    // Fields: size=0, Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1w_z_p_bi_field_imm4_1_poweroftwo_e000_e501e000() {
    // Encoding: 0xE501E000
    // Test ST1W_Z.P.BI__ field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rn=0, size=0, Zt=0, Pg=0
    let encoding: u32 = 0xE501E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1w_z_p_bi_field_imm4_3_poweroftwominusone_e000_e503e000() {
    // Encoding: 0xE503E000
    // Test ST1W_Z.P.BI__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE503E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1w_z_p_bi_field_imm4_4_poweroftwo_e000_e504e000() {
    // Encoding: 0xE504E000
    // Test ST1W_Z.P.BI__ field imm4 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=0, size=0, imm4=4
    let encoding: u32 = 0xE504E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st1w_z_p_bi_field_imm4_7_poweroftwominusone_e000_e507e000() {
    // Encoding: 0xE507E000
    // Test ST1W_Z.P.BI__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, size=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xE507E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1w_z_p_bi_field_imm4_8_poweroftwo_e000_e508e000() {
    // Encoding: 0xE508E000
    // Test ST1W_Z.P.BI__ field imm4 = 8 (PowerOfTwo)
    // Fields: imm4=8, Rn=0, size=0, Pg=0, Zt=0
    let encoding: u32 = 0xE508E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st1w_z_p_bi_field_imm4_15_max_e000_e50fe000() {
    // Encoding: 0xE50FE000
    // Test ST1W_Z.P.BI__ field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Rn=0, size=0, Zt=0
    let encoding: u32 = 0xE50FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bi_field_pg_0_min_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, size=0, Pg=0, imm4=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bi_field_pg_1_poweroftwo_e000_e500e400() {
    // Encoding: 0xE500E400
    // Test ST1W_Z.P.BI__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, size=0, imm4=0
    let encoding: u32 = 0xE500E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bi_field_rn_0_min_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, size=0, Zt=0, Pg=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bi_field_rn_1_poweroftwo_e000_e500e020() {
    // Encoding: 0xE500E020
    // Test ST1W_Z.P.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, imm4=0, Rn=1, Zt=0
    let encoding: u32 = 0xE500E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bi_field_rn_30_poweroftwominusone_e000_e500e3c0() {
    // Encoding: 0xE500E3C0
    // Test ST1W_Z.P.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, size=0, imm4=0, Zt=0
    let encoding: u32 = 0xE500E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bi_field_rn_31_max_e000_e500e3e0() {
    // Encoding: 0xE500E3E0
    // Test ST1W_Z.P.BI__ field Rn = 31 (Max)
    // Fields: Rn=31, size=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bi_field_zt_0_min_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ field Zt = 0 (Min)
    // Fields: imm4=0, size=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bi_field_zt_1_poweroftwo_e000_e500e001() {
    // Encoding: 0xE500E001
    // Test ST1W_Z.P.BI__ field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Zt=1, size=0, Pg=0
    let encoding: u32 = 0xE500E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bi_field_zt_30_poweroftwominusone_e000_e500e01e() {
    // Encoding: 0xE500E01E
    // Test ST1W_Z.P.BI__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=0, Zt=30, imm4=0, Pg=0
    let encoding: u32 = 0xE500E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bi_field_zt_31_max_e000_e500e01f() {
    // Encoding: 0xE500E01F
    // Test ST1W_Z.P.BI__ field Zt = 31 (Max)
    // Fields: Rn=0, imm4=0, Zt=31, Pg=0, size=0
    let encoding: u32 = 0xE500E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1w_z_p_bi_combo_0_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ field combination: size=0, imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, size=0, Rn=0, imm4=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1w_z_p_bi_special_size_0_size_variant_0_57344_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1w_z_p_bi_special_size_1_size_variant_1_57344_e520e000() {
    // Encoding: 0xE520E000
    // Test ST1W_Z.P.BI__ special value size = 1 (Size variant 1)
    // Fields: Zt=0, size=1, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE520E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1w_z_p_bi_special_size_2_size_variant_2_57344_e540e000() {
    // Encoding: 0xE540E000
    // Test ST1W_Z.P.BI__ special value size = 2 (Size variant 2)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=0, size=2
    let encoding: u32 = 0xE540E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1w_z_p_bi_special_size_3_size_variant_3_57344_e560e000() {
    // Encoding: 0xE560E000
    // Test ST1W_Z.P.BI__ special value size = 3 (Size variant 3)
    // Fields: imm4=0, Rn=0, size=3, Pg=0, Zt=0
    let encoding: u32 = 0xE560E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bi_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e500e3e0() {
    // Encoding: 0xE500E3E0
    // Test ST1W_Z.P.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: size=0, Zt=0, Rn=31, Pg=0, imm4=0
    let encoding: u32 = 0xE500E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bi_invalid_0_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0, size=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bi_invalid_1_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([One, Either]) }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bi_invalid_2_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }
    // Fields: size=0, Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bi_invalid_3_e000_e500e000() {
    // Encoding: 0xE500E000
    // Test ST1W_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, size=0, imm4=0, Pg=0
    let encoding: u32 = 0xE500E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bi_sp_rn_e500e3e0() {
    // Test ST1W_Z.P.BI__ with Rn = SP (31)
    // Encoding: 0xE500E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE500E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BI__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bi_store_0_e500e020() {
    // Test ST1W_Z.P.BI__ memory store: 8 bytes
    // Encoding: 0xE500E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE500E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3B_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_0_zero_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e451e000() {
    // Encoding: 0xE451E000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE451E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e453e000() {
    // Encoding: 0xE453E000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xE453E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e454e000() {
    // Encoding: 0xE454E000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE454E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e457e000() {
    // Encoding: 0xE457E000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Rn=0, Pg=0
    let encoding: u32 = 0xE457E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e458e000() {
    // Encoding: 0xE458E000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=8
    let encoding: u32 = 0xE458E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st3b_z_p_bi_contiguous_field_imm4_15_max_e000_e45fe000() {
    // Encoding: 0xE45FE000
    // Test ST3B_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, imm4=15, Rn=0, Pg=0
    let encoding: u32 = 0xE45FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3b_z_p_bi_contiguous_field_pg_0_min_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3b_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e450e400() {
    // Encoding: 0xE450E400
    // Test ST3B_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=1, imm4=0
    let encoding: u32 = 0xE450E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3b_z_p_bi_contiguous_field_rn_0_min_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3b_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e450e020() {
    // Encoding: 0xE450E020
    // Test ST3B_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE450E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3b_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e450e3c0() {
    // Encoding: 0xE450E3C0
    // Test ST3B_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rn=30, Pg=0, imm4=0
    let encoding: u32 = 0xE450E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3b_z_p_bi_contiguous_field_rn_31_max_e000_e450e3e0() {
    // Encoding: 0xE450E3E0
    // Test ST3B_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE450E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3b_z_p_bi_contiguous_field_zt_0_min_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3b_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e450e001() {
    // Encoding: 0xE450E001
    // Test ST3B_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, imm4=0
    let encoding: u32 = 0xE450E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3b_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e450e01e() {
    // Encoding: 0xE450E01E
    // Test ST3B_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xE450E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3b_z_p_bi_contiguous_field_zt_31_max_e000_e450e01f() {
    // Encoding: 0xE450E01F
    // Test ST3B_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=31
    let encoding: u32 = 0xE450E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st3b_z_p_bi_contiguous_combo_0_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3b_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e450e3e0() {
    // Encoding: 0xE450E3E0
    // Test ST3B_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE450E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3b_z_p_bi_contiguous_invalid_0_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3b_z_p_bi_contiguous_invalid_1_e000_e450e000() {
    // Encoding: 0xE450E000
    // Test ST3B_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE450E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3b_z_p_bi_contiguous_sp_rn_e450e3e0() {
    // Test ST3B_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE450E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE450E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3B_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3b_z_p_bi_contiguous_store_0_e450e020() {
    // Test ST3B_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE450E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE450E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4b_z_p_br_contiguous_field_rm_0_min_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4b_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4616000() {
    // Encoding: 0xE4616000
    // Test ST4B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xE4616000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4b_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e47e6000() {
    // Encoding: 0xE47E6000
    // Test ST4B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Rm=30, Pg=0, Zt=0
    let encoding: u32 = 0xE47E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st4b_z_p_br_contiguous_field_rm_31_max_6000_e47f6000() {
    // Encoding: 0xE47F6000
    // Test ST4B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rn=0, Rm=31, Pg=0, Zt=0
    let encoding: u32 = 0xE47F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4b_z_p_br_contiguous_field_pg_0_min_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4b_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4606400() {
    // Encoding: 0xE4606400
    // Test ST4B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4b_z_p_br_contiguous_field_rn_0_min_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4b_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4606020() {
    // Encoding: 0xE4606020
    // Test ST4B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Rn=1, Zt=0
    let encoding: u32 = 0xE4606020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4b_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e46063c0() {
    // Encoding: 0xE46063C0
    // Test ST4B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE46063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4b_z_p_br_contiguous_field_rn_31_max_6000_e46063e0() {
    // Encoding: 0xE46063E0
    // Test ST4B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0
    let encoding: u32 = 0xE46063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4b_z_p_br_contiguous_field_zt_0_min_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4b_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4606001() {
    // Encoding: 0xE4606001
    // Test ST4B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=1
    let encoding: u32 = 0xE4606001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4b_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e460601e() {
    // Encoding: 0xE460601E
    // Test ST4B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=30
    let encoding: u32 = 0xE460601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4b_z_p_br_contiguous_field_zt_31_max_6000_e460601f() {
    // Encoding: 0xE460601F
    // Test ST4B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xE460601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st4b_z_p_br_contiguous_combo_0_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e46063e0() {
    // Encoding: 0xE46063E0
    // Test ST4B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xE46063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4b_z_p_br_contiguous_invalid_0_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4b_z_p_br_contiguous_invalid_1_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st4b_z_p_br_contiguous_invalid_2_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4b_z_p_br_contiguous_invalid_3_6000_e4606000() {
    // Encoding: 0xE4606000
    // Test ST4B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4b_z_p_br_contiguous_sp_rn_e46063e0() {
    // Test ST4B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE46063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE46063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4B_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4b_z_p_br_contiguous_store_0_e4606020() {
    // Test ST4B_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4606020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4606020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rm_0_min_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4016000() {
    // Encoding: 0xE4016000
    // Test STNT1B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4016000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e41e6000() {
    // Encoding: 0xE41E6000
    // Test STNT1B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE41E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rm_31_max_6000_e41f6000() {
    // Encoding: 0xE41F6000
    // Test STNT1B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE41F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_pg_0_min_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4006400() {
    // Encoding: 0xE4006400
    // Test STNT1B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4006400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rn_0_min_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4006020() {
    // Encoding: 0xE4006020
    // Test STNT1B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Rn=1, Pg=0
    let encoding: u32 = 0xE4006020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e40063c0() {
    // Encoding: 0xE40063C0
    // Test STNT1B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE40063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1b_z_p_br_contiguous_field_rn_31_max_6000_e40063e0() {
    // Encoding: 0xE40063E0
    // Test STNT1B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1b_z_p_br_contiguous_field_zt_0_min_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1b_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4006001() {
    // Encoding: 0xE4006001
    // Test STNT1B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Rm=0, Pg=0
    let encoding: u32 = 0xE4006001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1b_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e400601e() {
    // Encoding: 0xE400601E
    // Test STNT1B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=30
    let encoding: u32 = 0xE400601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1b_z_p_br_contiguous_field_zt_31_max_6000_e400601f() {
    // Encoding: 0xE400601F
    // Test STNT1B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rm=0, Rn=0
    let encoding: u32 = 0xE400601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_stnt1b_z_p_br_contiguous_combo_0_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e40063e0() {
    // Encoding: 0xE40063E0
    // Test STNT1B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE40063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1b_z_p_br_contiguous_invalid_0_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1b_z_p_br_contiguous_invalid_1_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_stnt1b_z_p_br_contiguous_invalid_2_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1b_z_p_br_contiguous_invalid_3_6000_e4006000() {
    // Encoding: 0xE4006000
    // Test STNT1B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4006000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1b_z_p_br_contiguous_sp_rn_e40063e0() {
    // Test STNT1B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE40063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE40063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1B_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1b_z_p_br_contiguous_store_0_e4006020() {
    // Test STNT1B_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4006020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4006020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1D_Z.P.BI__ Tests
// ============================================================================

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1d_z_p_bi_field_size_0_min_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ field size = 0 (Min)
    // Fields: imm4=0, size=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1d_z_p_bi_field_size_1_poweroftwo_e000_e5a0e000() {
    // Encoding: 0xE5A0E000
    // Test ST1D_Z.P.BI__ field size = 1 (PowerOfTwo)
    // Fields: size=1, imm4=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1d_z_p_bi_field_size_2_poweroftwo_e000_e5c0e000() {
    // Encoding: 0xE5C0E000
    // Test ST1D_Z.P.BI__ field size = 2 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, size=2, Pg=0, Zt=0
    let encoding: u32 = 0xE5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1d_z_p_bi_field_size_3_max_e000_e5e0e000() {
    // Encoding: 0xE5E0E000
    // Test ST1D_Z.P.BI__ field size = 3 (Max)
    // Fields: Rn=0, Zt=0, imm4=0, size=3, Pg=0
    let encoding: u32 = 0xE5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1d_z_p_bi_field_imm4_0_zero_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ field imm4 = 0 (Zero)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0, size=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1d_z_p_bi_field_imm4_1_poweroftwo_e000_e581e000() {
    // Encoding: 0xE581E000
    // Test ST1D_Z.P.BI__ field imm4 = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zt=0, imm4=1, Rn=0
    let encoding: u32 = 0xE581E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1d_z_p_bi_field_imm4_3_poweroftwominusone_e000_e583e000() {
    // Encoding: 0xE583E000
    // Test ST1D_Z.P.BI__ field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=3, Pg=0, size=0, Zt=0
    let encoding: u32 = 0xE583E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1d_z_p_bi_field_imm4_4_poweroftwo_e000_e584e000() {
    // Encoding: 0xE584E000
    // Test ST1D_Z.P.BI__ field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, size=0, imm4=4, Pg=0
    let encoding: u32 = 0xE584E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st1d_z_p_bi_field_imm4_7_poweroftwominusone_e000_e587e000() {
    // Encoding: 0xE587E000
    // Test ST1D_Z.P.BI__ field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, imm4=7, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE587E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1d_z_p_bi_field_imm4_8_poweroftwo_e000_e588e000() {
    // Encoding: 0xE588E000
    // Test ST1D_Z.P.BI__ field imm4 = 8 (PowerOfTwo)
    // Fields: size=0, imm4=8, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE588E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st1d_z_p_bi_field_imm4_15_max_e000_e58fe000() {
    // Encoding: 0xE58FE000
    // Test ST1D_Z.P.BI__ field imm4 = 15 (Max)
    // Fields: size=0, imm4=15, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE58FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bi_field_pg_0_min_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, size=0, Zt=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bi_field_pg_1_poweroftwo_e000_e580e400() {
    // Encoding: 0xE580E400
    // Test ST1D_Z.P.BI__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, imm4=0, Zt=0, Rn=0, Pg=1
    let encoding: u32 = 0xE580E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bi_field_rn_0_min_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ field Rn = 0 (Min)
    // Fields: Pg=0, size=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bi_field_rn_1_poweroftwo_e000_e580e020() {
    // Encoding: 0xE580E020
    // Test ST1D_Z.P.BI__ field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, imm4=0, size=0, Zt=0
    let encoding: u32 = 0xE580E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_bi_field_rn_30_poweroftwominusone_e000_e580e3c0() {
    // Encoding: 0xE580E3C0
    // Test ST1D_Z.P.BI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, size=0, imm4=0, Zt=0
    let encoding: u32 = 0xE580E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1d_z_p_bi_field_rn_31_max_e000_e580e3e0() {
    // Encoding: 0xE580E3E0
    // Test ST1D_Z.P.BI__ field Rn = 31 (Max)
    // Fields: Zt=0, size=0, Rn=31, imm4=0, Pg=0
    let encoding: u32 = 0xE580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bi_field_zt_0_min_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ field Zt = 0 (Min)
    // Fields: size=0, imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bi_field_zt_1_poweroftwo_e000_e580e001() {
    // Encoding: 0xE580E001
    // Test ST1D_Z.P.BI__ field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, size=0, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE580E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bi_field_zt_30_poweroftwominusone_e000_e580e01e() {
    // Encoding: 0xE580E01E
    // Test ST1D_Z.P.BI__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, imm4=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xE580E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bi_field_zt_31_max_e000_e580e01f() {
    // Encoding: 0xE580E01F
    // Test ST1D_Z.P.BI__ field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, size=0, imm4=0
    let encoding: u32 = 0xE580E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1d_z_p_bi_combo_0_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ field combination: size=0, imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, size=0, Rn=0, Pg=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1d_z_p_bi_special_size_0_size_variant_0_57344_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Rn=0, size=0, Zt=0, imm4=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1d_z_p_bi_special_size_1_size_variant_1_57344_e5a0e000() {
    // Encoding: 0xE5A0E000
    // Test ST1D_Z.P.BI__ special value size = 1 (Size variant 1)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0, size=1
    let encoding: u32 = 0xE5A0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1d_z_p_bi_special_size_2_size_variant_2_57344_e5c0e000() {
    // Encoding: 0xE5C0E000
    // Test ST1D_Z.P.BI__ special value size = 2 (Size variant 2)
    // Fields: Rn=0, size=2, imm4=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1d_z_p_bi_special_size_3_size_variant_3_57344_e5e0e000() {
    // Encoding: 0xE5E0E000
    // Test ST1D_Z.P.BI__ special value size = 3 (Size variant 3)
    // Fields: size=3, imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5E0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1d_z_p_bi_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e580e3e0() {
    // Encoding: 0xE580E3E0
    // Test ST1D_Z.P.BI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, imm4=0, Pg=0, Zt=0, size=0
    let encoding: u32 = 0xE580E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bi_invalid_0_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, size=0, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bi_invalid_1_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bi_invalid_2_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zt=0, Pg=0, imm4=0, size=0, Rn=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bi_invalid_3_e000_e580e000() {
    // Encoding: 0xE580E000
    // Test ST1D_Z.P.BI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, size=0, Zt=0
    let encoding: u32 = 0xE580E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1d_z_p_bi_sp_rn_e580e3e0() {
    // Test ST1D_Z.P.BI__ with Rn = SP (31)
    // Encoding: 0xE580E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE580E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BI__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_bi_store_0_e580e020() {
    // Test ST1D_Z.P.BI__ memory store: 8 bytes
    // Encoding: 0xE580E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE580E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1D_Z.P.BZ_D.x32.scaled Tests
// ============================================================================

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zm_0_min_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_8000_e5a18000() {
    // Encoding: 0xE5A18000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Rn=0, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xE5A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_8000_e5be8000() {
    // Encoding: 0xE5BE8000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=30, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5BE8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zm_31_max_8000_e5bf8000() {
    // Encoding: 0xE5BF8000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5BF8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_xs_0_min_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=0, xs=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_xs_1_max_8000_e5a0c000() {
    // Encoding: 0xE5A0C000
    // Test ST1D_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Zt=0, Pg=0, Zm=0, xs=1, Rn=0
    let encoding: u32 = 0xE5A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_pg_0_min_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_8000_e5a08400() {
    // Encoding: 0xE5A08400
    // Test ST1D_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xE5A08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_rn_0_min_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_8000_e5a08020() {
    // Encoding: 0xE5A08020
    // Test ST1D_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Zm=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xE5A08020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_8000_e5a083c0() {
    // Encoding: 0xE5A083C0
    // Test ST1D_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, xs=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xE5A083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_rn_31_max_8000_e5a083e0() {
    // Encoding: 0xE5A083E0
    // Test ST1D_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Rn=31, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5A083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zt_0_min_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, xs=0, Rn=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_8000_e5a08001() {
    // Encoding: 0xE5A08001
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=0, Zt=1, Pg=0, xs=0
    let encoding: u32 = 0xE5A08001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_8000_e5a0801e() {
    // Encoding: 0xE5A0801E
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, xs=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5A0801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_field_zt_31_max_8000_e5a0801f() {
    // Encoding: 0xE5A0801F
    // Test ST1D_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Rn=0, Zm=0, Zt=31
    let encoding: u32 = 0xE5A0801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_combo_0_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Rn=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e5a083e0() {
    // Encoding: 0xE5A083E0
    // Test ST1D_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Pg=0, xs=0, Rn=31, Zm=0
    let encoding: u32 = 0xE5A083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_invalid_0_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zt=0, Rn=0, xs=0, Pg=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_invalid_1_8000_e5a08000() {
    // Encoding: 0xE5A08000
    // Test ST1D_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: xs=0, Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zm_0_min_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_8000_e5818000() {
    // Encoding: 0xE5818000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, xs=0, Rn=0, Zt=0, Zm=1
    let encoding: u32 = 0xE5818000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_8000_e59e8000() {
    // Encoding: 0xE59E8000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=30, Pg=0, Rn=0, xs=0
    let encoding: u32 = 0xE59E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zm_31_max_8000_e59f8000() {
    // Encoding: 0xE59F8000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xE59F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_xs_0_min_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, xs=0, Zm=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_xs_1_max_8000_e580c000() {
    // Encoding: 0xE580C000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Zm=0, Rn=0, xs=1, Zt=0
    let encoding: u32 = 0xE580C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_pg_0_min_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_8000_e5808400() {
    // Encoding: 0xE5808400
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Rn=0, Pg=1, Zt=0
    let encoding: u32 = 0xE5808400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_rn_0_min_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_8000_e5808020() {
    // Encoding: 0xE5808020
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xE5808020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_8000_e58083c0() {
    // Encoding: 0xE58083C0
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=30
    let encoding: u32 = 0xE58083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_rn_31_max_8000_e58083e0() {
    // Encoding: 0xE58083E0
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: xs=0, Zm=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE58083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zt_0_min_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_8000_e5808001() {
    // Encoding: 0xE5808001
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zm=0, Zt=1, xs=0
    let encoding: u32 = 0xE5808001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_8000_e580801e() {
    // Encoding: 0xE580801E
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, xs=0, Rn=0, Zt=30
    let encoding: u32 = 0xE580801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_field_zt_31_max_8000_e580801f() {
    // Encoding: 0xE580801F
    // Test ST1D_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: xs=0, Pg=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0xE580801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_combo_0_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Pg=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e58083e0() {
    // Encoding: 0xE58083E0
    // Test ST1D_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, xs=0, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE58083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_invalid_0_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_invalid_1_8000_e5808000() {
    // Encoding: 0xE5808000
    // Test ST1D_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5808000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zm_0_min_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_a000_e5a1a000() {
    // Encoding: 0xE5A1A000
    // Test ST1D_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_a000_e5bea000() {
    // Encoding: 0xE5BEA000
    // Test ST1D_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zm=30, Pg=0, Zt=0
    let encoding: u32 = 0xE5BEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zm_31_max_a000_e5bfa000() {
    // Encoding: 0xE5BFA000
    // Test ST1D_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=31
    let encoding: u32 = 0xE5BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_pg_0_min_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_a000_e5a0a400() {
    // Encoding: 0xE5A0A400
    // Test ST1D_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xE5A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_rn_0_min_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_a000_e5a0a020() {
    // Encoding: 0xE5A0A020
    // Test ST1D_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Zm=0, Pg=0
    let encoding: u32 = 0xE5A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_a000_e5a0a3c0() {
    // Encoding: 0xE5A0A3C0
    // Test ST1D_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, Zt=0, Zm=0
    let encoding: u32 = 0xE5A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_rn_31_max_a000_e5a0a3e0() {
    // Encoding: 0xE5A0A3E0
    // Test ST1D_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xE5A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zt_0_min_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_a000_e5a0a001() {
    // Encoding: 0xE5A0A001
    // Test ST1D_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xE5A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_a000_e5a0a01e() {
    // Encoding: 0xE5A0A01E
    // Test ST1D_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Zt=30, Pg=0
    let encoding: u32 = 0xE5A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_64_scaled_field_zt_31_max_a000_e5a0a01f() {
    // Encoding: 0xE5A0A01F
    // Test ST1D_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_combo_0_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1d_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e5a0a3e0() {
    // Encoding: 0xE5A0A3E0
    // Test ST1D_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=31
    let encoding: u32 = 0xE5A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_64_scaled_invalid_0_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_64_scaled_invalid_1_a000_e5a0a000() {
    // Encoding: 0xE5A0A000
    // Test ST1D_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xE5A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zm_0_min_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_e581a000() {
    // Encoding: 0xE581A000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zm=1, Rn=0
    let encoding: u32 = 0xE581A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_e59ea000() {
    // Encoding: 0xE59EA000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zm=30, Pg=0, Rn=0
    let encoding: u32 = 0xE59EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zm_31_max_a000_e59fa000() {
    // Encoding: 0xE59FA000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Zm=31, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE59FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_pg_0_min_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_e580a400() {
    // Encoding: 0xE580A400
    // Test ST1D_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xE580A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_rn_0_min_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zm=0, Zt=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_e580a020() {
    // Encoding: 0xE580A020
    // Test ST1D_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zm=0, Rn=1
    let encoding: u32 = 0xE580A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_e580a3c0() {
    // Encoding: 0xE580A3C0
    // Test ST1D_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xE580A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_rn_31_max_a000_e580a3e0() {
    // Encoding: 0xE580A3E0
    // Test ST1D_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE580A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zt_0_min_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_e580a001() {
    // Encoding: 0xE580A001
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zt=1, Rn=0
    let encoding: u32 = 0xE580A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_e580a01e() {
    // Encoding: 0xE580A01E
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, Zm=0
    let encoding: u32 = 0xE580A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_field_zt_31_max_a000_e580a01f() {
    // Encoding: 0xE580A01F
    // Test ST1D_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=31, Zm=0
    let encoding: u32 = 0xE580A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_combo_0_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e580a3e0() {
    // Encoding: 0xE580A3E0
    // Test ST1D_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, Zm=0, Rn=31
    let encoding: u32 = 0xE580A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_invalid_0_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_invalid_1_a000_e580a000() {
    // Encoding: 0xE580A000
    // Test ST1D_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE580A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_sp_rn_e5a083e0() {
    // Test ST1D_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xE5A083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5A083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.x32.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_bz_d_x32_scaled_store_0_e5a08020() {
    // Test ST1D_Z.P.BZ_D.x32.scaled memory store: 8 bytes
    // Encoding: 0xE5A08020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5A08020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_sp_rn_e58083e0() {
    // Test ST1D_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE58083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE58083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_bz_d_x32_unscaled_store_0_e5808020() {
    // Test ST1D_Z.P.BZ_D.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE5808020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5808020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1d_z_p_bz_d_64_scaled_sp_rn_e5a0a3e0() {
    // Test ST1D_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xE5A0A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5A0A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.64.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_bz_d_64_scaled_store_0_e5a0a020() {
    // Test ST1D_Z.P.BZ_D.64.scaled memory store: 8 bytes
    // Encoding: 0xE5A0A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5A0A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_sp_rn_e580a3e0() {
    // Test ST1D_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xE580A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE580A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1D_Z.P.BZ_D.64.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1d_z_p_bz_d_64_unscaled_store_0_e580a020() {
    // Test ST1D_Z.P.BZ_D.64.unscaled memory store: 8 bytes
    // Encoding: 0xE580A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE580A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2h_z_p_br_contiguous_field_rm_0_min_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2h_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4a16000() {
    // Encoding: 0xE4A16000
    // Test ST2H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xE4A16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2h_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e4be6000() {
    // Encoding: 0xE4BE6000
    // Test ST2H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4BE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st2h_z_p_br_contiguous_field_rm_31_max_6000_e4bf6000() {
    // Encoding: 0xE4BF6000
    // Test ST2H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Zt=0, Rn=0
    let encoding: u32 = 0xE4BF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2h_z_p_br_contiguous_field_pg_0_min_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2h_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4a06400() {
    // Encoding: 0xE4A06400
    // Test ST2H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=1
    let encoding: u32 = 0xE4A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2h_z_p_br_contiguous_field_rn_0_min_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2h_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4a06020() {
    // Encoding: 0xE4A06020
    // Test ST2H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4A06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2h_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e4a063c0() {
    // Encoding: 0xE4A063C0
    // Test ST2H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xE4A063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2h_z_p_br_contiguous_field_rn_31_max_6000_e4a063e0() {
    // Encoding: 0xE4A063E0
    // Test ST2H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=31
    let encoding: u32 = 0xE4A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2h_z_p_br_contiguous_field_zt_0_min_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2h_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4a06001() {
    // Encoding: 0xE4A06001
    // Test ST2H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rn=0, Rm=0
    let encoding: u32 = 0xE4A06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2h_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e4a0601e() {
    // Encoding: 0xE4A0601E
    // Test ST2H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4A0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2h_z_p_br_contiguous_field_zt_31_max_6000_e4a0601f() {
    // Encoding: 0xE4A0601F
    // Test ST2H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4A0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st2h_z_p_br_contiguous_combo_0_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e4a063e0() {
    // Encoding: 0xE4A063E0
    // Test ST2H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, Rm=0
    let encoding: u32 = 0xE4A063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2h_z_p_br_contiguous_invalid_0_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2h_z_p_br_contiguous_invalid_1_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st2h_z_p_br_contiguous_invalid_2_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2h_z_p_br_contiguous_invalid_3_6000_e4a06000() {
    // Encoding: 0xE4A06000
    // Test ST2H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2h_z_p_br_contiguous_sp_rn_e4a063e0() {
    // Test ST2H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE4A063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4A063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2H_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2h_z_p_br_contiguous_store_0_e4a06020() {
    // Test ST2H_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4A06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4A06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_0_zero_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e511e000() {
    // Encoding: 0xE511E000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE511E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e513e000() {
    // Encoding: 0xE513E000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm4=3, Rn=0
    let encoding: u32 = 0xE513E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e514e000() {
    // Encoding: 0xE514E000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm4=4, Rn=0
    let encoding: u32 = 0xE514E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e517e000() {
    // Encoding: 0xE517E000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE517E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e518e000() {
    // Encoding: 0xE518E000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=8
    let encoding: u32 = 0xE518E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_imm4_15_max_e000_e51fe000() {
    // Encoding: 0xE51FE000
    // Test STNT1W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, imm4=15, Pg=0, Zt=0
    let encoding: u32 = 0xE51FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_pg_0_min_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e510e400() {
    // Encoding: 0xE510E400
    // Test STNT1W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xE510E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_rn_0_min_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e510e020() {
    // Encoding: 0xE510E020
    // Test STNT1W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=1
    let encoding: u32 = 0xE510E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e510e3c0() {
    // Encoding: 0xE510E3C0
    // Test STNT1W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xE510E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_rn_31_max_e000_e510e3e0() {
    // Encoding: 0xE510E3E0
    // Test STNT1W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=31
    let encoding: u32 = 0xE510E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_zt_0_min_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e510e001() {
    // Encoding: 0xE510E001
    // Test STNT1W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xE510E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e510e01e() {
    // Encoding: 0xE510E01E
    // Test STNT1W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Zt=30, Rn=0
    let encoding: u32 = 0xE510E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1w_z_p_bi_contiguous_field_zt_31_max_e000_e510e01f() {
    // Encoding: 0xE510E01F
    // Test STNT1W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE510E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_stnt1w_z_p_bi_contiguous_combo_0_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Pg=0, imm4=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e510e3e0() {
    // Encoding: 0xE510E3E0
    // Test STNT1W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE510E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1w_z_p_bi_contiguous_invalid_0_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1w_z_p_bi_contiguous_invalid_1_e000_e510e000() {
    // Encoding: 0xE510E000
    // Test STNT1W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE510E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1w_z_p_bi_contiguous_sp_rn_e510e3e0() {
    // Test STNT1W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE510E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE510E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1W_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1w_z_p_bi_contiguous_store_0_e510e020() {
    // Test STNT1W_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE510E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE510E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_0_zero_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e5f1e000() {
    // Encoding: 0xE5F1E000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Pg=0, Zt=0
    let encoding: u32 = 0xE5F1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e5f3e000() {
    // Encoding: 0xE5F3E000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5F3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e5f4e000() {
    // Encoding: 0xE5F4E000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5F4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e5f7e000() {
    // Encoding: 0xE5F7E000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Pg=0, Zt=0
    let encoding: u32 = 0xE5F7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e5f8e000() {
    // Encoding: 0xE5F8E000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Rn=0, Zt=0
    let encoding: u32 = 0xE5F8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st4d_z_p_bi_contiguous_field_imm4_15_max_e000_e5ffe000() {
    // Encoding: 0xE5FFE000
    // Test ST4D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5FFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4d_z_p_bi_contiguous_field_pg_0_min_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e5f0e400() {
    // Encoding: 0xE5F0E400
    // Test ST4D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE5F0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4d_z_p_bi_contiguous_field_rn_0_min_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e5f0e020() {
    // Encoding: 0xE5F0E020
    // Test ST4D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, imm4=0
    let encoding: u32 = 0xE5F0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e5f0e3c0() {
    // Encoding: 0xE5F0E3C0
    // Test ST4D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=0, Rn=30, Zt=0
    let encoding: u32 = 0xE5F0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4d_z_p_bi_contiguous_field_rn_31_max_e000_e5f0e3e0() {
    // Encoding: 0xE5F0E3E0
    // Test ST4D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, Zt=0, Rn=31, imm4=0
    let encoding: u32 = 0xE5F0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4d_z_p_bi_contiguous_field_zt_0_min_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e5f0e001() {
    // Encoding: 0xE5F0E001
    // Test ST4D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xE5F0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e5f0e01e() {
    // Encoding: 0xE5F0E01E
    // Test ST4D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Rn=0, imm4=0
    let encoding: u32 = 0xE5F0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4d_z_p_bi_contiguous_field_zt_31_max_e000_e5f0e01f() {
    // Encoding: 0xE5F0E01F
    // Test ST4D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, imm4=0, Pg=0
    let encoding: u32 = 0xE5F0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st4d_z_p_bi_contiguous_combo_0_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e5f0e3e0() {
    // Encoding: 0xE5F0E3E0
    // Test ST4D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE5F0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4d_z_p_bi_contiguous_invalid_0_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4d_z_p_bi_contiguous_invalid_1_e000_e5f0e000() {
    // Encoding: 0xE5F0E000
    // Test ST4D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5F0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4d_z_p_bi_contiguous_sp_rn_e5f0e3e0() {
    // Test ST4D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE5F0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5F0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4D_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4d_z_p_bi_contiguous_store_0_e5f0e020() {
    // Test ST4D_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE5F0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE5F0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3D_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3d_z_p_br_contiguous_field_rm_0_min_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3d_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5c16000() {
    // Encoding: 0xE5C16000
    // Test ST3D_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5C16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3d_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e5de6000() {
    // Encoding: 0xE5DE6000
    // Test ST3D_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=30
    let encoding: u32 = 0xE5DE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st3d_z_p_br_contiguous_field_rm_31_max_6000_e5df6000() {
    // Encoding: 0xE5DF6000
    // Test ST3D_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=31
    let encoding: u32 = 0xE5DF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3d_z_p_br_contiguous_field_pg_0_min_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3d_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5c06400() {
    // Encoding: 0xE5C06400
    // Test ST3D_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=1
    let encoding: u32 = 0xE5C06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3d_z_p_br_contiguous_field_rn_0_min_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3d_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5c06020() {
    // Encoding: 0xE5C06020
    // Test ST3D_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5C06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3d_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e5c063c0() {
    // Encoding: 0xE5C063C0
    // Test ST3D_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE5C063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3d_z_p_br_contiguous_field_rn_31_max_6000_e5c063e0() {
    // Encoding: 0xE5C063E0
    // Test ST3D_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3d_z_p_br_contiguous_field_zt_0_min_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3d_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5c06001() {
    // Encoding: 0xE5C06001
    // Test ST3D_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Pg=0, Rm=0
    let encoding: u32 = 0xE5C06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3d_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e5c0601e() {
    // Encoding: 0xE5C0601E
    // Test ST3D_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xE5C0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3d_z_p_br_contiguous_field_zt_31_max_6000_e5c0601f() {
    // Encoding: 0xE5C0601F
    // Test ST3D_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Rm=0, Zt=31
    let encoding: u32 = 0xE5C0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st3d_z_p_br_contiguous_combo_0_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3d_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e5c063e0() {
    // Encoding: 0xE5C063E0
    // Test ST3D_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5C063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3d_z_p_br_contiguous_invalid_0_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3d_z_p_br_contiguous_invalid_1_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st3d_z_p_br_contiguous_invalid_2_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3d_z_p_br_contiguous_invalid_3_6000_e5c06000() {
    // Encoding: 0xE5C06000
    // Test ST3D_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE5C06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3d_z_p_br_contiguous_sp_rn_e5c063e0() {
    // Test ST3D_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE5C063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5C063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3D_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3d_z_p_br_contiguous_store_0_e5c06020() {
    // Test ST3D_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5C06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5C06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1B_Z.P.BR__ Tests
// ============================================================================

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1b_z_p_br_field_size_0_min_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ field size = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, size=0, Zt=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1b_z_p_br_field_size_1_poweroftwo_4000_e4204000() {
    // Encoding: 0xE4204000
    // Test ST1B_Z.P.BR__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, size=1, Zt=0, Rm=0
    let encoding: u32 = 0xE4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1b_z_p_br_field_size_2_poweroftwo_4000_e4404000() {
    // Encoding: 0xE4404000
    // Test ST1B_Z.P.BR__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1b_z_p_br_field_size_3_max_4000_e4604000() {
    // Encoding: 0xE4604000
    // Test ST1B_Z.P.BR__ field size = 3 (Max)
    // Fields: Zt=0, Pg=0, Rm=0, size=3, Rn=0
    let encoding: u32 = 0xE4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_br_field_rm_0_min_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ field Rm = 0 (Min)
    // Fields: Rn=0, size=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_br_field_rm_1_poweroftwo_4000_e4014000() {
    // Encoding: 0xE4014000
    // Test ST1B_Z.P.BR__ field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, size=0, Rm=1, Pg=0
    let encoding: u32 = 0xE4014000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1b_z_p_br_field_rm_30_poweroftwominusone_4000_e41e4000() {
    // Encoding: 0xE41E4000
    // Test ST1B_Z.P.BR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=0, Zt=0, Pg=0, Rm=30
    let encoding: u32 = 0xE41E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st1b_z_p_br_field_rm_31_max_4000_e41f4000() {
    // Encoding: 0xE41F4000
    // Test ST1B_Z.P.BR__ field Rm = 31 (Max)
    // Fields: Pg=0, size=0, Rm=31, Rn=0, Zt=0
    let encoding: u32 = 0xE41F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_br_field_pg_0_min_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ field Pg = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, size=0, Rm=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_br_field_pg_1_poweroftwo_4000_e4004400() {
    // Encoding: 0xE4004400
    // Test ST1B_Z.P.BR__ field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Rm=0, Pg=1, size=0
    let encoding: u32 = 0xE4004400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_br_field_rn_0_min_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ field Rn = 0 (Min)
    // Fields: Rm=0, size=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_br_field_rn_1_poweroftwo_4000_e4004020() {
    // Encoding: 0xE4004020
    // Test ST1B_Z.P.BR__ field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, size=0, Zt=0, Rn=1
    let encoding: u32 = 0xE4004020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1b_z_p_br_field_rn_30_poweroftwominusone_4000_e40043c0() {
    // Encoding: 0xE40043C0
    // Test ST1B_Z.P.BR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zt=0, Rm=0, Rn=30
    let encoding: u32 = 0xE40043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1b_z_p_br_field_rn_31_max_4000_e40043e0() {
    // Encoding: 0xE40043E0
    // Test ST1B_Z.P.BR__ field Rn = 31 (Max)
    // Fields: Pg=0, Rm=0, Rn=31, Zt=0, size=0
    let encoding: u32 = 0xE40043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_br_field_zt_0_min_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ field Zt = 0 (Min)
    // Fields: size=0, Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_br_field_zt_1_poweroftwo_4000_e4004001() {
    // Encoding: 0xE4004001
    // Test ST1B_Z.P.BR__ field Zt = 1 (PowerOfTwo)
    // Fields: Rm=0, size=0, Rn=0, Zt=1, Pg=0
    let encoding: u32 = 0xE4004001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_br_field_zt_30_poweroftwominusone_4000_e400401e() {
    // Encoding: 0xE400401E
    // Test ST1B_Z.P.BR__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rn=0, Pg=0, size=0, Rm=0
    let encoding: u32 = 0xE400401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_br_field_zt_31_max_4000_e400401f() {
    // Encoding: 0xE400401F
    // Test ST1B_Z.P.BR__ field Zt = 31 (Max)
    // Fields: Pg=0, Rn=0, size=0, Zt=31, Rm=0
    let encoding: u32 = 0xE400401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1b_z_p_br_combo_0_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: size=0, Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1b_z_p_br_special_size_0_size_variant_0_16384_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ special value size = 0 (Size variant 0)
    // Fields: Zt=0, Rn=0, Rm=0, size=0, Pg=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1b_z_p_br_special_size_1_size_variant_1_16384_e4204000() {
    // Encoding: 0xE4204000
    // Test ST1B_Z.P.BR__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1b_z_p_br_special_size_2_size_variant_2_16384_e4404000() {
    // Encoding: 0xE4404000
    // Test ST1B_Z.P.BR__ special value size = 2 (Size variant 2)
    // Fields: Rm=0, Pg=0, Rn=0, size=2, Zt=0
    let encoding: u32 = 0xE4404000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1b_z_p_br_special_size_3_size_variant_3_16384_e4604000() {
    // Encoding: 0xE4604000
    // Test ST1B_Z.P.BR__ special value size = 3 (Size variant 3)
    // Fields: Rm=0, Rn=0, size=3, Pg=0, Zt=0
    let encoding: u32 = 0xE4604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1b_z_p_br_special_rn_31_stack_pointer_sp_may_require_alignment_16384_e40043e0() {
    // Encoding: 0xE40043E0
    // Test ST1B_Z.P.BR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, size=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE40043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_br_invalid_0_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, size=0, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_br_invalid_1_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_br_invalid_2_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rn=0, Pg=0, Rm=0, size=0, Zt=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_br_invalid_3_4000_e4004000() {
    // Encoding: 0xE4004000
    // Test ST1B_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0, size=0
    let encoding: u32 = 0xE4004000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1b_z_p_br_sp_rn_e40043e0() {
    // Test ST1B_Z.P.BR__ with Rn = SP (31)
    // Encoding: 0xE40043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE40043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.BR__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_br_store_0_e4004020() {
    // Test ST1B_Z.P.BR__ memory store: 8 bytes
    // Encoding: 0xE4004020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4004020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1B_Z.P.AI_S Tests
// ============================================================================

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1b_z_p_ai_s_field_imm5_0_zero_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1b_z_p_ai_s_field_imm5_1_poweroftwo_a000_e461a000() {
    // Encoding: 0xE461A000
    // Test ST1B_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: imm5=1, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE461A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1b_z_p_ai_s_field_imm5_3_poweroftwominusone_a000_e463a000() {
    // Encoding: 0xE463A000
    // Test ST1B_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, imm5=3, Zn=0
    let encoding: u32 = 0xE463A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1b_z_p_ai_s_field_imm5_4_poweroftwo_a000_e464a000() {
    // Encoding: 0xE464A000
    // Test ST1B_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: imm5=4, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xE464A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1b_z_p_ai_s_field_imm5_7_poweroftwominusone_a000_e467a000() {
    // Encoding: 0xE467A000
    // Test ST1B_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=7
    let encoding: u32 = 0xE467A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1b_z_p_ai_s_field_imm5_8_poweroftwo_a000_e468a000() {
    // Encoding: 0xE468A000
    // Test ST1B_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, imm5=8, Zn=0, Pg=0
    let encoding: u32 = 0xE468A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1b_z_p_ai_s_field_imm5_15_poweroftwominusone_a000_e46fa000() {
    // Encoding: 0xE46FA000
    // Test ST1B_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm5=15, Zn=0, Zt=0
    let encoding: u32 = 0xE46FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1b_z_p_ai_s_field_imm5_16_poweroftwo_a000_e470a000() {
    // Encoding: 0xE470A000
    // Test ST1B_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xE470A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1b_z_p_ai_s_field_imm5_31_max_a000_e47fa000() {
    // Encoding: 0xE47FA000
    // Test ST1B_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zt=0, imm5=31, Pg=0, Zn=0
    let encoding: u32 = 0xE47FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_ai_s_field_pg_0_min_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Pg=0, Zt=0, imm5=0, Zn=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_ai_s_field_pg_1_poweroftwo_a000_e460a400() {
    // Encoding: 0xE460A400
    // Test ST1B_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xE460A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_ai_s_field_zn_0_min_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S field Zn = 0 (Min)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_ai_s_field_zn_1_poweroftwo_a000_e460a020() {
    // Encoding: 0xE460A020
    // Test ST1B_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=1
    let encoding: u32 = 0xE460A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_ai_s_field_zn_30_poweroftwominusone_a000_e460a3c0() {
    // Encoding: 0xE460A3C0
    // Test ST1B_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xE460A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_ai_s_field_zn_31_max_a000_e460a3e0() {
    // Encoding: 0xE460A3E0
    // Test ST1B_Z.P.AI_S field Zn = 31 (Max)
    // Fields: imm5=0, Zn=31, Zt=0, Pg=0
    let encoding: u32 = 0xE460A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_ai_s_field_zt_0_min_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_ai_s_field_zt_1_poweroftwo_a000_e460a001() {
    // Encoding: 0xE460A001
    // Test ST1B_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=1, imm5=0
    let encoding: u32 = 0xE460A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_ai_s_field_zt_30_poweroftwominusone_a000_e460a01e() {
    // Encoding: 0xE460A01E
    // Test ST1B_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=30, Pg=0, imm5=0
    let encoding: u32 = 0xE460A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_ai_s_field_zt_31_max_a000_e460a01f() {
    // Encoding: 0xE460A01F
    // Test ST1B_Z.P.AI_S field Zt = 31 (Max)
    // Fields: imm5=0, Zn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE460A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1b_z_p_ai_s_combo_0_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_ai_s_invalid_0_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, Zn=0, imm5=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_ai_s_invalid_1_a000_e460a000() {
    // Encoding: 0xE460A000
    // Test ST1B_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zt=0, imm5=0, Pg=0
    let encoding: u32 = 0xE460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1b_z_p_ai_d_field_imm5_0_zero_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: Pg=0, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1b_z_p_ai_d_field_imm5_1_poweroftwo_a000_e441a000() {
    // Encoding: 0xE441A000
    // Test ST1B_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=1, Zn=0, Pg=0
    let encoding: u32 = 0xE441A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1b_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_e443a000() {
    // Encoding: 0xE443A000
    // Test ST1B_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=3, Pg=0, Zn=0
    let encoding: u32 = 0xE443A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1b_z_p_ai_d_field_imm5_4_poweroftwo_a000_e444a000() {
    // Encoding: 0xE444A000
    // Test ST1B_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm5=4, Pg=0, Zn=0
    let encoding: u32 = 0xE444A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1b_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_e447a000() {
    // Encoding: 0xE447A000
    // Test ST1B_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zt=0, imm5=7, Pg=0
    let encoding: u32 = 0xE447A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1b_z_p_ai_d_field_imm5_8_poweroftwo_a000_e448a000() {
    // Encoding: 0xE448A000
    // Test ST1B_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm5=8, Zt=0, Zn=0
    let encoding: u32 = 0xE448A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1b_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_e44fa000() {
    // Encoding: 0xE44FA000
    // Test ST1B_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE44FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1b_z_p_ai_d_field_imm5_16_poweroftwo_a000_e450a000() {
    // Encoding: 0xE450A000
    // Test ST1B_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, imm5=16, Pg=0, Zt=0
    let encoding: u32 = 0xE450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1b_z_p_ai_d_field_imm5_31_max_a000_e45fa000() {
    // Encoding: 0xE45FA000
    // Test ST1B_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: imm5=31, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xE45FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1b_z_p_ai_d_field_pg_0_min_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1b_z_p_ai_d_field_pg_1_poweroftwo_a000_e440a400() {
    // Encoding: 0xE440A400
    // Test ST1B_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, imm5=0, Zt=0, Zn=0
    let encoding: u32 = 0xE440A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_ai_d_field_zn_0_min_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D field Zn = 0 (Min)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_ai_d_field_zn_1_poweroftwo_a000_e440a020() {
    // Encoding: 0xE440A020
    // Test ST1B_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=1
    let encoding: u32 = 0xE440A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_ai_d_field_zn_30_poweroftwominusone_a000_e440a3c0() {
    // Encoding: 0xE440A3C0
    // Test ST1B_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, imm5=0, Zt=0
    let encoding: u32 = 0xE440A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_ai_d_field_zn_31_max_a000_e440a3e0() {
    // Encoding: 0xE440A3E0
    // Test ST1B_Z.P.AI_D field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, imm5=0, Zt=0
    let encoding: u32 = 0xE440A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1b_z_p_ai_d_field_zt_0_min_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D field Zt = 0 (Min)
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1b_z_p_ai_d_field_zt_1_poweroftwo_a000_e440a001() {
    // Encoding: 0xE440A001
    // Test ST1B_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zt=1, imm5=0
    let encoding: u32 = 0xE440A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1b_z_p_ai_d_field_zt_30_poweroftwominusone_a000_e440a01e() {
    // Encoding: 0xE440A01E
    // Test ST1B_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xE440A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1b_z_p_ai_d_field_zt_31_max_a000_e440a01f() {
    // Encoding: 0xE440A01F
    // Test ST1B_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=31
    let encoding: u32 = 0xE440A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1b_z_p_ai_d_combo_0_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: Pg=0, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_ai_d_invalid_0_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1b_z_p_ai_d_invalid_1_a000_e440a000() {
    // Encoding: 0xE440A000
    // Test ST1B_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xE440A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1B_Z.P.AI_S
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_ai_s_store_0_e460a000() {
    // Test ST1B_Z.P.AI_S memory store: 8 bytes
    // Encoding: 0xE460A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE460A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1B_Z.P.AI_D
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1b_z_p_ai_d_store_0_e440a000() {
    // Test ST1B_Z.P.AI_D memory store: 8 bytes
    // Encoding: 0xE440A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE440A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_0_zero_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e571e000() {
    // Encoding: 0xE571E000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE571E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e573e000() {
    // Encoding: 0xE573E000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=3, Pg=0, Zt=0
    let encoding: u32 = 0xE573E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e574e000() {
    // Encoding: 0xE574E000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE574E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e577e000() {
    // Encoding: 0xE577E000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=7, Pg=0, Zt=0
    let encoding: u32 = 0xE577E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e578e000() {
    // Encoding: 0xE578E000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, imm4=8, Zt=0, Pg=0
    let encoding: u32 = 0xE578E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st4w_z_p_bi_contiguous_field_imm4_15_max_e000_e57fe000() {
    // Encoding: 0xE57FE000
    // Test ST4W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE57FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4w_z_p_bi_contiguous_field_pg_0_min_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e570e400() {
    // Encoding: 0xE570E400
    // Test ST4W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE570E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4w_z_p_bi_contiguous_field_rn_0_min_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e570e020() {
    // Encoding: 0xE570E020
    // Test ST4W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, imm4=0, Pg=0
    let encoding: u32 = 0xE570E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e570e3c0() {
    // Encoding: 0xE570E3C0
    // Test ST4W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=0, Rn=30, Pg=0
    let encoding: u32 = 0xE570E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4w_z_p_bi_contiguous_field_rn_31_max_e000_e570e3e0() {
    // Encoding: 0xE570E3E0
    // Test ST4W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Pg=0, imm4=0, Rn=31, Zt=0
    let encoding: u32 = 0xE570E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4w_z_p_bi_contiguous_field_zt_0_min_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e570e001() {
    // Encoding: 0xE570E001
    // Test ST4W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE570E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e570e01e() {
    // Encoding: 0xE570E01E
    // Test ST4W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, imm4=0, Rn=0, Pg=0
    let encoding: u32 = 0xE570E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4w_z_p_bi_contiguous_field_zt_31_max_e000_e570e01f() {
    // Encoding: 0xE570E01F
    // Test ST4W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, imm4=0, Rn=0
    let encoding: u32 = 0xE570E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st4w_z_p_bi_contiguous_combo_0_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e570e3e0() {
    // Encoding: 0xE570E3E0
    // Test ST4W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE570E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4w_z_p_bi_contiguous_invalid_0_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4w_z_p_bi_contiguous_invalid_1_e000_e570e000() {
    // Encoding: 0xE570E000
    // Test ST4W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xE570E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4w_z_p_bi_contiguous_sp_rn_e570e3e0() {
    // Test ST4W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE570E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE570E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4W_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4w_z_p_bi_contiguous_store_0_e570e020() {
    // Test ST4W_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE570E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE570E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3W_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3w_z_p_br_contiguous_field_rm_0_min_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3w_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e5416000() {
    // Encoding: 0xE5416000
    // Test ST3W_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Pg=0, Rm=1
    let encoding: u32 = 0xE5416000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3w_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e55e6000() {
    // Encoding: 0xE55E6000
    // Test ST3W_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Rm=30, Zt=0
    let encoding: u32 = 0xE55E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st3w_z_p_br_contiguous_field_rm_31_max_6000_e55f6000() {
    // Encoding: 0xE55F6000
    // Test ST3W_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Zt=0, Pg=0, Rm=31, Rn=0
    let encoding: u32 = 0xE55F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3w_z_p_br_contiguous_field_pg_0_min_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3w_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e5406400() {
    // Encoding: 0xE5406400
    // Test ST3W_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=1
    let encoding: u32 = 0xE5406400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3w_z_p_br_contiguous_field_rn_0_min_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3w_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e5406020() {
    // Encoding: 0xE5406020
    // Test ST3W_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rn=1, Rm=0
    let encoding: u32 = 0xE5406020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3w_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e54063c0() {
    // Encoding: 0xE54063C0
    // Test ST3W_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Rn=30, Zt=0
    let encoding: u32 = 0xE54063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3w_z_p_br_contiguous_field_rn_31_max_6000_e54063e0() {
    // Encoding: 0xE54063E0
    // Test ST3W_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=31
    let encoding: u32 = 0xE54063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3w_z_p_br_contiguous_field_zt_0_min_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3w_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e5406001() {
    // Encoding: 0xE5406001
    // Test ST3W_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=1, Rm=0, Rn=0
    let encoding: u32 = 0xE5406001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3w_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e540601e() {
    // Encoding: 0xE540601E
    // Test ST3W_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE540601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3w_z_p_br_contiguous_field_zt_31_max_6000_e540601f() {
    // Encoding: 0xE540601F
    // Test ST3W_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rm=0, Zt=31, Pg=0, Rn=0
    let encoding: u32 = 0xE540601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st3w_z_p_br_contiguous_combo_0_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3w_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e54063e0() {
    // Encoding: 0xE54063E0
    // Test ST3W_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Rm=0, Zt=0
    let encoding: u32 = 0xE54063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3w_z_p_br_contiguous_invalid_0_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3w_z_p_br_contiguous_invalid_1_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st3w_z_p_br_contiguous_invalid_2_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3w_z_p_br_contiguous_invalid_3_6000_e5406000() {
    // Encoding: 0xE5406000
    // Test ST3W_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Rm=0, Zt=0
    let encoding: u32 = 0xE5406000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3w_z_p_br_contiguous_sp_rn_e54063e0() {
    // Test ST3W_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE54063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE54063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3W_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3w_z_p_br_contiguous_store_0_e5406020() {
    // Test ST3W_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE5406020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE5406020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1W_Z.P.BZ_S.x32.scaled Tests
// ============================================================================

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zm_0_min_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zm = 0 (Min)
    // Fields: Rn=0, Pg=0, xs=0, Zm=0, Zt=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zm_1_poweroftwo_8000_e5618000() {
    // Encoding: 0xE5618000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, xs=0, Rn=0, Zm=1
    let encoding: u32 = 0xE5618000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zm_30_poweroftwominusone_8000_e57e8000() {
    // Encoding: 0xE57E8000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE57E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zm_31_max_8000_e57f8000() {
    // Encoding: 0xE57F8000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zm = 31 (Max)
    // Fields: xs=0, Pg=0, Zm=31, Rn=0, Zt=0
    let encoding: u32 = 0xE57F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_xs_0_min_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled field xs = 0 (Min)
    // Fields: Rn=0, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_xs_1_max_8000_e560c000() {
    // Encoding: 0xE560C000
    // Test ST1W_Z.P.BZ_S.x32.scaled field xs = 1 (Max)
    // Fields: Zm=0, Pg=0, xs=1, Rn=0, Zt=0
    let encoding: u32 = 0xE560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_pg_0_min_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_pg_1_poweroftwo_8000_e5608400() {
    // Encoding: 0xE5608400
    // Test ST1W_Z.P.BZ_S.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xE5608400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_rn_0_min_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Rn = 0 (Min)
    // Fields: Zt=0, xs=0, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_rn_1_poweroftwo_8000_e5608020() {
    // Encoding: 0xE5608020
    // Test ST1W_Z.P.BZ_S.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Rn=1, Pg=0, Zm=0
    let encoding: u32 = 0xE5608020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_rn_30_poweroftwominusone_8000_e56083c0() {
    // Encoding: 0xE56083C0
    // Test ST1W_Z.P.BZ_S.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Zm=0, Pg=0, Rn=30
    let encoding: u32 = 0xE56083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_rn_31_max_8000_e56083e0() {
    // Encoding: 0xE56083E0
    // Test ST1W_Z.P.BZ_S.x32.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, Rn=31, Zm=0, xs=0
    let encoding: u32 = 0xE56083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zt_0_min_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zt = 0 (Min)
    // Fields: Rn=0, Zm=0, xs=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zt_1_poweroftwo_8000_e5608001() {
    // Encoding: 0xE5608001
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, xs=0, Rn=0, Pg=0, Zt=1
    let encoding: u32 = 0xE5608001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zt_30_poweroftwominusone_8000_e560801e() {
    // Encoding: 0xE560801E
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=0, Zt=30, Zm=0, Pg=0
    let encoding: u32 = 0xE560801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_field_zt_31_max_8000_e560801f() {
    // Encoding: 0xE560801F
    // Test ST1W_Z.P.BZ_S.x32.scaled field Zt = 31 (Max)
    // Fields: Pg=0, Zt=31, Rn=0, Zm=0, xs=0
    let encoding: u32 = 0xE560801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_combo_0_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e56083e0() {
    // Encoding: 0xE56083E0
    // Test ST1W_Z.P.BZ_S.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zm=0, xs=0, Rn=31, Zt=0
    let encoding: u32 = 0xE56083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_invalid_0_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Rn=0, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_invalid_1_8000_e5608000() {
    // Encoding: 0xE5608000
    // Test ST1W_Z.P.BZ_S.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zm_0_min_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Rn=0, xs=0, Zt=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zm_1_poweroftwo_8000_e5218000() {
    // Encoding: 0xE5218000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Zm=1, Pg=0, Rn=0
    let encoding: u32 = 0xE5218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zm_30_poweroftwominusone_8000_e53e8000() {
    // Encoding: 0xE53E8000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, xs=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE53E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zm_31_max_8000_e53f8000() {
    // Encoding: 0xE53F8000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zm = 31 (Max)
    // Fields: Zm=31, Zt=0, xs=0, Pg=0, Rn=0
    let encoding: u32 = 0xE53F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_xs_0_min_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled field xs = 0 (Min)
    // Fields: xs=0, Zt=0, Pg=0, Rn=0, Zm=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_xs_1_max_8000_e520c000() {
    // Encoding: 0xE520C000
    // Test ST1W_Z.P.BZ_D.x32.scaled field xs = 1 (Max)
    // Fields: Zt=0, xs=1, Rn=0, Pg=0, Zm=0
    let encoding: u32 = 0xE520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_pg_0_min_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Pg = 0 (Min)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_pg_1_poweroftwo_8000_e5208400() {
    // Encoding: 0xE5208400
    // Test ST1W_Z.P.BZ_D.x32.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=1, xs=0
    let encoding: u32 = 0xE5208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_rn_0_min_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_rn_1_poweroftwo_8000_e5208020() {
    // Encoding: 0xE5208020
    // Test ST1W_Z.P.BZ_D.x32.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Zm=0, Rn=1, Pg=0, xs=0, Zt=0
    let encoding: u32 = 0xE5208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_rn_30_poweroftwominusone_8000_e52083c0() {
    // Encoding: 0xE52083C0
    // Test ST1W_Z.P.BZ_D.x32.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Rn=30, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xE52083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_rn_31_max_8000_e52083e0() {
    // Encoding: 0xE52083E0
    // Test ST1W_Z.P.BZ_D.x32.scaled field Rn = 31 (Max)
    // Fields: Pg=0, Zm=0, Rn=31, Zt=0, xs=0
    let encoding: u32 = 0xE52083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zt_0_min_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zt = 0 (Min)
    // Fields: xs=0, Rn=0, Pg=0, Zt=0, Zm=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zt_1_poweroftwo_8000_e5208001() {
    // Encoding: 0xE5208001
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zt=1, Pg=0, Zm=0
    let encoding: u32 = 0xE5208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zt_30_poweroftwominusone_8000_e520801e() {
    // Encoding: 0xE520801E
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Pg=0, Rn=0, Zt=30
    let encoding: u32 = 0xE520801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_field_zt_31_max_8000_e520801f() {
    // Encoding: 0xE520801F
    // Test ST1W_Z.P.BZ_D.x32.scaled field Zt = 31 (Max)
    // Fields: xs=0, Pg=0, Rn=0, Zt=31, Zm=0
    let encoding: u32 = 0xE520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_combo_0_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, xs=0, Rn=0, Pg=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e52083e0() {
    // Encoding: 0xE52083E0
    // Test ST1W_Z.P.BZ_D.x32.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Pg=0, xs=0, Rn=31
    let encoding: u32 = 0xE52083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_invalid_0_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, xs=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_invalid_1_8000_e5208000() {
    // Encoding: 0xE5208000
    // Test ST1W_Z.P.BZ_D.x32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, Zm=0, xs=0, Zt=0
    let encoding: u32 = 0xE5208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zm_0_min_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zm = 0 (Min)
    // Fields: Rn=0, Zt=0, xs=0, Pg=0, Zm=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zm_1_poweroftwo_8000_e5018000() {
    // Encoding: 0xE5018000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=1, Rn=0, Zt=0, xs=0
    let encoding: u32 = 0xE5018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zm_30_poweroftwominusone_8000_e51e8000() {
    // Encoding: 0xE51E8000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=30
    let encoding: u32 = 0xE51E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zm_31_max_8000_e51f8000() {
    // Encoding: 0xE51F8000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zm = 31 (Max)
    // Fields: Rn=0, Zm=31, Pg=0, Zt=0, xs=0
    let encoding: u32 = 0xE51F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_xs_0_min_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field xs = 0 (Min)
    // Fields: Zt=0, Pg=0, Zm=0, xs=0, Rn=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_xs_1_max_8000_e500c000() {
    // Encoding: 0xE500C000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field xs = 1 (Max)
    // Fields: Rn=0, Zt=0, Pg=0, xs=1, Zm=0
    let encoding: u32 = 0xE500C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_pg_0_min_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, xs=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_pg_1_poweroftwo_8000_e5008400() {
    // Encoding: 0xE5008400
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, xs=0, Pg=1, Zm=0, Rn=0
    let encoding: u32 = 0xE5008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_rn_0_min_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Rn = 0 (Min)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_rn_1_poweroftwo_8000_e5008020() {
    // Encoding: 0xE5008020
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: xs=0, Pg=0, Zt=0, Zm=0, Rn=1
    let encoding: u32 = 0xE5008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_rn_30_poweroftwominusone_8000_e50083c0() {
    // Encoding: 0xE50083C0
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xE50083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_rn_31_max_8000_e50083e0() {
    // Encoding: 0xE50083E0
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Rn = 31 (Max)
    // Fields: Rn=31, Zm=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xE50083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zt_0_min_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0, xs=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zt_1_poweroftwo_8000_e5008001() {
    // Encoding: 0xE5008001
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, xs=0, Zt=1, Pg=0
    let encoding: u32 = 0xE5008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zt_30_poweroftwominusone_8000_e500801e() {
    // Encoding: 0xE500801E
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, xs=0, Pg=0, Zt=30, Zm=0
    let encoding: u32 = 0xE500801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_field_zt_31_max_8000_e500801f() {
    // Encoding: 0xE500801F
    // Test ST1W_Z.P.BZ_D.x32.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xE500801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_combo_0_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: xs=0, Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e50083e0() {
    // Encoding: 0xE50083E0
    // Test ST1W_Z.P.BZ_D.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, xs=0, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE50083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_invalid_0_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zt=0, Rn=0, xs=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_invalid_1_8000_e5008000() {
    // Encoding: 0xE5008000
    // Test ST1W_Z.P.BZ_D.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, xs=0, Pg=0, Zm=0, Rn=0
    let encoding: u32 = 0xE5008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zm_0_min_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zm = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zm_1_poweroftwo_8000_e5418000() {
    // Encoding: 0xE5418000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Zt=0, Pg=0, Zm=1
    let encoding: u32 = 0xE5418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zm_30_poweroftwominusone_8000_e55e8000() {
    // Encoding: 0xE55E8000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, xs=0, Pg=0, Rn=0, Zm=30
    let encoding: u32 = 0xE55E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zm_31_max_8000_e55f8000() {
    // Encoding: 0xE55F8000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zm = 31 (Max)
    // Fields: xs=0, Rn=0, Pg=0, Zt=0, Zm=31
    let encoding: u32 = 0xE55F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_xs_0_min_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field xs = 0 (Min)
    // Fields: Pg=0, Zt=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field xs 14 +: 1`
/// Requirement: FieldBoundary { field: "xs", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_xs_1_max_8000_e540c000() {
    // Encoding: 0xE540C000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field xs = 1 (Max)
    // Fields: Pg=0, Rn=0, xs=1, Zt=0, Zm=0
    let encoding: u32 = 0xE540C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_pg_0_min_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Pg = 0 (Min)
    // Fields: Zt=0, Pg=0, xs=0, Rn=0, Zm=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_pg_1_poweroftwo_8000_e5408400() {
    // Encoding: 0xE5408400
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Zt=0, xs=0, Rn=0
    let encoding: u32 = 0xE5408400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_rn_0_min_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Rn = 0 (Min)
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0, xs=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_rn_1_poweroftwo_8000_e5408020() {
    // Encoding: 0xE5408020
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, xs=0, Rn=1, Zt=0
    let encoding: u32 = 0xE5408020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_rn_30_poweroftwominusone_8000_e54083c0() {
    // Encoding: 0xE54083C0
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: xs=0, Zm=0, Rn=30, Zt=0, Pg=0
    let encoding: u32 = 0xE54083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_rn_31_max_8000_e54083e0() {
    // Encoding: 0xE54083E0
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Rn = 31 (Max)
    // Fields: Zm=0, xs=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE54083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zt_0_min_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zt = 0 (Min)
    // Fields: xs=0, Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zt_1_poweroftwo_8000_e5408001() {
    // Encoding: 0xE5408001
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: xs=0, Rn=0, Pg=0, Zm=0, Zt=1
    let encoding: u32 = 0xE5408001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zt_30_poweroftwominusone_8000_e540801e() {
    // Encoding: 0xE540801E
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=30, Pg=0, Zm=0, Rn=0, xs=0
    let encoding: u32 = 0xE540801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_field_zt_31_max_8000_e540801f() {
    // Encoding: 0xE540801F
    // Test ST1W_Z.P.BZ_S.x32.unscaled field Zt = 31 (Max)
    // Fields: Pg=0, xs=0, Zm=0, Rn=0, Zt=31
    let encoding: u32 = 0xE540801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_combo_0_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled field combination: Zm=0, xs=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Pg=0, Rn=0, Zm=0, xs=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_32768_e54083e0() {
    // Encoding: 0xE54083E0
    // Test ST1W_Z.P.BZ_S.x32.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: xs=0, Zt=0, Pg=0, Rn=31, Zm=0
    let encoding: u32 = 0xE54083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_invalid_0_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zt=0, xs=0, Zm=0, Pg=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_invalid_1_8000_e5408000() {
    // Encoding: 0xE5408000
    // Test ST1W_Z.P.BZ_S.x32.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Pg=0, Zm=0, xs=0
    let encoding: u32 = 0xE5408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zm_0_min_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zm_1_poweroftwo_a000_e521a000() {
    // Encoding: 0xE521A000
    // Test ST1W_Z.P.BZ_D.64.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zm=1, Zt=0
    let encoding: u32 = 0xE521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zm_30_poweroftwominusone_a000_e53ea000() {
    // Encoding: 0xE53EA000
    // Test ST1W_Z.P.BZ_D.64.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE53EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zm_31_max_a000_e53fa000() {
    // Encoding: 0xE53FA000
    // Test ST1W_Z.P.BZ_D.64.scaled field Zm = 31 (Max)
    // Fields: Zt=0, Rn=0, Zm=31, Pg=0
    let encoding: u32 = 0xE53FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_pg_0_min_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled field Pg = 0 (Min)
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_pg_1_poweroftwo_a000_e520a400() {
    // Encoding: 0xE520A400
    // Test ST1W_Z.P.BZ_D.64.scaled field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, Zm=0, Zt=0, Pg=1
    let encoding: u32 = 0xE520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_rn_0_min_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Zm=0, Pg=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_rn_1_poweroftwo_a000_e520a020() {
    // Encoding: 0xE520A020
    // Test ST1W_Z.P.BZ_D.64.scaled field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, Pg=0, Zm=0
    let encoding: u32 = 0xE520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_rn_30_poweroftwominusone_a000_e520a3c0() {
    // Encoding: 0xE520A3C0
    // Test ST1W_Z.P.BZ_D.64.scaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xE520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_rn_31_max_a000_e520a3e0() {
    // Encoding: 0xE520A3E0
    // Test ST1W_Z.P.BZ_D.64.scaled field Rn = 31 (Max)
    // Fields: Zt=0, Rn=31, Pg=0, Zm=0
    let encoding: u32 = 0xE520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zt_0_min_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zt_1_poweroftwo_a000_e520a001() {
    // Encoding: 0xE520A001
    // Test ST1W_Z.P.BZ_D.64.scaled field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, Zm=0
    let encoding: u32 = 0xE520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zt_30_poweroftwominusone_a000_e520a01e() {
    // Encoding: 0xE520A01E
    // Test ST1W_Z.P.BZ_D.64.scaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xE520A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_64_scaled_field_zt_31_max_a000_e520a01f() {
    // Encoding: 0xE520A01F
    // Test ST1W_Z.P.BZ_D.64.scaled field Zt = 31 (Max)
    // Fields: Zm=0, Rn=0, Zt=31, Pg=0
    let encoding: u32 = 0xE520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_combo_0_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zt=0, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bz_d_64_scaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e520a3e0() {
    // Encoding: 0xE520A3E0
    // Test ST1W_Z.P.BZ_D.64.scaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_64_scaled_invalid_0_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, Zm=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_64_scaled_invalid_1_a000_e520a000() {
    // Encoding: 0xE520A000
    // Test ST1W_Z.P.BZ_D.64.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zm_0_min_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zm = 0 (Min)
    // Fields: Zm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zm_1_poweroftwo_a000_e501a000() {
    // Encoding: 0xE501A000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zm = 1 (PowerOfTwo)
    // Fields: Zt=0, Zm=1, Pg=0, Rn=0
    let encoding: u32 = 0xE501A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zm_30_poweroftwominusone_a000_e51ea000() {
    // Encoding: 0xE51EA000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE51EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zm_31_max_a000_e51fa000() {
    // Encoding: 0xE51FA000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zm=31, Zt=0
    let encoding: u32 = 0xE51FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_pg_0_min_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_pg_1_poweroftwo_a000_e500a400() {
    // Encoding: 0xE500A400
    // Test ST1W_Z.P.BZ_D.64.unscaled field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, Rn=0, Zm=0
    let encoding: u32 = 0xE500A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_rn_0_min_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Rn = 0 (Min)
    // Fields: Zm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_rn_1_poweroftwo_a000_e500a020() {
    // Encoding: 0xE500A020
    // Test ST1W_Z.P.BZ_D.64.unscaled field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=1, Zt=0, Zm=0
    let encoding: u32 = 0xE500A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_rn_30_poweroftwominusone_a000_e500a3c0() {
    // Encoding: 0xE500A3C0
    // Test ST1W_Z.P.BZ_D.64.unscaled field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Zm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE500A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_rn_31_max_a000_e500a3e0() {
    // Encoding: 0xE500A3E0
    // Test ST1W_Z.P.BZ_D.64.unscaled field Rn = 31 (Max)
    // Fields: Pg=0, Rn=31, Zm=0, Zt=0
    let encoding: u32 = 0xE500A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zt_0_min_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zt = 0 (Min)
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zt_1_poweroftwo_a000_e500a001() {
    // Encoding: 0xE500A001
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zt = 1 (PowerOfTwo)
    // Fields: Zm=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xE500A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zt_30_poweroftwominusone_a000_e500a01e() {
    // Encoding: 0xE500A01E
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Rn=0, Zt=30
    let encoding: u32 = 0xE500A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_field_zt_31_max_a000_e500a01f() {
    // Encoding: 0xE500A01F
    // Test ST1W_Z.P.BZ_D.64.unscaled field Zt = 31 (Max)
    // Fields: Zt=31, Zm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE500A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_combo_0_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled field combination: Zm=0, Pg=0, Rn=0, Zt=0
    // Fields: Zm=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_special_rn_31_stack_pointer_sp_may_require_alignment_40960_e500a3e0() {
    // Encoding: 0xE500A3E0
    // Test ST1W_Z.P.BZ_D.64.unscaled special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Zm=0, Pg=0, Rn=31
    let encoding: u32 = 0xE500A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_invalid_0_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_invalid_1_a000_e500a000() {
    // Encoding: 0xE500A000
    // Test ST1W_Z.P.BZ_D.64.unscaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE500A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_sp_rn_e56083e0() {
    // Test ST1W_Z.P.BZ_S.x32.scaled with Rn = SP (31)
    // Encoding: 0xE56083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE56083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_S.x32.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bz_s_x32_scaled_store_0_e5608020() {
    // Test ST1W_Z.P.BZ_S.x32.scaled memory store: 8 bytes
    // Encoding: 0xE5608020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5608020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_sp_rn_e52083e0() {
    // Test ST1W_Z.P.BZ_D.x32.scaled with Rn = SP (31)
    // Encoding: 0xE52083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE52083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.x32.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bz_d_x32_scaled_store_0_e5208020() {
    // Test ST1W_Z.P.BZ_D.x32.scaled memory store: 8 bytes
    // Encoding: 0xE5208020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5208020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_sp_rn_e50083e0() {
    // Test ST1W_Z.P.BZ_D.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE50083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE50083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bz_d_x32_unscaled_store_0_e5008020() {
    // Test ST1W_Z.P.BZ_D.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE5008020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5008020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_sp_rn_e54083e0() {
    // Test ST1W_Z.P.BZ_S.x32.unscaled with Rn = SP (31)
    // Encoding: 0xE54083E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE54083E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_S.x32.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bz_s_x32_unscaled_store_0_e5408020() {
    // Test ST1W_Z.P.BZ_S.x32.unscaled memory store: 8 bytes
    // Encoding: 0xE5408020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5408020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bz_d_64_scaled_sp_rn_e520a3e0() {
    // Test ST1W_Z.P.BZ_D.64.scaled with Rn = SP (31)
    // Encoding: 0xE520A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE520A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.64.scaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bz_d_64_scaled_store_0_e520a020() {
    // Test ST1W_Z.P.BZ_D.64.scaled memory store: 8 bytes
    // Encoding: 0xE520A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE520A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_sp_rn_e500a3e0() {
    // Test ST1W_Z.P.BZ_D.64.unscaled with Rn = SP (31)
    // Encoding: 0xE500A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE500A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1W_Z.P.BZ_D.64.unscaled
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1w_z_p_bz_d_64_unscaled_store_0_e500a020() {
    // Test ST1W_Z.P.BZ_D.64.unscaled memory store: 8 bytes
    // Encoding: 0xE500A020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE500A020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_0_zero_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e591e000() {
    // Encoding: 0xE591E000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=1
    let encoding: u32 = 0xE591E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e593e000() {
    // Encoding: 0xE593E000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: imm4=3, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE593E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e594e000() {
    // Encoding: 0xE594E000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Zt=0, imm4=4, Pg=0, Rn=0
    let encoding: u32 = 0xE594E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e597e000() {
    // Encoding: 0xE597E000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zt=0, imm4=7
    let encoding: u32 = 0xE597E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e598e000() {
    // Encoding: 0xE598E000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, imm4=8
    let encoding: u32 = 0xE598E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_imm4_15_max_e000_e59fe000() {
    // Encoding: 0xE59FE000
    // Test STNT1D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE59FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_pg_0_min_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e590e400() {
    // Encoding: 0xE590E400
    // Test STNT1D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE590E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_rn_0_min_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rn=0, Pg=0, imm4=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e590e020() {
    // Encoding: 0xE590E020
    // Test STNT1D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zt=0, imm4=0, Pg=0
    let encoding: u32 = 0xE590E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e590e3c0() {
    // Encoding: 0xE590E3C0
    // Test STNT1D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=30, imm4=0, Zt=0
    let encoding: u32 = 0xE590E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_rn_31_max_e000_e590e3e0() {
    // Encoding: 0xE590E3E0
    // Test STNT1D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE590E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_zt_0_min_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Rn=0, Pg=0, imm4=0, Zt=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e590e001() {
    // Encoding: 0xE590E001
    // Test STNT1D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=1
    let encoding: u32 = 0xE590E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e590e01e() {
    // Encoding: 0xE590E01E
    // Test STNT1D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xE590E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1d_z_p_bi_contiguous_field_zt_31_max_e000_e590e01f() {
    // Encoding: 0xE590E01F
    // Test STNT1D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: imm4=0, Rn=0, Pg=0, Zt=31
    let encoding: u32 = 0xE590E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_stnt1d_z_p_bi_contiguous_combo_0_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e590e3e0() {
    // Encoding: 0xE590E3E0
    // Test STNT1D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE590E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1d_z_p_bi_contiguous_invalid_0_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1d_z_p_bi_contiguous_invalid_1_e000_e590e000() {
    // Encoding: 0xE590E000
    // Test STNT1D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE590E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1d_z_p_bi_contiguous_sp_rn_e590e3e0() {
    // Test STNT1D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE590E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE590E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1D_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1d_z_p_bi_contiguous_store_0_e590e020() {
    // Test STNT1D_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE590E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE590E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2B_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2b_z_p_br_contiguous_field_rm_0_min_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2b_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4216000() {
    // Encoding: 0xE4216000
    // Test ST2B_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=0, Rm=1, Pg=0
    let encoding: u32 = 0xE4216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2b_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e43e6000() {
    // Encoding: 0xE43E6000
    // Test ST2B_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE43E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st2b_z_p_br_contiguous_field_rm_31_max_6000_e43f6000() {
    // Encoding: 0xE43F6000
    // Test ST2B_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE43F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2b_z_p_br_contiguous_field_pg_0_min_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2b_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4206400() {
    // Encoding: 0xE4206400
    // Test ST2B_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xE4206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2b_z_p_br_contiguous_field_rn_0_min_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Rn=0, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2b_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4206020() {
    // Encoding: 0xE4206020
    // Test ST2B_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=1
    let encoding: u32 = 0xE4206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2b_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e42063c0() {
    // Encoding: 0xE42063C0
    // Test ST2B_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=30
    let encoding: u32 = 0xE42063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2b_z_p_br_contiguous_field_rn_31_max_6000_e42063e0() {
    // Encoding: 0xE42063E0
    // Test ST2B_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE42063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2b_z_p_br_contiguous_field_zt_0_min_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2b_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4206001() {
    // Encoding: 0xE4206001
    // Test ST2B_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2b_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e420601e() {
    // Encoding: 0xE420601E
    // Test ST2B_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=30, Pg=0, Rm=0
    let encoding: u32 = 0xE420601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2b_z_p_br_contiguous_field_zt_31_max_6000_e420601f() {
    // Encoding: 0xE420601F
    // Test ST2B_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE420601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st2b_z_p_br_contiguous_combo_0_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2b_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e42063e0() {
    // Encoding: 0xE42063E0
    // Test ST2B_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=31
    let encoding: u32 = 0xE42063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2b_z_p_br_contiguous_invalid_0_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2b_z_p_br_contiguous_invalid_1_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st2b_z_p_br_contiguous_invalid_2_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2b_z_p_br_contiguous_invalid_3_6000_e4206000() {
    // Encoding: 0xE4206000
    // Test ST2B_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2b_z_p_br_contiguous_sp_rn_e42063e0() {
    // Test ST2B_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE42063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE42063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2B_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2b_z_p_br_contiguous_store_0_e4206020() {
    // Test ST2B_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4206020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4206020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1H_Z.P.AI_S Tests
// ============================================================================

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1h_z_p_ai_s_field_imm5_0_zero_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field imm5 = 0 (Zero)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1h_z_p_ai_s_field_imm5_1_poweroftwo_a000_e4e1a000() {
    // Encoding: 0xE4E1A000
    // Test ST1H_Z.P.AI_S field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, Zt=0, imm5=1, Pg=0
    let encoding: u32 = 0xE4E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1h_z_p_ai_s_field_imm5_3_poweroftwominusone_a000_e4e3a000() {
    // Encoding: 0xE4E3A000
    // Test ST1H_Z.P.AI_S field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=3
    let encoding: u32 = 0xE4E3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_4_poweroftwo_a000_e4e4a000() {
    // Encoding: 0xE4E4A000
    // Test ST1H_Z.P.AI_S field imm5 = 4 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Zn=0, imm5=4
    let encoding: u32 = 0xE4E4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1h_z_p_ai_s_field_imm5_7_poweroftwominusone_a000_e4e7a000() {
    // Encoding: 0xE4E7A000
    // Test ST1H_Z.P.AI_S field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=7, Pg=0, Zt=0
    let encoding: u32 = 0xE4E7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_8_poweroftwo_a000_e4e8a000() {
    // Encoding: 0xE4E8A000
    // Test ST1H_Z.P.AI_S field imm5 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, imm5=8, Zn=0
    let encoding: u32 = 0xE4E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_15_poweroftwominusone_a000_e4efa000() {
    // Encoding: 0xE4EFA000
    // Test ST1H_Z.P.AI_S field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm5=15, Zn=0, Pg=0
    let encoding: u32 = 0xE4EFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_16_poweroftwo_a000_e4f0a000() {
    // Encoding: 0xE4F0A000
    // Test ST1H_Z.P.AI_S field imm5 = 16 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=16
    let encoding: u32 = 0xE4F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1h_z_p_ai_s_field_imm5_31_max_a000_e4ffa000() {
    // Encoding: 0xE4FFA000
    // Test ST1H_Z.P.AI_S field imm5 = 31 (Max)
    // Fields: Zn=0, imm5=31, Pg=0, Zt=0
    let encoding: u32 = 0xE4FFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_ai_s_field_pg_0_min_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field Pg = 0 (Min)
    // Fields: Zt=0, imm5=0, Pg=0, Zn=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_ai_s_field_pg_1_poweroftwo_a000_e4e0a400() {
    // Encoding: 0xE4E0A400
    // Test ST1H_Z.P.AI_S field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, imm5=0, Zt=0
    let encoding: u32 = 0xE4E0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_s_field_zn_0_min_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field Zn = 0 (Min)
    // Fields: imm5=0, Pg=0, Zt=0, Zn=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_s_field_zn_1_poweroftwo_a000_e4e0a020() {
    // Encoding: 0xE4E0A020
    // Test ST1H_Z.P.AI_S field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=1, imm5=0
    let encoding: u32 = 0xE4E0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_s_field_zn_30_poweroftwominusone_a000_e4e0a3c0() {
    // Encoding: 0xE4E0A3C0
    // Test ST1H_Z.P.AI_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, imm5=0, Zn=30
    let encoding: u32 = 0xE4E0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_s_field_zn_31_max_a000_e4e0a3e0() {
    // Encoding: 0xE4E0A3E0
    // Test ST1H_Z.P.AI_S field Zn = 31 (Max)
    // Fields: imm5=0, Zn=31, Pg=0, Zt=0
    let encoding: u32 = 0xE4E0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_s_field_zt_0_min_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field Zt = 0 (Min)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_s_field_zt_1_poweroftwo_a000_e4e0a001() {
    // Encoding: 0xE4E0A001
    // Test ST1H_Z.P.AI_S field Zt = 1 (PowerOfTwo)
    // Fields: Zt=1, Pg=0, imm5=0, Zn=0
    let encoding: u32 = 0xE4E0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_s_field_zt_30_poweroftwominusone_a000_e4e0a01e() {
    // Encoding: 0xE4E0A01E
    // Test ST1H_Z.P.AI_S field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zt=30, Zn=0
    let encoding: u32 = 0xE4E0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_s_field_zt_31_max_a000_e4e0a01f() {
    // Encoding: 0xE4E0A01F
    // Test ST1H_Z.P.AI_S field Zt = 31 (Max)
    // Fields: Zt=31, imm5=0, Zn=0, Pg=0
    let encoding: u32 = 0xE4E0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1h_z_p_ai_s_combo_0_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_s_invalid_0_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zt=0, Zn=0, imm5=0, Pg=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_s_invalid_1_a000_e4e0a000() {
    // Encoding: 0xE4E0A000
    // Test ST1H_Z.P.AI_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Pg=0, Zn=0, imm5=0
    let encoding: u32 = 0xE4E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st1h_z_p_ai_d_field_imm5_0_zero_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field imm5 = 0 (Zero)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st1h_z_p_ai_d_field_imm5_1_poweroftwo_a000_e4c1a000() {
    // Encoding: 0xE4C1A000
    // Test ST1H_Z.P.AI_D field imm5 = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zt=0, imm5=1
    let encoding: u32 = 0xE4C1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st1h_z_p_ai_d_field_imm5_3_poweroftwominusone_a000_e4c3a000() {
    // Encoding: 0xE4C3A000
    // Test ST1H_Z.P.AI_D field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=3, Zt=0, Pg=0
    let encoding: u32 = 0xE4C3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_4_poweroftwo_a000_e4c4a000() {
    // Encoding: 0xE4C4A000
    // Test ST1H_Z.P.AI_D field imm5 = 4 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, imm5=4, Zt=0
    let encoding: u32 = 0xE4C4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_st1h_z_p_ai_d_field_imm5_7_poweroftwominusone_a000_e4c7a000() {
    // Encoding: 0xE4C7A000
    // Test ST1H_Z.P.AI_D field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Zn=0, Pg=0, imm5=7
    let encoding: u32 = 0xE4C7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_8_poweroftwo_a000_e4c8a000() {
    // Encoding: 0xE4C8A000
    // Test ST1H_Z.P.AI_D field imm5 = 8 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=8
    let encoding: u32 = 0xE4C8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_15_poweroftwominusone_a000_e4cfa000() {
    // Encoding: 0xE4CFA000
    // Test ST1H_Z.P.AI_D field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=15, Pg=0, Zt=0
    let encoding: u32 = 0xE4CFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_16_poweroftwo_a000_e4d0a000() {
    // Encoding: 0xE4D0A000
    // Test ST1H_Z.P.AI_D field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zt=0, Pg=0, Zn=0
    let encoding: u32 = 0xE4D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_st1h_z_p_ai_d_field_imm5_31_max_a000_e4dfa000() {
    // Encoding: 0xE4DFA000
    // Test ST1H_Z.P.AI_D field imm5 = 31 (Max)
    // Fields: Pg=0, Zt=0, Zn=0, imm5=31
    let encoding: u32 = 0xE4DFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_ai_d_field_pg_0_min_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field Pg = 0 (Min)
    // Fields: Zn=0, imm5=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_ai_d_field_pg_1_poweroftwo_a000_e4c0a400() {
    // Encoding: 0xE4C0A400
    // Test ST1H_Z.P.AI_D field Pg = 1 (PowerOfTwo)
    // Fields: imm5=0, Zt=0, Zn=0, Pg=1
    let encoding: u32 = 0xE4C0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_d_field_zn_0_min_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field Zn = 0 (Min)
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_d_field_zn_1_poweroftwo_a000_e4c0a020() {
    // Encoding: 0xE4C0A020
    // Test ST1H_Z.P.AI_D field Zn = 1 (PowerOfTwo)
    // Fields: imm5=0, Zn=1, Zt=0, Pg=0
    let encoding: u32 = 0xE4C0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_d_field_zn_30_poweroftwominusone_a000_e4c0a3c0() {
    // Encoding: 0xE4C0A3C0
    // Test ST1H_Z.P.AI_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, Pg=0, Zn=30, Zt=0
    let encoding: u32 = 0xE4C0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_d_field_zn_31_max_a000_e4c0a3e0() {
    // Encoding: 0xE4C0A3E0
    // Test ST1H_Z.P.AI_D field Zn = 31 (Max)
    // Fields: imm5=0, Zt=0, Zn=31, Pg=0
    let encoding: u32 = 0xE4C0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_ai_d_field_zt_0_min_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field Zt = 0 (Min)
    // Fields: imm5=0, Pg=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_ai_d_field_zt_1_poweroftwo_a000_e4c0a001() {
    // Encoding: 0xE4C0A001
    // Test ST1H_Z.P.AI_D field Zt = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, imm5=0, Zt=1
    let encoding: u32 = 0xE4C0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_ai_d_field_zt_30_poweroftwominusone_a000_e4c0a01e() {
    // Encoding: 0xE4C0A01E
    // Test ST1H_Z.P.AI_D field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm5=0, Pg=0, Zt=30
    let encoding: u32 = 0xE4C0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_ai_d_field_zt_31_max_a000_e4c0a01f() {
    // Encoding: 0xE4C0A01F
    // Test ST1H_Z.P.AI_D field Zt = 31 (Max)
    // Fields: Zn=0, Zt=31, imm5=0, Pg=0
    let encoding: u32 = 0xE4C0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm5=0 (immediate value 0)
#[test]
fn test_st1h_z_p_ai_d_combo_0_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D field combination: imm5=0, Pg=0, Zn=0, Zt=0
    // Fields: imm5=0, Zn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_d_invalid_0_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, imm5=0, Zn=0, Zt=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_ai_d_invalid_1_a000_e4c0a000() {
    // Encoding: 0xE4C0A000
    // Test ST1H_Z.P.AI_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, Zt=0, imm5=0
    let encoding: u32 = 0xE4C0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.AI_S
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_ai_s_store_0_e4e0a000() {
    // Test ST1H_Z.P.AI_S memory store: 8 bytes
    // Encoding: 0xE4E0A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4E0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.AI_D
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_ai_d_store_0_e4c0a000() {
    // Test ST1H_Z.P.AI_D memory store: 8 bytes
    // Encoding: 0xE4C0A000
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4C0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST1H_Z.P.BR__ Tests
// ============================================================================

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_st1h_z_p_br_field_size_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field size = 0 (Min)
    // Fields: Rn=0, Rm=0, size=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_st1h_z_p_br_field_size_1_poweroftwo_4000_e4a04000() {
    // Encoding: 0xE4A04000
    // Test ST1H_Z.P.BR__ field size = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, Pg=0, size=1, Rm=0
    let encoding: u32 = 0xE4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_st1h_z_p_br_field_size_2_poweroftwo_4000_e4c04000() {
    // Encoding: 0xE4C04000
    // Test ST1H_Z.P.BR__ field size = 2 (PowerOfTwo)
    // Fields: Rn=0, size=2, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size 21 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_st1h_z_p_br_field_size_3_max_4000_e4e04000() {
    // Encoding: 0xE4E04000
    // Test ST1H_Z.P.BR__ field size = 3 (Max)
    // Fields: Rn=0, size=3, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_br_field_rm_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Rm = 0 (Min)
    // Fields: size=0, Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_br_field_rm_1_poweroftwo_4000_e4814000() {
    // Encoding: 0xE4814000
    // Test ST1H_Z.P.BR__ field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, Rn=0, Zt=0, Pg=0, size=0
    let encoding: u32 = 0xE4814000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_br_field_rm_30_poweroftwominusone_4000_e49e4000() {
    // Encoding: 0xE49E4000
    // Test ST1H_Z.P.BR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Zt=0, Rm=30, size=0, Pg=0
    let encoding: u32 = 0xE49E4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st1h_z_p_br_field_rm_31_max_4000_e49f4000() {
    // Encoding: 0xE49F4000
    // Test ST1H_Z.P.BR__ field Rm = 31 (Max)
    // Fields: Pg=0, Rm=31, Rn=0, Zt=0, size=0
    let encoding: u32 = 0xE49F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_br_field_pg_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Pg = 0 (Min)
    // Fields: Pg=0, Rm=0, Zt=0, Rn=0, size=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_br_field_pg_1_poweroftwo_4000_e4804400() {
    // Encoding: 0xE4804400
    // Test ST1H_Z.P.BR__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rm=0, size=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4804400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st1h_z_p_br_field_rn_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Rn = 0 (Min)
    // Fields: size=0, Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st1h_z_p_br_field_rn_1_poweroftwo_4000_e4804020() {
    // Encoding: 0xE4804020
    // Test ST1H_Z.P.BR__ field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=0, Zt=0, size=0, Rn=1
    let encoding: u32 = 0xE4804020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st1h_z_p_br_field_rn_30_poweroftwominusone_4000_e48043c0() {
    // Encoding: 0xE48043C0
    // Test ST1H_Z.P.BR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, size=0, Rm=0
    let encoding: u32 = 0xE48043C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st1h_z_p_br_field_rn_31_max_4000_e48043e0() {
    // Encoding: 0xE48043E0
    // Test ST1H_Z.P.BR__ field Rn = 31 (Max)
    // Fields: size=0, Pg=0, Zt=0, Rm=0, Rn=31
    let encoding: u32 = 0xE48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st1h_z_p_br_field_zt_0_min_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field Zt = 0 (Min)
    // Fields: size=0, Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st1h_z_p_br_field_zt_1_poweroftwo_4000_e4804001() {
    // Encoding: 0xE4804001
    // Test ST1H_Z.P.BR__ field Zt = 1 (PowerOfTwo)
    // Fields: size=0, Rn=0, Zt=1, Pg=0, Rm=0
    let encoding: u32 = 0xE4804001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st1h_z_p_br_field_zt_30_poweroftwominusone_4000_e480401e() {
    // Encoding: 0xE480401E
    // Test ST1H_Z.P.BR__ field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rm=0, size=0, Rn=0, Zt=30
    let encoding: u32 = 0xE480401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st1h_z_p_br_field_zt_31_max_4000_e480401f() {
    // Encoding: 0xE480401F
    // Test ST1H_Z.P.BR__ field Zt = 31 (Max)
    // Fields: size=0, Rm=0, Pg=0, Rn=0, Zt=31
    let encoding: u32 = 0xE480401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_st1h_z_p_br_combo_0_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ field combination: size=0, Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, size=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_st1h_z_p_br_special_size_0_size_variant_0_16384_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ special value size = 0 (Size variant 0)
    // Fields: Rm=0, size=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_st1h_z_p_br_special_size_1_size_variant_1_16384_e4a04000() {
    // Encoding: 0xE4A04000
    // Test ST1H_Z.P.BR__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_st1h_z_p_br_special_size_2_size_variant_2_16384_e4c04000() {
    // Encoding: 0xE4C04000
    // Test ST1H_Z.P.BR__ special value size = 2 (Size variant 2)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0, size=2
    let encoding: u32 = 0xE4C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_st1h_z_p_br_special_size_3_size_variant_3_16384_e4e04000() {
    // Encoding: 0xE4E04000
    // Test ST1H_Z.P.BR__ special value size = 3 (Size variant 3)
    // Fields: Zt=0, Rm=0, Rn=0, size=3, Pg=0
    let encoding: u32 = 0xE4E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st1h_z_p_br_special_rn_31_stack_pointer_sp_may_require_alignment_16384_e48043e0() {
    // Encoding: 0xE48043E0
    // Test ST1H_Z.P.BR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rm=0, Zt=0, size=0, Rn=31
    let encoding: u32 = 0xE48043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_0_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0, size=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_1_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, size=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_2_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0, size=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_3_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Pg=0, Zt=0, size=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_4_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Rm=0, size=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st1h_z_p_br_invalid_5_4000_e4804000() {
    // Encoding: 0xE4804000
    // Test ST1H_Z.P.BR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rn=0, size=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4804000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st1h_z_p_br_sp_rn_e48043e0() {
    // Test ST1H_Z.P.BR__ with Rn = SP (31)
    // Encoding: 0xE48043E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE48043E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST1H_Z.P.BR__
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st1h_z_p_br_store_0_e4804020() {
    // Test ST1H_Z.P.BR__ memory store: 8 bytes
    // Encoding: 0xE4804020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4804020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2D_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_0_zero_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, Rn=0, imm4=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e5b1e000() {
    // Encoding: 0xE5B1E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=1, Zt=0
    let encoding: u32 = 0xE5B1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e5b3e000() {
    // Encoding: 0xE5B3E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=3, Rn=0, Pg=0
    let encoding: u32 = 0xE5B3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e5b4e000() {
    // Encoding: 0xE5B4E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: Rn=0, Zt=0, imm4=4, Pg=0
    let encoding: u32 = 0xE5B4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e5b7e000() {
    // Encoding: 0xE5B7E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xE5B7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e5b8e000() {
    // Encoding: 0xE5B8E000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Zt=0, Pg=0, Rn=0, imm4=8
    let encoding: u32 = 0xE5B8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st2d_z_p_bi_contiguous_field_imm4_15_max_e000_e5bfe000() {
    // Encoding: 0xE5BFE000
    // Test ST2D_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: imm4=15, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE5BFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_pg_0_min_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e5b0e400() {
    // Encoding: 0xE5B0E400
    // Test ST2D_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Zt=0, imm4=0, Pg=1, Rn=0
    let encoding: u32 = 0xE5B0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_0_min_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e5b0e020() {
    // Encoding: 0xE5B0E020
    // Test ST2D_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Zt=0, Rn=1
    let encoding: u32 = 0xE5B0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e5b0e3c0() {
    // Encoding: 0xE5B0E3C0
    // Test ST2D_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE5B0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2d_z_p_bi_contiguous_field_rn_31_max_e000_e5b0e3e0() {
    // Encoding: 0xE5B0E3E0
    // Test ST2D_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: Zt=0, Pg=0, imm4=0, Rn=31
    let encoding: u32 = 0xE5B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_0_min_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: Zt=0, Rn=0, imm4=0, Pg=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e5b0e001() {
    // Encoding: 0xE5B0E001
    // Test ST2D_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Zt=1, Rn=0, Pg=0
    let encoding: u32 = 0xE5B0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e5b0e01e() {
    // Encoding: 0xE5B0E01E
    // Test ST2D_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm4=0, Zt=30, Pg=0
    let encoding: u32 = 0xE5B0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2d_z_p_bi_contiguous_field_zt_31_max_e000_e5b0e01f() {
    // Encoding: 0xE5B0E01F
    // Test ST2D_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Pg=0, imm4=0, Rn=0
    let encoding: u32 = 0xE5B0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st2d_z_p_bi_contiguous_combo_0_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2d_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e5b0e3e0() {
    // Encoding: 0xE5B0E3E0
    // Test ST2D_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Zt=0, imm4=0, Rn=31
    let encoding: u32 = 0xE5B0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_bi_contiguous_invalid_0_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm4=0, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2d_z_p_bi_contiguous_invalid_1_e000_e5b0e000() {
    // Encoding: 0xE5B0E000
    // Test ST2D_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE5B0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2d_z_p_bi_contiguous_sp_rn_e5b0e3e0() {
    // Test ST2D_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE5B0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE5B0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2D_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2d_z_p_bi_contiguous_store_0_e5b0e020() {
    // Test ST2D_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE5B0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE5B0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST4H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Rm=0, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4e16000() {
    // Encoding: 0xE4E16000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zt=0, Rm=1, Rn=0
    let encoding: u32 = 0xE4E16000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e4fe6000() {
    // Encoding: 0xE4FE6000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4FE6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_st4h_z_p_br_contiguous_field_rm_31_max_6000_e4ff6000() {
    // Encoding: 0xE4FF6000
    // Test ST4H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Rm=31, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4FF6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_br_contiguous_field_pg_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rn=0, Rm=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4e06400() {
    // Encoding: 0xE4E06400
    // Test ST4H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rm=0, Pg=1, Rn=0, Zt=0
    let encoding: u32 = 0xE4E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Rm=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4e06020() {
    // Encoding: 0xE4E06020
    // Test ST4H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE4E06020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e4e063c0() {
    // Encoding: 0xE4E063C0
    // Test ST4H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=30, Pg=0, Zt=0
    let encoding: u32 = 0xE4E063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st4h_z_p_br_contiguous_field_rn_31_max_6000_e4e063e0() {
    // Encoding: 0xE4E063E0
    // Test ST4H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rn=31, Zt=0, Pg=0, Rm=0
    let encoding: u32 = 0xE4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_0_min_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4e06001() {
    // Encoding: 0xE4E06001
    // Test ST4H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, Zt=1, Rm=0
    let encoding: u32 = 0xE4E06001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e4e0601e() {
    // Encoding: 0xE4E0601E
    // Test ST4H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=30, Rm=0, Rn=0
    let encoding: u32 = 0xE4E0601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st4h_z_p_br_contiguous_field_zt_31_max_6000_e4e0601f() {
    // Encoding: 0xE4E0601F
    // Test ST4H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Zt=31, Rm=0, Pg=0
    let encoding: u32 = 0xE4E0601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_st4h_z_p_br_contiguous_combo_0_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st4h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e4e063e0() {
    // Encoding: 0xE4E063E0
    // Test ST4H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4E063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_0_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_1_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rm=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_2_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st4h_z_p_br_contiguous_invalid_3_6000_e4e06000() {
    // Encoding: 0xE4E06000
    // Test ST4H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Zt=0, Rm=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st4h_z_p_br_contiguous_sp_rn_e4e063e0() {
    // Test ST4H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE4E063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4E063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST4H_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st4h_z_p_br_contiguous_store_0_e4e06020() {
    // Test ST4H_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4E06020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4E06020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST3H_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_0_zero_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Pg=0, imm4=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e4d1e000() {
    // Encoding: 0xE4D1E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: imm4=1, Pg=0, Zt=0, Rn=0
    let encoding: u32 = 0xE4D1E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e4d3e000() {
    // Encoding: 0xE4D3E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=3
    let encoding: u32 = 0xE4D3E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e4d4e000() {
    // Encoding: 0xE4D4E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4D4E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e4d7e000() {
    // Encoding: 0xE4D7E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: imm4=7, Zt=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4D7E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e4d8e000() {
    // Encoding: 0xE4D8E000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, Rn=0, imm4=8, Zt=0
    let encoding: u32 = 0xE4D8E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st3h_z_p_bi_contiguous_field_imm4_15_max_e000_e4dfe000() {
    // Encoding: 0xE4DFE000
    // Test ST3H_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Zt=0, Rn=0, imm4=15, Pg=0
    let encoding: u32 = 0xE4DFE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_pg_0_min_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: Zt=0, imm4=0, Pg=0, Rn=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e4d0e400() {
    // Encoding: 0xE4D0E400
    // Test ST3H_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=1, Zt=0, Rn=0
    let encoding: u32 = 0xE4D0E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_0_min_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e4d0e020() {
    // Encoding: 0xE4D0E020
    // Test ST3H_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, imm4=0, Pg=0
    let encoding: u32 = 0xE4D0E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e4d0e3c0() {
    // Encoding: 0xE4D0E3C0
    // Test ST3H_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Pg=0, Rn=30, imm4=0
    let encoding: u32 = 0xE4D0E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st3h_z_p_bi_contiguous_field_rn_31_max_e000_e4d0e3e0() {
    // Encoding: 0xE4D0E3E0
    // Test ST3H_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Zt=0, Pg=0, Rn=31
    let encoding: u32 = 0xE4D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_0_min_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e4d0e001() {
    // Encoding: 0xE4D0E001
    // Test ST3H_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Pg=0, Zt=1, imm4=0
    let encoding: u32 = 0xE4D0E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e4d0e01e() {
    // Encoding: 0xE4D0E01E
    // Test ST3H_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Pg=0, Zt=30, Rn=0
    let encoding: u32 = 0xE4D0E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st3h_z_p_bi_contiguous_field_zt_31_max_e000_e4d0e01f() {
    // Encoding: 0xE4D0E01F
    // Test ST3H_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Pg=0, imm4=0, Zt=31, Rn=0
    let encoding: u32 = 0xE4D0E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st3h_z_p_bi_contiguous_combo_0_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st3h_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e4d0e3e0() {
    // Encoding: 0xE4D0E3E0
    // Test ST3H_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Pg=0, Rn=31, Zt=0, imm4=0
    let encoding: u32 = 0xE4D0E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_bi_contiguous_invalid_0_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Rn=0, Zt=0, imm4=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st3h_z_p_bi_contiguous_invalid_1_e000_e4d0e000() {
    // Encoding: 0xE4D0E000
    // Test ST3H_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, imm4=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4D0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st3h_z_p_bi_contiguous_sp_rn_e4d0e3e0() {
    // Test ST3H_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE4D0E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE4D0E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST3H_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st3h_z_p_bi_contiguous_store_0_e4d0e020() {
    // Test ST3H_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE4D0E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    set_x(&mut cpu, 1, 0x100000000000);
    let encoding: u32 = 0xE4D0E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ST2W_Z.P.BI_Contiguous Tests
// ============================================================================

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_0_zero_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 0 (Zero)
    // Fields: Rn=0, Pg=0, Zt=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_1_poweroftwo_e000_e531e000() {
    // Encoding: 0xE531E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=1, Zt=0, Pg=0
    let encoding: u32 = 0xE531E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_3_poweroftwominusone_e000_e533e000() {
    // Encoding: 0xE533E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 3 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm4=3, Zt=0, Rn=0
    let encoding: u32 = 0xE533E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_4_poweroftwo_e000_e534e000() {
    // Encoding: 0xE534E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 4 (PowerOfTwo)
    // Fields: imm4=4, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE534E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 7, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (7)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_7_poweroftwominusone_e000_e537e000() {
    // Encoding: 0xE537E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 7 (PowerOfTwoMinusOne)
    // Fields: Zt=0, imm4=7, Pg=0, Rn=0
    let encoding: u32 = 0xE537E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_8_poweroftwo_e000_e538e000() {
    // Encoding: 0xE538E000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 8 (PowerOfTwo)
    // Fields: Pg=0, imm4=8, Rn=0, Zt=0
    let encoding: u32 = 0xE538E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field imm4 16 +: 4`
/// Requirement: FieldBoundary { field: "imm4", value: 15, boundary: Max }
/// maximum immediate (15)
#[test]
fn test_st2w_z_p_bi_contiguous_field_imm4_15_max_e000_e53fe000() {
    // Encoding: 0xE53FE000
    // Test ST2W_Z.P.BI_Contiguous field imm4 = 15 (Max)
    // Fields: Rn=0, Zt=0, imm4=15, Pg=0
    let encoding: u32 = 0xE53FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_pg_0_min_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field Pg = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_pg_1_poweroftwo_e000_e530e400() {
    // Encoding: 0xE530E400
    // Test ST2W_Z.P.BI_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Rn=0, imm4=0, Zt=0, Pg=1
    let encoding: u32 = 0xE530E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_0_min_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field Rn = 0 (Min)
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_1_poweroftwo_e000_e530e020() {
    // Encoding: 0xE530E020
    // Test ST2W_Z.P.BI_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Pg=0, imm4=0, Rn=1, Zt=0
    let encoding: u32 = 0xE530E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_30_poweroftwominusone_e000_e530e3c0() {
    // Encoding: 0xE530E3C0
    // Test ST2W_Z.P.BI_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zt=0, Rn=30, imm4=0
    let encoding: u32 = 0xE530E3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_st2w_z_p_bi_contiguous_field_rn_31_max_e000_e530e3e0() {
    // Encoding: 0xE530E3E0
    // Test ST2W_Z.P.BI_Contiguous field Rn = 31 (Max)
    // Fields: imm4=0, Pg=0, Rn=31, Zt=0
    let encoding: u32 = 0xE530E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_0_min_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field Zt = 0 (Min)
    // Fields: imm4=0, Rn=0, Zt=0, Pg=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_1_poweroftwo_e000_e530e001() {
    // Encoding: 0xE530E001
    // Test ST2W_Z.P.BI_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: imm4=0, Pg=0, Zt=1, Rn=0
    let encoding: u32 = 0xE530E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_30_poweroftwominusone_e000_e530e01e() {
    // Encoding: 0xE530E01E
    // Test ST2W_Z.P.BI_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: imm4=0, Zt=30, Pg=0, Rn=0
    let encoding: u32 = 0xE530E01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_st2w_z_p_bi_contiguous_field_zt_31_max_e000_e530e01f() {
    // Encoding: 0xE530E01F
    // Test ST2W_Z.P.BI_Contiguous field Zt = 31 (Max)
    // Fields: Rn=0, Pg=0, Zt=31, imm4=0
    let encoding: u32 = 0xE530E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm4=0 (immediate value 0)
#[test]
fn test_st2w_z_p_bi_contiguous_combo_0_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous field combination: imm4=0, Pg=0, Rn=0, Zt=0
    // Fields: imm4=0, Pg=0, Rn=0, Zt=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_st2w_z_p_bi_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_57344_e530e3e0() {
    // Encoding: 0xE530E3E0
    // Test ST2W_Z.P.BI_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: imm4=0, Pg=0, Zt=0, Rn=31
    let encoding: u32 = 0xE530E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_bi_contiguous_invalid_0_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zt=0, imm4=0, Rn=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_st2w_z_p_bi_contiguous_invalid_1_e000_e530e000() {
    // Encoding: 0xE530E000
    // Test ST2W_Z.P.BI_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rn=0, imm4=0
    let encoding: u32 = 0xE530E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_st2w_z_p_bi_contiguous_sp_rn_e530e3e0() {
    // Test ST2W_Z.P.BI_Contiguous with Rn = SP (31)
    // Encoding: 0xE530E3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE530E3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ST2W_Z.P.BI_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_st2w_z_p_bi_contiguous_store_0_e530e020() {
    // Test ST2W_Z.P.BI_Contiguous memory store: 8 bytes
    // Encoding: 0xE530E020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE530E020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// STNT1H_Z.P.BR_Contiguous Tests
// ============================================================================

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 0 (Min)
    // Fields: Zt=0, Rn=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_1_poweroftwo_6000_e4816000() {
    // Encoding: 0xE4816000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 1 (PowerOfTwo)
    // Fields: Zt=0, Rm=1, Rn=0, Pg=0
    let encoding: u32 = 0xE4816000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_30_poweroftwominusone_6000_e49e6000() {
    // Encoding: 0xE49E6000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Zt=0, Rm=30, Pg=0, Rn=0
    let encoding: u32 = 0xE49E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rm_31_max_6000_e49f6000() {
    // Encoding: 0xE49F6000
    // Test STNT1H_Z.P.BR_Contiguous field Rm = 31 (Max)
    // Fields: Pg=0, Rn=0, Zt=0, Rm=31
    let encoding: u32 = 0xE49F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_pg_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Pg = 0 (Min)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_pg_1_poweroftwo_6000_e4806400() {
    // Encoding: 0xE4806400
    // Test STNT1H_Z.P.BR_Contiguous field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Rn=0, Zt=0, Rm=0
    let encoding: u32 = 0xE4806400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 0 (Min)
    // Fields: Zt=0, Pg=0, Rn=0, Rm=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_1_poweroftwo_6000_e4806020() {
    // Encoding: 0xE4806020
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 1 (PowerOfTwo)
    // Fields: Zt=0, Rn=1, Pg=0, Rm=0
    let encoding: u32 = 0xE4806020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_30_poweroftwominusone_6000_e48063c0() {
    // Encoding: 0xE48063C0
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE48063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_stnt1h_z_p_br_contiguous_field_rn_31_max_6000_e48063e0() {
    // Encoding: 0xE48063E0
    // Test STNT1H_Z.P.BR_Contiguous field Rn = 31 (Max)
    // Fields: Rm=0, Zt=0, Rn=31, Pg=0
    let encoding: u32 = 0xE48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_0_min_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 0 (Min)
    // Fields: Pg=0, Rm=0, Rn=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_1_poweroftwo_6000_e4806001() {
    // Encoding: 0xE4806001
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 1 (PowerOfTwo)
    // Fields: Rn=0, Zt=1, Rm=0, Pg=0
    let encoding: u32 = 0xE4806001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_30_poweroftwominusone_6000_e480601e() {
    // Encoding: 0xE480601E
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, Rn=0, Pg=0, Zt=30
    let encoding: u32 = 0xE480601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Zt 0 +: 5`
/// Requirement: FieldBoundary { field: "Zt", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_stnt1h_z_p_br_contiguous_field_zt_31_max_6000_e480601f() {
    // Encoding: 0xE480601F
    // Test STNT1H_Z.P.BR_Contiguous field Zt = 31 (Max)
    // Fields: Zt=31, Rn=0, Pg=0, Rm=0
    let encoding: u32 = 0xE480601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Rm=0 (register index 0 (first register))
#[test]
fn test_stnt1h_z_p_br_contiguous_combo_0_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous field combination: Rm=0, Pg=0, Rn=0, Zt=0
    // Fields: Rn=0, Rm=0, Zt=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_stnt1h_z_p_br_contiguous_special_rn_31_stack_pointer_sp_may_require_alignment_24576_e48063e0() {
    // Encoding: 0xE48063E0
    // Test STNT1H_Z.P.BR_Contiguous special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Pg=0, Rm=0, Zt=0
    let encoding: u32 = 0xE48063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction 0x{:08X} should execute successfully", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_0_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rm=0, Rn=0, Pg=0, Zt=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_1_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Rn=0, Zt=0, Rm=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"Rm\" }), rhs: LitBits([true, true, true, true, true]) }" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_2_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "Rm" }), rhs: LitBits([true, true, true, true, true]) }
    // Fields: Rm=0, Zt=0, Rn=0, Pg=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_stnt1h_z_p_br_contiguous_invalid_3_6000_e4806000() {
    // Encoding: 0xE4806000
    // Test STNT1H_Z.P.BR_Contiguous invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zt=0, Rm=0, Rn=0
    let encoding: u32 = 0xE4806000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue), "expected UNDEFINED for encoding 0x{:08X}", encoding);
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_stnt1h_z_p_br_contiguous_sp_rn_e48063e0() {
    // Test STNT1H_Z.P.BR_Contiguous with Rn = SP (31)
    // Encoding: 0xE48063E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0xE48063E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: STNT1H_Z.P.BR_Contiguous
/// ASL: `Mem[address, 8] = data`
/// Requirement: MemoryAccess { op: Store, size_bits: 64, addressing: "Base { reg: \"address\" }" }
/// 8-byte store
#[test]
fn test_stnt1h_z_p_br_contiguous_store_0_e4806020() {
    // Test STNT1H_Z.P.BR_Contiguous memory store: 8 bytes
    // Encoding: 0xE4806020
    let mut cpu = create_test_cpu();
    set_x(&mut cpu, 1, 0x100000000000);
    set_x(&mut cpu, 0, 0xDEADBEEFCAFEBABE);
    let encoding: u32 = 0xE4806020;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

