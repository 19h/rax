//! A64 sve other tests.
//!
//! Auto-generated from ARM ASL specifications.
//! DO NOT EDIT MANUALLY.

#![allow(unused_imports)]
#![allow(dead_code)]

use crate::generated::test_helpers::*;

// ============================================================================
// ASRR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_asrr_z_p_zz_field_size_0_min_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_asrr_z_p_zz_field_size_1_poweroftwo_8000_04548000() {
    // Encoding: 0x04548000
    // Test ASRR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04548000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_asrr_z_p_zz_field_size_2_poweroftwo_8000_04948000() {
    // Encoding: 0x04948000
    // Test ASRR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x04948000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_asrr_z_p_zz_field_size_3_max_8000_04d48000() {
    // Encoding: 0x04D48000
    // Test ASRR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, Pg=0, size=3, Zm=0
    let encoding: u32 = 0x04D48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_asrr_z_p_zz_field_pg_0_min_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_asrr_z_p_zz_field_pg_1_poweroftwo_8000_04148400() {
    // Encoding: 0x04148400
    // Test ASRR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zdn=0, Zm=0
    let encoding: u32 = 0x04148400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asrr_z_p_zz_field_zm_0_min_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asrr_z_p_zz_field_zm_1_poweroftwo_8000_04148020() {
    // Encoding: 0x04148020
    // Test ASRR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zm=1, Zdn=0
    let encoding: u32 = 0x04148020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asrr_z_p_zz_field_zm_30_poweroftwominusone_8000_041483c0() {
    // Encoding: 0x041483C0
    // Test ASRR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=0, Zm=30
    let encoding: u32 = 0x041483C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asrr_z_p_zz_field_zm_31_max_8000_041483e0() {
    // Encoding: 0x041483E0
    // Test ASRR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Pg=0, Zdn=0
    let encoding: u32 = 0x041483E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asrr_z_p_zz_field_zdn_0_min_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asrr_z_p_zz_field_zdn_1_poweroftwo_8000_04148001() {
    // Encoding: 0x04148001
    // Test ASRR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x04148001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_asrr_z_p_zz_field_zdn_15_poweroftwominusone_8000_0414800f() {
    // Encoding: 0x0414800F
    // Test ASRR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zdn=15, size=0
    let encoding: u32 = 0x0414800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_asrr_z_p_zz_field_zdn_31_max_8000_0414801f() {
    // Encoding: 0x0414801F
    // Test ASRR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zdn=31, size=0
    let encoding: u32 = 0x0414801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_asrr_z_p_zz_combo_0_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_asrr_z_p_zz_special_size_0_size_variant_0_32768_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_asrr_z_p_zz_special_size_1_size_variant_1_32768_04548000() {
    // Encoding: 0x04548000
    // Test ASRR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04548000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_asrr_z_p_zz_special_size_2_size_variant_2_32768_04948000() {
    // Encoding: 0x04948000
    // Test ASRR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04948000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_asrr_z_p_zz_special_size_3_size_variant_3_32768_04d48000() {
    // Encoding: 0x04D48000
    // Test ASRR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Pg=0, Zm=0, size=3
    let encoding: u32 = 0x04D48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asrr_z_p_zz_invalid_0_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asrr_z_p_zz_invalid_1_8000_04148000() {
    // Encoding: 0x04148000
    // Test ASRR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x04148000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASRR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_asrr_z_p_zz_reg_write_0_04148000() {
    // Test ASRR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04148000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04148000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// EXT_Z.ZI_Des Tests
// ============================================================================

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ext_z_zi_des_field_imm8h_0_zero_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des field imm8h = 0 (Zero)
    // Fields: Zm=0, Zdn=0, imm8h=0, imm8l=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ext_z_zi_des_field_imm8h_1_poweroftwo_0_05210000() {
    // Encoding: 0x05210000
    // Test EXT_Z.ZI_Des field imm8h = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm8h=1, imm8l=0, Zm=0
    let encoding: u32 = 0x05210000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_ext_z_zi_des_field_imm8h_3_poweroftwominusone_0_05230000() {
    // Encoding: 0x05230000
    // Test EXT_Z.ZI_Des field imm8h = 3 (PowerOfTwoMinusOne)
    // Fields: imm8h=3, Zm=0, Zdn=0, imm8l=0
    let encoding: u32 = 0x05230000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_ext_z_zi_des_field_imm8h_4_poweroftwo_0_05240000() {
    // Encoding: 0x05240000
    // Test EXT_Z.ZI_Des field imm8h = 4 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, imm8h=4, imm8l=0
    let encoding: u32 = 0x05240000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_ext_z_zi_des_field_imm8h_7_poweroftwominusone_0_05270000() {
    // Encoding: 0x05270000
    // Test EXT_Z.ZI_Des field imm8h = 7 (PowerOfTwoMinusOne)
    // Fields: imm8l=0, Zm=0, imm8h=7, Zdn=0
    let encoding: u32 = 0x05270000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_ext_z_zi_des_field_imm8h_8_poweroftwo_0_05280000() {
    // Encoding: 0x05280000
    // Test EXT_Z.ZI_Des field imm8h = 8 (PowerOfTwo)
    // Fields: imm8h=8, Zm=0, imm8l=0, Zdn=0
    let encoding: u32 = 0x05280000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_ext_z_zi_des_field_imm8h_15_poweroftwominusone_0_052f0000() {
    // Encoding: 0x052F0000
    // Test EXT_Z.ZI_Des field imm8h = 15 (PowerOfTwoMinusOne)
    // Fields: imm8h=15, Zm=0, imm8l=0, Zdn=0
    let encoding: u32 = 0x052F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_ext_z_zi_des_field_imm8h_16_poweroftwo_0_05300000() {
    // Encoding: 0x05300000
    // Test EXT_Z.ZI_Des field imm8h = 16 (PowerOfTwo)
    // Fields: Zm=0, imm8h=16, imm8l=0, Zdn=0
    let encoding: u32 = 0x05300000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8h 16 +: 5`
/// Requirement: FieldBoundary { field: "imm8h", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_ext_z_zi_des_field_imm8h_31_max_0_053f0000() {
    // Encoding: 0x053F0000
    // Test EXT_Z.ZI_Des field imm8h = 31 (Max)
    // Fields: imm8l=0, imm8h=31, Zdn=0, Zm=0
    let encoding: u32 = 0x053F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm8l", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_ext_z_zi_des_field_imm8l_0_zero_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des field imm8l = 0 (Zero)
    // Fields: imm8h=0, Zdn=0, Zm=0, imm8l=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm8l", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_ext_z_zi_des_field_imm8l_1_poweroftwo_0_05200400() {
    // Encoding: 0x05200400
    // Test EXT_Z.ZI_Des field imm8l = 1 (PowerOfTwo)
    // Fields: Zm=0, imm8l=1, Zdn=0, imm8h=0
    let encoding: u32 = 0x05200400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm8l", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_ext_z_zi_des_field_imm8l_3_poweroftwominusone_0_05200c00() {
    // Encoding: 0x05200C00
    // Test EXT_Z.ZI_Des field imm8l = 3 (PowerOfTwoMinusOne)
    // Fields: imm8h=0, Zm=0, imm8l=3, Zdn=0
    let encoding: u32 = 0x05200C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field imm8l 10 +: 3`
/// Requirement: FieldBoundary { field: "imm8l", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_ext_z_zi_des_field_imm8l_7_max_0_05201c00() {
    // Encoding: 0x05201C00
    // Test EXT_Z.ZI_Des field imm8l = 7 (Max)
    // Fields: imm8h=0, Zm=0, Zdn=0, imm8l=7
    let encoding: u32 = 0x05201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_ext_z_zi_des_field_zm_0_min_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des field Zm = 0 (Min)
    // Fields: Zdn=0, imm8h=0, Zm=0, imm8l=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_ext_z_zi_des_field_zm_1_poweroftwo_0_05200020() {
    // Encoding: 0x05200020
    // Test EXT_Z.ZI_Des field Zm = 1 (PowerOfTwo)
    // Fields: imm8l=0, imm8h=0, Zdn=0, Zm=1
    let encoding: u32 = 0x05200020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_ext_z_zi_des_field_zm_30_poweroftwominusone_0_052003c0() {
    // Encoding: 0x052003C0
    // Test EXT_Z.ZI_Des field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: imm8h=0, imm8l=0, Zm=30, Zdn=0
    let encoding: u32 = 0x052003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_ext_z_zi_des_field_zm_31_max_0_052003e0() {
    // Encoding: 0x052003E0
    // Test EXT_Z.ZI_Des field Zm = 31 (Max)
    // Fields: imm8l=0, Zdn=0, Zm=31, imm8h=0
    let encoding: u32 = 0x052003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_ext_z_zi_des_field_zdn_0_min_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des field Zdn = 0 (Min)
    // Fields: imm8h=0, Zm=0, imm8l=0, Zdn=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_ext_z_zi_des_field_zdn_1_poweroftwo_0_05200001() {
    // Encoding: 0x05200001
    // Test EXT_Z.ZI_Des field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, imm8h=0, imm8l=0, Zdn=1
    let encoding: u32 = 0x05200001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_ext_z_zi_des_field_zdn_15_poweroftwominusone_0_0520000f() {
    // Encoding: 0x0520000F
    // Test EXT_Z.ZI_Des field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm8l=0, Zm=0, imm8h=0, Zdn=15
    let encoding: u32 = 0x0520000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_ext_z_zi_des_field_zdn_31_max_0_0520001f() {
    // Encoding: 0x0520001F
    // Test EXT_Z.ZI_Des field Zdn = 31 (Max)
    // Fields: imm8l=0, imm8h=0, Zm=0, Zdn=31
    let encoding: u32 = 0x0520001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm8h=0 (immediate value 0)
#[test]
fn test_ext_z_zi_des_combo_0_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des field combination: imm8h=0, imm8l=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Zm=0, imm8h=0, imm8l=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_ext_z_zi_des_invalid_0_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, imm8h=0, Zdn=0, imm8l=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_ext_z_zi_des_invalid_1_0_05200000() {
    // Encoding: 0x05200000
    // Test EXT_Z.ZI_Des invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, imm8l=0, Zdn=0, imm8h=0
    let encoding: u32 = 0x05200000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: EXT_Z.ZI_Des
/// ASL: `SimdFromField("dst") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dst")
#[test]
fn test_ext_z_zi_des_reg_write_0_05200000() {
    // Test EXT_Z.ZI_Des register write: SimdFromField("dst")
    // Encoding: 0x05200000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05200000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ABS_Z.P.Z__ Tests
// ============================================================================

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_abs_z_p_z_field_size_0_min_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_abs_z_p_z_field_size_1_poweroftwo_a000_0456a000() {
    // Encoding: 0x0456A000
    // Test ABS_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=1, Pg=0
    let encoding: u32 = 0x0456A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_abs_z_p_z_field_size_2_poweroftwo_a000_0496a000() {
    // Encoding: 0x0496A000
    // Test ABS_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0496A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_abs_z_p_z_field_size_3_max_a000_04d6a000() {
    // Encoding: 0x04D6A000
    // Test ABS_Z.P.Z__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x04D6A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_abs_z_p_z_field_pg_0_min_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_abs_z_p_z_field_pg_1_poweroftwo_a000_0416a400() {
    // Encoding: 0x0416A400
    // Test ABS_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zd=0, Zn=0, Pg=1
    let encoding: u32 = 0x0416A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_abs_z_p_z_field_zn_0_min_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_abs_z_p_z_field_zn_1_poweroftwo_a000_0416a020() {
    // Encoding: 0x0416A020
    // Test ABS_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zn=1, Zd=0
    let encoding: u32 = 0x0416A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_abs_z_p_z_field_zn_30_poweroftwominusone_a000_0416a3c0() {
    // Encoding: 0x0416A3C0
    // Test ABS_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Pg=0, Zd=0
    let encoding: u32 = 0x0416A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_abs_z_p_z_field_zn_31_max_a000_0416a3e0() {
    // Encoding: 0x0416A3E0
    // Test ABS_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x0416A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_abs_z_p_z_field_zd_0_min_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_abs_z_p_z_field_zd_1_poweroftwo_a000_0416a001() {
    // Encoding: 0x0416A001
    // Test ABS_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1, Pg=0
    let encoding: u32 = 0x0416A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_abs_z_p_z_field_zd_30_poweroftwominusone_a000_0416a01e() {
    // Encoding: 0x0416A01E
    // Test ABS_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=0, Zd=30
    let encoding: u32 = 0x0416A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_abs_z_p_z_field_zd_31_max_a000_0416a01f() {
    // Encoding: 0x0416A01F
    // Test ABS_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0416A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_abs_z_p_z_combo_0_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_abs_z_p_z_special_size_0_size_variant_0_40960_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_abs_z_p_z_special_size_1_size_variant_1_40960_0456a000() {
    // Encoding: 0x0456A000
    // Test ABS_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0456A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_abs_z_p_z_special_size_2_size_variant_2_40960_0496a000() {
    // Encoding: 0x0496A000
    // Test ABS_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Pg=0, Zd=0
    let encoding: u32 = 0x0496A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_abs_z_p_z_special_size_3_size_variant_3_40960_04d6a000() {
    // Encoding: 0x04D6A000
    // Test ABS_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zd=0, size=3, Pg=0
    let encoding: u32 = 0x04D6A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_abs_z_p_z_invalid_0_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_abs_z_p_z_invalid_1_a000_0416a000() {
    // Encoding: 0x0416A000
    // Test ABS_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x0416A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ABS_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_abs_z_p_z_reg_write_0_0416a000() {
    // Test ABS_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0416A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0416A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQSUB_Z.ZI__ Tests
// ============================================================================

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqsub_z_zi_field_size_0_min_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ field size = 0 (Min)
    // Fields: imm8=0, size=0, sh=0, Zdn=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqsub_z_zi_field_size_1_poweroftwo_c000_2567c000() {
    // Encoding: 0x2567C000
    // Test UQSUB_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: size=1, imm8=0, Zdn=0, sh=0
    let encoding: u32 = 0x2567C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqsub_z_zi_field_size_2_poweroftwo_c000_25a7c000() {
    // Encoding: 0x25A7C000
    // Test UQSUB_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, imm8=0, sh=0, size=2
    let encoding: u32 = 0x25A7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqsub_z_zi_field_size_3_max_c000_25e7c000() {
    // Encoding: 0x25E7C000
    // Test UQSUB_Z.ZI__ field size = 3 (Max)
    // Fields: size=3, imm8=0, Zdn=0, sh=0
    let encoding: u32 = 0x25E7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_uqsub_z_zi_field_sh_0_min_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ field sh = 0 (Min)
    // Fields: sh=0, Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_uqsub_z_zi_field_sh_1_max_c000_2527e000() {
    // Encoding: 0x2527E000
    // Test UQSUB_Z.ZI__ field sh = 1 (Max)
    // Fields: sh=1, imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x2527E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqsub_z_zi_field_imm8_0_zero_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: imm8=0, Zdn=0, sh=0, size=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqsub_z_zi_field_imm8_1_poweroftwo_c000_2527c020() {
    // Encoding: 0x2527C020
    // Test UQSUB_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, imm8=1, sh=0
    let encoding: u32 = 0x2527C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqsub_z_zi_field_imm8_3_poweroftwominusone_c000_2527c060() {
    // Encoding: 0x2527C060
    // Test UQSUB_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=3, size=0, Zdn=0
    let encoding: u32 = 0x2527C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqsub_z_zi_field_imm8_4_poweroftwo_c000_2527c080() {
    // Encoding: 0x2527C080
    // Test UQSUB_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: imm8=4, size=0, sh=0, Zdn=0
    let encoding: u32 = 0x2527C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_uqsub_z_zi_field_imm8_7_poweroftwominusone_c000_2527c0e0() {
    // Encoding: 0x2527C0E0
    // Test UQSUB_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: imm8=7, size=0, sh=0, Zdn=0
    let encoding: u32 = 0x2527C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqsub_z_zi_field_imm8_8_poweroftwo_c000_2527c100() {
    // Encoding: 0x2527C100
    // Test UQSUB_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: Zdn=0, size=0, sh=0, imm8=8
    let encoding: u32 = 0x2527C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_uqsub_z_zi_field_imm8_15_poweroftwominusone_c000_2527c1e0() {
    // Encoding: 0x2527C1E0
    // Test UQSUB_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, imm8=15, sh=0
    let encoding: u32 = 0x2527C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_uqsub_z_zi_field_imm8_16_poweroftwo_c000_2527c200() {
    // Encoding: 0x2527C200
    // Test UQSUB_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: sh=0, Zdn=0, size=0, imm8=16
    let encoding: u32 = 0x2527C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_uqsub_z_zi_field_imm8_31_poweroftwominusone_c000_2527c3e0() {
    // Encoding: 0x2527C3E0
    // Test UQSUB_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: imm8=31, size=0, sh=0, Zdn=0
    let encoding: u32 = 0x2527C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_uqsub_z_zi_field_imm8_32_poweroftwo_c000_2527c400() {
    // Encoding: 0x2527C400
    // Test UQSUB_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: size=0, sh=0, Zdn=0, imm8=32
    let encoding: u32 = 0x2527C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_uqsub_z_zi_field_imm8_63_poweroftwominusone_c000_2527c7e0() {
    // Encoding: 0x2527C7E0
    // Test UQSUB_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=63, size=0, sh=0
    let encoding: u32 = 0x2527C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_uqsub_z_zi_field_imm8_64_poweroftwo_c000_2527c800() {
    // Encoding: 0x2527C800
    // Test UQSUB_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: imm8=64, Zdn=0, sh=0, size=0
    let encoding: u32 = 0x2527C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_uqsub_z_zi_field_imm8_127_poweroftwominusone_c000_2527cfe0() {
    // Encoding: 0x2527CFE0
    // Test UQSUB_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, sh=0, imm8=127, size=0
    let encoding: u32 = 0x2527CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_uqsub_z_zi_field_imm8_128_poweroftwo_c000_2527d000() {
    // Encoding: 0x2527D000
    // Test UQSUB_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: imm8=128, Zdn=0, size=0, sh=0
    let encoding: u32 = 0x2527D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_uqsub_z_zi_field_imm8_255_max_c000_2527dfe0() {
    // Encoding: 0x2527DFE0
    // Test UQSUB_Z.ZI__ field imm8 = 255 (Max)
    // Fields: sh=0, size=0, imm8=255, Zdn=0
    let encoding: u32 = 0x2527DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqsub_z_zi_field_zdn_0_min_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ field Zdn = 0 (Min)
    // Fields: sh=0, imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqsub_z_zi_field_zdn_1_poweroftwo_c000_2527c001() {
    // Encoding: 0x2527C001
    // Test UQSUB_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, sh=0, imm8=0, Zdn=1
    let encoding: u32 = 0x2527C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqsub_z_zi_field_zdn_15_poweroftwominusone_c000_2527c00f() {
    // Encoding: 0x2527C00F
    // Test UQSUB_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, imm8=0, sh=0
    let encoding: u32 = 0x2527C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqsub_z_zi_field_zdn_31_max_c000_2527c01f() {
    // Encoding: 0x2527C01F
    // Test UQSUB_Z.ZI__ field Zdn = 31 (Max)
    // Fields: size=0, imm8=0, Zdn=31, sh=0
    let encoding: u32 = 0x2527C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqsub_z_zi_combo_0_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ field combination: size=0, sh=0, imm8=0, Zdn=0
    // Fields: sh=0, Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqsub_z_zi_special_size_0_size_variant_0_49152_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: imm8=0, sh=0, size=0, Zdn=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqsub_z_zi_special_size_1_size_variant_1_49152_2567c000() {
    // Encoding: 0x2567C000
    // Test UQSUB_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, sh=0, imm8=0, size=1
    let encoding: u32 = 0x2567C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqsub_z_zi_special_size_2_size_variant_2_49152_25a7c000() {
    // Encoding: 0x25A7C000
    // Test UQSUB_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: size=2, sh=0, imm8=0, Zdn=0
    let encoding: u32 = 0x25A7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqsub_z_zi_special_size_3_size_variant_3_49152_25e7c000() {
    // Encoding: 0x25E7C000
    // Test UQSUB_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: size=3, imm8=0, Zdn=0, sh=0
    let encoding: u32 = 0x25E7C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_uqsub_z_zi_special_sh_0_shift_type_lsl_49152_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ special value sh = 0 (Shift type LSL)
    // Fields: Zdn=0, sh=0, imm8=0, size=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_uqsub_z_zi_special_sh_1_shift_type_lsr_49152_2527e000() {
    // Encoding: 0x2527E000
    // Test UQSUB_Z.ZI__ special value sh = 1 (Shift type LSR)
    // Fields: size=0, imm8=0, Zdn=0, sh=1
    let encoding: u32 = 0x2527E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_uqsub_z_zi_special_sh_2_shift_type_asr_49152_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ special value sh = 2 (Shift type ASR)
    // Fields: size=0, imm8=0, sh=2, Zdn=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_uqsub_z_zi_special_sh_3_shift_type_ror_49152_2527e000() {
    // Encoding: 0x2527E000
    // Test UQSUB_Z.ZI__ special value sh = 3 (Shift type ROR)
    // Fields: imm8=0, Zdn=0, sh=3, size=0
    let encoding: u32 = 0x2527E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqsub_z_zi_invalid_0_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: sh=0, Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqsub_z_zi_invalid_1_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, sh=0, imm8=0, size=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sh\" }), rhs: LitBits([false, false, true]) } }" }
/// triggers Undefined
#[test]
fn test_uqsub_z_zi_invalid_2_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }
    // Fields: sh=0, imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqsub_z_zi_invalid_3_c000_2527c000() {
    // Encoding: 0x2527C000
    // Test UQSUB_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, imm8=0, sh=0, Zdn=0
    let encoding: u32 = 0x2527C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqsub_z_zi_reg_write_0_2527c000() {
    // Test UQSUB_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x2527C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2527C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UDIVR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_udivr_z_p_zz_field_size_0_min_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_udivr_z_p_zz_field_size_1_poweroftwo_0_04570000() {
    // Encoding: 0x04570000
    // Test UDIVR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x04570000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_udivr_z_p_zz_field_size_2_poweroftwo_0_04970000() {
    // Encoding: 0x04970000
    // Test UDIVR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=2, Zdn=0
    let encoding: u32 = 0x04970000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_udivr_z_p_zz_field_size_3_max_0_04d70000() {
    // Encoding: 0x04D70000
    // Test UDIVR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04D70000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_udivr_z_p_zz_field_pg_0_min_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_udivr_z_p_zz_field_pg_1_poweroftwo_0_04170400() {
    // Encoding: 0x04170400
    // Test UDIVR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zm=0, Zdn=0
    let encoding: u32 = 0x04170400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udivr_z_p_zz_field_zm_0_min_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udivr_z_p_zz_field_zm_1_poweroftwo_0_04170020() {
    // Encoding: 0x04170020
    // Test UDIVR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zm=1, Zdn=0
    let encoding: u32 = 0x04170020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_udivr_z_p_zz_field_zm_30_poweroftwominusone_0_041703c0() {
    // Encoding: 0x041703C0
    // Test UDIVR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=0, size=0, Zm=30
    let encoding: u32 = 0x041703C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_udivr_z_p_zz_field_zm_31_max_0_041703e0() {
    // Encoding: 0x041703E0
    // Test UDIVR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, size=0, Pg=0, Zm=31
    let encoding: u32 = 0x041703E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udivr_z_p_zz_field_zdn_0_min_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_udivr_z_p_zz_field_zdn_1_poweroftwo_0_04170001() {
    // Encoding: 0x04170001
    // Test UDIVR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zdn=1, Pg=0
    let encoding: u32 = 0x04170001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_udivr_z_p_zz_field_zdn_15_poweroftwominusone_0_0417000f() {
    // Encoding: 0x0417000F
    // Test UDIVR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=15, Pg=0, Zm=0
    let encoding: u32 = 0x0417000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_udivr_z_p_zz_field_zdn_31_max_0_0417001f() {
    // Encoding: 0x0417001F
    // Test UDIVR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zm=0, Pg=0, Zdn=31
    let encoding: u32 = 0x0417001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_udivr_z_p_zz_combo_0_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_udivr_z_p_zz_special_size_0_size_variant_0_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_udivr_z_p_zz_special_size_1_size_variant_1_0_04570000() {
    // Encoding: 0x04570000
    // Test UDIVR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04570000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_udivr_z_p_zz_special_size_2_size_variant_2_0_04970000() {
    // Encoding: 0x04970000
    // Test UDIVR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x04970000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_udivr_z_p_zz_special_size_3_size_variant_3_0_04d70000() {
    // Encoding: 0x04D70000
    // Test UDIVR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04D70000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_udivr_z_p_zz_invalid_0_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udivr_z_p_zz_invalid_1_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([Zero, Either]) }" }
/// triggers Undefined
#[test]
fn test_udivr_z_p_zz_invalid_2_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udivr_z_p_zz_invalid_3_0_04170000() {
    // Encoding: 0x04170000
    // Test UDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04170000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIVR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_udivr_z_p_zz_reg_write_0_04170000() {
    // Test UDIVR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04170000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04170000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ASR_Z.ZW__ Tests
// ============================================================================

/// Provenance: ASR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_asr_z_zw_field_size_0_min_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ field size = 0 (Min)
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_asr_z_zw_field_size_1_poweroftwo_8000_04608000() {
    // Encoding: 0x04608000
    // Test ASR_Z.ZW__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=0, size=1, Zn=0
    let encoding: u32 = 0x04608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_asr_z_zw_field_size_2_poweroftwo_8000_04a08000() {
    // Encoding: 0x04A08000
    // Test ASR_Z.ZW__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=2, Zm=0
    let encoding: u32 = 0x04A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_asr_z_zw_field_size_3_max_8000_04e08000() {
    // Encoding: 0x04E08000
    // Test ASR_Z.ZW__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_zw_field_zm_0_min_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_zw_field_zm_1_poweroftwo_8000_04218000() {
    // Encoding: 0x04218000
    // Test ASR_Z.ZW__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=1, Zd=0
    let encoding: u32 = 0x04218000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_zw_field_zm_30_poweroftwominusone_8000_043e8000() {
    // Encoding: 0x043E8000
    // Test ASR_Z.ZW__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zm=30, size=0, Zd=0
    let encoding: u32 = 0x043E8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_zw_field_zm_31_max_8000_043f8000() {
    // Encoding: 0x043F8000
    // Test ASR_Z.ZW__ field Zm = 31 (Max)
    // Fields: Zm=31, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x043F8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_zw_field_zn_0_min_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ field Zn = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_zw_field_zn_1_poweroftwo_8000_04208020() {
    // Encoding: 0x04208020
    // Test ASR_Z.ZW__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zd=0, Zn=1
    let encoding: u32 = 0x04208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_zw_field_zn_30_poweroftwominusone_8000_042083c0() {
    // Encoding: 0x042083C0
    // Test ASR_Z.ZW__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zn=30, Zd=0
    let encoding: u32 = 0x042083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_zw_field_zn_31_max_8000_042083e0() {
    // Encoding: 0x042083E0
    // Test ASR_Z.ZW__ field Zn = 31 (Max)
    // Fields: Zm=0, size=0, Zd=0, Zn=31
    let encoding: u32 = 0x042083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_zw_field_zd_0_min_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ field Zd = 0 (Min)
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_zw_field_zd_1_poweroftwo_8000_04208001() {
    // Encoding: 0x04208001
    // Test ASR_Z.ZW__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zm=0, Zd=1
    let encoding: u32 = 0x04208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_zw_field_zd_30_poweroftwominusone_8000_0420801e() {
    // Encoding: 0x0420801E
    // Test ASR_Z.ZW__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0, Zm=0
    let encoding: u32 = 0x0420801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_zw_field_zd_31_max_8000_0420801f() {
    // Encoding: 0x0420801F
    // Test ASR_Z.ZW__ field Zd = 31 (Max)
    // Fields: Zd=31, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x0420801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_asr_z_zw_combo_0_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_asr_z_zw_special_size_0_size_variant_0_32768_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_asr_z_zw_special_size_1_size_variant_1_32768_04608000() {
    // Encoding: 0x04608000
    // Test ASR_Z.ZW__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zd=0, size=1, Zn=0
    let encoding: u32 = 0x04608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_asr_z_zw_special_size_2_size_variant_2_32768_04a08000() {
    // Encoding: 0x04A08000
    // Test ASR_Z.ZW__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zd=0, Zm=0
    let encoding: u32 = 0x04A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_asr_z_zw_special_size_3_size_variant_3_32768_04e08000() {
    // Encoding: 0x04E08000
    // Test ASR_Z.ZW__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x04E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asr_z_zw_invalid_0_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_zw_invalid_1_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_asr_z_zw_invalid_2_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_zw_invalid_3_8000_04208000() {
    // Encoding: 0x04208000
    // Test ASR_Z.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x04208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZW__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_asr_z_zw_reg_write_0_04208000() {
    // Test ASR_Z.ZW__ register write: SimdFromField("d")
    // Encoding: 0x04208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMIN_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umin_z_p_zz_field_size_0_min_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umin_z_p_zz_field_size_1_poweroftwo_0_044b0000() {
    // Encoding: 0x044B0000
    // Test UMIN_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x044B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umin_z_p_zz_field_size_2_poweroftwo_0_048b0000() {
    // Encoding: 0x048B0000
    // Test UMIN_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=2, Zm=0
    let encoding: u32 = 0x048B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umin_z_p_zz_field_size_3_max_0_04cb0000() {
    // Encoding: 0x04CB0000
    // Test UMIN_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Pg=0, Zdn=0, size=3, Zm=0
    let encoding: u32 = 0x04CB0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_umin_z_p_zz_field_pg_0_min_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_umin_z_p_zz_field_pg_1_poweroftwo_0_040b0400() {
    // Encoding: 0x040B0400
    // Test UMIN_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zdn=0, Pg=1
    let encoding: u32 = 0x040B0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_umin_z_p_zz_field_zm_0_min_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_umin_z_p_zz_field_zm_1_poweroftwo_0_040b0020() {
    // Encoding: 0x040B0020
    // Test UMIN_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, Zm=1, size=0
    let encoding: u32 = 0x040B0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_umin_z_p_zz_field_zm_30_poweroftwominusone_0_040b03c0() {
    // Encoding: 0x040B03C0
    // Test UMIN_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, Zm=30, Pg=0
    let encoding: u32 = 0x040B03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_umin_z_p_zz_field_zm_31_max_0_040b03e0() {
    // Encoding: 0x040B03E0
    // Test UMIN_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zdn=0, Zm=31, Pg=0
    let encoding: u32 = 0x040B03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_umin_z_p_zz_field_zdn_0_min_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_umin_z_p_zz_field_zdn_1_poweroftwo_0_040b0001() {
    // Encoding: 0x040B0001
    // Test UMIN_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, size=0, Zdn=1
    let encoding: u32 = 0x040B0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_umin_z_p_zz_field_zdn_15_poweroftwominusone_0_040b000f() {
    // Encoding: 0x040B000F
    // Test UMIN_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=0, Zdn=15, size=0
    let encoding: u32 = 0x040B000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_umin_z_p_zz_field_zdn_31_max_0_040b001f() {
    // Encoding: 0x040B001F
    // Test UMIN_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zdn=31, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x040B001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umin_z_p_zz_combo_0_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umin_z_p_zz_special_size_0_size_variant_0_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umin_z_p_zz_special_size_1_size_variant_1_0_044b0000() {
    // Encoding: 0x044B0000
    // Test UMIN_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x044B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umin_z_p_zz_special_size_2_size_variant_2_0_048b0000() {
    // Encoding: 0x048B0000
    // Test UMIN_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, size=2, Pg=0, Zm=0
    let encoding: u32 = 0x048B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umin_z_p_zz_special_size_3_size_variant_3_0_04cb0000() {
    // Encoding: 0x04CB0000
    // Test UMIN_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x04CB0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umin_z_p_zz_invalid_0_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umin_z_p_zz_invalid_1_0_040b0000() {
    // Encoding: 0x040B0000
    // Test UMIN_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x040B0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMIN_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_umin_z_p_zz_reg_write_0_040b0000() {
    // Test UMIN_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x040B0000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040B0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INDEX_Z.II__ Tests
// ============================================================================

/// Provenance: INDEX_Z.II__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_index_z_ii_field_size_0_min_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ field size = 0 (Min)
    // Fields: imm5b=0, Zd=0, imm5=0, size=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_index_z_ii_field_size_1_poweroftwo_4000_04604000() {
    // Encoding: 0x04604000
    // Test INDEX_Z.II__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, imm5b=0, imm5=0, size=1
    let encoding: u32 = 0x04604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_index_z_ii_field_size_2_poweroftwo_4000_04a04000() {
    // Encoding: 0x04A04000
    // Test INDEX_Z.II__ field size = 2 (PowerOfTwo)
    // Fields: imm5b=0, size=2, imm5=0, Zd=0
    let encoding: u32 = 0x04A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_index_z_ii_field_size_3_max_4000_04e04000() {
    // Encoding: 0x04E04000
    // Test INDEX_Z.II__ field size = 3 (Max)
    // Fields: size=3, imm5=0, Zd=0, imm5b=0
    let encoding: u32 = 0x04E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_index_z_ii_field_imm5b_0_zero_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ field imm5b = 0 (Zero)
    // Fields: size=0, Zd=0, imm5=0, imm5b=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_index_z_ii_field_imm5b_1_poweroftwo_4000_04214000() {
    // Encoding: 0x04214000
    // Test INDEX_Z.II__ field imm5b = 1 (PowerOfTwo)
    // Fields: size=0, imm5=0, Zd=0, imm5b=1
    let encoding: u32 = 0x04214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_index_z_ii_field_imm5b_3_poweroftwominusone_4000_04234000() {
    // Encoding: 0x04234000
    // Test INDEX_Z.II__ field imm5b = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=0, size=0, Zd=0, imm5b=3
    let encoding: u32 = 0x04234000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_index_z_ii_field_imm5b_4_poweroftwo_4000_04244000() {
    // Encoding: 0x04244000
    // Test INDEX_Z.II__ field imm5b = 4 (PowerOfTwo)
    // Fields: size=0, Zd=0, imm5=0, imm5b=4
    let encoding: u32 = 0x04244000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_index_z_ii_field_imm5b_7_poweroftwominusone_4000_04274000() {
    // Encoding: 0x04274000
    // Test INDEX_Z.II__ field imm5b = 7 (PowerOfTwoMinusOne)
    // Fields: Zd=0, imm5b=7, imm5=0, size=0
    let encoding: u32 = 0x04274000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_index_z_ii_field_imm5b_8_poweroftwo_4000_04284000() {
    // Encoding: 0x04284000
    // Test INDEX_Z.II__ field imm5b = 8 (PowerOfTwo)
    // Fields: imm5b=8, size=0, Zd=0, imm5=0
    let encoding: u32 = 0x04284000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_index_z_ii_field_imm5b_15_poweroftwominusone_4000_042f4000() {
    // Encoding: 0x042F4000
    // Test INDEX_Z.II__ field imm5b = 15 (PowerOfTwoMinusOne)
    // Fields: imm5b=15, imm5=0, Zd=0, size=0
    let encoding: u32 = 0x042F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_index_z_ii_field_imm5b_16_poweroftwo_4000_04304000() {
    // Encoding: 0x04304000
    // Test INDEX_Z.II__ field imm5b = 16 (PowerOfTwo)
    // Fields: imm5=0, Zd=0, imm5b=16, size=0
    let encoding: u32 = 0x04304000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5b 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5b", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_index_z_ii_field_imm5b_31_max_4000_043f4000() {
    // Encoding: 0x043F4000
    // Test INDEX_Z.II__ field imm5b = 31 (Max)
    // Fields: imm5b=31, size=0, Zd=0, imm5=0
    let encoding: u32 = 0x043F4000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_index_z_ii_field_imm5_0_zero_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ field imm5 = 0 (Zero)
    // Fields: imm5=0, size=0, imm5b=0, Zd=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_index_z_ii_field_imm5_1_poweroftwo_4000_04204020() {
    // Encoding: 0x04204020
    // Test INDEX_Z.II__ field imm5 = 1 (PowerOfTwo)
    // Fields: imm5b=0, size=0, Zd=0, imm5=1
    let encoding: u32 = 0x04204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_index_z_ii_field_imm5_3_poweroftwominusone_4000_04204060() {
    // Encoding: 0x04204060
    // Test INDEX_Z.II__ field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, imm5b=0, imm5=3
    let encoding: u32 = 0x04204060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_index_z_ii_field_imm5_4_poweroftwo_4000_04204080() {
    // Encoding: 0x04204080
    // Test INDEX_Z.II__ field imm5 = 4 (PowerOfTwo)
    // Fields: Zd=0, imm5=4, imm5b=0, size=0
    let encoding: u32 = 0x04204080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_index_z_ii_field_imm5_7_poweroftwominusone_4000_042040e0() {
    // Encoding: 0x042040E0
    // Test INDEX_Z.II__ field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: imm5=7, size=0, imm5b=0, Zd=0
    let encoding: u32 = 0x042040E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_index_z_ii_field_imm5_8_poweroftwo_4000_04204100() {
    // Encoding: 0x04204100
    // Test INDEX_Z.II__ field imm5 = 8 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm5=8, imm5b=0
    let encoding: u32 = 0x04204100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_index_z_ii_field_imm5_15_poweroftwominusone_4000_042041e0() {
    // Encoding: 0x042041E0
    // Test INDEX_Z.II__ field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, imm5b=0, Zd=0, size=0
    let encoding: u32 = 0x042041E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_index_z_ii_field_imm5_16_poweroftwo_4000_04204200() {
    // Encoding: 0x04204200
    // Test INDEX_Z.II__ field imm5 = 16 (PowerOfTwo)
    // Fields: size=0, imm5=16, Zd=0, imm5b=0
    let encoding: u32 = 0x04204200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_index_z_ii_field_imm5_31_max_4000_042043e0() {
    // Encoding: 0x042043E0
    // Test INDEX_Z.II__ field imm5 = 31 (Max)
    // Fields: size=0, imm5b=0, imm5=31, Zd=0
    let encoding: u32 = 0x042043E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_index_z_ii_field_zd_0_min_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ field Zd = 0 (Min)
    // Fields: size=0, imm5b=0, imm5=0, Zd=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_index_z_ii_field_zd_1_poweroftwo_4000_04204001() {
    // Encoding: 0x04204001
    // Test INDEX_Z.II__ field Zd = 1 (PowerOfTwo)
    // Fields: imm5b=0, imm5=0, size=0, Zd=1
    let encoding: u32 = 0x04204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_index_z_ii_field_zd_30_poweroftwominusone_4000_0420401e() {
    // Encoding: 0x0420401E
    // Test INDEX_Z.II__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, size=0, imm5=0, imm5b=0
    let encoding: u32 = 0x0420401E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_index_z_ii_field_zd_31_max_4000_0420401f() {
    // Encoding: 0x0420401F
    // Test INDEX_Z.II__ field Zd = 31 (Max)
    // Fields: imm5=0, imm5b=0, Zd=31, size=0
    let encoding: u32 = 0x0420401F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_index_z_ii_combo_0_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ field combination: size=0, imm5b=0, imm5=0, Zd=0
    // Fields: Zd=0, imm5b=0, size=0, imm5=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_index_z_ii_special_size_0_size_variant_0_16384_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ special value size = 0 (Size variant 0)
    // Fields: size=0, imm5b=0, imm5=0, Zd=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_index_z_ii_special_size_1_size_variant_1_16384_04604000() {
    // Encoding: 0x04604000
    // Test INDEX_Z.II__ special value size = 1 (Size variant 1)
    // Fields: imm5b=0, size=1, Zd=0, imm5=0
    let encoding: u32 = 0x04604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_index_z_ii_special_size_2_size_variant_2_16384_04a04000() {
    // Encoding: 0x04A04000
    // Test INDEX_Z.II__ special value size = 2 (Size variant 2)
    // Fields: imm5b=0, size=2, imm5=0, Zd=0
    let encoding: u32 = 0x04A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_index_z_ii_special_size_3_size_variant_3_16384_04e04000() {
    // Encoding: 0x04E04000
    // Test INDEX_Z.II__ special value size = 3 (Size variant 3)
    // Fields: imm5b=0, imm5=0, size=3, Zd=0
    let encoding: u32 = 0x04E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_index_z_ii_invalid_0_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm5=0, size=0, Zd=0, imm5b=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_index_z_ii_invalid_1_4000_04204000() {
    // Encoding: 0x04204000
    // Test INDEX_Z.II__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm5=0, size=0, imm5b=0, Zd=0
    let encoding: u32 = 0x04204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.II__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_index_z_ii_reg_write_0_04204000() {
    // Test INDEX_Z.II__ register write: SimdFromField("d")
    // Encoding: 0x04204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UZP1_Z.ZZ__ Tests
// ============================================================================

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uzp1_z_zz_field_size_0_min_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uzp1_z_zz_field_size_1_poweroftwo_6800_05606800() {
    // Encoding: 0x05606800
    // Test UZP1_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Zn=0, Zd=0
    let encoding: u32 = 0x05606800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uzp1_z_zz_field_size_2_poweroftwo_6800_05a06800() {
    // Encoding: 0x05A06800
    // Test UZP1_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, size=2, Zn=0
    let encoding: u32 = 0x05A06800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uzp1_z_zz_field_size_3_max_6800_05e06800() {
    // Encoding: 0x05E06800
    // Test UZP1_Z.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Zd=0, size=3, Zn=0
    let encoding: u32 = 0x05E06800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uzp1_z_zz_field_zm_0_min_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uzp1_z_zz_field_zm_1_poweroftwo_6800_05216800() {
    // Encoding: 0x05216800
    // Test UZP1_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=0, Zm=1
    let encoding: u32 = 0x05216800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uzp1_z_zz_field_zm_30_poweroftwominusone_6800_053e6800() {
    // Encoding: 0x053E6800
    // Test UZP1_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Zm=30, Zn=0
    let encoding: u32 = 0x053E6800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uzp1_z_zz_field_zm_31_max_6800_053f6800() {
    // Encoding: 0x053F6800
    // Test UZP1_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, Zd=0, Zm=31, size=0
    let encoding: u32 = 0x053F6800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uzp1_z_zz_field_zn_0_min_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uzp1_z_zz_field_zn_1_poweroftwo_6800_05206820() {
    // Encoding: 0x05206820
    // Test UZP1_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, Zm=0, size=0
    let encoding: u32 = 0x05206820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uzp1_z_zz_field_zn_30_poweroftwominusone_6800_05206bc0() {
    // Encoding: 0x05206BC0
    // Test UZP1_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zn=30, Zd=0
    let encoding: u32 = 0x05206BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uzp1_z_zz_field_zn_31_max_6800_05206be0() {
    // Encoding: 0x05206BE0
    // Test UZP1_Z.ZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Zm=0, Zd=0
    let encoding: u32 = 0x05206BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uzp1_z_zz_field_zd_0_min_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uzp1_z_zz_field_zd_1_poweroftwo_6800_05206801() {
    // Encoding: 0x05206801
    // Test UZP1_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=1, size=0
    let encoding: u32 = 0x05206801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uzp1_z_zz_field_zd_30_poweroftwominusone_6800_0520681e() {
    // Encoding: 0x0520681E
    // Test UZP1_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0, Zm=0
    let encoding: u32 = 0x0520681E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uzp1_z_zz_field_zd_31_max_6800_0520681f() {
    // Encoding: 0x0520681F
    // Test UZP1_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zm=0, Zd=31
    let encoding: u32 = 0x0520681F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uzp1_z_zz_combo_0_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uzp1_z_zz_special_size_0_size_variant_0_26624_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uzp1_z_zz_special_size_1_size_variant_1_26624_05606800() {
    // Encoding: 0x05606800
    // Test UZP1_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zd=0, size=1, Zn=0
    let encoding: u32 = 0x05606800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uzp1_z_zz_special_size_2_size_variant_2_26624_05a06800() {
    // Encoding: 0x05A06800
    // Test UZP1_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Zn=0, Zd=0
    let encoding: u32 = 0x05A06800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uzp1_z_zz_special_size_3_size_variant_3_26624_05e06800() {
    // Encoding: 0x05E06800
    // Test UZP1_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zm=0, size=3, Zd=0
    let encoding: u32 = 0x05E06800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uzp1_z_zz_invalid_0_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uzp1_z_zz_invalid_1_6800_05206800() {
    // Encoding: 0x05206800
    // Test UZP1_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x05206800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uzp2_z_zz_field_size_0_min_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uzp2_z_zz_field_size_1_poweroftwo_6c00_05606c00() {
    // Encoding: 0x05606C00
    // Test UZP2_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=1, Zm=0
    let encoding: u32 = 0x05606C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uzp2_z_zz_field_size_2_poweroftwo_6c00_05a06c00() {
    // Encoding: 0x05A06C00
    // Test UZP2_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x05A06C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uzp2_z_zz_field_size_3_max_6c00_05e06c00() {
    // Encoding: 0x05E06C00
    // Test UZP2_Z.ZZ__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Zn=0, Zm=0
    let encoding: u32 = 0x05E06C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uzp2_z_zz_field_zm_0_min_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uzp2_z_zz_field_zm_1_poweroftwo_6c00_05216c00() {
    // Encoding: 0x05216C00
    // Test UZP2_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05216C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uzp2_z_zz_field_zm_30_poweroftwominusone_6c00_053e6c00() {
    // Encoding: 0x053E6C00
    // Test UZP2_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=0, Zm=30, size=0
    let encoding: u32 = 0x053E6C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uzp2_z_zz_field_zm_31_max_6c00_053f6c00() {
    // Encoding: 0x053F6C00
    // Test UZP2_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x053F6C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uzp2_z_zz_field_zn_0_min_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, Zm=0, size=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uzp2_z_zz_field_zn_1_poweroftwo_6c00_05206c20() {
    // Encoding: 0x05206C20
    // Test UZP2_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x05206C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uzp2_z_zz_field_zn_30_poweroftwominusone_6c00_05206fc0() {
    // Encoding: 0x05206FC0
    // Test UZP2_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x05206FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uzp2_z_zz_field_zn_31_max_6c00_05206fe0() {
    // Encoding: 0x05206FE0
    // Test UZP2_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zd=0, size=0, Zm=0, Zn=31
    let encoding: u32 = 0x05206FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uzp2_z_zz_field_zd_0_min_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uzp2_z_zz_field_zd_1_poweroftwo_6c00_05206c01() {
    // Encoding: 0x05206C01
    // Test UZP2_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x05206C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uzp2_z_zz_field_zd_30_poweroftwominusone_6c00_05206c1e() {
    // Encoding: 0x05206C1E
    // Test UZP2_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zn=0, Zd=30
    let encoding: u32 = 0x05206C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uzp2_z_zz_field_zd_31_max_6c00_05206c1f() {
    // Encoding: 0x05206C1F
    // Test UZP2_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, Zm=0, size=0, Zd=31
    let encoding: u32 = 0x05206C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uzp2_z_zz_combo_0_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uzp2_z_zz_special_size_0_size_variant_0_27648_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uzp2_z_zz_special_size_1_size_variant_1_27648_05606c00() {
    // Encoding: 0x05606C00
    // Test UZP2_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zn=0, Zm=0, size=1
    let encoding: u32 = 0x05606C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uzp2_z_zz_special_size_2_size_variant_2_27648_05a06c00() {
    // Encoding: 0x05A06C00
    // Test UZP2_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zd=0, size=2, Zn=0
    let encoding: u32 = 0x05A06C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uzp2_z_zz_special_size_3_size_variant_3_27648_05e06c00() {
    // Encoding: 0x05E06C00
    // Test UZP2_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zd=0, Zm=0, size=3
    let encoding: u32 = 0x05E06C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uzp2_z_zz_invalid_0_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uzp2_z_zz_invalid_1_6c00_05206c00() {
    // Encoding: 0x05206C00
    // Test UZP2_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x05206C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP1_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uzp1_z_zz_reg_write_0_05206800() {
    // Test UZP1_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x05206800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05206800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UZP2_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uzp2_z_zz_reg_write_0_05206c00() {
    // Test UZP2_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x05206C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05206C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// REV_P.P__ Tests
// ============================================================================

/// Provenance: REV_P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_rev_p_p_field_size_0_min_4000_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ field size = 0 (Min)
    // Fields: Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_rev_p_p_field_size_1_poweroftwo_4000_05744000() {
    // Encoding: 0x05744000
    // Test REV_P.P__ field size = 1 (PowerOfTwo)
    // Fields: Pd=0, size=1, Pn=0
    let encoding: u32 = 0x05744000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_rev_p_p_field_size_2_poweroftwo_4000_05b44000() {
    // Encoding: 0x05B44000
    // Test REV_P.P__ field size = 2 (PowerOfTwo)
    // Fields: Pn=0, Pd=0, size=2
    let encoding: u32 = 0x05B44000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_rev_p_p_field_size_3_max_4000_05f44000() {
    // Encoding: 0x05F44000
    // Test REV_P.P__ field size = 3 (Max)
    // Fields: Pd=0, size=3, Pn=0
    let encoding: u32 = 0x05F44000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_rev_p_p_field_pn_0_min_4000_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ field Pn = 0 (Min)
    // Fields: size=0, Pd=0, Pn=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_rev_p_p_field_pn_1_poweroftwo_4000_05344020() {
    // Encoding: 0x05344020
    // Test REV_P.P__ field Pn = 1 (PowerOfTwo)
    // Fields: size=0, Pn=1, Pd=0
    let encoding: u32 = 0x05344020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_rev_p_p_field_pd_0_min_4000_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ field Pd = 0 (Min)
    // Fields: size=0, Pn=0, Pd=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_rev_p_p_field_pd_1_poweroftwo_4000_05344001() {
    // Encoding: 0x05344001
    // Test REV_P.P__ field Pd = 1 (PowerOfTwo)
    // Fields: Pd=1, Pn=0, size=0
    let encoding: u32 = 0x05344001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_rev_p_p_combo_0_4000_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ field combination: size=0, Pn=0, Pd=0
    // Fields: size=0, Pn=0, Pd=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_rev_p_p_special_size_0_size_variant_0_16384_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pd=0, Pn=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_rev_p_p_special_size_1_size_variant_1_16384_05744000() {
    // Encoding: 0x05744000
    // Test REV_P.P__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pn=0, Pd=0
    let encoding: u32 = 0x05744000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_rev_p_p_special_size_2_size_variant_2_16384_05b44000() {
    // Encoding: 0x05B44000
    // Test REV_P.P__ special value size = 2 (Size variant 2)
    // Fields: Pd=0, Pn=0, size=2
    let encoding: u32 = 0x05B44000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_rev_p_p_special_size_3_size_variant_3_16384_05f44000() {
    // Encoding: 0x05F44000
    // Test REV_P.P__ special value size = 3 (Size variant 3)
    // Fields: Pn=0, size=3, Pd=0
    let encoding: u32 = 0x05F44000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_rev_p_p_invalid_0_4000_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pd=0, Pn=0, size=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_rev_p_p_invalid_1_4000_05344000() {
    // Encoding: 0x05344000
    // Test REV_P.P__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pd=0, Pn=0, size=0
    let encoding: u32 = 0x05344000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REV_P.P__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_rev_p_p_reg_write_0_05344000() {
    // Test REV_P.P__ register write: SimdFromField("Pd")
    // Encoding: 0x05344000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05344000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SPLICE_Z.P.ZZ_Des Tests
// ============================================================================

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_splice_z_p_zz_des_field_size_0_min_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_splice_z_p_zz_des_field_size_1_poweroftwo_8000_056c8000() {
    // Encoding: 0x056C8000
    // Test SPLICE_Z.P.ZZ_Des field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=1, Zdn=0
    let encoding: u32 = 0x056C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_splice_z_p_zz_des_field_size_2_poweroftwo_8000_05ac8000() {
    // Encoding: 0x05AC8000
    // Test SPLICE_Z.P.ZZ_Des field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x05AC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_splice_z_p_zz_des_field_size_3_max_8000_05ec8000() {
    // Encoding: 0x05EC8000
    // Test SPLICE_Z.P.ZZ_Des field size = 3 (Max)
    // Fields: size=3, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x05EC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_splice_z_p_zz_des_field_pg_0_min_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des field Pg = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_splice_z_p_zz_des_field_pg_1_poweroftwo_8000_052c8400() {
    // Encoding: 0x052C8400
    // Test SPLICE_Z.P.ZZ_Des field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, size=0, Pg=1
    let encoding: u32 = 0x052C8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_splice_z_p_zz_des_field_zm_0_min_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_splice_z_p_zz_des_field_zm_1_poweroftwo_8000_052c8020() {
    // Encoding: 0x052C8020
    // Test SPLICE_Z.P.ZZ_Des field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x052C8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_splice_z_p_zz_des_field_zm_30_poweroftwominusone_8000_052c83c0() {
    // Encoding: 0x052C83C0
    // Test SPLICE_Z.P.ZZ_Des field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, Pg=0, Zm=30
    let encoding: u32 = 0x052C83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_splice_z_p_zz_des_field_zm_31_max_8000_052c83e0() {
    // Encoding: 0x052C83E0
    // Test SPLICE_Z.P.ZZ_Des field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zdn=0, size=0
    let encoding: u32 = 0x052C83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_splice_z_p_zz_des_field_zdn_0_min_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des field Zdn = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_splice_z_p_zz_des_field_zdn_1_poweroftwo_8000_052c8001() {
    // Encoding: 0x052C8001
    // Test SPLICE_Z.P.ZZ_Des field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=0, Zdn=1
    let encoding: u32 = 0x052C8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_splice_z_p_zz_des_field_zdn_15_poweroftwominusone_8000_052c800f() {
    // Encoding: 0x052C800F
    // Test SPLICE_Z.P.ZZ_Des field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zdn=15, Pg=0
    let encoding: u32 = 0x052C800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_splice_z_p_zz_des_field_zdn_31_max_8000_052c801f() {
    // Encoding: 0x052C801F
    // Test SPLICE_Z.P.ZZ_Des field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31, Zm=0
    let encoding: u32 = 0x052C801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_splice_z_p_zz_des_combo_0_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_splice_z_p_zz_des_special_size_0_size_variant_0_32768_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_splice_z_p_zz_des_special_size_1_size_variant_1_32768_056c8000() {
    // Encoding: 0x056C8000
    // Test SPLICE_Z.P.ZZ_Des special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zdn=0, size=1, Zm=0
    let encoding: u32 = 0x056C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_splice_z_p_zz_des_special_size_2_size_variant_2_32768_05ac8000() {
    // Encoding: 0x05AC8000
    // Test SPLICE_Z.P.ZZ_Des special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x05AC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_splice_z_p_zz_des_special_size_3_size_variant_3_32768_05ec8000() {
    // Encoding: 0x05EC8000
    // Test SPLICE_Z.P.ZZ_Des special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x05EC8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_splice_z_p_zz_des_invalid_0_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_splice_z_p_zz_des_invalid_1_8000_052c8000() {
    // Encoding: 0x052C8000
    // Test SPLICE_Z.P.ZZ_Des invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x052C8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SPLICE_Z.P.ZZ_Des
/// ASL: `SimdFromField("dst") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dst")
#[test]
fn test_splice_z_p_zz_des_reg_write_0_052c8000() {
    // Test SPLICE_Z.P.ZZ_Des register write: SimdFromField("dst")
    // Encoding: 0x052C8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x052C8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMULH_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_smulh_z_p_zz_field_size_0_min_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_smulh_z_p_zz_field_size_1_poweroftwo_0_04520000() {
    // Encoding: 0x04520000
    // Test SMULH_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, size=1
    let encoding: u32 = 0x04520000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_smulh_z_p_zz_field_size_2_poweroftwo_0_04920000() {
    // Encoding: 0x04920000
    // Test SMULH_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Zm=0, Pg=0
    let encoding: u32 = 0x04920000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_smulh_z_p_zz_field_size_3_max_0_04d20000() {
    // Encoding: 0x04D20000
    // Test SMULH_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x04D20000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_smulh_z_p_zz_field_pg_0_min_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_smulh_z_p_zz_field_pg_1_poweroftwo_0_04120400() {
    // Encoding: 0x04120400
    // Test SMULH_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04120400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_smulh_z_p_zz_field_zm_0_min_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_smulh_z_p_zz_field_zm_1_poweroftwo_0_04120020() {
    // Encoding: 0x04120020
    // Test SMULH_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Pg=0, Zm=1
    let encoding: u32 = 0x04120020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_smulh_z_p_zz_field_zm_30_poweroftwominusone_0_041203c0() {
    // Encoding: 0x041203C0
    // Test SMULH_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=0, size=0, Zm=30
    let encoding: u32 = 0x041203C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_smulh_z_p_zz_field_zm_31_max_0_041203e0() {
    // Encoding: 0x041203E0
    // Test SMULH_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, size=0, Zm=31, Zdn=0
    let encoding: u32 = 0x041203E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_smulh_z_p_zz_field_zdn_0_min_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_smulh_z_p_zz_field_zdn_1_poweroftwo_0_04120001() {
    // Encoding: 0x04120001
    // Test SMULH_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=1, Pg=0, size=0
    let encoding: u32 = 0x04120001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_smulh_z_p_zz_field_zdn_15_poweroftwominusone_0_0412000f() {
    // Encoding: 0x0412000F
    // Test SMULH_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zdn=15, size=0, Pg=0
    let encoding: u32 = 0x0412000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_smulh_z_p_zz_field_zdn_31_max_0_0412001f() {
    // Encoding: 0x0412001F
    // Test SMULH_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, Zm=0, Pg=0
    let encoding: u32 = 0x0412001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_smulh_z_p_zz_combo_0_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_smulh_z_p_zz_special_size_0_size_variant_0_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_smulh_z_p_zz_special_size_1_size_variant_1_0_04520000() {
    // Encoding: 0x04520000
    // Test SMULH_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Pg=0, size=1, Zdn=0
    let encoding: u32 = 0x04520000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_smulh_z_p_zz_special_size_2_size_variant_2_0_04920000() {
    // Encoding: 0x04920000
    // Test SMULH_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zdn=0, Zm=0, size=2
    let encoding: u32 = 0x04920000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_smulh_z_p_zz_special_size_3_size_variant_3_0_04d20000() {
    // Encoding: 0x04D20000
    // Test SMULH_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zdn=0, size=3, Zm=0
    let encoding: u32 = 0x04D20000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_smulh_z_p_zz_invalid_0_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_smulh_z_p_zz_invalid_1_0_04120000() {
    // Encoding: 0x04120000
    // Test SMULH_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04120000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMULH_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_smulh_z_p_zz_reg_write_0_04120000() {
    // Test SMULH_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04120000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04120000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ASRD_Z.P.ZI__ Tests
// ============================================================================

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asrd_z_p_zi_field_tszh_0_min_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ field tszh = 0 (Min)
    // Fields: Pg=0, Zdn=0, tszh=0, imm3=0, tszl=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asrd_z_p_zi_field_tszh_1_poweroftwo_8000_04448000() {
    // Encoding: 0x04448000
    // Test ASRD_Z.P.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: tszh=1, tszl=0, imm3=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04448000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_asrd_z_p_zi_field_tszh_3_max_8000_04c48000() {
    // Encoding: 0x04C48000
    // Test ASRD_Z.P.ZI__ field tszh = 3 (Max)
    // Fields: tszl=0, Zdn=0, imm3=0, Pg=0, tszh=3
    let encoding: u32 = 0x04C48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_asrd_z_p_zi_field_pg_0_min_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ field Pg = 0 (Min)
    // Fields: imm3=0, tszh=0, Zdn=0, Pg=0, tszl=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_asrd_z_p_zi_field_pg_1_poweroftwo_8000_04048400() {
    // Encoding: 0x04048400
    // Test ASRD_Z.P.ZI__ field Pg = 1 (PowerOfTwo)
    // Fields: tszh=0, Pg=1, tszl=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04048400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asrd_z_p_zi_field_tszl_0_min_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ field tszl = 0 (Min)
    // Fields: imm3=0, tszl=0, Zdn=0, Pg=0, tszh=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asrd_z_p_zi_field_tszl_1_poweroftwo_8000_04048100() {
    // Encoding: 0x04048100
    // Test ASRD_Z.P.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: Zdn=0, imm3=0, tszh=0, tszl=1, Pg=0
    let encoding: u32 = 0x04048100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_asrd_z_p_zi_field_tszl_3_max_8000_04048300() {
    // Encoding: 0x04048300
    // Test ASRD_Z.P.ZI__ field tszl = 3 (Max)
    // Fields: Pg=0, tszh=0, imm3=0, tszl=3, Zdn=0
    let encoding: u32 = 0x04048300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_asrd_z_p_zi_field_imm3_0_zero_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ field imm3 = 0 (Zero)
    // Fields: Zdn=0, imm3=0, tszh=0, tszl=0, Pg=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_asrd_z_p_zi_field_imm3_1_poweroftwo_8000_04048020() {
    // Encoding: 0x04048020
    // Test ASRD_Z.P.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: Zdn=0, tszh=0, Pg=0, tszl=0, imm3=1
    let encoding: u32 = 0x04048020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_asrd_z_p_zi_field_imm3_3_poweroftwominusone_8000_04048060() {
    // Encoding: 0x04048060
    // Test ASRD_Z.P.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Zdn=0, Pg=0, tszh=0, imm3=3
    let encoding: u32 = 0x04048060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_asrd_z_p_zi_field_imm3_7_max_8000_040480e0() {
    // Encoding: 0x040480E0
    // Test ASRD_Z.P.ZI__ field imm3 = 7 (Max)
    // Fields: imm3=7, Zdn=0, tszl=0, tszh=0, Pg=0
    let encoding: u32 = 0x040480E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asrd_z_p_zi_field_zdn_0_min_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ field Zdn = 0 (Min)
    // Fields: tszl=0, Zdn=0, Pg=0, imm3=0, tszh=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asrd_z_p_zi_field_zdn_1_poweroftwo_8000_04048001() {
    // Encoding: 0x04048001
    // Test ASRD_Z.P.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, Zdn=1, Pg=0, imm3=0
    let encoding: u32 = 0x04048001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_asrd_z_p_zi_field_zdn_15_poweroftwominusone_8000_0404800f() {
    // Encoding: 0x0404800F
    // Test ASRD_Z.P.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Zdn=15, imm3=0, Pg=0, tszh=0
    let encoding: u32 = 0x0404800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_asrd_z_p_zi_field_zdn_31_max_8000_0404801f() {
    // Encoding: 0x0404801F
    // Test ASRD_Z.P.ZI__ field Zdn = 31 (Max)
    // Fields: tszl=0, tszh=0, Pg=0, Zdn=31, imm3=0
    let encoding: u32 = 0x0404801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_asrd_z_p_zi_combo_0_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszh=0, tszl=0, imm3=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asrd_z_p_zi_invalid_0_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszl=0, Zdn=0, tszh=0, Pg=0, imm3=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asrd_z_p_zi_invalid_1_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, imm3=0, tszh=0, tszl=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asrd_z_p_zi_invalid_2_8000_04048000() {
    // Encoding: 0x04048000
    // Test ASRD_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, tszh=0, Pg=0, tszl=0, imm3=0
    let encoding: u32 = 0x04048000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASRD_Z.P.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_asrd_z_p_zi_reg_write_0_04048000() {
    // Test ASRD_Z.P.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x04048000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04048000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSR_Z.ZW__ Tests
// ============================================================================

/// Provenance: LSR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsr_z_zw_field_size_0_min_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ field size = 0 (Min)
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsr_z_zw_field_size_1_poweroftwo_8400_04608400() {
    // Encoding: 0x04608400
    // Test LSR_Z.ZW__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=1, Zm=0
    let encoding: u32 = 0x04608400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsr_z_zw_field_size_2_poweroftwo_8400_04a08400() {
    // Encoding: 0x04A08400
    // Test LSR_Z.ZW__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04A08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsr_z_zw_field_size_3_max_8400_04e08400() {
    // Encoding: 0x04E08400
    // Test LSR_Z.ZW__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, Zm=0, size=3
    let encoding: u32 = 0x04E08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_zw_field_zm_0_min_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ field Zm = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_zw_field_zm_1_poweroftwo_8400_04218400() {
    // Encoding: 0x04218400
    // Test LSR_Z.ZW__ field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zd=0, Zm=1
    let encoding: u32 = 0x04218400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_zw_field_zm_30_poweroftwominusone_8400_043e8400() {
    // Encoding: 0x043E8400
    // Test LSR_Z.ZW__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=0, Zm=30, size=0
    let encoding: u32 = 0x043E8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_zw_field_zm_31_max_8400_043f8400() {
    // Encoding: 0x043F8400
    // Test LSR_Z.ZW__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zn=0, Zd=0
    let encoding: u32 = 0x043F8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_zw_field_zn_0_min_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ field Zn = 0 (Min)
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_zw_field_zn_1_poweroftwo_8400_04208420() {
    // Encoding: 0x04208420
    // Test LSR_Z.ZW__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x04208420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_zw_field_zn_30_poweroftwominusone_8400_042087c0() {
    // Encoding: 0x042087C0
    // Test LSR_Z.ZW__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zm=0, size=0, Zn=30
    let encoding: u32 = 0x042087C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_zw_field_zn_31_max_8400_042087e0() {
    // Encoding: 0x042087E0
    // Test LSR_Z.ZW__ field Zn = 31 (Max)
    // Fields: Zn=31, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x042087E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_zw_field_zd_0_min_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_zw_field_zd_1_poweroftwo_8400_04208401() {
    // Encoding: 0x04208401
    // Test LSR_Z.ZW__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x04208401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_zw_field_zd_30_poweroftwominusone_8400_0420841e() {
    // Encoding: 0x0420841E
    // Test LSR_Z.ZW__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, size=0, Zd=30, Zm=0
    let encoding: u32 = 0x0420841E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_zw_field_zd_31_max_8400_0420841f() {
    // Encoding: 0x0420841F
    // Test LSR_Z.ZW__ field Zd = 31 (Max)
    // Fields: Zd=31, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x0420841F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsr_z_zw_combo_0_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsr_z_zw_special_size_0_size_variant_0_33792_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsr_z_zw_special_size_1_size_variant_1_33792_04608400() {
    // Encoding: 0x04608400
    // Test LSR_Z.ZW__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Zm=0, Zd=0
    let encoding: u32 = 0x04608400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsr_z_zw_special_size_2_size_variant_2_33792_04a08400() {
    // Encoding: 0x04A08400
    // Test LSR_Z.ZW__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, Zm=0, size=2
    let encoding: u32 = 0x04A08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsr_z_zw_special_size_3_size_variant_3_33792_04e08400() {
    // Encoding: 0x04E08400
    // Test LSR_Z.ZW__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04E08400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsr_z_zw_invalid_0_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_zw_invalid_1_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_lsr_z_zw_invalid_2_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_zw_invalid_3_8400_04208400() {
    // Encoding: 0x04208400
    // Test LSR_Z.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x04208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZW__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lsr_z_zw_reg_write_0_04208400() {
    // Test LSR_Z.ZW__ register write: SimdFromField("d")
    // Encoding: 0x04208400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04208400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQSUB_Z.ZZ__ Tests
// ============================================================================

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqsub_z_zz_field_size_0_min_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqsub_z_zz_field_size_1_poweroftwo_1800_04601800() {
    // Encoding: 0x04601800
    // Test SQSUB_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, size=1, Zd=0
    let encoding: u32 = 0x04601800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqsub_z_zz_field_size_2_poweroftwo_1800_04a01800() {
    // Encoding: 0x04A01800
    // Test SQSUB_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, Zd=0, size=2
    let encoding: u32 = 0x04A01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqsub_z_zz_field_size_3_max_1800_04e01800() {
    // Encoding: 0x04E01800
    // Test SQSUB_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04E01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sqsub_z_zz_field_zm_0_min_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sqsub_z_zz_field_zm_1_poweroftwo_1800_04211800() {
    // Encoding: 0x04211800
    // Test SQSUB_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=1, Zd=0
    let encoding: u32 = 0x04211800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sqsub_z_zz_field_zm_30_poweroftwominusone_1800_043e1800() {
    // Encoding: 0x043E1800
    // Test SQSUB_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x043E1800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sqsub_z_zz_field_zm_31_max_1800_043f1800() {
    // Encoding: 0x043F1800
    // Test SQSUB_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zd=0, Zm=31, Zn=0, size=0
    let encoding: u32 = 0x043F1800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sqsub_z_zz_field_zn_0_min_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ field Zn = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sqsub_z_zz_field_zn_1_poweroftwo_1800_04201820() {
    // Encoding: 0x04201820
    // Test SQSUB_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zd=0, Zn=1, Zm=0
    let encoding: u32 = 0x04201820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sqsub_z_zz_field_zn_30_poweroftwominusone_1800_04201bc0() {
    // Encoding: 0x04201BC0
    // Test SQSUB_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, Zm=0, size=0
    let encoding: u32 = 0x04201BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sqsub_z_zz_field_zn_31_max_1800_04201be0() {
    // Encoding: 0x04201BE0
    // Test SQSUB_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x04201BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sqsub_z_zz_field_zd_0_min_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sqsub_z_zz_field_zd_1_poweroftwo_1800_04201801() {
    // Encoding: 0x04201801
    // Test SQSUB_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=1, size=0
    let encoding: u32 = 0x04201801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sqsub_z_zz_field_zd_30_poweroftwominusone_1800_0420181e() {
    // Encoding: 0x0420181E
    // Test SQSUB_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zm=0, Zd=30, size=0
    let encoding: u32 = 0x0420181E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sqsub_z_zz_field_zd_31_max_1800_0420181f() {
    // Encoding: 0x0420181F
    // Test SQSUB_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zd=31, Zm=0
    let encoding: u32 = 0x0420181F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqsub_z_zz_combo_0_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqsub_z_zz_special_size_0_size_variant_0_6144_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqsub_z_zz_special_size_1_size_variant_1_6144_04601800() {
    // Encoding: 0x04601800
    // Test SQSUB_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zn=0, Zd=0, size=1
    let encoding: u32 = 0x04601800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqsub_z_zz_special_size_2_size_variant_2_6144_04a01800() {
    // Encoding: 0x04A01800
    // Test SQSUB_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zm=0, Zd=0
    let encoding: u32 = 0x04A01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqsub_z_zz_special_size_3_size_variant_3_6144_04e01800() {
    // Encoding: 0x04E01800
    // Test SQSUB_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Zd=0, size=3, Zn=0
    let encoding: u32 = 0x04E01800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqsub_z_zz_invalid_0_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqsub_z_zz_invalid_1_1800_04201800() {
    // Encoding: 0x04201800
    // Test SQSUB_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04201800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sqsub_z_zz_reg_write_0_04201800() {
    // Test SQSUB_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x04201800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04201800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// REV_Z.Z__ Tests
// ============================================================================

/// Provenance: REV_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_rev_z_z_field_size_0_min_3800_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_rev_z_z_field_size_1_poweroftwo_3800_05783800() {
    // Encoding: 0x05783800
    // Test REV_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, size=1, Zd=0
    let encoding: u32 = 0x05783800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_rev_z_z_field_size_2_poweroftwo_3800_05b83800() {
    // Encoding: 0x05B83800
    // Test REV_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Zd=0
    let encoding: u32 = 0x05B83800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_rev_z_z_field_size_3_max_3800_05f83800() {
    // Encoding: 0x05F83800
    // Test REV_Z.Z__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, size=3
    let encoding: u32 = 0x05F83800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_rev_z_z_field_zn_0_min_3800_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_rev_z_z_field_zn_1_poweroftwo_3800_05383820() {
    // Encoding: 0x05383820
    // Test REV_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0
    let encoding: u32 = 0x05383820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_rev_z_z_field_zn_30_poweroftwominusone_3800_05383bc0() {
    // Encoding: 0x05383BC0
    // Test REV_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Zn=30
    let encoding: u32 = 0x05383BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_rev_z_z_field_zn_31_max_3800_05383be0() {
    // Encoding: 0x05383BE0
    // Test REV_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0
    let encoding: u32 = 0x05383BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_rev_z_z_field_zd_0_min_3800_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_rev_z_z_field_zd_1_poweroftwo_3800_05383801() {
    // Encoding: 0x05383801
    // Test REV_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, size=0
    let encoding: u32 = 0x05383801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_rev_z_z_field_zd_30_poweroftwominusone_3800_0538381e() {
    // Encoding: 0x0538381E
    // Test REV_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, size=0, Zn=0
    let encoding: u32 = 0x0538381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_rev_z_z_field_zd_31_max_3800_0538381f() {
    // Encoding: 0x0538381F
    // Test REV_Z.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zd=31
    let encoding: u32 = 0x0538381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_rev_z_z_combo_0_3800_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_rev_z_z_special_size_0_size_variant_0_14336_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_rev_z_z_special_size_1_size_variant_1_14336_05783800() {
    // Encoding: 0x05783800
    // Test REV_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zd=0
    let encoding: u32 = 0x05783800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_rev_z_z_special_size_2_size_variant_2_14336_05b83800() {
    // Encoding: 0x05B83800
    // Test REV_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zd=0
    let encoding: u32 = 0x05B83800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_rev_z_z_special_size_3_size_variant_3_14336_05f83800() {
    // Encoding: 0x05F83800
    // Test REV_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x05F83800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_rev_z_z_invalid_0_3800_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_rev_z_z_invalid_1_3800_05383800() {
    // Encoding: 0x05383800
    // Test REV_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05383800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REV_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_rev_z_z_reg_write_0_05383800() {
    // Test REV_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05383800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05383800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.ZW__ Tests
// ============================================================================

/// Provenance: LSL_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsl_z_zw_field_size_0_min_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ field size = 0 (Min)
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsl_z_zw_field_size_1_poweroftwo_8c00_04608c00() {
    // Encoding: 0x04608C00
    // Test LSL_Z.ZW__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04608C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsl_z_zw_field_size_2_poweroftwo_8c00_04a08c00() {
    // Encoding: 0x04A08C00
    // Test LSL_Z.ZW__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x04A08C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsl_z_zw_field_size_3_max_8c00_04e08c00() {
    // Encoding: 0x04E08C00
    // Test LSL_Z.ZW__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04E08C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zw_field_zm_0_min_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zw_field_zm_1_poweroftwo_8c00_04218c00() {
    // Encoding: 0x04218C00
    // Test LSL_Z.ZW__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zd=0, Zm=1, Zn=0
    let encoding: u32 = 0x04218C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zw_field_zm_30_poweroftwominusone_8c00_043e8c00() {
    // Encoding: 0x043E8C00
    // Test LSL_Z.ZW__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x043E8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zw_field_zm_31_max_8c00_043f8c00() {
    // Encoding: 0x043F8C00
    // Test LSL_Z.ZW__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zn=0, Zd=0
    let encoding: u32 = 0x043F8C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zw_field_zn_0_min_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zw_field_zn_1_poweroftwo_8c00_04208c20() {
    // Encoding: 0x04208C20
    // Test LSL_Z.ZW__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x04208C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zw_field_zn_30_poweroftwominusone_8c00_04208fc0() {
    // Encoding: 0x04208FC0
    // Test LSL_Z.ZW__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=30, Zd=0, size=0
    let encoding: u32 = 0x04208FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zw_field_zn_31_max_8c00_04208fe0() {
    // Encoding: 0x04208FE0
    // Test LSL_Z.ZW__ field Zn = 31 (Max)
    // Fields: size=0, Zd=0, Zn=31, Zm=0
    let encoding: u32 = 0x04208FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zw_field_zd_0_min_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ field Zd = 0 (Min)
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zw_field_zd_1_poweroftwo_8c00_04208c01() {
    // Encoding: 0x04208C01
    // Test LSL_Z.ZW__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zd=1, Zm=0
    let encoding: u32 = 0x04208C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zw_field_zd_30_poweroftwominusone_8c00_04208c1e() {
    // Encoding: 0x04208C1E
    // Test LSL_Z.ZW__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x04208C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zw_field_zd_31_max_8c00_04208c1f() {
    // Encoding: 0x04208C1F
    // Test LSL_Z.ZW__ field Zd = 31 (Max)
    // Fields: size=0, Zn=0, Zm=0, Zd=31
    let encoding: u32 = 0x04208C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsl_z_zw_combo_0_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsl_z_zw_special_size_0_size_variant_0_35840_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsl_z_zw_special_size_1_size_variant_1_35840_04608c00() {
    // Encoding: 0x04608C00
    // Test LSL_Z.ZW__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x04608C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsl_z_zw_special_size_2_size_variant_2_35840_04a08c00() {
    // Encoding: 0x04A08C00
    // Test LSL_Z.ZW__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zd=0, size=2, Zn=0
    let encoding: u32 = 0x04A08C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsl_z_zw_special_size_3_size_variant_3_35840_04e08c00() {
    // Encoding: 0x04E08C00
    // Test LSL_Z.ZW__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zm=0, Zn=0, size=3
    let encoding: u32 = 0x04E08C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_zw_invalid_0_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_zw_invalid_1_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_lsl_z_zw_invalid_2_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_zw_invalid_3_8c00_04208c00() {
    // Encoding: 0x04208C00
    // Test LSL_Z.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x04208C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZW__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lsl_z_zw_reg_write_0_04208c00() {
    // Test LSL_Z.ZW__ register write: SimdFromField("d")
    // Encoding: 0x04208C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04208C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQSUB_Z.ZI__ Tests
// ============================================================================

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqsub_z_zi_field_size_0_min_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ field size = 0 (Min)
    // Fields: imm8=0, size=0, Zdn=0, sh=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqsub_z_zi_field_size_1_poweroftwo_c000_2566c000() {
    // Encoding: 0x2566C000
    // Test SQSUB_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, sh=0, imm8=0
    let encoding: u32 = 0x2566C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqsub_z_zi_field_size_2_poweroftwo_c000_25a6c000() {
    // Encoding: 0x25A6C000
    // Test SQSUB_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: sh=0, size=2, Zdn=0, imm8=0
    let encoding: u32 = 0x25A6C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqsub_z_zi_field_size_3_max_c000_25e6c000() {
    // Encoding: 0x25E6C000
    // Test SQSUB_Z.ZI__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, sh=0, imm8=0
    let encoding: u32 = 0x25E6C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_sqsub_z_zi_field_sh_0_min_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ field sh = 0 (Min)
    // Fields: sh=0, imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_sqsub_z_zi_field_sh_1_max_c000_2526e000() {
    // Encoding: 0x2526E000
    // Test SQSUB_Z.ZI__ field sh = 1 (Max)
    // Fields: Zdn=0, size=0, sh=1, imm8=0
    let encoding: u32 = 0x2526E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqsub_z_zi_field_imm8_0_zero_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: sh=0, imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqsub_z_zi_field_imm8_1_poweroftwo_c000_2526c020() {
    // Encoding: 0x2526C020
    // Test SQSUB_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: sh=0, Zdn=0, size=0, imm8=1
    let encoding: u32 = 0x2526C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqsub_z_zi_field_imm8_3_poweroftwominusone_c000_2526c060() {
    // Encoding: 0x2526C060
    // Test SQSUB_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=3, Zdn=0, size=0
    let encoding: u32 = 0x2526C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqsub_z_zi_field_imm8_4_poweroftwo_c000_2526c080() {
    // Encoding: 0x2526C080
    // Test SQSUB_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, imm8=4, sh=0, Zdn=0
    let encoding: u32 = 0x2526C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_sqsub_z_zi_field_imm8_7_poweroftwominusone_c000_2526c0e0() {
    // Encoding: 0x2526C0E0
    // Test SQSUB_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: imm8=7, size=0, Zdn=0, sh=0
    let encoding: u32 = 0x2526C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqsub_z_zi_field_imm8_8_poweroftwo_c000_2526c100() {
    // Encoding: 0x2526C100
    // Test SQSUB_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: size=0, imm8=8, Zdn=0, sh=0
    let encoding: u32 = 0x2526C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_sqsub_z_zi_field_imm8_15_poweroftwominusone_c000_2526c1e0() {
    // Encoding: 0x2526C1E0
    // Test SQSUB_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, sh=0, imm8=15, Zdn=0
    let encoding: u32 = 0x2526C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_sqsub_z_zi_field_imm8_16_poweroftwo_c000_2526c200() {
    // Encoding: 0x2526C200
    // Test SQSUB_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: imm8=16, Zdn=0, sh=0, size=0
    let encoding: u32 = 0x2526C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_sqsub_z_zi_field_imm8_31_poweroftwominusone_c000_2526c3e0() {
    // Encoding: 0x2526C3E0
    // Test SQSUB_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, sh=0, imm8=31
    let encoding: u32 = 0x2526C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_sqsub_z_zi_field_imm8_32_poweroftwo_c000_2526c400() {
    // Encoding: 0x2526C400
    // Test SQSUB_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: size=0, Zdn=0, imm8=32, sh=0
    let encoding: u32 = 0x2526C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_sqsub_z_zi_field_imm8_63_poweroftwominusone_c000_2526c7e0() {
    // Encoding: 0x2526C7E0
    // Test SQSUB_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=63, sh=0, Zdn=0
    let encoding: u32 = 0x2526C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_sqsub_z_zi_field_imm8_64_poweroftwo_c000_2526c800() {
    // Encoding: 0x2526C800
    // Test SQSUB_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: imm8=64, size=0, Zdn=0, sh=0
    let encoding: u32 = 0x2526C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_sqsub_z_zi_field_imm8_127_poweroftwominusone_c000_2526cfe0() {
    // Encoding: 0x2526CFE0
    // Test SQSUB_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, sh=0, size=0, imm8=127
    let encoding: u32 = 0x2526CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_sqsub_z_zi_field_imm8_128_poweroftwo_c000_2526d000() {
    // Encoding: 0x2526D000
    // Test SQSUB_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: Zdn=0, size=0, sh=0, imm8=128
    let encoding: u32 = 0x2526D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_sqsub_z_zi_field_imm8_255_max_c000_2526dfe0() {
    // Encoding: 0x2526DFE0
    // Test SQSUB_Z.ZI__ field imm8 = 255 (Max)
    // Fields: sh=0, imm8=255, size=0, Zdn=0
    let encoding: u32 = 0x2526DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqsub_z_zi_field_zdn_0_min_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, sh=0, imm8=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqsub_z_zi_field_zdn_1_poweroftwo_c000_2526c001() {
    // Encoding: 0x2526C001
    // Test SQSUB_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm8=0, Zdn=1, sh=0, size=0
    let encoding: u32 = 0x2526C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqsub_z_zi_field_zdn_15_poweroftwominusone_c000_2526c00f() {
    // Encoding: 0x2526C00F
    // Test SQSUB_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, imm8=0, sh=0, size=0
    let encoding: u32 = 0x2526C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqsub_z_zi_field_zdn_31_max_c000_2526c01f() {
    // Encoding: 0x2526C01F
    // Test SQSUB_Z.ZI__ field Zdn = 31 (Max)
    // Fields: sh=0, size=0, Zdn=31, imm8=0
    let encoding: u32 = 0x2526C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqsub_z_zi_combo_0_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ field combination: size=0, sh=0, imm8=0, Zdn=0
    // Fields: sh=0, imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqsub_z_zi_special_size_0_size_variant_0_49152_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, sh=0, imm8=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqsub_z_zi_special_size_1_size_variant_1_49152_2566c000() {
    // Encoding: 0x2566C000
    // Test SQSUB_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: sh=0, Zdn=0, size=1, imm8=0
    let encoding: u32 = 0x2566C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqsub_z_zi_special_size_2_size_variant_2_49152_25a6c000() {
    // Encoding: 0x25A6C000
    // Test SQSUB_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: sh=0, imm8=0, size=2, Zdn=0
    let encoding: u32 = 0x25A6C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqsub_z_zi_special_size_3_size_variant_3_49152_25e6c000() {
    // Encoding: 0x25E6C000
    // Test SQSUB_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: sh=0, size=3, imm8=0, Zdn=0
    let encoding: u32 = 0x25E6C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_sqsub_z_zi_special_sh_0_shift_type_lsl_49152_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ special value sh = 0 (Shift type LSL)
    // Fields: imm8=0, sh=0, size=0, Zdn=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_sqsub_z_zi_special_sh_1_shift_type_lsr_49152_2526e000() {
    // Encoding: 0x2526E000
    // Test SQSUB_Z.ZI__ special value sh = 1 (Shift type LSR)
    // Fields: size=0, Zdn=0, sh=1, imm8=0
    let encoding: u32 = 0x2526E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_sqsub_z_zi_special_sh_2_shift_type_asr_49152_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ special value sh = 2 (Shift type ASR)
    // Fields: sh=2, imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_sqsub_z_zi_special_sh_3_shift_type_ror_49152_2526e000() {
    // Encoding: 0x2526E000
    // Test SQSUB_Z.ZI__ special value sh = 3 (Shift type ROR)
    // Fields: imm8=0, sh=3, size=0, Zdn=0
    let encoding: u32 = 0x2526E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqsub_z_zi_invalid_0_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm8=0, sh=0, size=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqsub_z_zi_invalid_1_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, sh=0, size=0, imm8=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sh\" }), rhs: LitBits([false, false, true]) } }" }
/// triggers Undefined
#[test]
fn test_sqsub_z_zi_invalid_2_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }
    // Fields: Zdn=0, imm8=0, sh=0, size=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqsub_z_zi_invalid_3_c000_2526c000() {
    // Encoding: 0x2526C000
    // Test SQSUB_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, imm8=0, sh=0, Zdn=0
    let encoding: u32 = 0x2526C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQSUB_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqsub_z_zi_reg_write_0_2526c000() {
    // Test SQSUB_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x2526C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2526C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SDIVR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sdivr_z_p_zz_field_size_0_min_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sdivr_z_p_zz_field_size_1_poweroftwo_0_04560000() {
    // Encoding: 0x04560000
    // Test SDIVR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, Pg=0, Zm=0
    let encoding: u32 = 0x04560000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sdivr_z_p_zz_field_size_2_poweroftwo_0_04960000() {
    // Encoding: 0x04960000
    // Test SDIVR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x04960000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sdivr_z_p_zz_field_size_3_max_0_04d60000() {
    // Encoding: 0x04D60000
    // Test SDIVR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, Zdn=0, size=3, Pg=0
    let encoding: u32 = 0x04D60000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sdivr_z_p_zz_field_pg_0_min_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sdivr_z_p_zz_field_pg_1_poweroftwo_0_04160400() {
    // Encoding: 0x04160400
    // Test SDIVR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Zm=0, Pg=1
    let encoding: u32 = 0x04160400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdivr_z_p_zz_field_zm_0_min_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdivr_z_p_zz_field_zm_1_poweroftwo_0_04160020() {
    // Encoding: 0x04160020
    // Test SDIVR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=0, Zm=1
    let encoding: u32 = 0x04160020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sdivr_z_p_zz_field_zm_30_poweroftwominusone_0_041603c0() {
    // Encoding: 0x041603C0
    // Test SDIVR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x041603C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sdivr_z_p_zz_field_zm_31_max_0_041603e0() {
    // Encoding: 0x041603E0
    // Test SDIVR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, Zm=31, size=0, Pg=0
    let encoding: u32 = 0x041603E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdivr_z_p_zz_field_zdn_0_min_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sdivr_z_p_zz_field_zdn_1_poweroftwo_0_04160001() {
    // Encoding: 0x04160001
    // Test SDIVR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zdn=1, Pg=0
    let encoding: u32 = 0x04160001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sdivr_z_p_zz_field_zdn_15_poweroftwominusone_0_0416000f() {
    // Encoding: 0x0416000F
    // Test SDIVR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Pg=0, Zdn=15
    let encoding: u32 = 0x0416000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sdivr_z_p_zz_field_zdn_31_max_0_0416001f() {
    // Encoding: 0x0416001F
    // Test SDIVR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, size=0, Zm=0, Zdn=31
    let encoding: u32 = 0x0416001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sdivr_z_p_zz_combo_0_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sdivr_z_p_zz_special_size_0_size_variant_0_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sdivr_z_p_zz_special_size_1_size_variant_1_0_04560000() {
    // Encoding: 0x04560000
    // Test SDIVR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zm=0, size=1, Zdn=0
    let encoding: u32 = 0x04560000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sdivr_z_p_zz_special_size_2_size_variant_2_0_04960000() {
    // Encoding: 0x04960000
    // Test SDIVR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Zdn=0, Pg=0
    let encoding: u32 = 0x04960000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sdivr_z_p_zz_special_size_3_size_variant_3_0_04d60000() {
    // Encoding: 0x04D60000
    // Test SDIVR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04D60000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sdivr_z_p_zz_invalid_0_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdivr_z_p_zz_invalid_1_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([Zero, Either]) }" }
/// triggers Undefined
#[test]
fn test_sdivr_z_p_zz_invalid_2_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdivr_z_p_zz_invalid_3_0_04160000() {
    // Encoding: 0x04160000
    // Test SDIVR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04160000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIVR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sdivr_z_p_zz_reg_write_0_04160000() {
    // Test SDIVR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04160000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04160000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LASTA_R.P.Z__ Tests
// ============================================================================

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lasta_r_p_z_field_size_0_min_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Rd=0, Zn=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lasta_r_p_z_field_size_1_poweroftwo_a000_0560a000() {
    // Encoding: 0x0560A000
    // Test LASTA_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, size=1, Pg=0, Rd=0
    let encoding: u32 = 0x0560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lasta_r_p_z_field_size_2_poweroftwo_a000_05a0a000() {
    // Encoding: 0x05A0A000
    // Test LASTA_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Rd=0, Zn=0, size=2
    let encoding: u32 = 0x05A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lasta_r_p_z_field_size_3_max_a000_05e0a000() {
    // Encoding: 0x05E0A000
    // Test LASTA_R.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Rd=0, Zn=0
    let encoding: u32 = 0x05E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lasta_r_p_z_field_pg_0_min_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Rd=0, Zn=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lasta_r_p_z_field_pg_1_poweroftwo_a000_0520a400() {
    // Encoding: 0x0520A400
    // Test LASTA_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Rd=0, Zn=0, Pg=1
    let encoding: u32 = 0x0520A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lasta_r_p_z_field_zn_0_min_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Rd=0, Zn=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lasta_r_p_z_field_zn_1_poweroftwo_a000_0520a020() {
    // Encoding: 0x0520A020
    // Test LASTA_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Rd=0, Pg=0, Zn=1
    let encoding: u32 = 0x0520A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lasta_r_p_z_field_zn_30_poweroftwominusone_a000_0520a3c0() {
    // Encoding: 0x0520A3C0
    // Test LASTA_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Rd=0
    let encoding: u32 = 0x0520A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lasta_r_p_z_field_zn_31_max_a000_0520a3e0() {
    // Encoding: 0x0520A3E0
    // Test LASTA_R.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, size=0, Rd=0
    let encoding: u32 = 0x0520A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lasta_r_p_z_field_rd_0_min_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ field Rd = 0 (Min)
    // Fields: size=0, Rd=0, Zn=0, Pg=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lasta_r_p_z_field_rd_1_poweroftwo_a000_0520a001() {
    // Encoding: 0x0520A001
    // Test LASTA_R.P.Z__ field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Rd=1, Zn=0, Pg=0
    let encoding: u32 = 0x0520A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_lasta_r_p_z_field_rd_30_poweroftwominusone_a000_0520a01e() {
    // Encoding: 0x0520A01E
    // Test LASTA_R.P.Z__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rd=30, Pg=0, Zn=0
    let encoding: u32 = 0x0520A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_lasta_r_p_z_field_rd_31_max_a000_0520a01f() {
    // Encoding: 0x0520A01F
    // Test LASTA_R.P.Z__ field Rd = 31 (Max)
    // Fields: Rd=31, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x0520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lasta_r_p_z_combo_0_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=0
    // Fields: Pg=0, Zn=0, size=0, Rd=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lasta_r_p_z_special_size_0_size_variant_0_40960_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zn=0, size=0, Rd=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lasta_r_p_z_special_size_1_size_variant_1_40960_0560a000() {
    // Encoding: 0x0560A000
    // Test LASTA_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zn=0, size=1, Rd=0
    let encoding: u32 = 0x0560A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lasta_r_p_z_special_size_2_size_variant_2_40960_05a0a000() {
    // Encoding: 0x05A0A000
    // Test LASTA_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Rd=0, Zn=0
    let encoding: u32 = 0x05A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lasta_r_p_z_special_size_3_size_variant_3_40960_05e0a000() {
    // Encoding: 0x05E0A000
    // Test LASTA_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Rd=0, Zn=0, size=3
    let encoding: u32 = 0x05E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_lasta_r_p_z_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_40960_0520a01f()
{
    // Encoding: 0x0520A01F
    // Test LASTA_R.P.Z__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Zn=0, Pg=0, Rd=31, size=0
    let encoding: u32 = 0x0520A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lasta_r_p_z_invalid_0_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, size=0, Rd=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lasta_r_p_z_invalid_1_a000_0520a000() {
    // Encoding: 0x0520A000
    // Test LASTA_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Rd=0, size=0, Pg=0
    let encoding: u32 = 0x0520A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_lasta_r_p_z_reg_write_0_0520a000() {
    // Test LASTA_R.P.Z__ register write: GpFromField("d")
    // Encoding: 0x0520A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0520A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LASTA_R.P.Z__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_lasta_r_p_z_zr_rd_0520a01f() {
    // Test LASTA_R.P.Z__ with Rd = ZR (31)
    // Encoding: 0x0520A01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0520A01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// INDEX_Z.RR__ Tests
// ============================================================================

/// Provenance: INDEX_Z.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_index_z_rr_field_size_0_min_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Rn=0, Rm=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_index_z_rr_field_size_1_poweroftwo_4c00_04604c00() {
    // Encoding: 0x04604C00
    // Test INDEX_Z.RR__ field size = 1 (PowerOfTwo)
    // Fields: Rn=0, Rm=0, Zd=0, size=1
    let encoding: u32 = 0x04604C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_index_z_rr_field_size_2_poweroftwo_4c00_04a04c00() {
    // Encoding: 0x04A04C00
    // Test INDEX_Z.RR__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Rn=0, Rm=0
    let encoding: u32 = 0x04A04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_index_z_rr_field_size_3_max_4c00_04e04c00() {
    // Encoding: 0x04E04C00
    // Test INDEX_Z.RR__ field size = 3 (Max)
    // Fields: Zd=0, Rm=0, size=3, Rn=0
    let encoding: u32 = 0x04E04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_index_z_rr_field_rm_0_min_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ field Rm = 0 (Min)
    // Fields: size=0, Rn=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_index_z_rr_field_rm_1_poweroftwo_4c00_04214c00() {
    // Encoding: 0x04214C00
    // Test INDEX_Z.RR__ field Rm = 1 (PowerOfTwo)
    // Fields: Rn=0, size=0, Rm=1, Zd=0
    let encoding: u32 = 0x04214C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_index_z_rr_field_rm_30_poweroftwominusone_4c00_043e4c00() {
    // Encoding: 0x043E4C00
    // Test INDEX_Z.RR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=30, size=0, Zd=0, Rn=0
    let encoding: u32 = 0x043E4C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_index_z_rr_field_rm_31_max_4c00_043f4c00() {
    // Encoding: 0x043F4C00
    // Test INDEX_Z.RR__ field Rm = 31 (Max)
    // Fields: size=0, Rm=31, Rn=0, Zd=0
    let encoding: u32 = 0x043F4C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_index_z_rr_field_rn_0_min_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ field Rn = 0 (Min)
    // Fields: Rn=0, size=0, Zd=0, Rm=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_index_z_rr_field_rn_1_poweroftwo_4c00_04204c20() {
    // Encoding: 0x04204C20
    // Test INDEX_Z.RR__ field Rn = 1 (PowerOfTwo)
    // Fields: Rm=0, size=0, Rn=1, Zd=0
    let encoding: u32 = 0x04204C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_index_z_rr_field_rn_30_poweroftwominusone_4c00_04204fc0() {
    // Encoding: 0x04204FC0
    // Test INDEX_Z.RR__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rm=0, size=0, Zd=0, Rn=30
    let encoding: u32 = 0x04204FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_index_z_rr_field_rn_31_max_4c00_04204fe0() {
    // Encoding: 0x04204FE0
    // Test INDEX_Z.RR__ field Rn = 31 (Max)
    // Fields: Zd=0, Rn=31, size=0, Rm=0
    let encoding: u32 = 0x04204FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_index_z_rr_field_zd_0_min_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ field Zd = 0 (Min)
    // Fields: size=0, Zd=0, Rn=0, Rm=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_index_z_rr_field_zd_1_poweroftwo_4c00_04204c01() {
    // Encoding: 0x04204C01
    // Test INDEX_Z.RR__ field Zd = 1 (PowerOfTwo)
    // Fields: Rm=0, Rn=0, Zd=1, size=0
    let encoding: u32 = 0x04204C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_index_z_rr_field_zd_30_poweroftwominusone_4c00_04204c1e() {
    // Encoding: 0x04204C1E
    // Test INDEX_Z.RR__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rn=0, Rm=0, Zd=30
    let encoding: u32 = 0x04204C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_index_z_rr_field_zd_31_max_4c00_04204c1f() {
    // Encoding: 0x04204C1F
    // Test INDEX_Z.RR__ field Zd = 31 (Max)
    // Fields: size=0, Rm=0, Rn=0, Zd=31
    let encoding: u32 = 0x04204C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_index_z_rr_combo_0_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ field combination: size=0, Rm=0, Rn=0, Zd=0
    // Fields: Rm=0, Zd=0, Rn=0, size=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_index_z_rr_special_size_0_size_variant_0_19456_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ special value size = 0 (Size variant 0)
    // Fields: size=0, Rn=0, Zd=0, Rm=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_index_z_rr_special_size_1_size_variant_1_19456_04604c00() {
    // Encoding: 0x04604C00
    // Test INDEX_Z.RR__ special value size = 1 (Size variant 1)
    // Fields: size=1, Rn=0, Rm=0, Zd=0
    let encoding: u32 = 0x04604C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_index_z_rr_special_size_2_size_variant_2_19456_04a04c00() {
    // Encoding: 0x04A04C00
    // Test INDEX_Z.RR__ special value size = 2 (Size variant 2)
    // Fields: Rm=0, Rn=0, Zd=0, size=2
    let encoding: u32 = 0x04A04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_index_z_rr_special_size_3_size_variant_3_19456_04e04c00() {
    // Encoding: 0x04E04C00
    // Test INDEX_Z.RR__ special value size = 3 (Size variant 3)
    // Fields: Rn=0, Rm=0, size=3, Zd=0
    let encoding: u32 = 0x04E04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_index_z_rr_special_rn_31_stack_pointer_sp_may_require_alignment_19456_04204fe0() {
    // Encoding: 0x04204FE0
    // Test INDEX_Z.RR__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rm=0, size=0, Rn=31, Zd=0
    let encoding: u32 = 0x04204FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_index_z_rr_invalid_0_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Rn=0, size=0, Rm=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_index_z_rr_invalid_1_4c00_04204c00() {
    // Encoding: 0x04204C00
    // Test INDEX_Z.RR__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rm=0, Zd=0, Rn=0
    let encoding: u32 = 0x04204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.RR__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_index_z_rr_reg_write_0_04204c00() {
    // Test INDEX_Z.RR__ register write: SimdFromField("d")
    // Encoding: 0x04204C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INDEX_Z.RR__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_index_z_rr_sp_rn_04204fe0() {
    // Test INDEX_Z.RR__ with Rn = SP (31)
    // Encoding: 0x04204FE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204FE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LASTB_V.P.Z__ Tests
// ============================================================================

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lastb_v_p_z_field_size_0_min_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lastb_v_p_z_field_size_1_poweroftwo_8000_05638000() {
    // Encoding: 0x05638000
    // Test LASTB_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05638000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lastb_v_p_z_field_size_2_poweroftwo_8000_05a38000() {
    // Encoding: 0x05A38000
    // Test LASTB_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Pg=0, Vd=0
    let encoding: u32 = 0x05A38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lastb_v_p_z_field_size_3_max_8000_05e38000() {
    // Encoding: 0x05E38000
    // Test LASTB_V.P.Z__ field size = 3 (Max)
    // Fields: size=3, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05E38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lastb_v_p_z_field_pg_0_min_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lastb_v_p_z_field_pg_1_poweroftwo_8000_05238400() {
    // Encoding: 0x05238400
    // Test LASTB_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Vd=0, Zn=0
    let encoding: u32 = 0x05238400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lastb_v_p_z_field_zn_0_min_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ field Zn = 0 (Min)
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lastb_v_p_z_field_zn_1_poweroftwo_8000_05238020() {
    // Encoding: 0x05238020
    // Test LASTB_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Vd=0, size=0, Pg=0, Zn=1
    let encoding: u32 = 0x05238020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lastb_v_p_z_field_zn_30_poweroftwominusone_8000_052383c0() {
    // Encoding: 0x052383C0
    // Test LASTB_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=0, size=0, Zn=30, Pg=0
    let encoding: u32 = 0x052383C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lastb_v_p_z_field_zn_31_max_8000_052383e0() {
    // Encoding: 0x052383E0
    // Test LASTB_V.P.Z__ field Zn = 31 (Max)
    // Fields: Vd=0, size=0, Zn=31, Pg=0
    let encoding: u32 = 0x052383E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lastb_v_p_z_field_vd_0_min_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ field Vd = 0 (Min)
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lastb_v_p_z_field_vd_1_poweroftwo_8000_05238001() {
    // Encoding: 0x05238001
    // Test LASTB_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=0, Vd=1
    let encoding: u32 = 0x05238001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lastb_v_p_z_field_vd_30_poweroftwominusone_8000_0523801e() {
    // Encoding: 0x0523801E
    // Test LASTB_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vd=30, Pg=0, Zn=0
    let encoding: u32 = 0x0523801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lastb_v_p_z_field_vd_31_max_8000_0523801f() {
    // Encoding: 0x0523801F
    // Test LASTB_V.P.Z__ field Vd = 31 (Max)
    // Fields: Pg=0, Vd=31, Zn=0, size=0
    let encoding: u32 = 0x0523801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lastb_v_p_z_combo_0_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lastb_v_p_z_special_size_0_size_variant_0_32768_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lastb_v_p_z_special_size_1_size_variant_1_32768_05638000() {
    // Encoding: 0x05638000
    // Test LASTB_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Vd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x05638000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lastb_v_p_z_special_size_2_size_variant_2_32768_05a38000() {
    // Encoding: 0x05A38000
    // Test LASTB_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Vd=0, Pg=0
    let encoding: u32 = 0x05A38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lastb_v_p_z_special_size_3_size_variant_3_32768_05e38000() {
    // Encoding: 0x05E38000
    // Test LASTB_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x05E38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lastb_v_p_z_invalid_0_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lastb_v_p_z_invalid_1_8000_05238000() {
    // Encoding: 0x05238000
    // Test LASTB_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x05238000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTB_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lastb_v_p_z_reg_write_0_05238000() {
    // Test LASTB_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x05238000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05238000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CPY_Z.P.I__ Tests
// ============================================================================

/// Provenance: CPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cpy_z_p_i_field_size_0_min_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Pg=0, sh=0, M=0, imm8=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cpy_z_p_i_field_size_1_poweroftwo_0_05500000() {
    // Encoding: 0x05500000
    // Test CPY_Z.P.I__ field size = 1 (PowerOfTwo)
    // Fields: sh=0, M=0, imm8=0, Pg=0, Zd=0, size=1
    let encoding: u32 = 0x05500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cpy_z_p_i_field_size_2_poweroftwo_0_05900000() {
    // Encoding: 0x05900000
    // Test CPY_Z.P.I__ field size = 2 (PowerOfTwo)
    // Fields: sh=0, M=0, Pg=0, imm8=0, size=2, Zd=0
    let encoding: u32 = 0x05900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cpy_z_p_i_field_size_3_max_0_05d00000() {
    // Encoding: 0x05D00000
    // Test CPY_Z.P.I__ field size = 3 (Max)
    // Fields: Zd=0, size=3, sh=0, Pg=0, imm8=0, M=0
    let encoding: u32 = 0x05D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field Pg 16 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cpy_z_p_i_field_pg_0_min_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field Pg = 0 (Min)
    // Fields: M=0, Zd=0, imm8=0, size=0, Pg=0, sh=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field Pg 16 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cpy_z_p_i_field_pg_1_poweroftwo_0_05110000() {
    // Encoding: 0x05110000
    // Test CPY_Z.P.I__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, M=0, Zd=0, size=0, sh=0, imm8=0
    let encoding: u32 = 0x05110000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_cpy_z_p_i_field_m_0_min_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field M = 0 (Min)
    // Fields: imm8=0, Zd=0, size=0, M=0, sh=0, Pg=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field M 14 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_cpy_z_p_i_field_m_1_max_0_05104000() {
    // Encoding: 0x05104000
    // Test CPY_Z.P.I__ field M = 1 (Max)
    // Fields: imm8=0, Zd=0, size=0, Pg=0, sh=0, M=1
    let encoding: u32 = 0x05104000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_cpy_z_p_i_field_sh_0_min_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field sh = 0 (Min)
    // Fields: imm8=0, M=0, Pg=0, size=0, sh=0, Zd=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_cpy_z_p_i_field_sh_1_max_0_05102000() {
    // Encoding: 0x05102000
    // Test CPY_Z.P.I__ field sh = 1 (Max)
    // Fields: size=0, sh=1, Zd=0, M=0, Pg=0, imm8=0
    let encoding: u32 = 0x05102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_cpy_z_p_i_field_imm8_0_zero_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field imm8 = 0 (Zero)
    // Fields: sh=0, M=0, Zd=0, imm8=0, size=0, Pg=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_cpy_z_p_i_field_imm8_1_poweroftwo_0_05100020() {
    // Encoding: 0x05100020
    // Test CPY_Z.P.I__ field imm8 = 1 (PowerOfTwo)
    // Fields: Pg=0, M=0, imm8=1, sh=0, size=0, Zd=0
    let encoding: u32 = 0x05100020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_cpy_z_p_i_field_imm8_3_poweroftwominusone_0_05100060() {
    // Encoding: 0x05100060
    // Test CPY_Z.P.I__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: M=0, Zd=0, Pg=0, imm8=3, size=0, sh=0
    let encoding: u32 = 0x05100060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_cpy_z_p_i_field_imm8_4_poweroftwo_0_05100080() {
    // Encoding: 0x05100080
    // Test CPY_Z.P.I__ field imm8 = 4 (PowerOfTwo)
    // Fields: imm8=4, Zd=0, sh=0, size=0, Pg=0, M=0
    let encoding: u32 = 0x05100080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_cpy_z_p_i_field_imm8_7_poweroftwominusone_0_051000e0() {
    // Encoding: 0x051000E0
    // Test CPY_Z.P.I__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, M=0, imm8=7, Zd=0, sh=0
    let encoding: u32 = 0x051000E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_cpy_z_p_i_field_imm8_8_poweroftwo_0_05100100() {
    // Encoding: 0x05100100
    // Test CPY_Z.P.I__ field imm8 = 8 (PowerOfTwo)
    // Fields: size=0, Zd=0, imm8=8, sh=0, Pg=0, M=0
    let encoding: u32 = 0x05100100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_cpy_z_p_i_field_imm8_15_poweroftwominusone_0_051001e0() {
    // Encoding: 0x051001E0
    // Test CPY_Z.P.I__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=15, M=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x051001E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_cpy_z_p_i_field_imm8_16_poweroftwo_0_05100200() {
    // Encoding: 0x05100200
    // Test CPY_Z.P.I__ field imm8 = 16 (PowerOfTwo)
    // Fields: Pg=0, M=0, imm8=16, size=0, Zd=0, sh=0
    let encoding: u32 = 0x05100200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_cpy_z_p_i_field_imm8_31_poweroftwominusone_0_051003e0() {
    // Encoding: 0x051003E0
    // Test CPY_Z.P.I__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm8=31, sh=0, Zd=0, size=0, M=0
    let encoding: u32 = 0x051003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_cpy_z_p_i_field_imm8_32_poweroftwo_0_05100400() {
    // Encoding: 0x05100400
    // Test CPY_Z.P.I__ field imm8 = 32 (PowerOfTwo)
    // Fields: Pg=0, M=0, imm8=32, size=0, Zd=0, sh=0
    let encoding: u32 = 0x05100400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_cpy_z_p_i_field_imm8_63_poweroftwominusone_0_051007e0() {
    // Encoding: 0x051007E0
    // Test CPY_Z.P.I__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, sh=0, M=0, size=0, imm8=63
    let encoding: u32 = 0x051007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_cpy_z_p_i_field_imm8_64_poweroftwo_0_05100800() {
    // Encoding: 0x05100800
    // Test CPY_Z.P.I__ field imm8 = 64 (PowerOfTwo)
    // Fields: M=0, Pg=0, sh=0, size=0, imm8=64, Zd=0
    let encoding: u32 = 0x05100800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_cpy_z_p_i_field_imm8_127_poweroftwominusone_0_05100fe0() {
    // Encoding: 0x05100FE0
    // Test CPY_Z.P.I__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Zd=0, M=0, size=0, imm8=127, Pg=0, sh=0
    let encoding: u32 = 0x05100FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_cpy_z_p_i_field_imm8_128_poweroftwo_0_05101000() {
    // Encoding: 0x05101000
    // Test CPY_Z.P.I__ field imm8 = 128 (PowerOfTwo)
    // Fields: Pg=0, sh=0, Zd=0, size=0, imm8=128, M=0
    let encoding: u32 = 0x05101000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_cpy_z_p_i_field_imm8_255_max_0_05101fe0() {
    // Encoding: 0x05101FE0
    // Test CPY_Z.P.I__ field imm8 = 255 (Max)
    // Fields: Zd=0, Pg=0, sh=0, M=0, size=0, imm8=255
    let encoding: u32 = 0x05101FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cpy_z_p_i_field_zd_0_min_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field Zd = 0 (Min)
    // Fields: sh=0, size=0, imm8=0, Zd=0, Pg=0, M=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cpy_z_p_i_field_zd_1_poweroftwo_0_05100001() {
    // Encoding: 0x05100001
    // Test CPY_Z.P.I__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, imm8=0, Zd=1, sh=0, M=0
    let encoding: u32 = 0x05100001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cpy_z_p_i_field_zd_30_poweroftwominusone_0_0510001e() {
    // Encoding: 0x0510001E
    // Test CPY_Z.P.I__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, sh=0, Zd=30, imm8=0, Pg=0, M=0
    let encoding: u32 = 0x0510001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cpy_z_p_i_field_zd_31_max_0_0510001f() {
    // Encoding: 0x0510001F
    // Test CPY_Z.P.I__ field Zd = 31 (Max)
    // Fields: Pg=0, sh=0, M=0, imm8=0, size=0, Zd=31
    let encoding: u32 = 0x0510001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cpy_z_p_i_combo_0_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ field combination: size=0, Pg=0, M=0, sh=0, imm8=0, Zd=0
    // Fields: Pg=0, Zd=0, sh=0, imm8=0, M=0, size=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cpy_z_p_i_special_size_0_size_variant_0_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ special value size = 0 (Size variant 0)
    // Fields: imm8=0, Pg=0, sh=0, Zd=0, size=0, M=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cpy_z_p_i_special_size_1_size_variant_1_0_05500000() {
    // Encoding: 0x05500000
    // Test CPY_Z.P.I__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, sh=0, imm8=0, Zd=0, M=0, size=1
    let encoding: u32 = 0x05500000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cpy_z_p_i_special_size_2_size_variant_2_0_05900000() {
    // Encoding: 0x05900000
    // Test CPY_Z.P.I__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, M=0, sh=0, Zd=0, imm8=0, size=2
    let encoding: u32 = 0x05900000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cpy_z_p_i_special_size_3_size_variant_3_0_05d00000() {
    // Encoding: 0x05D00000
    // Test CPY_Z.P.I__ special value size = 3 (Size variant 3)
    // Fields: imm8=0, Pg=0, size=3, Zd=0, sh=0, M=0
    let encoding: u32 = 0x05D00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_cpy_z_p_i_special_sh_0_shift_type_lsl_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ special value sh = 0 (Shift type LSL)
    // Fields: sh=0, Zd=0, imm8=0, size=0, M=0, Pg=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_cpy_z_p_i_special_sh_1_shift_type_lsr_0_05102000() {
    // Encoding: 0x05102000
    // Test CPY_Z.P.I__ special value sh = 1 (Shift type LSR)
    // Fields: Zd=0, M=0, size=0, Pg=0, sh=1, imm8=0
    let encoding: u32 = 0x05102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_cpy_z_p_i_special_sh_2_shift_type_asr_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ special value sh = 2 (Shift type ASR)
    // Fields: sh=2, imm8=0, Zd=0, Pg=0, size=0, M=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_cpy_z_p_i_special_sh_3_shift_type_ror_0_05102000() {
    // Encoding: 0x05102000
    // Test CPY_Z.P.I__ special value sh = 3 (Shift type ROR)
    // Fields: imm8=0, Pg=0, sh=3, size=0, M=0, Zd=0
    let encoding: u32 = 0x05102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_i_invalid_0_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zd=0, imm8=0, M=0, sh=0, Pg=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_i_invalid_1_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm8=0, Pg=0, sh=0, size=0, Zd=0, M=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sh\" }), rhs: LitBits([false, false, true]) } }" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_i_invalid_2_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }
    // Fields: sh=0, M=0, Zd=0, imm8=0, size=0, Pg=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_i_invalid_3_0_05100000() {
    // Encoding: 0x05100000
    // Test CPY_Z.P.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, imm8=0, size=0, Zd=0, sh=0, M=0
    let encoding: u32 = 0x05100000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.I__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cpy_z_p_i_reg_write_0_05100000() {
    // Test CPY_Z.P.I__ register write: SimdFromField("d")
    // Encoding: 0x05100000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05100000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CNOT_Z.P.Z__ Tests
// ============================================================================

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cnot_z_p_z_field_size_0_min_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cnot_z_p_z_field_size_1_poweroftwo_a000_045ba000() {
    // Encoding: 0x045BA000
    // Test CNOT_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x045BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cnot_z_p_z_field_size_2_poweroftwo_a000_049ba000() {
    // Encoding: 0x049BA000
    // Test CNOT_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=2, Pg=0
    let encoding: u32 = 0x049BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cnot_z_p_z_field_size_3_max_a000_04dba000() {
    // Encoding: 0x04DBA000
    // Test CNOT_Z.P.Z__ field size = 3 (Max)
    // Fields: Zd=0, Zn=0, size=3, Pg=0
    let encoding: u32 = 0x04DBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cnot_z_p_z_field_pg_0_min_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cnot_z_p_z_field_pg_1_poweroftwo_a000_041ba400() {
    // Encoding: 0x041BA400
    // Test CNOT_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zd=0, Zn=0
    let encoding: u32 = 0x041BA400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cnot_z_p_z_field_zn_0_min_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cnot_z_p_z_field_zn_1_poweroftwo_a000_041ba020() {
    // Encoding: 0x041BA020
    // Test CNOT_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zn=1, Zd=0
    let encoding: u32 = 0x041BA020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cnot_z_p_z_field_zn_30_poweroftwominusone_a000_041ba3c0() {
    // Encoding: 0x041BA3C0
    // Test CNOT_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x041BA3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cnot_z_p_z_field_zn_31_max_a000_041ba3e0() {
    // Encoding: 0x041BA3E0
    // Test CNOT_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x041BA3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cnot_z_p_z_field_zd_0_min_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cnot_z_p_z_field_zd_1_poweroftwo_a000_041ba001() {
    // Encoding: 0x041BA001
    // Test CNOT_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Zn=0, size=0
    let encoding: u32 = 0x041BA001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cnot_z_p_z_field_zd_30_poweroftwominusone_a000_041ba01e() {
    // Encoding: 0x041BA01E
    // Test CNOT_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Pg=0, Zn=0
    let encoding: u32 = 0x041BA01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cnot_z_p_z_field_zd_31_max_a000_041ba01f() {
    // Encoding: 0x041BA01F
    // Test CNOT_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Pg=0, Zd=31
    let encoding: u32 = 0x041BA01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cnot_z_p_z_combo_0_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cnot_z_p_z_special_size_0_size_variant_0_40960_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cnot_z_p_z_special_size_1_size_variant_1_40960_045ba000() {
    // Encoding: 0x045BA000
    // Test CNOT_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x045BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cnot_z_p_z_special_size_2_size_variant_2_40960_049ba000() {
    // Encoding: 0x049BA000
    // Test CNOT_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x049BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cnot_z_p_z_special_size_3_size_variant_3_40960_04dba000() {
    // Encoding: 0x04DBA000
    // Test CNOT_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04DBA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cnot_z_p_z_invalid_0_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cnot_z_p_z_invalid_1_a000_041ba000() {
    // Encoding: 0x041BA000
    // Test CNOT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x041BA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CNOT_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cnot_z_p_z_reg_write_0_041ba000() {
    // Test CNOT_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x041BA000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041BA000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQSUB_Z.ZZ__ Tests
// ============================================================================

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqsub_z_zz_field_size_0_min_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqsub_z_zz_field_size_1_poweroftwo_1c00_04601c00() {
    // Encoding: 0x04601C00
    // Test UQSUB_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x04601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqsub_z_zz_field_size_2_poweroftwo_1c00_04a01c00() {
    // Encoding: 0x04A01C00
    // Test UQSUB_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Zm=0, size=2
    let encoding: u32 = 0x04A01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqsub_z_zz_field_size_3_max_1c00_04e01c00() {
    // Encoding: 0x04E01C00
    // Test UQSUB_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x04E01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uqsub_z_zz_field_zm_0_min_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uqsub_z_zz_field_zm_1_poweroftwo_1c00_04211c00() {
    // Encoding: 0x04211C00
    // Test UQSUB_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=0, Zm=1
    let encoding: u32 = 0x04211C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uqsub_z_zz_field_zm_30_poweroftwominusone_1c00_043e1c00() {
    // Encoding: 0x043E1C00
    // Test UQSUB_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Zm=30, Zd=0
    let encoding: u32 = 0x043E1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uqsub_z_zz_field_zm_31_max_1c00_043f1c00() {
    // Encoding: 0x043F1C00
    // Test UQSUB_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, size=0, Zm=31, Zd=0
    let encoding: u32 = 0x043F1C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uqsub_z_zz_field_zn_0_min_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uqsub_z_zz_field_zn_1_poweroftwo_1c00_04201c20() {
    // Encoding: 0x04201C20
    // Test UQSUB_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04201C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uqsub_z_zz_field_zn_30_poweroftwominusone_1c00_04201fc0() {
    // Encoding: 0x04201FC0
    // Test UQSUB_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zd=0, Zn=30
    let encoding: u32 = 0x04201FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uqsub_z_zz_field_zn_31_max_1c00_04201fe0() {
    // Encoding: 0x04201FE0
    // Test UQSUB_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x04201FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uqsub_z_zz_field_zd_0_min_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uqsub_z_zz_field_zd_1_poweroftwo_1c00_04201c01() {
    // Encoding: 0x04201C01
    // Test UQSUB_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=1, size=0
    let encoding: u32 = 0x04201C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uqsub_z_zz_field_zd_30_poweroftwominusone_1c00_04201c1e() {
    // Encoding: 0x04201C1E
    // Test UQSUB_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Zm=0, Zd=30
    let encoding: u32 = 0x04201C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uqsub_z_zz_field_zd_31_max_1c00_04201c1f() {
    // Encoding: 0x04201C1F
    // Test UQSUB_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, size=0, Zm=0, Zd=31
    let encoding: u32 = 0x04201C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqsub_z_zz_combo_0_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqsub_z_zz_special_size_0_size_variant_0_7168_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqsub_z_zz_special_size_1_size_variant_1_7168_04601c00() {
    // Encoding: 0x04601C00
    // Test UQSUB_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x04601C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqsub_z_zz_special_size_2_size_variant_2_7168_04a01c00() {
    // Encoding: 0x04A01C00
    // Test UQSUB_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, Zn=0, size=2, Zm=0
    let encoding: u32 = 0x04A01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqsub_z_zz_special_size_3_size_variant_3_7168_04e01c00() {
    // Encoding: 0x04E01C00
    // Test UQSUB_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04E01C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqsub_z_zz_invalid_0_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqsub_z_zz_invalid_1_1c00_04201c00() {
    // Encoding: 0x04201C00
    // Test UQSUB_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x04201C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQSUB_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uqsub_z_zz_reg_write_0_04201c00() {
    // Test UQSUB_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x04201C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04201C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSR_Z.P.ZW__ Tests
// ============================================================================

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsr_z_p_zw_field_size_0_min_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ field size = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsr_z_p_zw_field_size_1_poweroftwo_8000_04598000() {
    // Encoding: 0x04598000
    // Test LSR_Z.P.ZW__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x04598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsr_z_p_zw_field_size_2_poweroftwo_8000_04998000() {
    // Encoding: 0x04998000
    // Test LSR_Z.P.ZW__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=2, Zm=0
    let encoding: u32 = 0x04998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsr_z_p_zw_field_size_3_max_8000_04d98000() {
    // Encoding: 0x04D98000
    // Test LSR_Z.P.ZW__ field size = 3 (Max)
    // Fields: Pg=0, Zm=0, Zdn=0, size=3
    let encoding: u32 = 0x04D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsr_z_p_zw_field_pg_0_min_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsr_z_p_zw_field_pg_1_poweroftwo_8000_04198400() {
    // Encoding: 0x04198400
    // Test LSR_Z.P.ZW__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Zm=0, Pg=1
    let encoding: u32 = 0x04198400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_p_zw_field_zm_0_min_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ field Zm = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_p_zw_field_zm_1_poweroftwo_8000_04198020() {
    // Encoding: 0x04198020
    // Test LSR_Z.P.ZW__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Pg=0, Zdn=0
    let encoding: u32 = 0x04198020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_p_zw_field_zm_30_poweroftwominusone_8000_041983c0() {
    // Encoding: 0x041983C0
    // Test LSR_Z.P.ZW__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=0, size=0, Zm=30
    let encoding: u32 = 0x041983C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_p_zw_field_zm_31_max_8000_041983e0() {
    // Encoding: 0x041983E0
    // Test LSR_Z.P.ZW__ field Zm = 31 (Max)
    // Fields: Zdn=0, size=0, Pg=0, Zm=31
    let encoding: u32 = 0x041983E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zw_field_zdn_0_min_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ field Zdn = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zw_field_zdn_1_poweroftwo_8000_04198001() {
    // Encoding: 0x04198001
    // Test LSR_Z.P.ZW__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x04198001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsr_z_p_zw_field_zdn_15_poweroftwominusone_8000_0419800f() {
    // Encoding: 0x0419800F
    // Test LSR_Z.P.ZW__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=0, Zdn=15
    let encoding: u32 = 0x0419800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsr_z_p_zw_field_zdn_31_max_8000_0419801f() {
    // Encoding: 0x0419801F
    // Test LSR_Z.P.ZW__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x0419801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsr_z_p_zw_combo_0_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsr_z_p_zw_special_size_0_size_variant_0_32768_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsr_z_p_zw_special_size_1_size_variant_1_32768_04598000() {
    // Encoding: 0x04598000
    // Test LSR_Z.P.ZW__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, size=1, Zm=0, Pg=0
    let encoding: u32 = 0x04598000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsr_z_p_zw_special_size_2_size_variant_2_32768_04998000() {
    // Encoding: 0x04998000
    // Test LSR_Z.P.ZW__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04998000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsr_z_p_zw_special_size_3_size_variant_3_32768_04d98000() {
    // Encoding: 0x04D98000
    // Test LSR_Z.P.ZW__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Pg=0, Zm=0, size=3
    let encoding: u32 = 0x04D98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zw_invalid_0_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zw_invalid_1_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zw_invalid_2_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zw_invalid_3_8000_04198000() {
    // Encoding: 0x04198000
    // Test LSR_Z.P.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04198000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZW__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsr_z_p_zw_reg_write_0_04198000() {
    // Test LSR_Z.P.ZW__ register write: SimdFromField("dn")
    // Encoding: 0x04198000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04198000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLS_Z.P.Z__ Tests
// ============================================================================

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cls_z_p_z_field_size_0_min_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cls_z_p_z_field_size_1_poweroftwo_a000_0458a000() {
    // Encoding: 0x0458A000
    // Test CLS_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x0458A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cls_z_p_z_field_size_2_poweroftwo_a000_0498a000() {
    // Encoding: 0x0498A000
    // Test CLS_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x0498A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cls_z_p_z_field_size_3_max_a000_04d8a000() {
    // Encoding: 0x04D8A000
    // Test CLS_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cls_z_p_z_field_pg_0_min_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cls_z_p_z_field_pg_1_poweroftwo_a000_0418a400() {
    // Encoding: 0x0418A400
    // Test CLS_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x0418A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cls_z_p_z_field_zn_0_min_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cls_z_p_z_field_zn_1_poweroftwo_a000_0418a020() {
    // Encoding: 0x0418A020
    // Test CLS_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zd=0, Pg=0, Zn=1
    let encoding: u32 = 0x0418A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cls_z_p_z_field_zn_30_poweroftwominusone_a000_0418a3c0() {
    // Encoding: 0x0418A3C0
    // Test CLS_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x0418A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cls_z_p_z_field_zn_31_max_a000_0418a3e0() {
    // Encoding: 0x0418A3E0
    // Test CLS_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x0418A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cls_z_p_z_field_zd_0_min_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cls_z_p_z_field_zd_1_poweroftwo_a000_0418a001() {
    // Encoding: 0x0418A001
    // Test CLS_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=0, Zd=1
    let encoding: u32 = 0x0418A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cls_z_p_z_field_zd_30_poweroftwominusone_a000_0418a01e() {
    // Encoding: 0x0418A01E
    // Test CLS_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=0, Zd=30
    let encoding: u32 = 0x0418A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cls_z_p_z_field_zd_31_max_a000_0418a01f() {
    // Encoding: 0x0418A01F
    // Test CLS_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0418A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cls_z_p_z_combo_0_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cls_z_p_z_special_size_0_size_variant_0_40960_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cls_z_p_z_special_size_1_size_variant_1_40960_0458a000() {
    // Encoding: 0x0458A000
    // Test CLS_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x0458A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cls_z_p_z_special_size_2_size_variant_2_40960_0498a000() {
    // Encoding: 0x0498A000
    // Test CLS_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zn=0, size=2, Zd=0
    let encoding: u32 = 0x0498A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cls_z_p_z_special_size_3_size_variant_3_40960_04d8a000() {
    // Encoding: 0x04D8A000
    // Test CLS_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Pg=0, Zn=0, size=3
    let encoding: u32 = 0x04D8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cls_z_p_z_invalid_0_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cls_z_p_z_invalid_1_a000_0418a000() {
    // Encoding: 0x0418A000
    // Test CLS_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x0418A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLS_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cls_z_p_z_reg_write_0_0418a000() {
    // Test CLS_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0418A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0418A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SABD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sabd_z_p_zz_field_size_0_min_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sabd_z_p_zz_field_size_1_poweroftwo_0_044c0000() {
    // Encoding: 0x044C0000
    // Test SABD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x044C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sabd_z_p_zz_field_size_2_poweroftwo_0_048c0000() {
    // Encoding: 0x048C0000
    // Test SABD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x048C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sabd_z_p_zz_field_size_3_max_0_04cc0000() {
    // Encoding: 0x04CC0000
    // Test SABD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04CC0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sabd_z_p_zz_field_pg_0_min_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sabd_z_p_zz_field_pg_1_poweroftwo_0_040c0400() {
    // Encoding: 0x040C0400
    // Test SABD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x040C0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sabd_z_p_zz_field_zm_0_min_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sabd_z_p_zz_field_zm_1_poweroftwo_0_040c0020() {
    // Encoding: 0x040C0020
    // Test SABD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, Pg=0, size=0
    let encoding: u32 = 0x040C0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sabd_z_p_zz_field_zm_30_poweroftwominusone_0_040c03c0() {
    // Encoding: 0x040C03C0
    // Test SABD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=30, Zdn=0
    let encoding: u32 = 0x040C03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sabd_z_p_zz_field_zm_31_max_0_040c03e0() {
    // Encoding: 0x040C03E0
    // Test SABD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zdn=0, size=0
    let encoding: u32 = 0x040C03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sabd_z_p_zz_field_zdn_0_min_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sabd_z_p_zz_field_zdn_1_poweroftwo_0_040c0001() {
    // Encoding: 0x040C0001
    // Test SABD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zdn=1, Zm=0
    let encoding: u32 = 0x040C0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sabd_z_p_zz_field_zdn_15_poweroftwominusone_0_040c000f() {
    // Encoding: 0x040C000F
    // Test SABD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x040C000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sabd_z_p_zz_field_zdn_31_max_0_040c001f() {
    // Encoding: 0x040C001F
    // Test SABD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=31, Zm=0
    let encoding: u32 = 0x040C001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sabd_z_p_zz_combo_0_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sabd_z_p_zz_special_size_0_size_variant_0_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sabd_z_p_zz_special_size_1_size_variant_1_0_044c0000() {
    // Encoding: 0x044C0000
    // Test SABD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zdn=0, Zm=0
    let encoding: u32 = 0x044C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sabd_z_p_zz_special_size_2_size_variant_2_0_048c0000() {
    // Encoding: 0x048C0000
    // Test SABD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zm=0, Zdn=0
    let encoding: u32 = 0x048C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sabd_z_p_zz_special_size_3_size_variant_3_0_04cc0000() {
    // Encoding: 0x04CC0000
    // Test SABD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x04CC0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sabd_z_p_zz_invalid_0_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sabd_z_p_zz_invalid_1_0_040c0000() {
    // Encoding: 0x040C0000
    // Test SABD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x040C0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SABD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sabd_z_p_zz_reg_write_0_040c0000() {
    // Test SABD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x040C0000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040C0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMINV_R.P.Z__ Tests
// ============================================================================

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sminv_r_p_z_field_size_0_min_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sminv_r_p_z_field_size_1_poweroftwo_2000_044a2000() {
    // Encoding: 0x044A2000
    // Test SMINV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zn=0, Vd=0
    let encoding: u32 = 0x044A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sminv_r_p_z_field_size_2_poweroftwo_2000_048a2000() {
    // Encoding: 0x048A2000
    // Test SMINV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Vd=0, Pg=0, size=2
    let encoding: u32 = 0x048A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sminv_r_p_z_field_size_3_max_2000_04ca2000() {
    // Encoding: 0x04CA2000
    // Test SMINV_R.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Vd=0, size=3, Zn=0
    let encoding: u32 = 0x04CA2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sminv_r_p_z_field_pg_0_min_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Vd=0, Zn=0, size=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sminv_r_p_z_field_pg_1_poweroftwo_2000_040a2400() {
    // Encoding: 0x040A2400
    // Test SMINV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Pg=1, Vd=0
    let encoding: u32 = 0x040A2400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sminv_r_p_z_field_zn_0_min_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sminv_r_p_z_field_zn_1_poweroftwo_2000_040a2020() {
    // Encoding: 0x040A2020
    // Test SMINV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Vd=0, Pg=0
    let encoding: u32 = 0x040A2020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sminv_r_p_z_field_zn_30_poweroftwominusone_2000_040a23c0() {
    // Encoding: 0x040A23C0
    // Test SMINV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Vd=0, Zn=30, size=0
    let encoding: u32 = 0x040A23C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sminv_r_p_z_field_zn_31_max_2000_040a23e0() {
    // Encoding: 0x040A23E0
    // Test SMINV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x040A23E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sminv_r_p_z_field_vd_0_min_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ field Vd = 0 (Min)
    // Fields: size=0, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sminv_r_p_z_field_vd_1_poweroftwo_2000_040a2001() {
    // Encoding: 0x040A2001
    // Test SMINV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Vd=1, Pg=0
    let encoding: u32 = 0x040A2001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sminv_r_p_z_field_vd_30_poweroftwominusone_2000_040a201e() {
    // Encoding: 0x040A201E
    // Test SMINV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=0, Vd=30
    let encoding: u32 = 0x040A201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sminv_r_p_z_field_vd_31_max_2000_040a201f() {
    // Encoding: 0x040A201F
    // Test SMINV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Pg=0, Zn=0, size=0, Vd=31
    let encoding: u32 = 0x040A201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sminv_r_p_z_combo_0_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sminv_r_p_z_special_size_0_size_variant_0_8192_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sminv_r_p_z_special_size_1_size_variant_1_8192_044a2000() {
    // Encoding: 0x044A2000
    // Test SMINV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Vd=0, Pg=0
    let encoding: u32 = 0x044A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sminv_r_p_z_special_size_2_size_variant_2_8192_048a2000() {
    // Encoding: 0x048A2000
    // Test SMINV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Vd=0, size=2, Pg=0
    let encoding: u32 = 0x048A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sminv_r_p_z_special_size_3_size_variant_3_8192_04ca2000() {
    // Encoding: 0x04CA2000
    // Test SMINV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x04CA2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sminv_r_p_z_invalid_0_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Pg=0, Vd=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sminv_r_p_z_invalid_1_2000_040a2000() {
    // Encoding: 0x040A2000
    // Test SMINV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x040A2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMINV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sminv_r_p_z_reg_write_0_040a2000() {
    // Test SMINV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x040A2000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040A2000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTB_V.P.Z__ Tests
// ============================================================================

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clastb_v_p_z_field_size_0_min_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zm=0, Vdn=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clastb_v_p_z_field_size_1_poweroftwo_8000_056b8000() {
    // Encoding: 0x056B8000
    // Test CLASTB_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Vdn=0, Pg=0, size=1, Zm=0
    let encoding: u32 = 0x056B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clastb_v_p_z_field_size_2_poweroftwo_8000_05ab8000() {
    // Encoding: 0x05AB8000
    // Test CLASTB_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Vdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x05AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clastb_v_p_z_field_size_3_max_8000_05eb8000() {
    // Encoding: 0x05EB8000
    // Test CLASTB_V.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Vdn=0, size=3, Zm=0
    let encoding: u32 = 0x05EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clastb_v_p_z_field_pg_0_min_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ field Pg = 0 (Min)
    // Fields: Zm=0, Pg=0, size=0, Vdn=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clastb_v_p_z_field_pg_1_poweroftwo_8000_052b8400() {
    // Encoding: 0x052B8400
    // Test CLASTB_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Vdn=0, Zm=0
    let encoding: u32 = 0x052B8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clastb_v_p_z_field_zm_0_min_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ field Zm = 0 (Min)
    // Fields: size=0, Vdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clastb_v_p_z_field_zm_1_poweroftwo_8000_052b8020() {
    // Encoding: 0x052B8020
    // Test CLASTB_V.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Vdn=0
    let encoding: u32 = 0x052B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clastb_v_p_z_field_zm_30_poweroftwominusone_8000_052b83c0() {
    // Encoding: 0x052B83C0
    // Test CLASTB_V.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Vdn=0, size=0, Zm=30, Pg=0
    let encoding: u32 = 0x052B83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clastb_v_p_z_field_zm_31_max_8000_052b83e0() {
    // Encoding: 0x052B83E0
    // Test CLASTB_V.P.Z__ field Zm = 31 (Max)
    // Fields: Zm=31, Vdn=0, size=0, Pg=0
    let encoding: u32 = 0x052B83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clastb_v_p_z_field_vdn_0_min_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ field Vdn = 0 (Min)
    // Fields: Vdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clastb_v_p_z_field_vdn_1_poweroftwo_8000_052b8001() {
    // Encoding: 0x052B8001
    // Test CLASTB_V.P.Z__ field Vdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=0, Vdn=1
    let encoding: u32 = 0x052B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clastb_v_p_z_field_vdn_15_poweroftwominusone_8000_052b800f() {
    // Encoding: 0x052B800F
    // Test CLASTB_V.P.Z__ field Vdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Vdn=15, Zm=0
    let encoding: u32 = 0x052B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clastb_v_p_z_field_vdn_31_max_8000_052b801f() {
    // Encoding: 0x052B801F
    // Test CLASTB_V.P.Z__ field Vdn = 31 (Max)
    // Fields: Vdn=31, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x052B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clastb_v_p_z_combo_0_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: Pg=0, Zm=0, Vdn=0, size=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clastb_v_p_z_special_size_0_size_variant_0_32768_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zm=0, Vdn=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clastb_v_p_z_special_size_1_size_variant_1_32768_056b8000() {
    // Encoding: 0x056B8000
    // Test CLASTB_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Vdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x056B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clastb_v_p_z_special_size_2_size_variant_2_32768_05ab8000() {
    // Encoding: 0x05AB8000
    // Test CLASTB_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Vdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x05AB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clastb_v_p_z_special_size_3_size_variant_3_32768_05eb8000() {
    // Encoding: 0x05EB8000
    // Test CLASTB_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x05EB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clastb_v_p_z_invalid_0_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Vdn=0, Zm=0, size=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clastb_v_p_z_invalid_1_8000_052b8000() {
    // Encoding: 0x052B8000
    // Test CLASTB_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x052B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTB_V.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_clastb_v_p_z_reg_write_0_052b8000() {
    // Test CLASTB_V.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x052B8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x052B8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTA_R.P.Z__ Tests
// ============================================================================

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clasta_r_p_z_field_size_0_min_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zm=0, Rdn=0, size=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clasta_r_p_z_field_size_1_poweroftwo_a000_0570a000() {
    // Encoding: 0x0570A000
    // Test CLASTA_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Rdn=0, Zm=0, size=1
    let encoding: u32 = 0x0570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clasta_r_p_z_field_size_2_poweroftwo_a000_05b0a000() {
    // Encoding: 0x05B0A000
    // Test CLASTA_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Rdn=0, Pg=0, size=2
    let encoding: u32 = 0x05B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clasta_r_p_z_field_size_3_max_a000_05f0a000() {
    // Encoding: 0x05F0A000
    // Test CLASTA_R.P.Z__ field size = 3 (Max)
    // Fields: Zm=0, Rdn=0, Pg=0, size=3
    let encoding: u32 = 0x05F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clasta_r_p_z_field_pg_0_min_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rdn=0, Zm=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clasta_r_p_z_field_pg_1_poweroftwo_a000_0530a400() {
    // Encoding: 0x0530A400
    // Test CLASTA_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=1, Rdn=0
    let encoding: u32 = 0x0530A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clasta_r_p_z_field_zm_0_min_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ field Zm = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Rdn=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clasta_r_p_z_field_zm_1_poweroftwo_a000_0530a020() {
    // Encoding: 0x0530A020
    // Test CLASTA_R.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x0530A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clasta_r_p_z_field_zm_30_poweroftwominusone_a000_0530a3c0() {
    // Encoding: 0x0530A3C0
    // Test CLASTA_R.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rdn=0, size=0, Zm=30
    let encoding: u32 = 0x0530A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clasta_r_p_z_field_zm_31_max_a000_0530a3e0() {
    // Encoding: 0x0530A3E0
    // Test CLASTA_R.P.Z__ field Zm = 31 (Max)
    // Fields: Rdn=0, Pg=0, Zm=31, size=0
    let encoding: u32 = 0x0530A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clasta_r_p_z_field_rdn_0_min_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ field Rdn = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Rdn=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clasta_r_p_z_field_rdn_1_poweroftwo_a000_0530a001() {
    // Encoding: 0x0530A001
    // Test CLASTA_R.P.Z__ field Rdn = 1 (PowerOfTwo)
    // Fields: size=0, Rdn=1, Pg=0, Zm=0
    let encoding: u32 = 0x0530A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clasta_r_p_z_field_rdn_15_poweroftwominusone_a000_0530a00f() {
    // Encoding: 0x0530A00F
    // Test CLASTA_R.P.Z__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Rdn=15, Zm=0
    let encoding: u32 = 0x0530A00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clasta_r_p_z_field_rdn_31_max_a000_0530a01f() {
    // Encoding: 0x0530A01F
    // Test CLASTA_R.P.Z__ field Rdn = 31 (Max)
    // Fields: Rdn=31, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x0530A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clasta_r_p_z_combo_0_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=0
    // Fields: Rdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clasta_r_p_z_special_size_0_size_variant_0_40960_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Rdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clasta_r_p_z_special_size_1_size_variant_1_40960_0570a000() {
    // Encoding: 0x0570A000
    // Test CLASTA_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Rdn=0, size=1, Pg=0
    let encoding: u32 = 0x0570A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clasta_r_p_z_special_size_2_size_variant_2_40960_05b0a000() {
    // Encoding: 0x05B0A000
    // Test CLASTA_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Pg=0, size=2, Rdn=0
    let encoding: u32 = 0x05B0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clasta_r_p_z_special_size_3_size_variant_3_40960_05f0a000() {
    // Encoding: 0x05F0A000
    // Test CLASTA_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Rdn=0, size=3, Zm=0
    let encoding: u32 = 0x05F0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clasta_r_p_z_invalid_0_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, size=0, Rdn=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clasta_r_p_z_invalid_1_a000_0530a000() {
    // Encoding: 0x0530A000
    // Test CLASTA_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Pg=0, Rdn=0
    let encoding: u32 = 0x0530A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTA_R.P.Z__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_clasta_r_p_z_reg_write_0_0530a000() {
    // Test CLASTA_R.P.Z__ register write: GpFromField("dn")
    // Encoding: 0x0530A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0530A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMULH_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umulh_z_p_zz_field_size_0_min_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umulh_z_p_zz_field_size_1_poweroftwo_0_04530000() {
    // Encoding: 0x04530000
    // Test UMULH_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, size=1, Zm=0
    let encoding: u32 = 0x04530000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umulh_z_p_zz_field_size_2_poweroftwo_0_04930000() {
    // Encoding: 0x04930000
    // Test UMULH_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04930000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umulh_z_p_zz_field_size_3_max_0_04d30000() {
    // Encoding: 0x04D30000
    // Test UMULH_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x04D30000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_umulh_z_p_zz_field_pg_0_min_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_umulh_z_p_zz_field_pg_1_poweroftwo_0_04130400() {
    // Encoding: 0x04130400
    // Test UMULH_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, size=0, Pg=1
    let encoding: u32 = 0x04130400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_umulh_z_p_zz_field_zm_0_min_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_umulh_z_p_zz_field_zm_1_poweroftwo_0_04130020() {
    // Encoding: 0x04130020
    // Test UMULH_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=1, size=0, Zdn=0
    let encoding: u32 = 0x04130020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_umulh_z_p_zz_field_zm_30_poweroftwominusone_0_041303c0() {
    // Encoding: 0x041303C0
    // Test UMULH_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=0, size=0, Zm=30
    let encoding: u32 = 0x041303C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_umulh_z_p_zz_field_zm_31_max_0_041303e0() {
    // Encoding: 0x041303E0
    // Test UMULH_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zdn=0, Pg=0, Zm=31
    let encoding: u32 = 0x041303E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_umulh_z_p_zz_field_zdn_0_min_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_umulh_z_p_zz_field_zdn_1_poweroftwo_0_04130001() {
    // Encoding: 0x04130001
    // Test UMULH_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, size=0, Zdn=1
    let encoding: u32 = 0x04130001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_umulh_z_p_zz_field_zdn_15_poweroftwominusone_0_0413000f() {
    // Encoding: 0x0413000F
    // Test UMULH_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Pg=0, Zdn=15
    let encoding: u32 = 0x0413000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_umulh_z_p_zz_field_zdn_31_max_0_0413001f() {
    // Encoding: 0x0413001F
    // Test UMULH_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zdn=31, size=0
    let encoding: u32 = 0x0413001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umulh_z_p_zz_combo_0_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umulh_z_p_zz_special_size_0_size_variant_0_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umulh_z_p_zz_special_size_1_size_variant_1_0_04530000() {
    // Encoding: 0x04530000
    // Test UMULH_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zm=0, Zdn=0
    let encoding: u32 = 0x04530000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umulh_z_p_zz_special_size_2_size_variant_2_0_04930000() {
    // Encoding: 0x04930000
    // Test UMULH_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, size=2, Zdn=0
    let encoding: u32 = 0x04930000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umulh_z_p_zz_special_size_3_size_variant_3_0_04d30000() {
    // Encoding: 0x04D30000
    // Test UMULH_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, size=3, Zdn=0
    let encoding: u32 = 0x04D30000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umulh_z_p_zz_invalid_0_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umulh_z_p_zz_invalid_1_0_04130000() {
    // Encoding: 0x04130000
    // Test UMULH_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04130000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMULH_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_umulh_z_p_zz_reg_write_0_04130000() {
    // Test UMULH_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04130000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04130000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.P.ZW__ Tests
// ============================================================================

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsl_z_p_zw_field_size_0_min_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ field size = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsl_z_p_zw_field_size_1_poweroftwo_8000_045b8000() {
    // Encoding: 0x045B8000
    // Test LSL_Z.P.ZW__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=1, Zdn=0
    let encoding: u32 = 0x045B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsl_z_p_zw_field_size_2_poweroftwo_8000_049b8000() {
    // Encoding: 0x049B8000
    // Test LSL_Z.P.ZW__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x049B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsl_z_p_zw_field_size_3_max_8000_04db8000() {
    // Encoding: 0x04DB8000
    // Test LSL_Z.P.ZW__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x04DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsl_z_p_zw_field_pg_0_min_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ field Pg = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsl_z_p_zw_field_pg_1_poweroftwo_8000_041b8400() {
    // Encoding: 0x041B8400
    // Test LSL_Z.P.ZW__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zdn=0, Pg=1
    let encoding: u32 = 0x041B8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_p_zw_field_zm_0_min_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ field Zm = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_p_zw_field_zm_1_poweroftwo_8000_041b8020() {
    // Encoding: 0x041B8020
    // Test LSL_Z.P.ZW__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zm=1, Pg=0, Zdn=0
    let encoding: u32 = 0x041B8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_p_zw_field_zm_30_poweroftwominusone_8000_041b83c0() {
    // Encoding: 0x041B83C0
    // Test LSL_Z.P.ZW__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=30, Zdn=0
    let encoding: u32 = 0x041B83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_p_zw_field_zm_31_max_8000_041b83e0() {
    // Encoding: 0x041B83E0
    // Test LSL_Z.P.ZW__ field Zm = 31 (Max)
    // Fields: Zm=31, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x041B83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zw_field_zdn_0_min_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ field Zdn = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zw_field_zdn_1_poweroftwo_8000_041b8001() {
    // Encoding: 0x041B8001
    // Test LSL_Z.P.ZW__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=1, size=0
    let encoding: u32 = 0x041B8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsl_z_p_zw_field_zdn_15_poweroftwominusone_8000_041b800f() {
    // Encoding: 0x041B800F
    // Test LSL_Z.P.ZW__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x041B800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsl_z_p_zw_field_zdn_31_max_8000_041b801f() {
    // Encoding: 0x041B801F
    // Test LSL_Z.P.ZW__ field Zdn = 31 (Max)
    // Fields: size=0, Zm=0, Pg=0, Zdn=31
    let encoding: u32 = 0x041B801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsl_z_p_zw_combo_0_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsl_z_p_zw_special_size_0_size_variant_0_32768_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsl_z_p_zw_special_size_1_size_variant_1_32768_045b8000() {
    // Encoding: 0x045B8000
    // Test LSL_Z.P.ZW__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zm=0, Zdn=0
    let encoding: u32 = 0x045B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsl_z_p_zw_special_size_2_size_variant_2_32768_049b8000() {
    // Encoding: 0x049B8000
    // Test LSL_Z.P.ZW__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x049B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsl_z_p_zw_special_size_3_size_variant_3_32768_04db8000() {
    // Encoding: 0x04DB8000
    // Test LSL_Z.P.ZW__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04DB8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zw_invalid_0_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zw_invalid_1_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zw_invalid_2_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zw_invalid_3_8000_041b8000() {
    // Encoding: 0x041B8000
    // Test LSL_Z.P.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x041B8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZW__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsl_z_p_zw_reg_write_0_041b8000() {
    // Test LSL_Z.P.ZW__ register write: SimdFromField("dn")
    // Encoding: 0x041B8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x041B8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DUP_Z.R__ Tests
// ============================================================================

/// Provenance: DUP_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_dup_z_r_field_size_0_min_3800_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Rn=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_dup_z_r_field_size_1_poweroftwo_3800_05603800() {
    // Encoding: 0x05603800
    // Test DUP_Z.R__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Rn=0
    let encoding: u32 = 0x05603800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_dup_z_r_field_size_2_poweroftwo_3800_05a03800() {
    // Encoding: 0x05A03800
    // Test DUP_Z.R__ field size = 2 (PowerOfTwo)
    // Fields: Rn=0, Zd=0, size=2
    let encoding: u32 = 0x05A03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_dup_z_r_field_size_3_max_3800_05e03800() {
    // Encoding: 0x05E03800
    // Test DUP_Z.R__ field size = 3 (Max)
    // Fields: Zd=0, Rn=0, size=3
    let encoding: u32 = 0x05E03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_dup_z_r_field_rn_0_min_3800_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ field Rn = 0 (Min)
    // Fields: size=0, Rn=0, Zd=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_dup_z_r_field_rn_1_poweroftwo_3800_05203820() {
    // Encoding: 0x05203820
    // Test DUP_Z.R__ field Rn = 1 (PowerOfTwo)
    // Fields: size=0, Rn=1, Zd=0
    let encoding: u32 = 0x05203820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_dup_z_r_field_rn_30_poweroftwominusone_3800_05203bc0() {
    // Encoding: 0x05203BC0
    // Test DUP_Z.R__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=30, size=0, Zd=0
    let encoding: u32 = 0x05203BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_dup_z_r_field_rn_31_max_3800_05203be0() {
    // Encoding: 0x05203BE0
    // Test DUP_Z.R__ field Rn = 31 (Max)
    // Fields: size=0, Rn=31, Zd=0
    let encoding: u32 = 0x05203BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_dup_z_r_field_zd_0_min_3800_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ field Zd = 0 (Min)
    // Fields: size=0, Zd=0, Rn=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_dup_z_r_field_zd_1_poweroftwo_3800_05203801() {
    // Encoding: 0x05203801
    // Test DUP_Z.R__ field Zd = 1 (PowerOfTwo)
    // Fields: Rn=0, Zd=1, size=0
    let encoding: u32 = 0x05203801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_dup_z_r_field_zd_30_poweroftwominusone_3800_0520381e() {
    // Encoding: 0x0520381E
    // Test DUP_Z.R__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Rn=0
    let encoding: u32 = 0x0520381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_dup_z_r_field_zd_31_max_3800_0520381f() {
    // Encoding: 0x0520381F
    // Test DUP_Z.R__ field Zd = 31 (Max)
    // Fields: Rn=0, size=0, Zd=31
    let encoding: u32 = 0x0520381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_dup_z_r_combo_0_3800_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ field combination: size=0, Rn=0, Zd=0
    // Fields: size=0, Rn=0, Zd=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_dup_z_r_special_size_0_size_variant_0_14336_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Zd=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_dup_z_r_special_size_1_size_variant_1_14336_05603800() {
    // Encoding: 0x05603800
    // Test DUP_Z.R__ special value size = 1 (Size variant 1)
    // Fields: size=1, Rn=0, Zd=0
    let encoding: u32 = 0x05603800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_dup_z_r_special_size_2_size_variant_2_14336_05a03800() {
    // Encoding: 0x05A03800
    // Test DUP_Z.R__ special value size = 2 (Size variant 2)
    // Fields: size=2, Rn=0, Zd=0
    let encoding: u32 = 0x05A03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_dup_z_r_special_size_3_size_variant_3_14336_05e03800() {
    // Encoding: 0x05E03800
    // Test DUP_Z.R__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Rn=0
    let encoding: u32 = 0x05E03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_dup_z_r_special_rn_31_stack_pointer_sp_may_require_alignment_14336_05203be0() {
    // Encoding: 0x05203BE0
    // Test DUP_Z.R__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, size=0, Zd=0
    let encoding: u32 = 0x05203BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_dup_z_r_invalid_0_3800_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Rn=0, Zd=0, size=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dup_z_r_invalid_1_3800_05203800() {
    // Encoding: 0x05203800
    // Test DUP_Z.R__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rn=0, Zd=0
    let encoding: u32 = 0x05203800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.R__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_dup_z_r_reg_write_0_05203800() {
    // Test DUP_Z.R__ register write: SimdFromField("d")
    // Encoding: 0x05203800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05203800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: DUP_Z.R__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_dup_z_r_sp_rn_05203be0() {
    // Test DUP_Z.R__ with Rn = SP (31)
    // Encoding: 0x05203BE0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05203BE0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQADD_Z.ZZ__ Tests
// ============================================================================

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqadd_z_zz_field_size_0_min_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqadd_z_zz_field_size_1_poweroftwo_1400_04601400() {
    // Encoding: 0x04601400
    // Test UQADD_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Zd=0, Zn=0
    let encoding: u32 = 0x04601400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqadd_z_zz_field_size_2_poweroftwo_1400_04a01400() {
    // Encoding: 0x04A01400
    // Test UQADD_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x04A01400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqadd_z_zz_field_size_3_max_1400_04e01400() {
    // Encoding: 0x04E01400
    // Test UQADD_Z.ZZ__ field size = 3 (Max)
    // Fields: Zn=0, Zm=0, Zd=0, size=3
    let encoding: u32 = 0x04E01400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uqadd_z_zz_field_zm_0_min_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uqadd_z_zz_field_zm_1_poweroftwo_1400_04211400() {
    // Encoding: 0x04211400
    // Test UQADD_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=1, Zd=0, size=0
    let encoding: u32 = 0x04211400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uqadd_z_zz_field_zm_30_poweroftwominusone_1400_043e1400() {
    // Encoding: 0x043E1400
    // Test UQADD_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=0, size=0, Zm=30
    let encoding: u32 = 0x043E1400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uqadd_z_zz_field_zm_31_max_1400_043f1400() {
    // Encoding: 0x043F1400
    // Test UQADD_Z.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zn=0, Zd=0, Zm=31
    let encoding: u32 = 0x043F1400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uqadd_z_zz_field_zn_0_min_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uqadd_z_zz_field_zn_1_poweroftwo_1400_04201420() {
    // Encoding: 0x04201420
    // Test UQADD_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zn=1, Zd=0
    let encoding: u32 = 0x04201420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uqadd_z_zz_field_zn_30_poweroftwominusone_1400_042017c0() {
    // Encoding: 0x042017C0
    // Test UQADD_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=0, Zn=30, Zm=0
    let encoding: u32 = 0x042017C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uqadd_z_zz_field_zn_31_max_1400_042017e0() {
    // Encoding: 0x042017E0
    // Test UQADD_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x042017E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uqadd_z_zz_field_zd_0_min_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uqadd_z_zz_field_zd_1_poweroftwo_1400_04201401() {
    // Encoding: 0x04201401
    // Test UQADD_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, size=0, Zd=1
    let encoding: u32 = 0x04201401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uqadd_z_zz_field_zd_30_poweroftwominusone_1400_0420141e() {
    // Encoding: 0x0420141E
    // Test UQADD_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zm=0, size=0, Zd=30
    let encoding: u32 = 0x0420141E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uqadd_z_zz_field_zd_31_max_1400_0420141f() {
    // Encoding: 0x0420141F
    // Test UQADD_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zn=0, size=0, Zd=31
    let encoding: u32 = 0x0420141F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqadd_z_zz_combo_0_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqadd_z_zz_special_size_0_size_variant_0_5120_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqadd_z_zz_special_size_1_size_variant_1_5120_04601400() {
    // Encoding: 0x04601400
    // Test UQADD_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zn=0, size=1, Zd=0
    let encoding: u32 = 0x04601400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqadd_z_zz_special_size_2_size_variant_2_5120_04a01400() {
    // Encoding: 0x04A01400
    // Test UQADD_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04A01400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqadd_z_zz_special_size_3_size_variant_3_5120_04e01400() {
    // Encoding: 0x04E01400
    // Test UQADD_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, size=3, Zd=0, Zn=0
    let encoding: u32 = 0x04E01400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqadd_z_zz_invalid_0_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Zm=0, Zn=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqadd_z_zz_invalid_1_1400_04201400() {
    // Encoding: 0x04201400
    // Test UQADD_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x04201400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQADD_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uqadd_z_zz_reg_write_0_04201400() {
    // Test UQADD_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x04201400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04201400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSRR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsrr_z_p_zz_field_size_0_min_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsrr_z_p_zz_field_size_1_poweroftwo_8000_04558000() {
    // Encoding: 0x04558000
    // Test LSRR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04558000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsrr_z_p_zz_field_size_2_poweroftwo_8000_04958000() {
    // Encoding: 0x04958000
    // Test LSRR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, size=2
    let encoding: u32 = 0x04958000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsrr_z_p_zz_field_size_3_max_8000_04d58000() {
    // Encoding: 0x04D58000
    // Test LSRR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04D58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsrr_z_p_zz_field_pg_0_min_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsrr_z_p_zz_field_pg_1_poweroftwo_8000_04158400() {
    // Encoding: 0x04158400
    // Test LSRR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=1, Zdn=0
    let encoding: u32 = 0x04158400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsrr_z_p_zz_field_zm_0_min_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsrr_z_p_zz_field_zm_1_poweroftwo_8000_04158020() {
    // Encoding: 0x04158020
    // Test LSRR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x04158020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsrr_z_p_zz_field_zm_30_poweroftwominusone_8000_041583c0() {
    // Encoding: 0x041583C0
    // Test LSRR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x041583C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsrr_z_p_zz_field_zm_31_max_8000_041583e0() {
    // Encoding: 0x041583E0
    // Test LSRR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x041583E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsrr_z_p_zz_field_zdn_0_min_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsrr_z_p_zz_field_zdn_1_poweroftwo_8000_04158001() {
    // Encoding: 0x04158001
    // Test LSRR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zdn=1, Zm=0
    let encoding: u32 = 0x04158001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsrr_z_p_zz_field_zdn_15_poweroftwominusone_8000_0415800f() {
    // Encoding: 0x0415800F
    // Test LSRR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x0415800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsrr_z_p_zz_field_zdn_31_max_8000_0415801f() {
    // Encoding: 0x0415801F
    // Test LSRR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zdn=31, Zm=0, Pg=0
    let encoding: u32 = 0x0415801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsrr_z_p_zz_combo_0_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsrr_z_p_zz_special_size_0_size_variant_0_32768_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsrr_z_p_zz_special_size_1_size_variant_1_32768_04558000() {
    // Encoding: 0x04558000
    // Test LSRR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04558000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsrr_z_p_zz_special_size_2_size_variant_2_32768_04958000() {
    // Encoding: 0x04958000
    // Test LSRR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04958000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsrr_z_p_zz_special_size_3_size_variant_3_32768_04d58000() {
    // Encoding: 0x04D58000
    // Test LSRR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zm=0, Zdn=0
    let encoding: u32 = 0x04D58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsrr_z_p_zz_invalid_0_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsrr_z_p_zz_invalid_1_8000_04158000() {
    // Encoding: 0x04158000
    // Test LSRR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04158000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSRR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsrr_z_p_zz_reg_write_0_04158000() {
    // Test LSRR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04158000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04158000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SDOT_Z.ZZZ__ Tests
// ============================================================================

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sdot_z_zzz_field_size_0_min_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ field size = 0 (Min)
    // Fields: Zda=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sdot_z_zzz_field_size_1_poweroftwo_0_44400000() {
    // Encoding: 0x44400000
    // Test SDOT_Z.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x44400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sdot_z_zzz_field_size_2_poweroftwo_0_44800000() {
    // Encoding: 0x44800000
    // Test SDOT_Z.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zda=0, size=2, Zn=0, Zm=0
    let encoding: u32 = 0x44800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sdot_z_zzz_field_size_3_max_0_44c00000() {
    // Encoding: 0x44C00000
    // Test SDOT_Z.ZZZ__ field size = 3 (Max)
    // Fields: Zda=0, Zm=0, size=3, Zn=0
    let encoding: u32 = 0x44C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdot_z_zzz_field_zm_0_min_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdot_z_zzz_field_zm_1_poweroftwo_0_44010000() {
    // Encoding: 0x44010000
    // Test SDOT_Z.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zda=0, size=0, Zn=0
    let encoding: u32 = 0x44010000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sdot_z_zzz_field_zm_30_poweroftwominusone_0_441e0000() {
    // Encoding: 0x441E0000
    // Test SDOT_Z.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zda=0, size=0, Zn=0
    let encoding: u32 = 0x441E0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sdot_z_zzz_field_zm_31_max_0_441f0000() {
    // Encoding: 0x441F0000
    // Test SDOT_Z.ZZZ__ field Zm = 31 (Max)
    // Fields: Zda=0, size=0, Zn=0, Zm=31
    let encoding: u32 = 0x441F0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdot_z_zzz_field_zn_0_min_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, Zn=0, size=0, Zda=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdot_z_zzz_field_zn_1_poweroftwo_0_44000020() {
    // Encoding: 0x44000020
    // Test SDOT_Z.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zda=0, size=0, Zn=1
    let encoding: u32 = 0x44000020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sdot_z_zzz_field_zn_30_poweroftwominusone_0_440003c0() {
    // Encoding: 0x440003C0
    // Test SDOT_Z.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Zm=0, Zda=0
    let encoding: u32 = 0x440003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sdot_z_zzz_field_zn_31_max_0_440003e0() {
    // Encoding: 0x440003E0
    // Test SDOT_Z.ZZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zm=0, Zda=0, Zn=31
    let encoding: u32 = 0x440003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdot_z_zzz_field_zda_0_min_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ field Zda = 0 (Min)
    // Fields: Zm=0, Zda=0, size=0, Zn=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sdot_z_zzz_field_zda_1_poweroftwo_0_44000001() {
    // Encoding: 0x44000001
    // Test SDOT_Z.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, size=0, Zda=1
    let encoding: u32 = 0x44000001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sdot_z_zzz_field_zda_15_poweroftwominusone_0_4400000f() {
    // Encoding: 0x4400000F
    // Test SDOT_Z.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zn=0, Zda=15
    let encoding: u32 = 0x4400000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sdot_z_zzz_field_zda_31_max_0_4400001f() {
    // Encoding: 0x4400001F
    // Test SDOT_Z.ZZZ__ field Zda = 31 (Max)
    // Fields: size=0, Zm=0, Zda=31, Zn=0
    let encoding: u32 = 0x4400001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sdot_z_zzz_combo_0_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ field combination: size=0, Zm=0, Zn=0, Zda=0
    // Fields: size=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sdot_z_zzz_special_size_0_size_variant_0_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, size=0, Zda=0, Zn=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sdot_z_zzz_special_size_1_size_variant_1_0_44400000() {
    // Encoding: 0x44400000
    // Test SDOT_Z.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zn=0, Zda=0, size=1
    let encoding: u32 = 0x44400000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sdot_z_zzz_special_size_2_size_variant_2_0_44800000() {
    // Encoding: 0x44800000
    // Test SDOT_Z.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44800000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sdot_z_zzz_special_size_3_size_variant_3_0_44c00000() {
    // Encoding: 0x44C00000
    // Test SDOT_Z.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zda=0, Zm=0, size=3, Zn=0
    let encoding: u32 = 0x44C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzz_invalid_0_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zda=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzz_invalid_1_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([Zero, Either]) }" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzz_invalid_2_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }
    // Fields: Zn=0, Zda=0, Zm=0, size=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzz_invalid_3_0_44000000() {
    // Encoding: 0x44000000
    // Test SDOT_Z.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zm=0, size=0, Zda=0
    let encoding: u32 = 0x44000000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_sdot_z_zzz_reg_write_0_44000000() {
    // Test SDOT_Z.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x44000000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x44000000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UADDV_R.P.Z__ Tests
// ============================================================================

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uaddv_r_p_z_field_size_0_min_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uaddv_r_p_z_field_size_1_poweroftwo_2000_04412000() {
    // Encoding: 0x04412000
    // Test UADDV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Pg=0, Vd=0
    let encoding: u32 = 0x04412000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uaddv_r_p_z_field_size_2_poweroftwo_2000_04812000() {
    // Encoding: 0x04812000
    // Test UADDV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vd=0, size=2, Zn=0, Pg=0
    let encoding: u32 = 0x04812000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uaddv_r_p_z_field_size_3_max_2000_04c12000() {
    // Encoding: 0x04C12000
    // Test UADDV_R.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Pg=0, Vd=0
    let encoding: u32 = 0x04C12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uaddv_r_p_z_field_pg_0_min_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uaddv_r_p_z_field_pg_1_poweroftwo_2000_04012400() {
    // Encoding: 0x04012400
    // Test UADDV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zn=0, Vd=0
    let encoding: u32 = 0x04012400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uaddv_r_p_z_field_zn_0_min_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uaddv_r_p_z_field_zn_1_poweroftwo_2000_04012020() {
    // Encoding: 0x04012020
    // Test UADDV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Vd=0, Zn=1, Pg=0
    let encoding: u32 = 0x04012020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uaddv_r_p_z_field_zn_30_poweroftwominusone_2000_040123c0() {
    // Encoding: 0x040123C0
    // Test UADDV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=0, Zn=30, size=0, Pg=0
    let encoding: u32 = 0x040123C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uaddv_r_p_z_field_zn_31_max_2000_040123e0() {
    // Encoding: 0x040123E0
    // Test UADDV_R.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Pg=0, Vd=0
    let encoding: u32 = 0x040123E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uaddv_r_p_z_field_vd_0_min_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uaddv_r_p_z_field_vd_1_poweroftwo_2000_04012001() {
    // Encoding: 0x04012001
    // Test UADDV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Vd=1, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x04012001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uaddv_r_p_z_field_vd_30_poweroftwominusone_2000_0401201e() {
    // Encoding: 0x0401201E
    // Test UADDV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Vd=30, Zn=0
    let encoding: u32 = 0x0401201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uaddv_r_p_z_field_vd_31_max_2000_0401201f() {
    // Encoding: 0x0401201F
    // Test UADDV_R.P.Z__ field Vd = 31 (Max)
    // Fields: size=0, Zn=0, Pg=0, Vd=31
    let encoding: u32 = 0x0401201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uaddv_r_p_z_combo_0_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uaddv_r_p_z_special_size_0_size_variant_0_8192_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uaddv_r_p_z_special_size_1_size_variant_1_8192_04412000() {
    // Encoding: 0x04412000
    // Test UADDV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Vd=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x04412000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uaddv_r_p_z_special_size_2_size_variant_2_8192_04812000() {
    // Encoding: 0x04812000
    // Test UADDV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Vd=0, Zn=0, size=2, Pg=0
    let encoding: u32 = 0x04812000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uaddv_r_p_z_special_size_3_size_variant_3_8192_04c12000() {
    // Encoding: 0x04C12000
    // Test UADDV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Vd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x04C12000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uaddv_r_p_z_invalid_0_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uaddv_r_p_z_invalid_1_2000_04012000() {
    // Encoding: 0x04012000
    // Test UADDV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04012000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UADDV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uaddv_r_p_z_reg_write_0_04012000() {
    // Test UADDV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04012000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04012000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INSR_Z.V__ Tests
// ============================================================================

/// Provenance: INSR_Z.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_insr_z_v_field_size_0_min_3800_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ field size = 0 (Min)
    // Fields: Vm=0, Zdn=0, size=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_insr_z_v_field_size_1_poweroftwo_3800_05743800() {
    // Encoding: 0x05743800
    // Test INSR_Z.V__ field size = 1 (PowerOfTwo)
    // Fields: Vm=0, Zdn=0, size=1
    let encoding: u32 = 0x05743800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_insr_z_v_field_size_2_poweroftwo_3800_05b43800() {
    // Encoding: 0x05B43800
    // Test INSR_Z.V__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, Vm=0
    let encoding: u32 = 0x05B43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_insr_z_v_field_size_3_max_3800_05f43800() {
    // Encoding: 0x05F43800
    // Test INSR_Z.V__ field size = 3 (Max)
    // Fields: size=3, Vm=0, Zdn=0
    let encoding: u32 = 0x05F43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Vm 5 +: 5`
/// Requirement: FieldBoundary { field: "Vm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_insr_z_v_field_vm_0_min_3800_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ field Vm = 0 (Min)
    // Fields: Zdn=0, Vm=0, size=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Vm 5 +: 5`
/// Requirement: FieldBoundary { field: "Vm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_insr_z_v_field_vm_1_poweroftwo_3800_05343820() {
    // Encoding: 0x05343820
    // Test INSR_Z.V__ field Vm = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Vm=1
    let encoding: u32 = 0x05343820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Vm 5 +: 5`
/// Requirement: FieldBoundary { field: "Vm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_insr_z_v_field_vm_30_poweroftwominusone_3800_05343bc0() {
    // Encoding: 0x05343BC0
    // Test INSR_Z.V__ field Vm = 30 (PowerOfTwoMinusOne)
    // Fields: Vm=30, Zdn=0, size=0
    let encoding: u32 = 0x05343BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Vm 5 +: 5`
/// Requirement: FieldBoundary { field: "Vm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_insr_z_v_field_vm_31_max_3800_05343be0() {
    // Encoding: 0x05343BE0
    // Test INSR_Z.V__ field Vm = 31 (Max)
    // Fields: size=0, Zdn=0, Vm=31
    let encoding: u32 = 0x05343BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_insr_z_v_field_zdn_0_min_3800_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, Vm=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_insr_z_v_field_zdn_1_poweroftwo_3800_05343801() {
    // Encoding: 0x05343801
    // Test INSR_Z.V__ field Zdn = 1 (PowerOfTwo)
    // Fields: Vm=0, size=0, Zdn=1
    let encoding: u32 = 0x05343801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_insr_z_v_field_zdn_15_poweroftwominusone_3800_0534380f() {
    // Encoding: 0x0534380F
    // Test INSR_Z.V__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Vm=0, Zdn=15
    let encoding: u32 = 0x0534380F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_insr_z_v_field_zdn_31_max_3800_0534381f() {
    // Encoding: 0x0534381F
    // Test INSR_Z.V__ field Zdn = 31 (Max)
    // Fields: Zdn=31, size=0, Vm=0
    let encoding: u32 = 0x0534381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_insr_z_v_combo_0_3800_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ field combination: size=0, Vm=0, Zdn=0
    // Fields: Vm=0, size=0, Zdn=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_insr_z_v_special_size_0_size_variant_0_14336_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ special value size = 0 (Size variant 0)
    // Fields: Vm=0, Zdn=0, size=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_insr_z_v_special_size_1_size_variant_1_14336_05743800() {
    // Encoding: 0x05743800
    // Test INSR_Z.V__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, size=1, Vm=0
    let encoding: u32 = 0x05743800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_insr_z_v_special_size_2_size_variant_2_14336_05b43800() {
    // Encoding: 0x05B43800
    // Test INSR_Z.V__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Vm=0
    let encoding: u32 = 0x05B43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_insr_z_v_special_size_3_size_variant_3_14336_05f43800() {
    // Encoding: 0x05F43800
    // Test INSR_Z.V__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Vm=0
    let encoding: u32 = 0x05F43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_insr_z_v_invalid_0_3800_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, Vm=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_insr_z_v_invalid_1_3800_05343800() {
    // Encoding: 0x05343800
    // Test INSR_Z.V__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Vm=0, size=0
    let encoding: u32 = 0x05343800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INSR_Z.V__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_insr_z_v_reg_write_0_05343800() {
    // Test INSR_Z.V__ register write: SimdFromField("dn")
    // Encoding: 0x05343800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05343800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ASR_Z.P.ZW__ Tests
// ============================================================================

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_asr_z_p_zw_field_size_0_min_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ field size = 0 (Min)
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_asr_z_p_zw_field_size_1_poweroftwo_8000_04588000() {
    // Encoding: 0x04588000
    // Test ASR_Z.P.ZW__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zm=0, Zdn=0
    let encoding: u32 = 0x04588000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_asr_z_p_zw_field_size_2_poweroftwo_8000_04988000() {
    // Encoding: 0x04988000
    // Test ASR_Z.P.ZW__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, Zm=0, size=2
    let encoding: u32 = 0x04988000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_asr_z_p_zw_field_size_3_max_8000_04d88000() {
    // Encoding: 0x04D88000
    // Test ASR_Z.P.ZW__ field size = 3 (Max)
    // Fields: Zdn=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x04D88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_asr_z_p_zw_field_pg_0_min_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ field Pg = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_asr_z_p_zw_field_pg_1_poweroftwo_8000_04188400() {
    // Encoding: 0x04188400
    // Test ASR_Z.P.ZW__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zdn=0, Zm=0
    let encoding: u32 = 0x04188400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_p_zw_field_zm_0_min_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ field Zm = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_p_zw_field_zm_1_poweroftwo_8000_04188020() {
    // Encoding: 0x04188020
    // Test ASR_Z.P.ZW__ field Zm = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=1, size=0, Pg=0
    let encoding: u32 = 0x04188020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_p_zw_field_zm_30_poweroftwominusone_8000_041883c0() {
    // Encoding: 0x041883C0
    // Test ASR_Z.P.ZW__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, size=0, Zdn=0
    let encoding: u32 = 0x041883C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_p_zw_field_zm_31_max_8000_041883e0() {
    // Encoding: 0x041883E0
    // Test ASR_Z.P.ZW__ field Zm = 31 (Max)
    // Fields: Zdn=0, size=0, Pg=0, Zm=31
    let encoding: u32 = 0x041883E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_p_zw_field_zdn_0_min_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ field Zdn = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_p_zw_field_zdn_1_poweroftwo_8000_04188001() {
    // Encoding: 0x04188001
    // Test ASR_Z.P.ZW__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, size=0, Zdn=1
    let encoding: u32 = 0x04188001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_asr_z_p_zw_field_zdn_15_poweroftwominusone_8000_0418800f() {
    // Encoding: 0x0418800F
    // Test ASR_Z.P.ZW__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zdn=15, Zm=0
    let encoding: u32 = 0x0418800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_asr_z_p_zw_field_zdn_31_max_8000_0418801f() {
    // Encoding: 0x0418801F
    // Test ASR_Z.P.ZW__ field Zdn = 31 (Max)
    // Fields: Zdn=31, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x0418801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_asr_z_p_zw_combo_0_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_asr_z_p_zw_special_size_0_size_variant_0_32768_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_asr_z_p_zw_special_size_1_size_variant_1_32768_04588000() {
    // Encoding: 0x04588000
    // Test ASR_Z.P.ZW__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Zm=0, size=1, Pg=0
    let encoding: u32 = 0x04588000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_asr_z_p_zw_special_size_2_size_variant_2_32768_04988000() {
    // Encoding: 0x04988000
    // Test ASR_Z.P.ZW__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04988000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_asr_z_p_zw_special_size_3_size_variant_3_32768_04d88000() {
    // Encoding: 0x04D88000
    // Test ASR_Z.P.ZW__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04D88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zw_invalid_0_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zw_invalid_1_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zw_invalid_2_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zw_invalid_3_8000_04188000() {
    // Encoding: 0x04188000
    // Test ASR_Z.P.ZW__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04188000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZW__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_asr_z_p_zw_reg_write_0_04188000() {
    // Test ASR_Z.P.ZW__ register write: SimdFromField("dn")
    // Encoding: 0x04188000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04188000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ZIP2_Z.ZZ__ Tests
// ============================================================================

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_zip2_z_zz_field_size_0_min_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_zip2_z_zz_field_size_1_poweroftwo_6400_05606400() {
    // Encoding: 0x05606400
    // Test ZIP2_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, Zd=0, size=1
    let encoding: u32 = 0x05606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_zip2_z_zz_field_size_2_poweroftwo_6400_05a06400() {
    // Encoding: 0x05A06400
    // Test ZIP2_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x05A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_zip2_z_zz_field_size_3_max_6400_05e06400() {
    // Encoding: 0x05E06400
    // Test ZIP2_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x05E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_zip2_z_zz_field_zm_0_min_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_zip2_z_zz_field_zm_1_poweroftwo_6400_05216400() {
    // Encoding: 0x05216400
    // Test ZIP2_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=0, Zm=1
    let encoding: u32 = 0x05216400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_zip2_z_zz_field_zm_30_poweroftwominusone_6400_053e6400() {
    // Encoding: 0x053E6400
    // Test ZIP2_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x053E6400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_zip2_z_zz_field_zm_31_max_6400_053f6400() {
    // Encoding: 0x053F6400
    // Test ZIP2_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, Zd=0, size=0, Zm=31
    let encoding: u32 = 0x053F6400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_zip2_z_zz_field_zn_0_min_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_zip2_z_zz_field_zn_1_poweroftwo_6400_05206420() {
    // Encoding: 0x05206420
    // Test ZIP2_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zm=0, Zd=0
    let encoding: u32 = 0x05206420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_zip2_z_zz_field_zn_30_poweroftwominusone_6400_052067c0() {
    // Encoding: 0x052067C0
    // Test ZIP2_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zd=0, size=0, Zn=30
    let encoding: u32 = 0x052067C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_zip2_z_zz_field_zn_31_max_6400_052067e0() {
    // Encoding: 0x052067E0
    // Test ZIP2_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Zd=0, size=0, Zn=31
    let encoding: u32 = 0x052067E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_zip2_z_zz_field_zd_0_min_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_zip2_z_zz_field_zd_1_poweroftwo_6400_05206401() {
    // Encoding: 0x05206401
    // Test ZIP2_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1, Zm=0
    let encoding: u32 = 0x05206401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_zip2_z_zz_field_zd_30_poweroftwominusone_6400_0520641e() {
    // Encoding: 0x0520641E
    // Test ZIP2_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, size=0, Zd=30
    let encoding: u32 = 0x0520641E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_zip2_z_zz_field_zd_31_max_6400_0520641f() {
    // Encoding: 0x0520641F
    // Test ZIP2_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zn=0, size=0, Zd=31
    let encoding: u32 = 0x0520641F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_zip2_z_zz_combo_0_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_zip2_z_zz_special_size_0_size_variant_0_25600_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_zip2_z_zz_special_size_1_size_variant_1_25600_05606400() {
    // Encoding: 0x05606400
    // Test ZIP2_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x05606400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_zip2_z_zz_special_size_2_size_variant_2_25600_05a06400() {
    // Encoding: 0x05A06400
    // Test ZIP2_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x05A06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_zip2_z_zz_special_size_3_size_variant_3_25600_05e06400() {
    // Encoding: 0x05E06400
    // Test ZIP2_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zm=0, size=3, Zd=0
    let encoding: u32 = 0x05E06400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_zip2_z_zz_invalid_0_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_zip2_z_zz_invalid_1_6400_05206400() {
    // Encoding: 0x05206400
    // Test ZIP2_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x05206400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_zip1_z_zz_field_size_0_min_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_zip1_z_zz_field_size_1_poweroftwo_6000_05606000() {
    // Encoding: 0x05606000
    // Test ZIP1_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x05606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_zip1_z_zz_field_size_2_poweroftwo_6000_05a06000() {
    // Encoding: 0x05A06000
    // Test ZIP1_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, Zn=0, size=2
    let encoding: u32 = 0x05A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_zip1_z_zz_field_size_3_max_6000_05e06000() {
    // Encoding: 0x05E06000
    // Test ZIP1_Z.ZZ__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Zm=0, Zn=0
    let encoding: u32 = 0x05E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_zip1_z_zz_field_zm_0_min_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_zip1_z_zz_field_zm_1_poweroftwo_6000_05216000() {
    // Encoding: 0x05216000
    // Test ZIP1_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=1, Zd=0
    let encoding: u32 = 0x05216000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_zip1_z_zz_field_zm_30_poweroftwominusone_6000_053e6000() {
    // Encoding: 0x053E6000
    // Test ZIP1_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Zd=0, Zn=0
    let encoding: u32 = 0x053E6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_zip1_z_zz_field_zm_31_max_6000_053f6000() {
    // Encoding: 0x053F6000
    // Test ZIP1_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, Zd=0, Zm=31, size=0
    let encoding: u32 = 0x053F6000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_zip1_z_zz_field_zn_0_min_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_zip1_z_zz_field_zn_1_poweroftwo_6000_05206020() {
    // Encoding: 0x05206020
    // Test ZIP1_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x05206020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_zip1_z_zz_field_zn_30_poweroftwominusone_6000_052063c0() {
    // Encoding: 0x052063C0
    // Test ZIP1_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zn=30, Zd=0
    let encoding: u32 = 0x052063C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_zip1_z_zz_field_zn_31_max_6000_052063e0() {
    // Encoding: 0x052063E0
    // Test ZIP1_Z.ZZ__ field Zn = 31 (Max)
    // Fields: size=0, Zm=0, Zn=31, Zd=0
    let encoding: u32 = 0x052063E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_zip1_z_zz_field_zd_0_min_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_zip1_z_zz_field_zd_1_poweroftwo_6000_05206001() {
    // Encoding: 0x05206001
    // Test ZIP1_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zm=0, Zd=1
    let encoding: u32 = 0x05206001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_zip1_z_zz_field_zd_30_poweroftwominusone_6000_0520601e() {
    // Encoding: 0x0520601E
    // Test ZIP1_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zn=0, Zd=30
    let encoding: u32 = 0x0520601E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_zip1_z_zz_field_zd_31_max_6000_0520601f() {
    // Encoding: 0x0520601F
    // Test ZIP1_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zn=0, size=0, Zd=31
    let encoding: u32 = 0x0520601F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_zip1_z_zz_combo_0_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_zip1_z_zz_special_size_0_size_variant_0_24576_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_zip1_z_zz_special_size_1_size_variant_1_24576_05606000() {
    // Encoding: 0x05606000
    // Test ZIP1_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zn=0, size=1, Zd=0
    let encoding: u32 = 0x05606000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_zip1_z_zz_special_size_2_size_variant_2_24576_05a06000() {
    // Encoding: 0x05A06000
    // Test ZIP1_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, size=2, Zm=0, Zn=0
    let encoding: u32 = 0x05A06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_zip1_z_zz_special_size_3_size_variant_3_24576_05e06000() {
    // Encoding: 0x05E06000
    // Test ZIP1_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Zn=0, Zd=0, size=3
    let encoding: u32 = 0x05E06000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_zip1_z_zz_invalid_0_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_zip1_z_zz_invalid_1_6000_05206000() {
    // Encoding: 0x05206000
    // Test ZIP1_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05206000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP2_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_zip2_z_zz_reg_write_0_05206400() {
    // Test ZIP2_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x05206400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05206400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ZIP1_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_zip1_z_zz_reg_write_0_05206000() {
    // Test ZIP1_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x05206000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05206000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQADD_Z.ZI__ Tests
// ============================================================================

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqadd_z_zi_field_size_0_min_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ field size = 0 (Min)
    // Fields: Zdn=0, imm8=0, sh=0, size=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqadd_z_zi_field_size_1_poweroftwo_c000_2564c000() {
    // Encoding: 0x2564C000
    // Test SQADD_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: sh=0, Zdn=0, size=1, imm8=0
    let encoding: u32 = 0x2564C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqadd_z_zi_field_size_2_poweroftwo_c000_25a4c000() {
    // Encoding: 0x25A4C000
    // Test SQADD_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: imm8=0, sh=0, Zdn=0, size=2
    let encoding: u32 = 0x25A4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqadd_z_zi_field_size_3_max_c000_25e4c000() {
    // Encoding: 0x25E4C000
    // Test SQADD_Z.ZI__ field size = 3 (Max)
    // Fields: size=3, sh=0, Zdn=0, imm8=0
    let encoding: u32 = 0x25E4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_sqadd_z_zi_field_sh_0_min_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ field sh = 0 (Min)
    // Fields: sh=0, Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_sqadd_z_zi_field_sh_1_max_c000_2524e000() {
    // Encoding: 0x2524E000
    // Test SQADD_Z.ZI__ field sh = 1 (Max)
    // Fields: imm8=0, sh=1, size=0, Zdn=0
    let encoding: u32 = 0x2524E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_sqadd_z_zi_field_imm8_0_zero_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: sh=0, size=0, Zdn=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_sqadd_z_zi_field_imm8_1_poweroftwo_c000_2524c020() {
    // Encoding: 0x2524C020
    // Test SQADD_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: size=0, imm8=1, sh=0, Zdn=0
    let encoding: u32 = 0x2524C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_sqadd_z_zi_field_imm8_3_poweroftwominusone_c000_2524c060() {
    // Encoding: 0x2524C060
    // Test SQADD_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: imm8=3, Zdn=0, sh=0, size=0
    let encoding: u32 = 0x2524C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_sqadd_z_zi_field_imm8_4_poweroftwo_c000_2524c080() {
    // Encoding: 0x2524C080
    // Test SQADD_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, sh=0, Zdn=0, imm8=4
    let encoding: u32 = 0x2524C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_sqadd_z_zi_field_imm8_7_poweroftwominusone_c000_2524c0e0() {
    // Encoding: 0x2524C0E0
    // Test SQADD_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: imm8=7, Zdn=0, sh=0, size=0
    let encoding: u32 = 0x2524C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_sqadd_z_zi_field_imm8_8_poweroftwo_c000_2524c100() {
    // Encoding: 0x2524C100
    // Test SQADD_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: imm8=8, sh=0, size=0, Zdn=0
    let encoding: u32 = 0x2524C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_sqadd_z_zi_field_imm8_15_poweroftwominusone_c000_2524c1e0() {
    // Encoding: 0x2524C1E0
    // Test SQADD_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=15, size=0, sh=0, Zdn=0
    let encoding: u32 = 0x2524C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_sqadd_z_zi_field_imm8_16_poweroftwo_c000_2524c200() {
    // Encoding: 0x2524C200
    // Test SQADD_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: size=0, imm8=16, sh=0, Zdn=0
    let encoding: u32 = 0x2524C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_sqadd_z_zi_field_imm8_31_poweroftwominusone_c000_2524c3e0() {
    // Encoding: 0x2524C3E0
    // Test SQADD_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=31, size=0, Zdn=0
    let encoding: u32 = 0x2524C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_sqadd_z_zi_field_imm8_32_poweroftwo_c000_2524c400() {
    // Encoding: 0x2524C400
    // Test SQADD_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: imm8=32, size=0, sh=0, Zdn=0
    let encoding: u32 = 0x2524C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_sqadd_z_zi_field_imm8_63_poweroftwominusone_c000_2524c7e0() {
    // Encoding: 0x2524C7E0
    // Test SQADD_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=63, Zdn=0, size=0
    let encoding: u32 = 0x2524C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_sqadd_z_zi_field_imm8_64_poweroftwo_c000_2524c800() {
    // Encoding: 0x2524C800
    // Test SQADD_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: imm8=64, sh=0, Zdn=0, size=0
    let encoding: u32 = 0x2524C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_sqadd_z_zi_field_imm8_127_poweroftwominusone_c000_2524cfe0() {
    // Encoding: 0x2524CFE0
    // Test SQADD_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, sh=0, imm8=127, size=0
    let encoding: u32 = 0x2524CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_sqadd_z_zi_field_imm8_128_poweroftwo_c000_2524d000() {
    // Encoding: 0x2524D000
    // Test SQADD_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: imm8=128, Zdn=0, size=0, sh=0
    let encoding: u32 = 0x2524D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_sqadd_z_zi_field_imm8_255_max_c000_2524dfe0() {
    // Encoding: 0x2524DFE0
    // Test SQADD_Z.ZI__ field imm8 = 255 (Max)
    // Fields: sh=0, imm8=255, size=0, Zdn=0
    let encoding: u32 = 0x2524DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sqadd_z_zi_field_zdn_0_min_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, sh=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sqadd_z_zi_field_zdn_1_poweroftwo_c000_2524c001() {
    // Encoding: 0x2524C001
    // Test SQADD_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, sh=0, imm8=0
    let encoding: u32 = 0x2524C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sqadd_z_zi_field_zdn_15_poweroftwominusone_c000_2524c00f() {
    // Encoding: 0x2524C00F
    // Test SQADD_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=0, Zdn=15, size=0
    let encoding: u32 = 0x2524C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sqadd_z_zi_field_zdn_31_max_c000_2524c01f() {
    // Encoding: 0x2524C01F
    // Test SQADD_Z.ZI__ field Zdn = 31 (Max)
    // Fields: sh=0, Zdn=31, imm8=0, size=0
    let encoding: u32 = 0x2524C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqadd_z_zi_combo_0_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ field combination: size=0, sh=0, imm8=0, Zdn=0
    // Fields: Zdn=0, size=0, sh=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqadd_z_zi_special_size_0_size_variant_0_49152_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, size=0, sh=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqadd_z_zi_special_size_1_size_variant_1_49152_2564c000() {
    // Encoding: 0x2564C000
    // Test SQADD_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zdn=0, sh=0, imm8=0
    let encoding: u32 = 0x2564C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqadd_z_zi_special_size_2_size_variant_2_49152_25a4c000() {
    // Encoding: 0x25A4C000
    // Test SQADD_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, sh=0, size=2, imm8=0
    let encoding: u32 = 0x25A4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqadd_z_zi_special_size_3_size_variant_3_49152_25e4c000() {
    // Encoding: 0x25E4C000
    // Test SQADD_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, sh=0, imm8=0, size=3
    let encoding: u32 = 0x25E4C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_sqadd_z_zi_special_sh_0_shift_type_lsl_49152_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ special value sh = 0 (Shift type LSL)
    // Fields: size=0, sh=0, Zdn=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_sqadd_z_zi_special_sh_1_shift_type_lsr_49152_2524e000() {
    // Encoding: 0x2524E000
    // Test SQADD_Z.ZI__ special value sh = 1 (Shift type LSR)
    // Fields: sh=1, size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2524E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_sqadd_z_zi_special_sh_2_shift_type_asr_49152_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ special value sh = 2 (Shift type ASR)
    // Fields: sh=2, size=0, Zdn=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_sqadd_z_zi_special_sh_3_shift_type_ror_49152_2524e000() {
    // Encoding: 0x2524E000
    // Test SQADD_Z.ZI__ special value sh = 3 (Shift type ROR)
    // Fields: sh=3, Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2524E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqadd_z_zi_invalid_0_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, imm8=0, sh=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqadd_z_zi_invalid_1_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, sh=0, size=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sh\" }), rhs: LitBits([false, false, true]) } }" }
/// triggers Undefined
#[test]
fn test_sqadd_z_zi_invalid_2_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }
    // Fields: Zdn=0, size=0, sh=0, imm8=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqadd_z_zi_invalid_3_c000_2524c000() {
    // Encoding: 0x2524C000
    // Test SQADD_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, imm8=0, Zdn=0, sh=0
    let encoding: u32 = 0x2524C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQADD_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sqadd_z_zi_reg_write_0_2524c000() {
    // Test SQADD_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x2524C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2524C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SXTB_Z.P.Z__ Tests
// ============================================================================

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sxtb_z_p_z_field_size_0_min_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sxtb_z_p_z_field_size_1_poweroftwo_a000_0450a000() {
    // Encoding: 0x0450A000
    // Test SXTB_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sxtb_z_p_z_field_size_2_poweroftwo_a000_0490a000() {
    // Encoding: 0x0490A000
    // Test SXTB_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, size=2, Zd=0
    let encoding: u32 = 0x0490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sxtb_z_p_z_field_size_3_max_a000_04d0a000() {
    // Encoding: 0x04D0A000
    // Test SXTB_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sxtb_z_p_z_field_pg_0_min_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sxtb_z_p_z_field_pg_1_poweroftwo_a000_0410a400() {
    // Encoding: 0x0410A400
    // Test SXTB_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Zd=0, size=0
    let encoding: u32 = 0x0410A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sxtb_z_p_z_field_zn_0_min_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sxtb_z_p_z_field_zn_1_poweroftwo_a000_0410a020() {
    // Encoding: 0x0410A020
    // Test SXTB_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, size=0, Zd=0
    let encoding: u32 = 0x0410A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sxtb_z_p_z_field_zn_30_poweroftwominusone_a000_0410a3c0() {
    // Encoding: 0x0410A3C0
    // Test SXTB_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=30, Zd=0
    let encoding: u32 = 0x0410A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sxtb_z_p_z_field_zn_31_max_a000_0410a3e0() {
    // Encoding: 0x0410A3E0
    // Test SXTB_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, size=0, Pg=0, Zn=31
    let encoding: u32 = 0x0410A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sxtb_z_p_z_field_zd_0_min_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sxtb_z_p_z_field_zd_1_poweroftwo_a000_0410a001() {
    // Encoding: 0x0410A001
    // Test SXTB_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=1, size=0
    let encoding: u32 = 0x0410A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sxtb_z_p_z_field_zd_30_poweroftwominusone_a000_0410a01e() {
    // Encoding: 0x0410A01E
    // Test SXTB_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=30, Zn=0, size=0
    let encoding: u32 = 0x0410A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sxtb_z_p_z_field_zd_31_max_a000_0410a01f() {
    // Encoding: 0x0410A01F
    // Test SXTB_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x0410A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sxtb_z_p_z_combo_0_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sxtb_z_p_z_special_size_0_size_variant_0_40960_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sxtb_z_p_z_special_size_1_size_variant_1_40960_0450a000() {
    // Encoding: 0x0450A000
    // Test SXTB_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Pg=0, Zd=0, size=1
    let encoding: u32 = 0x0450A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sxtb_z_p_z_special_size_2_size_variant_2_40960_0490a000() {
    // Encoding: 0x0490A000
    // Test SXTB_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x0490A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sxtb_z_p_z_special_size_3_size_variant_3_40960_04d0a000() {
    // Encoding: 0x04D0A000
    // Test SXTB_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zn=0, size=3, Zd=0
    let encoding: u32 = 0x04D0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sxtb_z_p_z_invalid_0_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sxtb_z_p_z_invalid_1_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_sxtb_z_p_z_invalid_2_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sxtb_z_p_z_invalid_3_a000_0410a000() {
    // Encoding: 0x0410A000
    // Test SXTB_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x0410A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sxth_z_p_z_field_size_0_min_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sxth_z_p_z_field_size_1_poweroftwo_a000_0452a000() {
    // Encoding: 0x0452A000
    // Test SXTH_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, size=1, Zn=0
    let encoding: u32 = 0x0452A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sxth_z_p_z_field_size_2_poweroftwo_a000_0492a000() {
    // Encoding: 0x0492A000
    // Test SXTH_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Zd=0, Pg=0
    let encoding: u32 = 0x0492A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sxth_z_p_z_field_size_3_max_a000_04d2a000() {
    // Encoding: 0x04D2A000
    // Test SXTH_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04D2A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sxth_z_p_z_field_pg_0_min_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sxth_z_p_z_field_pg_1_poweroftwo_a000_0412a400() {
    // Encoding: 0x0412A400
    // Test SXTH_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0412A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sxth_z_p_z_field_zn_0_min_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sxth_z_p_z_field_zn_1_poweroftwo_a000_0412a020() {
    // Encoding: 0x0412A020
    // Test SXTH_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x0412A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sxth_z_p_z_field_zn_30_poweroftwominusone_a000_0412a3c0() {
    // Encoding: 0x0412A3C0
    // Test SXTH_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0, Pg=0
    let encoding: u32 = 0x0412A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sxth_z_p_z_field_zn_31_max_a000_0412a3e0() {
    // Encoding: 0x0412A3E0
    // Test SXTH_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0, Pg=0
    let encoding: u32 = 0x0412A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sxth_z_p_z_field_zd_0_min_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sxth_z_p_z_field_zd_1_poweroftwo_a000_0412a001() {
    // Encoding: 0x0412A001
    // Test SXTH_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=0, Zd=1
    let encoding: u32 = 0x0412A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sxth_z_p_z_field_zd_30_poweroftwominusone_a000_0412a01e() {
    // Encoding: 0x0412A01E
    // Test SXTH_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Pg=0, size=0
    let encoding: u32 = 0x0412A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sxth_z_p_z_field_zd_31_max_a000_0412a01f() {
    // Encoding: 0x0412A01F
    // Test SXTH_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, size=0, Zd=31, Zn=0
    let encoding: u32 = 0x0412A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sxth_z_p_z_combo_0_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sxth_z_p_z_special_size_0_size_variant_0_40960_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sxth_z_p_z_special_size_1_size_variant_1_40960_0452a000() {
    // Encoding: 0x0452A000
    // Test SXTH_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x0452A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sxth_z_p_z_special_size_2_size_variant_2_40960_0492a000() {
    // Encoding: 0x0492A000
    // Test SXTH_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, Pg=0, size=2
    let encoding: u32 = 0x0492A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sxth_z_p_z_special_size_3_size_variant_3_40960_04d2a000() {
    // Encoding: 0x04D2A000
    // Test SXTH_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zn=0, Zd=0, size=3
    let encoding: u32 = 0x04D2A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sxth_z_p_z_invalid_0_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sxth_z_p_z_invalid_1_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([One, Either]) }" }
/// triggers Undefined
#[test]
fn test_sxth_z_p_z_invalid_2_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sxth_z_p_z_invalid_3_a000_0412a000() {
    // Encoding: 0x0412A000
    // Test SXTH_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x0412A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sxtw_z_p_z_field_size_0_min_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sxtw_z_p_z_field_size_1_poweroftwo_a000_0454a000() {
    // Encoding: 0x0454A000
    // Test SXTW_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0454A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sxtw_z_p_z_field_size_2_poweroftwo_a000_0494a000() {
    // Encoding: 0x0494A000
    // Test SXTW_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, size=2, Zn=0
    let encoding: u32 = 0x0494A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sxtw_z_p_z_field_size_3_max_a000_04d4a000() {
    // Encoding: 0x04D4A000
    // Test SXTW_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zd=0, Zn=0, size=3
    let encoding: u32 = 0x04D4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sxtw_z_p_z_field_pg_0_min_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sxtw_z_p_z_field_pg_1_poweroftwo_a000_0414a400() {
    // Encoding: 0x0414A400
    // Test SXTW_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0, size=0
    let encoding: u32 = 0x0414A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sxtw_z_p_z_field_zn_0_min_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sxtw_z_p_z_field_zn_1_poweroftwo_a000_0414a020() {
    // Encoding: 0x0414A020
    // Test SXTW_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Pg=0, Zd=0
    let encoding: u32 = 0x0414A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sxtw_z_p_z_field_zn_30_poweroftwominusone_a000_0414a3c0() {
    // Encoding: 0x0414A3C0
    // Test SXTW_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=30, Zd=0
    let encoding: u32 = 0x0414A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sxtw_z_p_z_field_zn_31_max_a000_0414a3e0() {
    // Encoding: 0x0414A3E0
    // Test SXTW_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, Zn=31, Zd=0, size=0
    let encoding: u32 = 0x0414A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sxtw_z_p_z_field_zd_0_min_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sxtw_z_p_z_field_zd_1_poweroftwo_a000_0414a001() {
    // Encoding: 0x0414A001
    // Test SXTW_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0414A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sxtw_z_p_z_field_zd_30_poweroftwominusone_a000_0414a01e() {
    // Encoding: 0x0414A01E
    // Test SXTW_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, size=0, Zd=30, Pg=0
    let encoding: u32 = 0x0414A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sxtw_z_p_z_field_zd_31_max_a000_0414a01f() {
    // Encoding: 0x0414A01F
    // Test SXTW_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, size=0, Zd=31, Zn=0
    let encoding: u32 = 0x0414A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sxtw_z_p_z_combo_0_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sxtw_z_p_z_special_size_0_size_variant_0_40960_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sxtw_z_p_z_special_size_1_size_variant_1_40960_0454a000() {
    // Encoding: 0x0454A000
    // Test SXTW_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0454A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sxtw_z_p_z_special_size_2_size_variant_2_40960_0494a000() {
    // Encoding: 0x0494A000
    // Test SXTW_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Pg=0, Zd=0
    let encoding: u32 = 0x0494A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sxtw_z_p_z_special_size_3_size_variant_3_40960_04d4a000() {
    // Encoding: 0x04D4A000
    // Test SXTW_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Pg=0, size=3, Zn=0
    let encoding: u32 = 0x04D4A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sxtw_z_p_z_invalid_0_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sxtw_z_p_z_invalid_1_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_sxtw_z_p_z_invalid_2_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sxtw_z_p_z_invalid_3_a000_0414a000() {
    // Encoding: 0x0414A000
    // Test SXTW_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0414A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SXTB_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sxtb_z_p_z_reg_write_0_0410a000() {
    // Test SXTB_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0410A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0410A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SXTH_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sxth_z_p_z_reg_write_0_0412a000() {
    // Test SXTH_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0412A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0412A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SXTW_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sxtw_z_p_z_reg_write_0_0414a000() {
    // Test SXTW_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0414A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0414A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMAX_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_smax_z_p_zz_field_size_0_min_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_smax_z_p_zz_field_size_1_poweroftwo_0_04480000() {
    // Encoding: 0x04480000
    // Test SMAX_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x04480000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_smax_z_p_zz_field_size_2_poweroftwo_0_04880000() {
    // Encoding: 0x04880000
    // Test SMAX_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04880000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_smax_z_p_zz_field_size_3_max_0_04c80000() {
    // Encoding: 0x04C80000
    // Test SMAX_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04C80000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_smax_z_p_zz_field_pg_0_min_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_smax_z_p_zz_field_pg_1_poweroftwo_0_04080400() {
    // Encoding: 0x04080400
    // Test SMAX_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=1, Zdn=0
    let encoding: u32 = 0x04080400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_smax_z_p_zz_field_zm_0_min_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_smax_z_p_zz_field_zm_1_poweroftwo_0_04080020() {
    // Encoding: 0x04080020
    // Test SMAX_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=0, Zm=1
    let encoding: u32 = 0x04080020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_smax_z_p_zz_field_zm_30_poweroftwominusone_0_040803c0() {
    // Encoding: 0x040803C0
    // Test SMAX_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=0, size=0, Zm=30
    let encoding: u32 = 0x040803C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_smax_z_p_zz_field_zm_31_max_0_040803e0() {
    // Encoding: 0x040803E0
    // Test SMAX_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zdn=0, Pg=0
    let encoding: u32 = 0x040803E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_smax_z_p_zz_field_zdn_0_min_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_smax_z_p_zz_field_zdn_1_poweroftwo_0_04080001() {
    // Encoding: 0x04080001
    // Test SMAX_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, Pg=0, Zm=0
    let encoding: u32 = 0x04080001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_smax_z_p_zz_field_zdn_15_poweroftwominusone_0_0408000f() {
    // Encoding: 0x0408000F
    // Test SMAX_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=15, Zm=0
    let encoding: u32 = 0x0408000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_smax_z_p_zz_field_zdn_31_max_0_0408001f() {
    // Encoding: 0x0408001F
    // Test SMAX_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zm=0, Zdn=31, size=0
    let encoding: u32 = 0x0408001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_smax_z_p_zz_combo_0_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_smax_z_p_zz_special_size_0_size_variant_0_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_smax_z_p_zz_special_size_1_size_variant_1_0_04480000() {
    // Encoding: 0x04480000
    // Test SMAX_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Zdn=0, size=1, Pg=0
    let encoding: u32 = 0x04480000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_smax_z_p_zz_special_size_2_size_variant_2_0_04880000() {
    // Encoding: 0x04880000
    // Test SMAX_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04880000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_smax_z_p_zz_special_size_3_size_variant_3_0_04c80000() {
    // Encoding: 0x04C80000
    // Test SMAX_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04C80000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_smax_z_p_zz_invalid_0_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_smax_z_p_zz_invalid_1_0_04080000() {
    // Encoding: 0x04080000
    // Test SMAX_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04080000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMAX_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_smax_z_p_zz_reg_write_0_04080000() {
    // Test SMAX_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04080000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04080000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DUP_Z.Zi__ Tests
// ============================================================================

/// Provenance: DUP_Z.Zi__
/// ASL: `field imm2 22 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_dup_z_zi_field_imm2_0_zero_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ field imm2 = 0 (Zero)
    // Fields: imm2=0, tsz=0, Zd=0, Zn=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field imm2 22 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_dup_z_zi_field_imm2_1_poweroftwo_2000_05602000() {
    // Encoding: 0x05602000
    // Test DUP_Z.Zi__ field imm2 = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, tsz=0, imm2=1
    let encoding: u32 = 0x05602000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field imm2 22 +: 2`
/// Requirement: FieldBoundary { field: "imm2", value: 3, boundary: Max }
/// maximum immediate (3)
#[test]
fn test_dup_z_zi_field_imm2_3_max_2000_05e02000() {
    // Encoding: 0x05E02000
    // Test DUP_Z.Zi__ field imm2 = 3 (Max)
    // Fields: tsz=0, Zd=0, imm2=3, Zn=0
    let encoding: u32 = 0x05E02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field tsz 16 +: 5`
/// Requirement: FieldBoundary { field: "tsz", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_dup_z_zi_field_tsz_0_min_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ field tsz = 0 (Min)
    // Fields: Zd=0, imm2=0, Zn=0, tsz=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field tsz 16 +: 5`
/// Requirement: FieldBoundary { field: "tsz", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_dup_z_zi_field_tsz_1_poweroftwo_2000_05212000() {
    // Encoding: 0x05212000
    // Test DUP_Z.Zi__ field tsz = 1 (PowerOfTwo)
    // Fields: imm2=0, Zd=0, tsz=1, Zn=0
    let encoding: u32 = 0x05212000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field tsz 16 +: 5`
/// Requirement: FieldBoundary { field: "tsz", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_dup_z_zi_field_tsz_15_poweroftwominusone_2000_052f2000() {
    // Encoding: 0x052F2000
    // Test DUP_Z.Zi__ field tsz = 15 (PowerOfTwoMinusOne)
    // Fields: tsz=15, Zd=0, imm2=0, Zn=0
    let encoding: u32 = 0x052F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field tsz 16 +: 5`
/// Requirement: FieldBoundary { field: "tsz", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_dup_z_zi_field_tsz_31_max_2000_053f2000() {
    // Encoding: 0x053F2000
    // Test DUP_Z.Zi__ field tsz = 31 (Max)
    // Fields: tsz=31, imm2=0, Zn=0, Zd=0
    let encoding: u32 = 0x053F2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_dup_z_zi_field_zn_0_min_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ field Zn = 0 (Min)
    // Fields: tsz=0, Zd=0, imm2=0, Zn=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_dup_z_zi_field_zn_1_poweroftwo_2000_05202020() {
    // Encoding: 0x05202020
    // Test DUP_Z.Zi__ field Zn = 1 (PowerOfTwo)
    // Fields: tsz=0, Zd=0, Zn=1, imm2=0
    let encoding: u32 = 0x05202020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_dup_z_zi_field_zn_30_poweroftwominusone_2000_052023c0() {
    // Encoding: 0x052023C0
    // Test DUP_Z.Zi__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm2=0, tsz=0, Zn=30, Zd=0
    let encoding: u32 = 0x052023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_dup_z_zi_field_zn_31_max_2000_052023e0() {
    // Encoding: 0x052023E0
    // Test DUP_Z.Zi__ field Zn = 31 (Max)
    // Fields: Zd=0, imm2=0, tsz=0, Zn=31
    let encoding: u32 = 0x052023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_dup_z_zi_field_zd_0_min_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ field Zd = 0 (Min)
    // Fields: Zn=0, tsz=0, imm2=0, Zd=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_dup_z_zi_field_zd_1_poweroftwo_2000_05202001() {
    // Encoding: 0x05202001
    // Test DUP_Z.Zi__ field Zd = 1 (PowerOfTwo)
    // Fields: imm2=0, tsz=0, Zn=0, Zd=1
    let encoding: u32 = 0x05202001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_dup_z_zi_field_zd_30_poweroftwominusone_2000_0520201e() {
    // Encoding: 0x0520201E
    // Test DUP_Z.Zi__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: imm2=0, tsz=0, Zn=0, Zd=30
    let encoding: u32 = 0x0520201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_dup_z_zi_field_zd_31_max_2000_0520201f() {
    // Encoding: 0x0520201F
    // Test DUP_Z.Zi__ field Zd = 31 (Max)
    // Fields: Zn=0, imm2=0, tsz=0, Zd=31
    let encoding: u32 = 0x0520201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm2=0 (immediate value 0)
#[test]
fn test_dup_z_zi_combo_0_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ field combination: imm2=0, tsz=0, Zn=0, Zd=0
    // Fields: Zd=0, imm2=0, tsz=0, Zn=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_dup_z_zi_invalid_0_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm2=0, Zn=0, tsz=0, Zd=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dup_z_zi_invalid_1_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, tsz=0, imm2=0, Zd=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dup_z_zi_invalid_2_2000_05202000() {
    // Encoding: 0x05202000
    // Test DUP_Z.Zi__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, tsz=0, Zd=0, imm2=0
    let encoding: u32 = 0x05202000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.Zi__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_dup_z_zi_reg_write_0_05202000() {
    // Test DUP_Z.Zi__ register write: SimdFromField("d")
    // Encoding: 0x05202000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05202000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// NEG_Z.P.Z__ Tests
// ============================================================================

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_neg_z_p_z_field_size_0_min_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_neg_z_p_z_field_size_1_poweroftwo_a000_0457a000() {
    // Encoding: 0x0457A000
    // Test NEG_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=0, size=1
    let encoding: u32 = 0x0457A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_neg_z_p_z_field_size_2_poweroftwo_a000_0497a000() {
    // Encoding: 0x0497A000
    // Test NEG_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x0497A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_neg_z_p_z_field_size_3_max_a000_04d7a000() {
    // Encoding: 0x04D7A000
    // Test NEG_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x04D7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_neg_z_p_z_field_pg_0_min_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_neg_z_p_z_field_pg_1_poweroftwo_a000_0417a400() {
    // Encoding: 0x0417A400
    // Test NEG_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0417A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_neg_z_p_z_field_zn_0_min_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_neg_z_p_z_field_zn_1_poweroftwo_a000_0417a020() {
    // Encoding: 0x0417A020
    // Test NEG_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, size=0, Zn=1
    let encoding: u32 = 0x0417A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_neg_z_p_z_field_zn_30_poweroftwominusone_a000_0417a3c0() {
    // Encoding: 0x0417A3C0
    // Test NEG_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=30, Zd=0
    let encoding: u32 = 0x0417A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_neg_z_p_z_field_zn_31_max_a000_0417a3e0() {
    // Encoding: 0x0417A3E0
    // Test NEG_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, Pg=0, size=0
    let encoding: u32 = 0x0417A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_neg_z_p_z_field_zd_0_min_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ field Zd = 0 (Min)
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_neg_z_p_z_field_zd_1_poweroftwo_a000_0417a001() {
    // Encoding: 0x0417A001
    // Test NEG_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Pg=0, Zd=1
    let encoding: u32 = 0x0417A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_neg_z_p_z_field_zd_30_poweroftwominusone_a000_0417a01e() {
    // Encoding: 0x0417A01E
    // Test NEG_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Zd=30, Pg=0
    let encoding: u32 = 0x0417A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_neg_z_p_z_field_zd_31_max_a000_0417a01f() {
    // Encoding: 0x0417A01F
    // Test NEG_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Zd=31
    let encoding: u32 = 0x0417A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_neg_z_p_z_combo_0_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_neg_z_p_z_special_size_0_size_variant_0_40960_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_neg_z_p_z_special_size_1_size_variant_1_40960_0457a000() {
    // Encoding: 0x0457A000
    // Test NEG_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Pg=0, Zd=0, size=1
    let encoding: u32 = 0x0457A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_neg_z_p_z_special_size_2_size_variant_2_40960_0497a000() {
    // Encoding: 0x0497A000
    // Test NEG_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, size=2, Pg=0
    let encoding: u32 = 0x0497A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_neg_z_p_z_special_size_3_size_variant_3_40960_04d7a000() {
    // Encoding: 0x04D7A000
    // Test NEG_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Pg=0, size=3, Zd=0
    let encoding: u32 = 0x04D7A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_neg_z_p_z_invalid_0_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_neg_z_p_z_invalid_1_a000_0417a000() {
    // Encoding: 0x0417A000
    // Test NEG_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x0417A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: NEG_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_neg_z_p_z_reg_write_0_0417a000() {
    // Test NEG_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0417A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0417A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMAXV_R.P.Z__ Tests
// ============================================================================

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umaxv_r_p_z_field_size_0_min_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umaxv_r_p_z_field_size_1_poweroftwo_2000_04492000() {
    // Encoding: 0x04492000
    // Test UMAXV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04492000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umaxv_r_p_z_field_size_2_poweroftwo_2000_04892000() {
    // Encoding: 0x04892000
    // Test UMAXV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Pg=0, Vd=0
    let encoding: u32 = 0x04892000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umaxv_r_p_z_field_size_3_max_2000_04c92000() {
    // Encoding: 0x04C92000
    // Test UMAXV_R.P.Z__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04C92000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_umaxv_r_p_z_field_pg_0_min_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Vd=0, Zn=0, size=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_umaxv_r_p_z_field_pg_1_poweroftwo_2000_04092400() {
    // Encoding: 0x04092400
    // Test UMAXV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x04092400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_umaxv_r_p_z_field_zn_0_min_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_umaxv_r_p_z_field_zn_1_poweroftwo_2000_04092020() {
    // Encoding: 0x04092020
    // Test UMAXV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x04092020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_umaxv_r_p_z_field_zn_30_poweroftwominusone_2000_040923c0() {
    // Encoding: 0x040923C0
    // Test UMAXV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vd=0, Zn=30, Pg=0
    let encoding: u32 = 0x040923C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_umaxv_r_p_z_field_zn_31_max_2000_040923e0() {
    // Encoding: 0x040923E0
    // Test UMAXV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x040923E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_umaxv_r_p_z_field_vd_0_min_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_umaxv_r_p_z_field_vd_1_poweroftwo_2000_04092001() {
    // Encoding: 0x04092001
    // Test UMAXV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, Vd=1, Zn=0, size=0
    let encoding: u32 = 0x04092001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_umaxv_r_p_z_field_vd_30_poweroftwominusone_2000_0409201e() {
    // Encoding: 0x0409201E
    // Test UMAXV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=30, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x0409201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_umaxv_r_p_z_field_vd_31_max_2000_0409201f() {
    // Encoding: 0x0409201F
    // Test UMAXV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Zn=0, size=0, Pg=0, Vd=31
    let encoding: u32 = 0x0409201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umaxv_r_p_z_combo_0_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umaxv_r_p_z_special_size_0_size_variant_0_8192_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umaxv_r_p_z_special_size_1_size_variant_1_8192_04492000() {
    // Encoding: 0x04492000
    // Test UMAXV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04492000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umaxv_r_p_z_special_size_2_size_variant_2_8192_04892000() {
    // Encoding: 0x04892000
    // Test UMAXV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, Vd=0, size=2
    let encoding: u32 = 0x04892000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umaxv_r_p_z_special_size_3_size_variant_3_8192_04c92000() {
    // Encoding: 0x04C92000
    // Test UMAXV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04C92000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umaxv_r_p_z_invalid_0_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umaxv_r_p_z_invalid_1_2000_04092000() {
    // Encoding: 0x04092000
    // Test UMAXV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x04092000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMAXV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_umaxv_r_p_z_reg_write_0_04092000() {
    // Test UMAXV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04092000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04092000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// TRN1_P.PP__ Tests
// ============================================================================

/// Provenance: TRN1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_trn1_p_pp_field_size_0_min_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ field size = 0 (Min)
    // Fields: Pm=0, Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_trn1_p_pp_field_size_1_poweroftwo_5000_05605000() {
    // Encoding: 0x05605000
    // Test TRN1_P.PP__ field size = 1 (PowerOfTwo)
    // Fields: Pd=0, Pn=0, size=1, Pm=0
    let encoding: u32 = 0x05605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_trn1_p_pp_field_size_2_poweroftwo_5000_05a05000() {
    // Encoding: 0x05A05000
    // Test TRN1_P.PP__ field size = 2 (PowerOfTwo)
    // Fields: Pm=0, Pd=0, Pn=0, size=2
    let encoding: u32 = 0x05A05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_trn1_p_pp_field_size_3_max_5000_05e05000() {
    // Encoding: 0x05E05000
    // Test TRN1_P.PP__ field size = 3 (Max)
    // Fields: Pm=0, Pd=0, size=3, Pn=0
    let encoding: u32 = 0x05E05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_trn1_p_pp_field_pm_0_min_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ field Pm = 0 (Min)
    // Fields: Pm=0, size=0, Pn=0, Pd=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_trn1_p_pp_field_pm_1_poweroftwo_5000_05215000() {
    // Encoding: 0x05215000
    // Test TRN1_P.PP__ field Pm = 1 (PowerOfTwo)
    // Fields: size=0, Pd=0, Pn=0, Pm=1
    let encoding: u32 = 0x05215000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_trn1_p_pp_field_pn_0_min_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ field Pn = 0 (Min)
    // Fields: size=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_trn1_p_pp_field_pn_1_poweroftwo_5000_05205020() {
    // Encoding: 0x05205020
    // Test TRN1_P.PP__ field Pn = 1 (PowerOfTwo)
    // Fields: Pm=0, Pn=1, size=0, Pd=0
    let encoding: u32 = 0x05205020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_trn1_p_pp_field_pd_0_min_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ field Pd = 0 (Min)
    // Fields: size=0, Pm=0, Pd=0, Pn=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_trn1_p_pp_field_pd_1_poweroftwo_5000_05205001() {
    // Encoding: 0x05205001
    // Test TRN1_P.PP__ field Pd = 1 (PowerOfTwo)
    // Fields: Pd=1, size=0, Pn=0, Pm=0
    let encoding: u32 = 0x05205001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_trn1_p_pp_combo_0_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ field combination: size=0, Pm=0, Pn=0, Pd=0
    // Fields: size=0, Pd=0, Pm=0, Pn=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_trn1_p_pp_special_size_0_size_variant_0_20480_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ special value size = 0 (Size variant 0)
    // Fields: Pn=0, size=0, Pd=0, Pm=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_trn1_p_pp_special_size_1_size_variant_1_20480_05605000() {
    // Encoding: 0x05605000
    // Test TRN1_P.PP__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05605000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_trn1_p_pp_special_size_2_size_variant_2_20480_05a05000() {
    // Encoding: 0x05A05000
    // Test TRN1_P.PP__ special value size = 2 (Size variant 2)
    // Fields: Pm=0, size=2, Pn=0, Pd=0
    let encoding: u32 = 0x05A05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_trn1_p_pp_special_size_3_size_variant_3_20480_05e05000() {
    // Encoding: 0x05E05000
    // Test TRN1_P.PP__ special value size = 3 (Size variant 3)
    // Fields: Pd=0, size=3, Pm=0, Pn=0
    let encoding: u32 = 0x05E05000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_trn1_p_pp_invalid_0_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pm=0, Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_trn1_p_pp_invalid_1_5000_05205000() {
    // Encoding: 0x05205000
    // Test TRN1_P.PP__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pm=0, size=0, Pn=0, Pd=0
    let encoding: u32 = 0x05205000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_trn2_p_pp_field_size_0_min_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ field size = 0 (Min)
    // Fields: Pn=0, size=0, Pd=0, Pm=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_trn2_p_pp_field_size_1_poweroftwo_5400_05605400() {
    // Encoding: 0x05605400
    // Test TRN2_P.PP__ field size = 1 (PowerOfTwo)
    // Fields: Pd=0, Pm=0, Pn=0, size=1
    let encoding: u32 = 0x05605400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_trn2_p_pp_field_size_2_poweroftwo_5400_05a05400() {
    // Encoding: 0x05A05400
    // Test TRN2_P.PP__ field size = 2 (PowerOfTwo)
    // Fields: Pd=0, size=2, Pn=0, Pm=0
    let encoding: u32 = 0x05A05400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_trn2_p_pp_field_size_3_max_5400_05e05400() {
    // Encoding: 0x05E05400
    // Test TRN2_P.PP__ field size = 3 (Max)
    // Fields: Pn=0, Pm=0, size=3, Pd=0
    let encoding: u32 = 0x05E05400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_trn2_p_pp_field_pm_0_min_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ field Pm = 0 (Min)
    // Fields: Pm=0, Pd=0, Pn=0, size=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_trn2_p_pp_field_pm_1_poweroftwo_5400_05215400() {
    // Encoding: 0x05215400
    // Test TRN2_P.PP__ field Pm = 1 (PowerOfTwo)
    // Fields: Pd=0, Pm=1, size=0, Pn=0
    let encoding: u32 = 0x05215400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_trn2_p_pp_field_pn_0_min_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ field Pn = 0 (Min)
    // Fields: Pn=0, size=0, Pm=0, Pd=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_trn2_p_pp_field_pn_1_poweroftwo_5400_05205420() {
    // Encoding: 0x05205420
    // Test TRN2_P.PP__ field Pn = 1 (PowerOfTwo)
    // Fields: Pd=0, Pm=0, Pn=1, size=0
    let encoding: u32 = 0x05205420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_trn2_p_pp_field_pd_0_min_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ field Pd = 0 (Min)
    // Fields: size=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_trn2_p_pp_field_pd_1_poweroftwo_5400_05205401() {
    // Encoding: 0x05205401
    // Test TRN2_P.PP__ field Pd = 1 (PowerOfTwo)
    // Fields: Pn=0, Pd=1, Pm=0, size=0
    let encoding: u32 = 0x05205401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_trn2_p_pp_combo_0_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ field combination: size=0, Pm=0, Pn=0, Pd=0
    // Fields: Pm=0, Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_trn2_p_pp_special_size_0_size_variant_0_21504_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ special value size = 0 (Size variant 0)
    // Fields: Pd=0, size=0, Pm=0, Pn=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_trn2_p_pp_special_size_1_size_variant_1_21504_05605400() {
    // Encoding: 0x05605400
    // Test TRN2_P.PP__ special value size = 1 (Size variant 1)
    // Fields: Pd=0, Pm=0, Pn=0, size=1
    let encoding: u32 = 0x05605400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_trn2_p_pp_special_size_2_size_variant_2_21504_05a05400() {
    // Encoding: 0x05A05400
    // Test TRN2_P.PP__ special value size = 2 (Size variant 2)
    // Fields: Pd=0, Pn=0, size=2, Pm=0
    let encoding: u32 = 0x05A05400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_trn2_p_pp_special_size_3_size_variant_3_21504_05e05400() {
    // Encoding: 0x05E05400
    // Test TRN2_P.PP__ special value size = 3 (Size variant 3)
    // Fields: Pm=0, Pn=0, size=3, Pd=0
    let encoding: u32 = 0x05E05400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_trn2_p_pp_invalid_0_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pd=0, Pn=0, size=0, Pm=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN2_P.PP__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_trn2_p_pp_invalid_1_5400_05205400() {
    // Encoding: 0x05205400
    // Test TRN2_P.PP__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pn=0, Pd=0, Pm=0
    let encoding: u32 = 0x05205400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN1_P.PP__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_trn1_p_pp_reg_write_0_05205000() {
    // Test TRN1_P.PP__ register write: SimdFromField("Pd")
    // Encoding: 0x05205000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05205000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: TRN2_P.PP__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_trn2_p_pp_reg_write_0_05205400() {
    // Test TRN2_P.PP__ register write: SimdFromField("Pd")
    // Encoding: 0x05205400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05205400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// RBIT_Z.P.Z__ Tests
// ============================================================================

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_rbit_z_p_z_field_size_0_min_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_rbit_z_p_z_field_size_1_poweroftwo_8000_05678000() {
    // Encoding: 0x05678000
    // Test RBIT_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05678000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_rbit_z_p_z_field_size_2_poweroftwo_8000_05a78000() {
    // Encoding: 0x05A78000
    // Test RBIT_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05A78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_rbit_z_p_z_field_size_3_max_8000_05e78000() {
    // Encoding: 0x05E78000
    // Test RBIT_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x05E78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_rbit_z_p_z_field_pg_0_min_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_rbit_z_p_z_field_pg_1_poweroftwo_8000_05278400() {
    // Encoding: 0x05278400
    // Test RBIT_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05278400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_rbit_z_p_z_field_zn_0_min_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_rbit_z_p_z_field_zn_1_poweroftwo_8000_05278020() {
    // Encoding: 0x05278020
    // Test RBIT_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x05278020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_rbit_z_p_z_field_zn_30_poweroftwominusone_8000_052783c0() {
    // Encoding: 0x052783C0
    // Test RBIT_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x052783C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_rbit_z_p_z_field_zn_31_max_8000_052783e0() {
    // Encoding: 0x052783E0
    // Test RBIT_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, size=0, Zn=31, Zd=0
    let encoding: u32 = 0x052783E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_rbit_z_p_z_field_zd_0_min_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_rbit_z_p_z_field_zd_1_poweroftwo_8000_05278001() {
    // Encoding: 0x05278001
    // Test RBIT_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=0, Zd=1
    let encoding: u32 = 0x05278001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_rbit_z_p_z_field_zd_30_poweroftwominusone_8000_0527801e() {
    // Encoding: 0x0527801E
    // Test RBIT_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0, Pg=0
    let encoding: u32 = 0x0527801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_rbit_z_p_z_field_zd_31_max_8000_0527801f() {
    // Encoding: 0x0527801F
    // Test RBIT_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Zd=31
    let encoding: u32 = 0x0527801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_rbit_z_p_z_combo_0_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_rbit_z_p_z_special_size_0_size_variant_0_32768_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_rbit_z_p_z_special_size_1_size_variant_1_32768_05678000() {
    // Encoding: 0x05678000
    // Test RBIT_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05678000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_rbit_z_p_z_special_size_2_size_variant_2_32768_05a78000() {
    // Encoding: 0x05A78000
    // Test RBIT_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x05A78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_rbit_z_p_z_special_size_3_size_variant_3_32768_05e78000() {
    // Encoding: 0x05E78000
    // Test RBIT_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05E78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_rbit_z_p_z_invalid_0_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_rbit_z_p_z_invalid_1_8000_05278000() {
    // Encoding: 0x05278000
    // Test RBIT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05278000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: RBIT_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_rbit_z_p_z_reg_write_0_05278000() {
    // Test RBIT_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x05278000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05278000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UDIV_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_udiv_z_p_zz_field_size_0_min_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_udiv_z_p_zz_field_size_1_poweroftwo_0_04550000() {
    // Encoding: 0x04550000
    // Test UDIV_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x04550000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_udiv_z_p_zz_field_size_2_poweroftwo_0_04950000() {
    // Encoding: 0x04950000
    // Test UDIV_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zdn=0, size=2
    let encoding: u32 = 0x04950000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_udiv_z_p_zz_field_size_3_max_0_04d50000() {
    // Encoding: 0x04D50000
    // Test UDIV_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04D50000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_udiv_z_p_zz_field_pg_0_min_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_udiv_z_p_zz_field_pg_1_poweroftwo_0_04150400() {
    // Encoding: 0x04150400
    // Test UDIV_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Pg=1, Zm=0
    let encoding: u32 = 0x04150400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udiv_z_p_zz_field_zm_0_min_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udiv_z_p_zz_field_zm_1_poweroftwo_0_04150020() {
    // Encoding: 0x04150020
    // Test UDIV_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04150020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_udiv_z_p_zz_field_zm_30_poweroftwominusone_0_041503c0() {
    // Encoding: 0x041503C0
    // Test UDIV_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zdn=0, Zm=30
    let encoding: u32 = 0x041503C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_udiv_z_p_zz_field_zm_31_max_0_041503e0() {
    // Encoding: 0x041503E0
    // Test UDIV_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zdn=0, Pg=0
    let encoding: u32 = 0x041503E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udiv_z_p_zz_field_zdn_0_min_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_udiv_z_p_zz_field_zdn_1_poweroftwo_0_04150001() {
    // Encoding: 0x04150001
    // Test UDIV_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=0, Zdn=1
    let encoding: u32 = 0x04150001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_udiv_z_p_zz_field_zdn_15_poweroftwominusone_0_0415000f() {
    // Encoding: 0x0415000F
    // Test UDIV_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Pg=0, Zdn=15
    let encoding: u32 = 0x0415000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_udiv_z_p_zz_field_zdn_31_max_0_0415001f() {
    // Encoding: 0x0415001F
    // Test UDIV_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zdn=31, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x0415001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_udiv_z_p_zz_combo_0_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_udiv_z_p_zz_special_size_0_size_variant_0_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_udiv_z_p_zz_special_size_1_size_variant_1_0_04550000() {
    // Encoding: 0x04550000
    // Test UDIV_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x04550000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_udiv_z_p_zz_special_size_2_size_variant_2_0_04950000() {
    // Encoding: 0x04950000
    // Test UDIV_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, Zdn=0, size=2
    let encoding: u32 = 0x04950000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_udiv_z_p_zz_special_size_3_size_variant_3_0_04d50000() {
    // Encoding: 0x04D50000
    // Test UDIV_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Pg=0, size=3, Zm=0
    let encoding: u32 = 0x04D50000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_udiv_z_p_zz_invalid_0_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udiv_z_p_zz_invalid_1_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([Zero, Either]) }" }
/// triggers Undefined
#[test]
fn test_udiv_z_p_zz_invalid_2_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udiv_z_p_zz_invalid_3_0_04150000() {
    // Encoding: 0x04150000
    // Test UDIV_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04150000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDIV_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_udiv_z_p_zz_reg_write_0_04150000() {
    // Test UDIV_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04150000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04150000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UDOT_Z.ZZZ__ Tests
// ============================================================================

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_udot_z_zzz_field_size_0_min_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Zm=0, Zda=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_udot_z_zzz_field_size_1_poweroftwo_400_44400400() {
    // Encoding: 0x44400400
    // Test UDOT_Z.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=0, size=1, Zm=0
    let encoding: u32 = 0x44400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_udot_z_zzz_field_size_2_poweroftwo_400_44800400() {
    // Encoding: 0x44800400
    // Test UDOT_Z.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, Zda=0, size=2
    let encoding: u32 = 0x44800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_udot_z_zzz_field_size_3_max_400_44c00400() {
    // Encoding: 0x44C00400
    // Test UDOT_Z.ZZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Zn=0, Zda=0
    let encoding: u32 = 0x44C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udot_z_zzz_field_zm_0_min_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udot_z_zzz_field_zm_1_poweroftwo_400_44010400() {
    // Encoding: 0x44010400
    // Test UDOT_Z.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=0, size=0, Zm=1
    let encoding: u32 = 0x44010400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_udot_z_zzz_field_zm_30_poweroftwominusone_400_441e0400() {
    // Encoding: 0x441E0400
    // Test UDOT_Z.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, Zm=30, size=0, Zn=0
    let encoding: u32 = 0x441E0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_udot_z_zzz_field_zm_31_max_400_441f0400() {
    // Encoding: 0x441F0400
    // Test UDOT_Z.ZZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zn=0, Zda=0, Zm=31
    let encoding: u32 = 0x441F0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udot_z_zzz_field_zn_0_min_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ field Zn = 0 (Min)
    // Fields: size=0, Zm=0, Zda=0, Zn=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udot_z_zzz_field_zn_1_poweroftwo_400_44000420() {
    // Encoding: 0x44000420
    // Test UDOT_Z.ZZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zn=1, Zda=0
    let encoding: u32 = 0x44000420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_udot_z_zzz_field_zn_30_poweroftwominusone_400_440007c0() {
    // Encoding: 0x440007C0
    // Test UDOT_Z.ZZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Zda=0, Zn=30
    let encoding: u32 = 0x440007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_udot_z_zzz_field_zn_31_max_400_440007e0() {
    // Encoding: 0x440007E0
    // Test UDOT_Z.ZZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Zn=31, size=0, Zda=0
    let encoding: u32 = 0x440007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udot_z_zzz_field_zda_0_min_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ field Zda = 0 (Min)
    // Fields: Zm=0, size=0, Zn=0, Zda=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_udot_z_zzz_field_zda_1_poweroftwo_400_44000401() {
    // Encoding: 0x44000401
    // Test UDOT_Z.ZZZ__ field Zda = 1 (PowerOfTwo)
    // Fields: Zda=1, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x44000401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_udot_z_zzz_field_zda_15_poweroftwominusone_400_4400040f() {
    // Encoding: 0x4400040F
    // Test UDOT_Z.ZZZ__ field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zm=0, size=0, Zda=15
    let encoding: u32 = 0x4400040F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_udot_z_zzz_field_zda_31_max_400_4400041f() {
    // Encoding: 0x4400041F
    // Test UDOT_Z.ZZZ__ field Zda = 31 (Max)
    // Fields: Zm=0, Zn=0, size=0, Zda=31
    let encoding: u32 = 0x4400041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_udot_z_zzz_combo_0_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ field combination: size=0, Zm=0, Zn=0, Zda=0
    // Fields: size=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_udot_z_zzz_special_size_0_size_variant_0_1024_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Zda=0, size=0, Zn=0, Zm=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_udot_z_zzz_special_size_1_size_variant_1_1024_44400400() {
    // Encoding: 0x44400400
    // Test UDOT_Z.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Zda=0, Zn=0, size=1, Zm=0
    let encoding: u32 = 0x44400400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_udot_z_zzz_special_size_2_size_variant_2_1024_44800400() {
    // Encoding: 0x44800400
    // Test UDOT_Z.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Zda=0, size=2, Zm=0, Zn=0
    let encoding: u32 = 0x44800400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_udot_z_zzz_special_size_3_size_variant_3_1024_44c00400() {
    // Encoding: 0x44C00400
    // Test UDOT_Z.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zda=0, size=3, Zm=0
    let encoding: u32 = 0x44C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_udot_z_zzz_invalid_0_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Zda=0, Zm=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udot_z_zzz_invalid_1_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([Zero, Either]) }" }
/// triggers Undefined
#[test]
fn test_udot_z_zzz_invalid_2_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }
    // Fields: size=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udot_z_zzz_invalid_3_400_44000400() {
    // Encoding: 0x44000400
    // Test UDOT_Z.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zda=0, size=0, Zn=0
    let encoding: u32 = 0x44000400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZ__
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_udot_z_zzz_reg_write_0_44000400() {
    // Test UDOT_Z.ZZZ__ register write: SimdFromField("da")
    // Encoding: 0x44000400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x44000400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SQADD_Z.ZZ__ Tests
// ============================================================================

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sqadd_z_zz_field_size_0_min_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sqadd_z_zz_field_size_1_poweroftwo_1000_04601000() {
    // Encoding: 0x04601000
    // Test SQADD_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Zm=0, size=1
    let encoding: u32 = 0x04601000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sqadd_z_zz_field_size_2_poweroftwo_1000_04a01000() {
    // Encoding: 0x04A01000
    // Test SQADD_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Zd=0, Zm=0
    let encoding: u32 = 0x04A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sqadd_z_zz_field_size_3_max_1000_04e01000() {
    // Encoding: 0x04E01000
    // Test SQADD_Z.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x04E01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sqadd_z_zz_field_zm_0_min_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sqadd_z_zz_field_zm_1_poweroftwo_1000_04211000() {
    // Encoding: 0x04211000
    // Test SQADD_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zm=1, Zd=0
    let encoding: u32 = 0x04211000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sqadd_z_zz_field_zm_30_poweroftwominusone_1000_043e1000() {
    // Encoding: 0x043E1000
    // Test SQADD_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, size=0, Zd=0, Zm=30
    let encoding: u32 = 0x043E1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sqadd_z_zz_field_zm_31_max_1000_043f1000() {
    // Encoding: 0x043F1000
    // Test SQADD_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, Zd=0, Zm=31, size=0
    let encoding: u32 = 0x043F1000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sqadd_z_zz_field_zn_0_min_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sqadd_z_zz_field_zn_1_poweroftwo_1000_04201020() {
    // Encoding: 0x04201020
    // Test SQADD_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=1, size=0, Zd=0
    let encoding: u32 = 0x04201020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sqadd_z_zz_field_zn_30_poweroftwominusone_1000_042013c0() {
    // Encoding: 0x042013C0
    // Test SQADD_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x042013C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sqadd_z_zz_field_zn_31_max_1000_042013e0() {
    // Encoding: 0x042013E0
    // Test SQADD_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x042013E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sqadd_z_zz_field_zd_0_min_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sqadd_z_zz_field_zd_1_poweroftwo_1000_04201001() {
    // Encoding: 0x04201001
    // Test SQADD_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1, Zm=0, size=0
    let encoding: u32 = 0x04201001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sqadd_z_zz_field_zd_30_poweroftwominusone_1000_0420101e() {
    // Encoding: 0x0420101E
    // Test SQADD_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x0420101E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sqadd_z_zz_field_zd_31_max_1000_0420101f() {
    // Encoding: 0x0420101F
    // Test SQADD_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, size=0, Zm=0
    let encoding: u32 = 0x0420101F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sqadd_z_zz_combo_0_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sqadd_z_zz_special_size_0_size_variant_0_4096_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sqadd_z_zz_special_size_1_size_variant_1_4096_04601000() {
    // Encoding: 0x04601000
    // Test SQADD_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x04601000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sqadd_z_zz_special_size_2_size_variant_2_4096_04a01000() {
    // Encoding: 0x04A01000
    // Test SQADD_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zm=0, Zd=0, size=2
    let encoding: u32 = 0x04A01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sqadd_z_zz_special_size_3_size_variant_3_4096_04e01000() {
    // Encoding: 0x04E01000
    // Test SQADD_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zn=0, Zm=0, size=3
    let encoding: u32 = 0x04E01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sqadd_z_zz_invalid_0_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sqadd_z_zz_invalid_1_1000_04201000() {
    // Encoding: 0x04201000
    // Test SQADD_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zm=0, size=0, Zn=0
    let encoding: u32 = 0x04201000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SQADD_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sqadd_z_zz_reg_write_0_04201000() {
    // Test SQADD_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x04201000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04201000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UXTB_Z.P.Z__ Tests
// ============================================================================

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uxtb_z_p_z_field_size_0_min_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uxtb_z_p_z_field_size_1_poweroftwo_a000_0451a000() {
    // Encoding: 0x0451A000
    // Test UXTB_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0451A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uxtb_z_p_z_field_size_2_poweroftwo_a000_0491a000() {
    // Encoding: 0x0491A000
    // Test UXTB_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0491A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uxtb_z_p_z_field_size_3_max_a000_04d1a000() {
    // Encoding: 0x04D1A000
    // Test UXTB_Z.P.Z__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x04D1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uxtb_z_p_z_field_pg_0_min_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uxtb_z_p_z_field_pg_1_poweroftwo_a000_0411a400() {
    // Encoding: 0x0411A400
    // Test UXTB_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0411A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uxtb_z_p_z_field_zn_0_min_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uxtb_z_p_z_field_zn_1_poweroftwo_a000_0411a020() {
    // Encoding: 0x0411A020
    // Test UXTB_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=1, Zd=0
    let encoding: u32 = 0x0411A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uxtb_z_p_z_field_zn_30_poweroftwominusone_a000_0411a3c0() {
    // Encoding: 0x0411A3C0
    // Test UXTB_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Pg=0, Zn=30, size=0
    let encoding: u32 = 0x0411A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uxtb_z_p_z_field_zn_31_max_a000_0411a3e0() {
    // Encoding: 0x0411A3E0
    // Test UXTB_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Zd=0, Pg=0
    let encoding: u32 = 0x0411A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uxtb_z_p_z_field_zd_0_min_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uxtb_z_p_z_field_zd_1_poweroftwo_a000_0411a001() {
    // Encoding: 0x0411A001
    // Test UXTB_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zd=1, size=0
    let encoding: u32 = 0x0411A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uxtb_z_p_z_field_zd_30_poweroftwominusone_a000_0411a01e() {
    // Encoding: 0x0411A01E
    // Test UXTB_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0, Pg=0
    let encoding: u32 = 0x0411A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uxtb_z_p_z_field_zd_31_max_a000_0411a01f() {
    // Encoding: 0x0411A01F
    // Test UXTB_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Zd=31
    let encoding: u32 = 0x0411A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uxtb_z_p_z_combo_0_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uxtb_z_p_z_special_size_0_size_variant_0_40960_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uxtb_z_p_z_special_size_1_size_variant_1_40960_0451a000() {
    // Encoding: 0x0451A000
    // Test UXTB_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Pg=0, Zn=0, size=1
    let encoding: u32 = 0x0451A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uxtb_z_p_z_special_size_2_size_variant_2_40960_0491a000() {
    // Encoding: 0x0491A000
    // Test UXTB_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0491A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uxtb_z_p_z_special_size_3_size_variant_3_40960_04d1a000() {
    // Encoding: 0x04D1A000
    // Test UXTB_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x04D1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uxtb_z_p_z_invalid_0_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uxtb_z_p_z_invalid_1_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_uxtb_z_p_z_invalid_2_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Pg=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uxtb_z_p_z_invalid_3_a000_0411a000() {
    // Encoding: 0x0411A000
    // Test UXTB_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0411A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uxth_z_p_z_field_size_0_min_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ field size = 0 (Min)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uxth_z_p_z_field_size_1_poweroftwo_a000_0453a000() {
    // Encoding: 0x0453A000
    // Test UXTH_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x0453A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uxth_z_p_z_field_size_2_poweroftwo_a000_0493a000() {
    // Encoding: 0x0493A000
    // Test UXTH_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, size=2, Zn=0
    let encoding: u32 = 0x0493A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uxth_z_p_z_field_size_3_max_a000_04d3a000() {
    // Encoding: 0x04D3A000
    // Test UXTH_Z.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x04D3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uxth_z_p_z_field_pg_0_min_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uxth_z_p_z_field_pg_1_poweroftwo_a000_0413a400() {
    // Encoding: 0x0413A400
    // Test UXTH_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0413A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uxth_z_p_z_field_zn_0_min_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uxth_z_p_z_field_zn_1_poweroftwo_a000_0413a020() {
    // Encoding: 0x0413A020
    // Test UXTH_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Pg=0, Zd=0
    let encoding: u32 = 0x0413A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uxth_z_p_z_field_zn_30_poweroftwominusone_a000_0413a3c0() {
    // Encoding: 0x0413A3C0
    // Test UXTH_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=0, Zn=30, size=0
    let encoding: u32 = 0x0413A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uxth_z_p_z_field_zn_31_max_a000_0413a3e0() {
    // Encoding: 0x0413A3E0
    // Test UXTH_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x0413A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uxth_z_p_z_field_zd_0_min_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uxth_z_p_z_field_zd_1_poweroftwo_a000_0413a001() {
    // Encoding: 0x0413A001
    // Test UXTH_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1, size=0, Pg=0
    let encoding: u32 = 0x0413A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uxth_z_p_z_field_zd_30_poweroftwominusone_a000_0413a01e() {
    // Encoding: 0x0413A01E
    // Test UXTH_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, Pg=0, size=0
    let encoding: u32 = 0x0413A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uxth_z_p_z_field_zd_31_max_a000_0413a01f() {
    // Encoding: 0x0413A01F
    // Test UXTH_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, Zd=31, size=0, Zn=0
    let encoding: u32 = 0x0413A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uxth_z_p_z_combo_0_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uxth_z_p_z_special_size_0_size_variant_0_40960_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uxth_z_p_z_special_size_1_size_variant_1_40960_0453a000() {
    // Encoding: 0x0453A000
    // Test UXTH_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x0453A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uxth_z_p_z_special_size_2_size_variant_2_40960_0493a000() {
    // Encoding: 0x0493A000
    // Test UXTH_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, Zd=0, size=2
    let encoding: u32 = 0x0493A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uxth_z_p_z_special_size_3_size_variant_3_40960_04d3a000() {
    // Encoding: 0x04D3A000
    // Test UXTH_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x04D3A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uxth_z_p_z_invalid_0_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uxth_z_p_z_invalid_1_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([One, Either]) }" }
/// triggers Undefined
#[test]
fn test_uxth_z_p_z_invalid_2_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uxth_z_p_z_invalid_3_a000_0413a000() {
    // Encoding: 0x0413A000
    // Test UXTH_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0413A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uxtw_z_p_z_field_size_0_min_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uxtw_z_p_z_field_size_1_poweroftwo_a000_0455a000() {
    // Encoding: 0x0455A000
    // Test UXTW_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x0455A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uxtw_z_p_z_field_size_2_poweroftwo_a000_0495a000() {
    // Encoding: 0x0495A000
    // Test UXTW_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, Pg=0, size=2
    let encoding: u32 = 0x0495A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uxtw_z_p_z_field_size_3_max_a000_04d5a000() {
    // Encoding: 0x04D5A000
    // Test UXTW_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zn=0, size=3, Zd=0
    let encoding: u32 = 0x04D5A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uxtw_z_p_z_field_pg_0_min_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uxtw_z_p_z_field_pg_1_poweroftwo_a000_0415a400() {
    // Encoding: 0x0415A400
    // Test UXTW_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, Pg=1, size=0
    let encoding: u32 = 0x0415A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uxtw_z_p_z_field_zn_0_min_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uxtw_z_p_z_field_zn_1_poweroftwo_a000_0415a020() {
    // Encoding: 0x0415A020
    // Test UXTW_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=1, Zd=0, size=0
    let encoding: u32 = 0x0415A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uxtw_z_p_z_field_zn_30_poweroftwominusone_a000_0415a3c0() {
    // Encoding: 0x0415A3C0
    // Test UXTW_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=30, Zd=0, size=0
    let encoding: u32 = 0x0415A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uxtw_z_p_z_field_zn_31_max_a000_0415a3e0() {
    // Encoding: 0x0415A3E0
    // Test UXTW_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, size=0, Pg=0, Zn=31
    let encoding: u32 = 0x0415A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uxtw_z_p_z_field_zd_0_min_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uxtw_z_p_z_field_zd_1_poweroftwo_a000_0415a001() {
    // Encoding: 0x0415A001
    // Test UXTW_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zn=0, Zd=1
    let encoding: u32 = 0x0415A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uxtw_z_p_z_field_zd_30_poweroftwominusone_a000_0415a01e() {
    // Encoding: 0x0415A01E
    // Test UXTW_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=0, Zd=30
    let encoding: u32 = 0x0415A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uxtw_z_p_z_field_zd_31_max_a000_0415a01f() {
    // Encoding: 0x0415A01F
    // Test UXTW_Z.P.Z__ field Zd = 31 (Max)
    // Fields: size=0, Pg=0, Zd=31, Zn=0
    let encoding: u32 = 0x0415A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uxtw_z_p_z_combo_0_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uxtw_z_p_z_special_size_0_size_variant_0_40960_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uxtw_z_p_z_special_size_1_size_variant_1_40960_0455a000() {
    // Encoding: 0x0455A000
    // Test UXTW_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Pg=0, size=1, Zd=0
    let encoding: u32 = 0x0455A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uxtw_z_p_z_special_size_2_size_variant_2_40960_0495a000() {
    // Encoding: 0x0495A000
    // Test UXTW_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zn=0, Zd=0
    let encoding: u32 = 0x0495A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uxtw_z_p_z_special_size_3_size_variant_3_40960_04d5a000() {
    // Encoding: 0x04D5A000
    // Test UXTW_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zd=0, Zn=0, size=3
    let encoding: u32 = 0x04D5A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uxtw_z_p_z_invalid_0_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uxtw_z_p_z_invalid_1_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_uxtw_z_p_z_invalid_2_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uxtw_z_p_z_invalid_3_a000_0415a000() {
    // Encoding: 0x0415A000
    // Test UXTW_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x0415A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UXTB_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uxtb_z_p_z_reg_write_0_0411a000() {
    // Test UXTB_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0411A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0411A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UXTH_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uxth_z_p_z_reg_write_0_0413a000() {
    // Test UXTH_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0413A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0413A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UXTW_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uxtw_z_p_z_reg_write_0_0415a000() {
    // Test UXTW_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0415A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0415A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INSR_Z.R__ Tests
// ============================================================================

/// Provenance: INSR_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_insr_z_r_field_size_0_min_3800_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ field size = 0 (Min)
    // Fields: Zdn=0, Rm=0, size=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_insr_z_r_field_size_1_poweroftwo_3800_05643800() {
    // Encoding: 0x05643800
    // Test INSR_Z.R__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, Rm=0, size=1
    let encoding: u32 = 0x05643800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_insr_z_r_field_size_2_poweroftwo_3800_05a43800() {
    // Encoding: 0x05A43800
    // Test INSR_Z.R__ field size = 2 (PowerOfTwo)
    // Fields: Rm=0, size=2, Zdn=0
    let encoding: u32 = 0x05A43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_insr_z_r_field_size_3_max_3800_05e43800() {
    // Encoding: 0x05E43800
    // Test INSR_Z.R__ field size = 3 (Max)
    // Fields: Zdn=0, Rm=0, size=3
    let encoding: u32 = 0x05E43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Rm 5 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_insr_z_r_field_rm_0_min_3800_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ field Rm = 0 (Min)
    // Fields: Rm=0, Zdn=0, size=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Rm 5 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_insr_z_r_field_rm_1_poweroftwo_3800_05243820() {
    // Encoding: 0x05243820
    // Test INSR_Z.R__ field Rm = 1 (PowerOfTwo)
    // Fields: Rm=1, size=0, Zdn=0
    let encoding: u32 = 0x05243820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Rm 5 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_insr_z_r_field_rm_30_poweroftwominusone_3800_05243bc0() {
    // Encoding: 0x05243BC0
    // Test INSR_Z.R__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, Rm=30
    let encoding: u32 = 0x05243BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Rm 5 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_insr_z_r_field_rm_31_max_3800_05243be0() {
    // Encoding: 0x05243BE0
    // Test INSR_Z.R__ field Rm = 31 (Max)
    // Fields: size=0, Rm=31, Zdn=0
    let encoding: u32 = 0x05243BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_insr_z_r_field_zdn_0_min_3800_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ field Zdn = 0 (Min)
    // Fields: size=0, Rm=0, Zdn=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_insr_z_r_field_zdn_1_poweroftwo_3800_05243801() {
    // Encoding: 0x05243801
    // Test INSR_Z.R__ field Zdn = 1 (PowerOfTwo)
    // Fields: Rm=0, Zdn=1, size=0
    let encoding: u32 = 0x05243801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_insr_z_r_field_zdn_15_poweroftwominusone_3800_0524380f() {
    // Encoding: 0x0524380F
    // Test INSR_Z.R__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Rm=0
    let encoding: u32 = 0x0524380F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_insr_z_r_field_zdn_31_max_3800_0524381f() {
    // Encoding: 0x0524381F
    // Test INSR_Z.R__ field Zdn = 31 (Max)
    // Fields: Rm=0, size=0, Zdn=31
    let encoding: u32 = 0x0524381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_insr_z_r_combo_0_3800_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ field combination: size=0, Rm=0, Zdn=0
    // Fields: Rm=0, size=0, Zdn=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_insr_z_r_special_size_0_size_variant_0_14336_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, Rm=0, size=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_insr_z_r_special_size_1_size_variant_1_14336_05643800() {
    // Encoding: 0x05643800
    // Test INSR_Z.R__ special value size = 1 (Size variant 1)
    // Fields: Rm=0, size=1, Zdn=0
    let encoding: u32 = 0x05643800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_insr_z_r_special_size_2_size_variant_2_14336_05a43800() {
    // Encoding: 0x05A43800
    // Test INSR_Z.R__ special value size = 2 (Size variant 2)
    // Fields: size=2, Rm=0, Zdn=0
    let encoding: u32 = 0x05A43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_insr_z_r_special_size_3_size_variant_3_14336_05e43800() {
    // Encoding: 0x05E43800
    // Test INSR_Z.R__ special value size = 3 (Size variant 3)
    // Fields: Rm=0, Zdn=0, size=3
    let encoding: u32 = 0x05E43800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_insr_z_r_invalid_0_3800_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Rm=0, Zdn=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_insr_z_r_invalid_1_3800_05243800() {
    // Encoding: 0x05243800
    // Test INSR_Z.R__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rm=0, Zdn=0
    let encoding: u32 = 0x05243800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INSR_Z.R__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_insr_z_r_reg_write_0_05243800() {
    // Test INSR_Z.R__ register write: SimdFromField("dn")
    // Encoding: 0x05243800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05243800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UUNPKHI_Z.Z__ Tests
// ============================================================================

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uunpkhi_z_z_field_size_0_min_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ field size = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uunpkhi_z_z_field_size_1_poweroftwo_3800_05733800() {
    // Encoding: 0x05733800
    // Test UUNPKHI_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zd=0, Zn=0
    let encoding: u32 = 0x05733800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uunpkhi_z_z_field_size_2_poweroftwo_3800_05b33800() {
    // Encoding: 0x05B33800
    // Test UUNPKHI_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, size=2, Zn=0
    let encoding: u32 = 0x05B33800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uunpkhi_z_z_field_size_3_max_3800_05f33800() {
    // Encoding: 0x05F33800
    // Test UUNPKHI_Z.Z__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Zn=0
    let encoding: u32 = 0x05F33800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uunpkhi_z_z_field_zn_0_min_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uunpkhi_z_z_field_zn_1_poweroftwo_3800_05333820() {
    // Encoding: 0x05333820
    // Test UUNPKHI_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, size=0
    let encoding: u32 = 0x05333820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uunpkhi_z_z_field_zn_30_poweroftwominusone_3800_05333bc0() {
    // Encoding: 0x05333BC0
    // Test UUNPKHI_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0
    let encoding: u32 = 0x05333BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uunpkhi_z_z_field_zn_31_max_3800_05333be0() {
    // Encoding: 0x05333BE0
    // Test UUNPKHI_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0
    let encoding: u32 = 0x05333BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uunpkhi_z_z_field_zd_0_min_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uunpkhi_z_z_field_zd_1_poweroftwo_3800_05333801() {
    // Encoding: 0x05333801
    // Test UUNPKHI_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1, size=0
    let encoding: u32 = 0x05333801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uunpkhi_z_z_field_zd_30_poweroftwominusone_3800_0533381e() {
    // Encoding: 0x0533381E
    // Test UUNPKHI_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Zn=0
    let encoding: u32 = 0x0533381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uunpkhi_z_z_field_zd_31_max_3800_0533381f() {
    // Encoding: 0x0533381F
    // Test UUNPKHI_Z.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, size=0, Zn=0
    let encoding: u32 = 0x0533381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uunpkhi_z_z_combo_0_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uunpkhi_z_z_special_size_0_size_variant_0_14336_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uunpkhi_z_z_special_size_1_size_variant_1_14336_05733800() {
    // Encoding: 0x05733800
    // Test UUNPKHI_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Zd=0, size=1
    let encoding: u32 = 0x05733800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uunpkhi_z_z_special_size_2_size_variant_2_14336_05b33800() {
    // Encoding: 0x05B33800
    // Test UUNPKHI_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zd=0
    let encoding: u32 = 0x05B33800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uunpkhi_z_z_special_size_3_size_variant_3_14336_05f33800() {
    // Encoding: 0x05F33800
    // Test UUNPKHI_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Zd=0
    let encoding: u32 = 0x05F33800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uunpkhi_z_z_invalid_0_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uunpkhi_z_z_invalid_1_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_uunpkhi_z_z_invalid_2_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uunpkhi_z_z_invalid_3_3800_05333800() {
    // Encoding: 0x05333800
    // Test UUNPKHI_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05333800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uunpklo_z_z_field_size_0_min_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ field size = 0 (Min)
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uunpklo_z_z_field_size_1_poweroftwo_3800_05723800() {
    // Encoding: 0x05723800
    // Test UUNPKLO_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0
    let encoding: u32 = 0x05723800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uunpklo_z_z_field_size_2_poweroftwo_3800_05b23800() {
    // Encoding: 0x05B23800
    // Test UUNPKLO_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Zd=0
    let encoding: u32 = 0x05B23800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uunpklo_z_z_field_size_3_max_3800_05f23800() {
    // Encoding: 0x05F23800
    // Test UUNPKLO_Z.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x05F23800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uunpklo_z_z_field_zn_0_min_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ field Zn = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uunpklo_z_z_field_zn_1_poweroftwo_3800_05323820() {
    // Encoding: 0x05323820
    // Test UUNPKLO_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0
    let encoding: u32 = 0x05323820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uunpklo_z_z_field_zn_30_poweroftwominusone_3800_05323bc0() {
    // Encoding: 0x05323BC0
    // Test UUNPKLO_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zd=0, size=0
    let encoding: u32 = 0x05323BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uunpklo_z_z_field_zn_31_max_3800_05323be0() {
    // Encoding: 0x05323BE0
    // Test UUNPKLO_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0
    let encoding: u32 = 0x05323BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uunpklo_z_z_field_zd_0_min_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uunpklo_z_z_field_zd_1_poweroftwo_3800_05323801() {
    // Encoding: 0x05323801
    // Test UUNPKLO_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, Zn=0
    let encoding: u32 = 0x05323801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uunpklo_z_z_field_zd_30_poweroftwominusone_3800_0532381e() {
    // Encoding: 0x0532381E
    // Test UUNPKLO_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Zn=0
    let encoding: u32 = 0x0532381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uunpklo_z_z_field_zd_31_max_3800_0532381f() {
    // Encoding: 0x0532381F
    // Test UUNPKLO_Z.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, size=0, Zn=0
    let encoding: u32 = 0x0532381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uunpklo_z_z_combo_0_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uunpklo_z_z_special_size_0_size_variant_0_14336_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uunpklo_z_z_special_size_1_size_variant_1_14336_05723800() {
    // Encoding: 0x05723800
    // Test UUNPKLO_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Zd=0
    let encoding: u32 = 0x05723800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uunpklo_z_z_special_size_2_size_variant_2_14336_05b23800() {
    // Encoding: 0x05B23800
    // Test UUNPKLO_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, size=2
    let encoding: u32 = 0x05B23800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uunpklo_z_z_special_size_3_size_variant_3_14336_05f23800() {
    // Encoding: 0x05F23800
    // Test UUNPKLO_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, Zn=0, size=3
    let encoding: u32 = 0x05F23800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uunpklo_z_z_invalid_0_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uunpklo_z_z_invalid_1_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_uunpklo_z_z_invalid_2_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uunpklo_z_z_invalid_3_3800_05323800() {
    // Encoding: 0x05323800
    // Test UUNPKLO_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05323800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UUNPKHI_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uunpkhi_z_z_reg_write_0_05333800() {
    // Test UUNPKHI_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05333800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05333800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UUNPKLO_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uunpklo_z_z_reg_write_0_05323800() {
    // Test UUNPKLO_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05323800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05323800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UQADD_Z.ZI__ Tests
// ============================================================================

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uqadd_z_zi_field_size_0_min_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ field size = 0 (Min)
    // Fields: sh=0, Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uqadd_z_zi_field_size_1_poweroftwo_c000_2565c000() {
    // Encoding: 0x2565C000
    // Test UQADD_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: imm8=0, Zdn=0, size=1, sh=0
    let encoding: u32 = 0x2565C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uqadd_z_zi_field_size_2_poweroftwo_c000_25a5c000() {
    // Encoding: 0x25A5C000
    // Test UQADD_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: size=2, imm8=0, sh=0, Zdn=0
    let encoding: u32 = 0x25A5C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uqadd_z_zi_field_size_3_max_c000_25e5c000() {
    // Encoding: 0x25E5C000
    // Test UQADD_Z.ZI__ field size = 3 (Max)
    // Fields: imm8=0, Zdn=0, size=3, sh=0
    let encoding: u32 = 0x25E5C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_uqadd_z_zi_field_sh_0_min_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ field sh = 0 (Min)
    // Fields: size=0, Zdn=0, sh=0, imm8=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_uqadd_z_zi_field_sh_1_max_c000_2525e000() {
    // Encoding: 0x2525E000
    // Test UQADD_Z.ZI__ field sh = 1 (Max)
    // Fields: sh=1, imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x2525E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_uqadd_z_zi_field_imm8_0_zero_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: size=0, Zdn=0, sh=0, imm8=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_uqadd_z_zi_field_imm8_1_poweroftwo_c000_2525c020() {
    // Encoding: 0x2525C020
    // Test UQADD_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, sh=0, imm8=1
    let encoding: u32 = 0x2525C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_uqadd_z_zi_field_imm8_3_poweroftwominusone_c000_2525c060() {
    // Encoding: 0x2525C060
    // Test UQADD_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: sh=0, size=0, Zdn=0, imm8=3
    let encoding: u32 = 0x2525C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_uqadd_z_zi_field_imm8_4_poweroftwo_c000_2525c080() {
    // Encoding: 0x2525C080
    // Test UQADD_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: sh=0, imm8=4, size=0, Zdn=0
    let encoding: u32 = 0x2525C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_uqadd_z_zi_field_imm8_7_poweroftwominusone_c000_2525c0e0() {
    // Encoding: 0x2525C0E0
    // Test UQADD_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: imm8=7, Zdn=0, sh=0, size=0
    let encoding: u32 = 0x2525C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_uqadd_z_zi_field_imm8_8_poweroftwo_c000_2525c100() {
    // Encoding: 0x2525C100
    // Test UQADD_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm8=8, size=0, sh=0
    let encoding: u32 = 0x2525C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_uqadd_z_zi_field_imm8_15_poweroftwominusone_c000_2525c1e0() {
    // Encoding: 0x2525C1E0
    // Test UQADD_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=15, sh=0, Zdn=0, size=0
    let encoding: u32 = 0x2525C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_uqadd_z_zi_field_imm8_16_poweroftwo_c000_2525c200() {
    // Encoding: 0x2525C200
    // Test UQADD_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: size=0, sh=0, Zdn=0, imm8=16
    let encoding: u32 = 0x2525C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_uqadd_z_zi_field_imm8_31_poweroftwominusone_c000_2525c3e0() {
    // Encoding: 0x2525C3E0
    // Test UQADD_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, imm8=31, sh=0
    let encoding: u32 = 0x2525C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_uqadd_z_zi_field_imm8_32_poweroftwo_c000_2525c400() {
    // Encoding: 0x2525C400
    // Test UQADD_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: sh=0, size=0, Zdn=0, imm8=32
    let encoding: u32 = 0x2525C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_uqadd_z_zi_field_imm8_63_poweroftwominusone_c000_2525c7e0() {
    // Encoding: 0x2525C7E0
    // Test UQADD_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=63, Zdn=0, sh=0
    let encoding: u32 = 0x2525C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_uqadd_z_zi_field_imm8_64_poweroftwo_c000_2525c800() {
    // Encoding: 0x2525C800
    // Test UQADD_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: sh=0, Zdn=0, size=0, imm8=64
    let encoding: u32 = 0x2525C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_uqadd_z_zi_field_imm8_127_poweroftwominusone_c000_2525cfe0() {
    // Encoding: 0x2525CFE0
    // Test UQADD_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=127, sh=0, size=0
    let encoding: u32 = 0x2525CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_uqadd_z_zi_field_imm8_128_poweroftwo_c000_2525d000() {
    // Encoding: 0x2525D000
    // Test UQADD_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: size=0, sh=0, imm8=128, Zdn=0
    let encoding: u32 = 0x2525D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_uqadd_z_zi_field_imm8_255_max_c000_2525dfe0() {
    // Encoding: 0x2525DFE0
    // Test UQADD_Z.ZI__ field imm8 = 255 (Max)
    // Fields: imm8=255, Zdn=0, size=0, sh=0
    let encoding: u32 = 0x2525DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uqadd_z_zi_field_zdn_0_min_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ field Zdn = 0 (Min)
    // Fields: imm8=0, Zdn=0, size=0, sh=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uqadd_z_zi_field_zdn_1_poweroftwo_c000_2525c001() {
    // Encoding: 0x2525C001
    // Test UQADD_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, sh=0, imm8=0, Zdn=1
    let encoding: u32 = 0x2525C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uqadd_z_zi_field_zdn_15_poweroftwominusone_c000_2525c00f() {
    // Encoding: 0x2525C00F
    // Test UQADD_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: sh=0, size=0, imm8=0, Zdn=15
    let encoding: u32 = 0x2525C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uqadd_z_zi_field_zdn_31_max_c000_2525c01f() {
    // Encoding: 0x2525C01F
    // Test UQADD_Z.ZI__ field Zdn = 31 (Max)
    // Fields: Zdn=31, sh=0, imm8=0, size=0
    let encoding: u32 = 0x2525C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uqadd_z_zi_combo_0_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ field combination: size=0, sh=0, imm8=0, Zdn=0
    // Fields: imm8=0, Zdn=0, size=0, sh=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uqadd_z_zi_special_size_0_size_variant_0_49152_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: size=0, sh=0, Zdn=0, imm8=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uqadd_z_zi_special_size_1_size_variant_1_49152_2565c000() {
    // Encoding: 0x2565C000
    // Test UQADD_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zdn=0, imm8=0, sh=0
    let encoding: u32 = 0x2565C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uqadd_z_zi_special_size_2_size_variant_2_49152_25a5c000() {
    // Encoding: 0x25A5C000
    // Test UQADD_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: imm8=0, sh=0, Zdn=0, size=2
    let encoding: u32 = 0x25A5C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uqadd_z_zi_special_size_3_size_variant_3_49152_25e5c000() {
    // Encoding: 0x25E5C000
    // Test UQADD_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: size=3, sh=0, imm8=0, Zdn=0
    let encoding: u32 = 0x25E5C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_uqadd_z_zi_special_sh_0_shift_type_lsl_49152_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ special value sh = 0 (Shift type LSL)
    // Fields: sh=0, size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_uqadd_z_zi_special_sh_1_shift_type_lsr_49152_2525e000() {
    // Encoding: 0x2525E000
    // Test UQADD_Z.ZI__ special value sh = 1 (Shift type LSR)
    // Fields: imm8=0, sh=1, Zdn=0, size=0
    let encoding: u32 = 0x2525E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_uqadd_z_zi_special_sh_2_shift_type_asr_49152_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ special value sh = 2 (Shift type ASR)
    // Fields: imm8=0, Zdn=0, size=0, sh=2
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_uqadd_z_zi_special_sh_3_shift_type_ror_49152_2525e000() {
    // Encoding: 0x2525E000
    // Test UQADD_Z.ZI__ special value sh = 3 (Shift type ROR)
    // Fields: imm8=0, sh=3, size=0, Zdn=0
    let encoding: u32 = 0x2525E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uqadd_z_zi_invalid_0_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, imm8=0, sh=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqadd_z_zi_invalid_1_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: sh=0, size=0, Zdn=0, imm8=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sh\" }), rhs: LitBits([false, false, true]) } }" }
/// triggers Undefined
#[test]
fn test_uqadd_z_zi_invalid_2_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }
    // Fields: imm8=0, sh=0, Zdn=0, size=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uqadd_z_zi_invalid_3_c000_2525c000() {
    // Encoding: 0x2525C000
    // Test UQADD_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, imm8=0, sh=0
    let encoding: u32 = 0x2525C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UQADD_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uqadd_z_zi_reg_write_0_2525c000() {
    // Test UQADD_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x2525C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2525C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTB_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clastb_z_p_zz_field_size_0_min_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clastb_z_p_zz_field_size_1_poweroftwo_8000_05698000() {
    // Encoding: 0x05698000
    // Test CLASTB_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x05698000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clastb_z_p_zz_field_size_2_poweroftwo_8000_05a98000() {
    // Encoding: 0x05A98000
    // Test CLASTB_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, Zdn=0, size=2
    let encoding: u32 = 0x05A98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clastb_z_p_zz_field_size_3_max_8000_05e98000() {
    // Encoding: 0x05E98000
    // Test CLASTB_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x05E98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clastb_z_p_zz_field_pg_0_min_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clastb_z_p_zz_field_pg_1_poweroftwo_8000_05298400() {
    // Encoding: 0x05298400
    // Test CLASTB_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=1, Zdn=0, size=0
    let encoding: u32 = 0x05298400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clastb_z_p_zz_field_zm_0_min_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clastb_z_p_zz_field_zm_1_poweroftwo_8000_05298020() {
    // Encoding: 0x05298020
    // Test CLASTB_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zm=1, Zdn=0
    let encoding: u32 = 0x05298020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clastb_z_p_zz_field_zm_30_poweroftwominusone_8000_052983c0() {
    // Encoding: 0x052983C0
    // Test CLASTB_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Pg=0, Zdn=0
    let encoding: u32 = 0x052983C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clastb_z_p_zz_field_zm_31_max_8000_052983e0() {
    // Encoding: 0x052983E0
    // Test CLASTB_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zdn=0, Zm=31, Pg=0
    let encoding: u32 = 0x052983E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clastb_z_p_zz_field_zdn_0_min_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clastb_z_p_zz_field_zdn_1_poweroftwo_8000_05298001() {
    // Encoding: 0x05298001
    // Test CLASTB_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=0, Zdn=1
    let encoding: u32 = 0x05298001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clastb_z_p_zz_field_zdn_15_poweroftwominusone_8000_0529800f() {
    // Encoding: 0x0529800F
    // Test CLASTB_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x0529800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clastb_z_p_zz_field_zdn_31_max_8000_0529801f() {
    // Encoding: 0x0529801F
    // Test CLASTB_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zdn=31, size=0
    let encoding: u32 = 0x0529801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clastb_z_p_zz_combo_0_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clastb_z_p_zz_special_size_0_size_variant_0_32768_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clastb_z_p_zz_special_size_1_size_variant_1_32768_05698000() {
    // Encoding: 0x05698000
    // Test CLASTB_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x05698000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clastb_z_p_zz_special_size_2_size_variant_2_32768_05a98000() {
    // Encoding: 0x05A98000
    // Test CLASTB_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, Pg=0, size=2, Zm=0
    let encoding: u32 = 0x05A98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clastb_z_p_zz_special_size_3_size_variant_3_32768_05e98000() {
    // Encoding: 0x05E98000
    // Test CLASTB_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zm=0, Zdn=0, size=3
    let encoding: u32 = 0x05E98000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clastb_z_p_zz_invalid_0_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clastb_z_p_zz_invalid_1_8000_05298000() {
    // Encoding: 0x05298000
    // Test CLASTB_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x05298000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTB_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_clastb_z_p_zz_reg_write_0_05298000() {
    // Test CLASTB_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x05298000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05298000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// MOVPRFX_Z.Z__ Tests
// ============================================================================

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_movprfx_z_z_field_zn_0_min_bc00_0420bc00() {
    // Encoding: 0x0420BC00
    // Test MOVPRFX_Z.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, Zd=0
    let encoding: u32 = 0x0420BC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_movprfx_z_z_field_zn_1_poweroftwo_bc00_0420bc20() {
    // Encoding: 0x0420BC20
    // Test MOVPRFX_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1
    let encoding: u32 = 0x0420BC20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_movprfx_z_z_field_zn_30_poweroftwominusone_bc00_0420bfc0() {
    // Encoding: 0x0420BFC0
    // Test MOVPRFX_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zd=0
    let encoding: u32 = 0x0420BFC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_movprfx_z_z_field_zn_31_max_bc00_0420bfe0() {
    // Encoding: 0x0420BFE0
    // Test MOVPRFX_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31
    let encoding: u32 = 0x0420BFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_movprfx_z_z_field_zd_0_min_bc00_0420bc00() {
    // Encoding: 0x0420BC00
    // Test MOVPRFX_Z.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, Zn=0
    let encoding: u32 = 0x0420BC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_movprfx_z_z_field_zd_1_poweroftwo_bc00_0420bc01() {
    // Encoding: 0x0420BC01
    // Test MOVPRFX_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=1
    let encoding: u32 = 0x0420BC01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_movprfx_z_z_field_zd_30_poweroftwominusone_bc00_0420bc1e() {
    // Encoding: 0x0420BC1E
    // Test MOVPRFX_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zn=0
    let encoding: u32 = 0x0420BC1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_movprfx_z_z_field_zd_31_max_bc00_0420bc1f() {
    // Encoding: 0x0420BC1F
    // Test MOVPRFX_Z.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31
    let encoding: u32 = 0x0420BC1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zn=0 (SIMD register V0)
#[test]
fn test_movprfx_z_z_combo_0_bc00_0420bc00() {
    // Encoding: 0x0420BC00
    // Test MOVPRFX_Z.Z__ field combination: Zn=0, Zd=0
    // Fields: Zd=0, Zn=0
    let encoding: u32 = 0x0420BC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_movprfx_z_z_invalid_0_bc00_0420bc00() {
    // Encoding: 0x0420BC00
    // Test MOVPRFX_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0
    let encoding: u32 = 0x0420BC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_movprfx_z_z_invalid_1_bc00_0420bc00() {
    // Encoding: 0x0420BC00
    // Test MOVPRFX_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0
    let encoding: u32 = 0x0420BC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_movprfx_z_z_reg_write_0_0420bc00() {
    // Test MOVPRFX_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x0420BC00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420BC00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UDOT_Z.ZZZi_S Tests
// ============================================================================

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udot_z_zzzi_s_field_i2_0_min_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S field i2 = 0 (Min)
    // Fields: Zm=0, i2=0, Zn=0, Zda=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_udot_z_zzzi_s_field_i2_1_poweroftwo_400_44a80400() {
    // Encoding: 0x44A80400
    // Test UDOT_Z.ZZZi_S field i2 = 1 (PowerOfTwo)
    // Fields: Zm=0, i2=1, Zn=0, Zda=0
    let encoding: u32 = 0x44A80400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_udot_z_zzzi_s_field_i2_3_max_400_44b80400() {
    // Encoding: 0x44B80400
    // Test UDOT_Z.ZZZi_S field i2 = 3 (Max)
    // Fields: Zda=0, Zm=0, Zn=0, i2=3
    let encoding: u32 = 0x44B80400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udot_z_zzzi_s_field_zm_0_min_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S field Zm = 0 (Min)
    // Fields: Zn=0, Zm=0, i2=0, Zda=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udot_z_zzzi_s_field_zm_1_poweroftwo_400_44a10400() {
    // Encoding: 0x44A10400
    // Test UDOT_Z.ZZZi_S field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, i2=0, Zn=0, Zda=0
    let encoding: u32 = 0x44A10400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udot_z_zzzi_s_field_zn_0_min_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S field Zn = 0 (Min)
    // Fields: Zn=0, i2=0, Zda=0, Zm=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udot_z_zzzi_s_field_zn_1_poweroftwo_400_44a00420() {
    // Encoding: 0x44A00420
    // Test UDOT_Z.ZZZi_S field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, i2=0, Zn=1, Zda=0
    let encoding: u32 = 0x44A00420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_udot_z_zzzi_s_field_zn_30_poweroftwominusone_400_44a007c0() {
    // Encoding: 0x44A007C0
    // Test UDOT_Z.ZZZi_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: i2=0, Zn=30, Zm=0, Zda=0
    let encoding: u32 = 0x44A007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_udot_z_zzzi_s_field_zn_31_max_400_44a007e0() {
    // Encoding: 0x44A007E0
    // Test UDOT_Z.ZZZi_S field Zn = 31 (Max)
    // Fields: Zn=31, Zda=0, i2=0, Zm=0
    let encoding: u32 = 0x44A007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udot_z_zzzi_s_field_zda_0_min_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S field Zda = 0 (Min)
    // Fields: Zm=0, Zda=0, Zn=0, i2=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_udot_z_zzzi_s_field_zda_1_poweroftwo_400_44a00401() {
    // Encoding: 0x44A00401
    // Test UDOT_Z.ZZZi_S field Zda = 1 (PowerOfTwo)
    // Fields: Zm=0, i2=0, Zda=1, Zn=0
    let encoding: u32 = 0x44A00401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_udot_z_zzzi_s_field_zda_15_poweroftwominusone_400_44a0040f() {
    // Encoding: 0x44A0040F
    // Test UDOT_Z.ZZZi_S field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, i2=0, Zda=15
    let encoding: u32 = 0x44A0040F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_udot_z_zzzi_s_field_zda_31_max_400_44a0041f() {
    // Encoding: 0x44A0041F
    // Test UDOT_Z.ZZZi_S field Zda = 31 (Max)
    // Fields: Zn=0, Zm=0, i2=0, Zda=31
    let encoding: u32 = 0x44A0041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i2=0 (minimum value)
#[test]
fn test_udot_z_zzzi_s_combo_0_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S field combination: i2=0, Zm=0, Zn=0, Zda=0
    // Fields: i2=0, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_udot_z_zzzi_s_invalid_0_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i2=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udot_z_zzzi_s_invalid_1_400_44a00400() {
    // Encoding: 0x44A00400
    // Test UDOT_Z.ZZZi_S invalid encoding: Unconditional UNDEFINED
    // Fields: Zda=0, i2=0, Zn=0, Zm=0
    let encoding: u32 = 0x44A00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udot_z_zzzi_d_field_i1_0_min_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D field i1 = 0 (Min)
    // Fields: i1=0, Zda=0, Zn=0, Zm=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_udot_z_zzzi_d_field_i1_1_max_400_44f00400() {
    // Encoding: 0x44F00400
    // Test UDOT_Z.ZZZi_D field i1 = 1 (Max)
    // Fields: i1=1, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44F00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udot_z_zzzi_d_field_zm_0_min_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D field Zm = 0 (Min)
    // Fields: Zn=0, Zda=0, i1=0, Zm=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udot_z_zzzi_d_field_zm_1_poweroftwo_400_44e10400() {
    // Encoding: 0x44E10400
    // Test UDOT_Z.ZZZi_D field Zm = 1 (PowerOfTwo)
    // Fields: i1=0, Zm=1, Zn=0, Zda=0
    let encoding: u32 = 0x44E10400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_udot_z_zzzi_d_field_zn_0_min_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D field Zn = 0 (Min)
    // Fields: Zda=0, i1=0, Zn=0, Zm=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_udot_z_zzzi_d_field_zn_1_poweroftwo_400_44e00420() {
    // Encoding: 0x44E00420
    // Test UDOT_Z.ZZZi_D field Zn = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=1, i1=0, Zm=0
    let encoding: u32 = 0x44E00420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_udot_z_zzzi_d_field_zn_30_poweroftwominusone_400_44e007c0() {
    // Encoding: 0x44E007C0
    // Test UDOT_Z.ZZZi_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, i1=0, Zm=0, Zda=0
    let encoding: u32 = 0x44E007C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_udot_z_zzzi_d_field_zn_31_max_400_44e007e0() {
    // Encoding: 0x44E007E0
    // Test UDOT_Z.ZZZi_D field Zn = 31 (Max)
    // Fields: Zda=0, i1=0, Zn=31, Zm=0
    let encoding: u32 = 0x44E007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_udot_z_zzzi_d_field_zda_0_min_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D field Zda = 0 (Min)
    // Fields: Zda=0, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_udot_z_zzzi_d_field_zda_1_poweroftwo_400_44e00401() {
    // Encoding: 0x44E00401
    // Test UDOT_Z.ZZZi_D field Zda = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zda=1, i1=0
    let encoding: u32 = 0x44E00401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_udot_z_zzzi_d_field_zda_15_poweroftwominusone_400_44e0040f() {
    // Encoding: 0x44E0040F
    // Test UDOT_Z.ZZZi_D field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, Zda=15, i1=0
    let encoding: u32 = 0x44E0040F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_udot_z_zzzi_d_field_zda_31_max_400_44e0041f() {
    // Encoding: 0x44E0041F
    // Test UDOT_Z.ZZZi_D field Zda = 31 (Max)
    // Fields: Zda=31, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x44E0041F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_udot_z_zzzi_d_combo_0_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D field combination: i1=0, Zm=0, Zn=0, Zda=0
    // Fields: Zm=0, i1=0, Zn=0, Zda=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_udot_z_zzzi_d_invalid_0_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: i1=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_udot_z_zzzi_d_invalid_1_400_44e00400() {
    // Encoding: 0x44E00400
    // Test UDOT_Z.ZZZi_D invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, i1=0, Zm=0, Zda=0
    let encoding: u32 = 0x44E00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UDOT_Z.ZZZi_S
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_udot_z_zzzi_s_reg_write_0_44a00400() {
    // Test UDOT_Z.ZZZi_S register write: SimdFromField("da")
    // Encoding: 0x44A00400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x44A00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UDOT_Z.ZZZi_D
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_udot_z_zzzi_d_reg_write_0_44e00400() {
    // Test UDOT_Z.ZZZi_D register write: SimdFromField("da")
    // Encoding: 0x44E00400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x44E00400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ZIP2_P.PP__ Tests
// ============================================================================

/// Provenance: ZIP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_zip2_p_pp_field_size_0_min_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ field size = 0 (Min)
    // Fields: size=0, Pd=0, Pn=0, Pm=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_zip2_p_pp_field_size_1_poweroftwo_4400_05604400() {
    // Encoding: 0x05604400
    // Test ZIP2_P.PP__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_zip2_p_pp_field_size_2_poweroftwo_4400_05a04400() {
    // Encoding: 0x05A04400
    // Test ZIP2_P.PP__ field size = 2 (PowerOfTwo)
    // Fields: Pn=0, Pd=0, size=2, Pm=0
    let encoding: u32 = 0x05A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_zip2_p_pp_field_size_3_max_4400_05e04400() {
    // Encoding: 0x05E04400
    // Test ZIP2_P.PP__ field size = 3 (Max)
    // Fields: Pn=0, Pm=0, Pd=0, size=3
    let encoding: u32 = 0x05E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_zip2_p_pp_field_pm_0_min_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ field Pm = 0 (Min)
    // Fields: size=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_zip2_p_pp_field_pm_1_poweroftwo_4400_05214400() {
    // Encoding: 0x05214400
    // Test ZIP2_P.PP__ field Pm = 1 (PowerOfTwo)
    // Fields: size=0, Pm=1, Pn=0, Pd=0
    let encoding: u32 = 0x05214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_zip2_p_pp_field_pn_0_min_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ field Pn = 0 (Min)
    // Fields: size=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_zip2_p_pp_field_pn_1_poweroftwo_4400_05204420() {
    // Encoding: 0x05204420
    // Test ZIP2_P.PP__ field Pn = 1 (PowerOfTwo)
    // Fields: Pd=0, Pn=1, Pm=0, size=0
    let encoding: u32 = 0x05204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_zip2_p_pp_field_pd_0_min_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ field Pd = 0 (Min)
    // Fields: Pd=0, Pm=0, size=0, Pn=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_zip2_p_pp_field_pd_1_poweroftwo_4400_05204401() {
    // Encoding: 0x05204401
    // Test ZIP2_P.PP__ field Pd = 1 (PowerOfTwo)
    // Fields: Pm=0, Pn=0, Pd=1, size=0
    let encoding: u32 = 0x05204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_zip2_p_pp_combo_0_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ field combination: size=0, Pm=0, Pn=0, Pd=0
    // Fields: Pm=0, Pd=0, Pn=0, size=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_zip2_p_pp_special_size_0_size_variant_0_17408_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_zip2_p_pp_special_size_1_size_variant_1_17408_05604400() {
    // Encoding: 0x05604400
    // Test ZIP2_P.PP__ special value size = 1 (Size variant 1)
    // Fields: Pd=0, Pn=0, Pm=0, size=1
    let encoding: u32 = 0x05604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_zip2_p_pp_special_size_2_size_variant_2_17408_05a04400() {
    // Encoding: 0x05A04400
    // Test ZIP2_P.PP__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pm=0, Pd=0, Pn=0
    let encoding: u32 = 0x05A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_zip2_p_pp_special_size_3_size_variant_3_17408_05e04400() {
    // Encoding: 0x05E04400
    // Test ZIP2_P.PP__ special value size = 3 (Size variant 3)
    // Fields: Pm=0, Pd=0, Pn=0, size=3
    let encoding: u32 = 0x05E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_zip2_p_pp_invalid_0_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pm=0, Pn=0, Pd=0, size=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_zip2_p_pp_invalid_1_4400_05204400() {
    // Encoding: 0x05204400
    // Test ZIP2_P.PP__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pm=0, Pd=0, Pn=0, size=0
    let encoding: u32 = 0x05204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_zip1_p_pp_field_size_0_min_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ field size = 0 (Min)
    // Fields: Pd=0, size=0, Pm=0, Pn=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_zip1_p_pp_field_size_1_poweroftwo_4000_05604000() {
    // Encoding: 0x05604000
    // Test ZIP1_P.PP__ field size = 1 (PowerOfTwo)
    // Fields: Pn=0, size=1, Pm=0, Pd=0
    let encoding: u32 = 0x05604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_zip1_p_pp_field_size_2_poweroftwo_4000_05a04000() {
    // Encoding: 0x05A04000
    // Test ZIP1_P.PP__ field size = 2 (PowerOfTwo)
    // Fields: Pm=0, size=2, Pn=0, Pd=0
    let encoding: u32 = 0x05A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_zip1_p_pp_field_size_3_max_4000_05e04000() {
    // Encoding: 0x05E04000
    // Test ZIP1_P.PP__ field size = 3 (Max)
    // Fields: Pm=0, Pn=0, size=3, Pd=0
    let encoding: u32 = 0x05E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_zip1_p_pp_field_pm_0_min_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ field Pm = 0 (Min)
    // Fields: size=0, Pd=0, Pm=0, Pn=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_zip1_p_pp_field_pm_1_poweroftwo_4000_05214000() {
    // Encoding: 0x05214000
    // Test ZIP1_P.PP__ field Pm = 1 (PowerOfTwo)
    // Fields: Pn=0, Pm=1, size=0, Pd=0
    let encoding: u32 = 0x05214000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_zip1_p_pp_field_pn_0_min_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ field Pn = 0 (Min)
    // Fields: Pm=0, Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_zip1_p_pp_field_pn_1_poweroftwo_4000_05204020() {
    // Encoding: 0x05204020
    // Test ZIP1_P.PP__ field Pn = 1 (PowerOfTwo)
    // Fields: size=0, Pm=0, Pn=1, Pd=0
    let encoding: u32 = 0x05204020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_zip1_p_pp_field_pd_0_min_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ field Pd = 0 (Min)
    // Fields: Pn=0, Pm=0, Pd=0, size=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_zip1_p_pp_field_pd_1_poweroftwo_4000_05204001() {
    // Encoding: 0x05204001
    // Test ZIP1_P.PP__ field Pd = 1 (PowerOfTwo)
    // Fields: size=0, Pd=1, Pn=0, Pm=0
    let encoding: u32 = 0x05204001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_zip1_p_pp_combo_0_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ field combination: size=0, Pm=0, Pn=0, Pd=0
    // Fields: Pm=0, size=0, Pd=0, Pn=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_zip1_p_pp_special_size_0_size_variant_0_16384_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ special value size = 0 (Size variant 0)
    // Fields: Pd=0, size=0, Pm=0, Pn=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_zip1_p_pp_special_size_1_size_variant_1_16384_05604000() {
    // Encoding: 0x05604000
    // Test ZIP1_P.PP__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pd=0, Pm=0, Pn=0
    let encoding: u32 = 0x05604000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_zip1_p_pp_special_size_2_size_variant_2_16384_05a04000() {
    // Encoding: 0x05A04000
    // Test ZIP1_P.PP__ special value size = 2 (Size variant 2)
    // Fields: Pm=0, Pn=0, Pd=0, size=2
    let encoding: u32 = 0x05A04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_zip1_p_pp_special_size_3_size_variant_3_16384_05e04000() {
    // Encoding: 0x05E04000
    // Test ZIP1_P.PP__ special value size = 3 (Size variant 3)
    // Fields: Pm=0, Pn=0, size=3, Pd=0
    let encoding: u32 = 0x05E04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_zip1_p_pp_invalid_0_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pn=0, size=0, Pd=0, Pm=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP1_P.PP__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_zip1_p_pp_invalid_1_4000_05204000() {
    // Encoding: 0x05204000
    // Test ZIP1_P.PP__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pn=0, Pd=0, size=0, Pm=0
    let encoding: u32 = 0x05204000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ZIP2_P.PP__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_zip2_p_pp_reg_write_0_05204400() {
    // Test ZIP2_P.PP__ register write: SimdFromField("Pd")
    // Encoding: 0x05204400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05204400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ZIP1_P.PP__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_zip1_p_pp_reg_write_0_05204000() {
    // Test ZIP1_P.PP__ register write: SimdFromField("Pd")
    // Encoding: 0x05204000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05204000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// MOVPRFX_Z.P.Z__ Tests
// ============================================================================

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_movprfx_z_p_z_field_size_0_min_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, M=0, Pg=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_movprfx_z_p_z_field_size_1_poweroftwo_2000_04502000() {
    // Encoding: 0x04502000
    // Test MOVPRFX_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, M=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x04502000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_movprfx_z_p_z_field_size_2_poweroftwo_2000_04902000() {
    // Encoding: 0x04902000
    // Test MOVPRFX_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, M=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x04902000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_movprfx_z_p_z_field_size_3_max_2000_04d02000() {
    // Encoding: 0x04D02000
    // Test MOVPRFX_Z.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, M=0, size=3, Pg=0, Zd=0
    let encoding: u32 = 0x04D02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field M 16 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_movprfx_z_p_z_field_m_0_min_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ field M = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, M=0, Pg=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field M 16 +: 1`
/// Requirement: FieldBoundary { field: "M", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_movprfx_z_p_z_field_m_1_max_2000_04112000() {
    // Encoding: 0x04112000
    // Test MOVPRFX_Z.P.Z__ field M = 1 (Max)
    // Fields: Zd=0, M=1, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x04112000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_movprfx_z_p_z_field_pg_0_min_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ field Pg = 0 (Min)
    // Fields: M=0, Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_movprfx_z_p_z_field_pg_1_poweroftwo_2000_04102400() {
    // Encoding: 0x04102400
    // Test MOVPRFX_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: M=0, size=0, Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x04102400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_movprfx_z_p_z_field_zn_0_min_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Pg=0, Zd=0, M=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_movprfx_z_p_z_field_zn_1_poweroftwo_2000_04102020() {
    // Encoding: 0x04102020
    // Test MOVPRFX_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, size=0, Zn=1, M=0
    let encoding: u32 = 0x04102020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_movprfx_z_p_z_field_zn_30_poweroftwominusone_2000_041023c0() {
    // Encoding: 0x041023C0
    // Test MOVPRFX_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zd=0, size=0, M=0, Zn=30
    let encoding: u32 = 0x041023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_movprfx_z_p_z_field_zn_31_max_2000_041023e0() {
    // Encoding: 0x041023E0
    // Test MOVPRFX_Z.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Zd=0, M=0, Pg=0
    let encoding: u32 = 0x041023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_movprfx_z_p_z_field_zd_0_min_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, Zn=0, Pg=0, M=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_movprfx_z_p_z_field_zd_1_poweroftwo_2000_04102001() {
    // Encoding: 0x04102001
    // Test MOVPRFX_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, M=0, Pg=0, Zd=1, Zn=0
    let encoding: u32 = 0x04102001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_movprfx_z_p_z_field_zd_30_poweroftwominusone_2000_0410201e() {
    // Encoding: 0x0410201E
    // Test MOVPRFX_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, M=0, Pg=0, Zn=0
    let encoding: u32 = 0x0410201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_movprfx_z_p_z_field_zd_31_max_2000_0410201f() {
    // Encoding: 0x0410201F
    // Test MOVPRFX_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, M=0, Pg=0, size=0
    let encoding: u32 = 0x0410201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_movprfx_z_p_z_combo_0_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ field combination: size=0, M=0, Pg=0, Zn=0, Zd=0
    // Fields: M=0, size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_movprfx_z_p_z_special_size_0_size_variant_0_8192_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, M=0, Zn=0, Zd=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_movprfx_z_p_z_special_size_1_size_variant_1_8192_04502000() {
    // Encoding: 0x04502000
    // Test MOVPRFX_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, M=0, Zd=0, Pg=0
    let encoding: u32 = 0x04502000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_movprfx_z_p_z_special_size_2_size_variant_2_8192_04902000() {
    // Encoding: 0x04902000
    // Test MOVPRFX_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: M=0, Pg=0, Zn=0, size=2, Zd=0
    let encoding: u32 = 0x04902000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_movprfx_z_p_z_special_size_3_size_variant_3_8192_04d02000() {
    // Encoding: 0x04D02000
    // Test MOVPRFX_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, M=0, size=3, Zd=0, Zn=0
    let encoding: u32 = 0x04D02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_movprfx_z_p_z_invalid_0_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Zd=0, M=0, Pg=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_movprfx_z_p_z_invalid_1_2000_04102000() {
    // Encoding: 0x04102000
    // Test MOVPRFX_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Zn=0, M=0, size=0
    let encoding: u32 = 0x04102000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MOVPRFX_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_movprfx_z_p_z_reg_write_0_04102000() {
    // Test MOVPRFX_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04102000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04102000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLZ_Z.P.Z__ Tests
// ============================================================================

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clz_z_p_z_field_size_0_min_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ field size = 0 (Min)
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clz_z_p_z_field_size_1_poweroftwo_a000_0459a000() {
    // Encoding: 0x0459A000
    // Test CLZ_Z.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zd=0, Zn=0
    let encoding: u32 = 0x0459A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clz_z_p_z_field_size_2_poweroftwo_a000_0499a000() {
    // Encoding: 0x0499A000
    // Test CLZ_Z.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=2, Pg=0
    let encoding: u32 = 0x0499A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clz_z_p_z_field_size_3_max_a000_04d9a000() {
    // Encoding: 0x04D9A000
    // Test CLZ_Z.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zd=0, Zn=0, size=3
    let encoding: u32 = 0x04D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clz_z_p_z_field_pg_0_min_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clz_z_p_z_field_pg_1_poweroftwo_a000_0419a400() {
    // Encoding: 0x0419A400
    // Test CLZ_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, size=0, Zd=0, Pg=1
    let encoding: u32 = 0x0419A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clz_z_p_z_field_zn_0_min_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clz_z_p_z_field_zn_1_poweroftwo_a000_0419a020() {
    // Encoding: 0x0419A020
    // Test CLZ_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, Pg=0, size=0
    let encoding: u32 = 0x0419A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clz_z_p_z_field_zn_30_poweroftwominusone_a000_0419a3c0() {
    // Encoding: 0x0419A3C0
    // Test CLZ_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x0419A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clz_z_p_z_field_zn_31_max_a000_0419a3e0() {
    // Encoding: 0x0419A3E0
    // Test CLZ_Z.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, size=0, Zn=31, Zd=0
    let encoding: u32 = 0x0419A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clz_z_p_z_field_zd_0_min_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clz_z_p_z_field_zd_1_poweroftwo_a000_0419a001() {
    // Encoding: 0x0419A001
    // Test CLZ_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, Zd=1, size=0
    let encoding: u32 = 0x0419A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clz_z_p_z_field_zd_30_poweroftwominusone_a000_0419a01e() {
    // Encoding: 0x0419A01E
    // Test CLZ_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Zd=30, Pg=0
    let encoding: u32 = 0x0419A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clz_z_p_z_field_zd_31_max_a000_0419a01f() {
    // Encoding: 0x0419A01F
    // Test CLZ_Z.P.Z__ field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x0419A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clz_z_p_z_combo_0_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clz_z_p_z_special_size_0_size_variant_0_40960_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clz_z_p_z_special_size_1_size_variant_1_40960_0459a000() {
    // Encoding: 0x0459A000
    // Test CLZ_Z.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x0459A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clz_z_p_z_special_size_2_size_variant_2_40960_0499a000() {
    // Encoding: 0x0499A000
    // Test CLZ_Z.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, Pg=0, size=2
    let encoding: u32 = 0x0499A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clz_z_p_z_special_size_3_size_variant_3_40960_04d9a000() {
    // Encoding: 0x04D9A000
    // Test CLZ_Z.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zd=0, Zn=0
    let encoding: u32 = 0x04D9A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clz_z_p_z_invalid_0_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clz_z_p_z_invalid_1_a000_0419a000() {
    // Encoding: 0x0419A000
    // Test CLZ_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0419A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLZ_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_clz_z_p_z_reg_write_0_0419a000() {
    // Test CLZ_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x0419A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0419A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMAX_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umax_z_p_zz_field_size_0_min_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umax_z_p_zz_field_size_1_poweroftwo_0_04490000() {
    // Encoding: 0x04490000
    // Test UMAX_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04490000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umax_z_p_zz_field_size_2_poweroftwo_0_04890000() {
    // Encoding: 0x04890000
    // Test UMAX_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zdn=0, Zm=0
    let encoding: u32 = 0x04890000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umax_z_p_zz_field_size_3_max_0_04c90000() {
    // Encoding: 0x04C90000
    // Test UMAX_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Zm=0, Zdn=0
    let encoding: u32 = 0x04C90000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_umax_z_p_zz_field_pg_0_min_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_umax_z_p_zz_field_pg_1_poweroftwo_0_04090400() {
    // Encoding: 0x04090400
    // Test UMAX_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Pg=1, Zdn=0
    let encoding: u32 = 0x04090400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_umax_z_p_zz_field_zm_0_min_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_umax_z_p_zz_field_zm_1_poweroftwo_0_04090020() {
    // Encoding: 0x04090020
    // Test UMAX_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x04090020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_umax_z_p_zz_field_zm_30_poweroftwominusone_0_040903c0() {
    // Encoding: 0x040903C0
    // Test UMAX_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, Zdn=0, size=0
    let encoding: u32 = 0x040903C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_umax_z_p_zz_field_zm_31_max_0_040903e0() {
    // Encoding: 0x040903E0
    // Test UMAX_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x040903E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_umax_z_p_zz_field_zdn_0_min_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_umax_z_p_zz_field_zdn_1_poweroftwo_0_04090001() {
    // Encoding: 0x04090001
    // Test UMAX_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zdn=1, Zm=0
    let encoding: u32 = 0x04090001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_umax_z_p_zz_field_zdn_15_poweroftwominusone_0_0409000f() {
    // Encoding: 0x0409000F
    // Test UMAX_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=0, Zdn=15
    let encoding: u32 = 0x0409000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_umax_z_p_zz_field_zdn_31_max_0_0409001f() {
    // Encoding: 0x0409001F
    // Test UMAX_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zm=0, Zdn=31, size=0
    let encoding: u32 = 0x0409001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umax_z_p_zz_combo_0_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umax_z_p_zz_special_size_0_size_variant_0_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umax_z_p_zz_special_size_1_size_variant_1_0_04490000() {
    // Encoding: 0x04490000
    // Test UMAX_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Pg=0, Zdn=0
    let encoding: u32 = 0x04490000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umax_z_p_zz_special_size_2_size_variant_2_0_04890000() {
    // Encoding: 0x04890000
    // Test UMAX_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, size=2, Pg=0, Zm=0
    let encoding: u32 = 0x04890000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umax_z_p_zz_special_size_3_size_variant_3_0_04c90000() {
    // Encoding: 0x04C90000
    // Test UMAX_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zm=0, size=3, Zdn=0
    let encoding: u32 = 0x04C90000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umax_z_p_zz_invalid_0_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umax_z_p_zz_invalid_1_0_04090000() {
    // Encoding: 0x04090000
    // Test UMAX_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04090000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMAX_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_umax_z_p_zz_reg_write_0_04090000() {
    // Test UMAX_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04090000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04090000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ASR_Z.P.ZI__ Tests
// ============================================================================

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_p_zi_field_tszh_0_min_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ field tszh = 0 (Min)
    // Fields: Zdn=0, imm3=0, tszh=0, Pg=0, tszl=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_p_zi_field_tszh_1_poweroftwo_8000_04408000() {
    // Encoding: 0x04408000
    // Test ASR_Z.P.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: tszh=1, tszl=0, Pg=0, Zdn=0, imm3=0
    let encoding: u32 = 0x04408000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_asr_z_p_zi_field_tszh_3_max_8000_04c08000() {
    // Encoding: 0x04C08000
    // Test ASR_Z.P.ZI__ field tszh = 3 (Max)
    // Fields: tszh=3, imm3=0, Pg=0, tszl=0, Zdn=0
    let encoding: u32 = 0x04C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_asr_z_p_zi_field_pg_0_min_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ field Pg = 0 (Min)
    // Fields: tszl=0, tszh=0, Pg=0, Zdn=0, imm3=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_asr_z_p_zi_field_pg_1_poweroftwo_8000_04008400() {
    // Encoding: 0x04008400
    // Test ASR_Z.P.ZI__ field Pg = 1 (PowerOfTwo)
    // Fields: imm3=0, tszl=0, tszh=0, Zdn=0, Pg=1
    let encoding: u32 = 0x04008400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_p_zi_field_tszl_0_min_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ field tszl = 0 (Min)
    // Fields: tszh=0, tszl=0, Zdn=0, imm3=0, Pg=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_p_zi_field_tszl_1_poweroftwo_8000_04008100() {
    // Encoding: 0x04008100
    // Test ASR_Z.P.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: imm3=0, tszh=0, Zdn=0, tszl=1, Pg=0
    let encoding: u32 = 0x04008100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_asr_z_p_zi_field_tszl_3_max_8000_04008300() {
    // Encoding: 0x04008300
    // Test ASR_Z.P.ZI__ field tszl = 3 (Max)
    // Fields: tszh=0, Pg=0, imm3=0, Zdn=0, tszl=3
    let encoding: u32 = 0x04008300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_asr_z_p_zi_field_imm3_0_zero_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ field imm3 = 0 (Zero)
    // Fields: imm3=0, Zdn=0, tszl=0, tszh=0, Pg=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_asr_z_p_zi_field_imm3_1_poweroftwo_8000_04008020() {
    // Encoding: 0x04008020
    // Test ASR_Z.P.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszl=0, tszh=0, Pg=0, imm3=1, Zdn=0
    let encoding: u32 = 0x04008020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_asr_z_p_zi_field_imm3_3_poweroftwominusone_8000_04008060() {
    // Encoding: 0x04008060
    // Test ASR_Z.P.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Pg=0, tszh=0, tszl=0, imm3=3
    let encoding: u32 = 0x04008060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_asr_z_p_zi_field_imm3_7_max_8000_040080e0() {
    // Encoding: 0x040080E0
    // Test ASR_Z.P.ZI__ field imm3 = 7 (Max)
    // Fields: tszl=0, imm3=7, Zdn=0, tszh=0, Pg=0
    let encoding: u32 = 0x040080E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_p_zi_field_zdn_0_min_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ field Zdn = 0 (Min)
    // Fields: Pg=0, tszh=0, tszl=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_p_zi_field_zdn_1_poweroftwo_8000_04008001() {
    // Encoding: 0x04008001
    // Test ASR_Z.P.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, imm3=0, Zdn=1, Pg=0
    let encoding: u32 = 0x04008001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_asr_z_p_zi_field_zdn_15_poweroftwominusone_8000_0400800f() {
    // Encoding: 0x0400800F
    // Test ASR_Z.P.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, imm3=0, tszl=0, tszh=0, Zdn=15
    let encoding: u32 = 0x0400800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_asr_z_p_zi_field_zdn_31_max_8000_0400801f() {
    // Encoding: 0x0400801F
    // Test ASR_Z.P.ZI__ field Zdn = 31 (Max)
    // Fields: tszl=0, imm3=0, tszh=0, Pg=0, Zdn=31
    let encoding: u32 = 0x0400801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_asr_z_p_zi_combo_0_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Zdn=0, Pg=0, tszh=0, tszl=0, imm3=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zi_invalid_0_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszh=0, imm3=0, Pg=0, Zdn=0, tszl=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zi_invalid_1_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszh=0, tszl=0, Pg=0, imm3=0, Zdn=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zi_invalid_2_8000_04008000() {
    // Encoding: 0x04008000
    // Test ASR_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszl=0, tszh=0, imm3=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04008000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_asr_z_p_zi_reg_write_0_04008000() {
    // Test ASR_Z.P.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x04008000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04008000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMAX_Z.ZI__ Tests
// ============================================================================

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umax_z_zi_field_size_0_min_c000_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ field size = 0 (Min)
    // Fields: size=0, Zdn=0, imm8=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umax_z_zi_field_size_1_poweroftwo_c000_2569c000() {
    // Encoding: 0x2569C000
    // Test UMAX_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: size=1, imm8=0, Zdn=0
    let encoding: u32 = 0x2569C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umax_z_zi_field_size_2_poweroftwo_c000_25a9c000() {
    // Encoding: 0x25A9C000
    // Test UMAX_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: imm8=0, size=2, Zdn=0
    let encoding: u32 = 0x25A9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umax_z_zi_field_size_3_max_c000_25e9c000() {
    // Encoding: 0x25E9C000
    // Test UMAX_Z.ZI__ field size = 3 (Max)
    // Fields: size=3, imm8=0, Zdn=0
    let encoding: u32 = 0x25E9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_umax_z_zi_field_imm8_0_zero_c000_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_umax_z_zi_field_imm8_1_poweroftwo_c000_2529c020() {
    // Encoding: 0x2529C020
    // Test UMAX_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, imm8=1
    let encoding: u32 = 0x2529C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_umax_z_zi_field_imm8_3_poweroftwominusone_c000_2529c060() {
    // Encoding: 0x2529C060
    // Test UMAX_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=3, Zdn=0
    let encoding: u32 = 0x2529C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_umax_z_zi_field_imm8_4_poweroftwo_c000_2529c080() {
    // Encoding: 0x2529C080
    // Test UMAX_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, imm8=4, Zdn=0
    let encoding: u32 = 0x2529C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_umax_z_zi_field_imm8_7_poweroftwominusone_c000_2529c0e0() {
    // Encoding: 0x2529C0E0
    // Test UMAX_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=7, Zdn=0
    let encoding: u32 = 0x2529C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_umax_z_zi_field_imm8_8_poweroftwo_c000_2529c100() {
    // Encoding: 0x2529C100
    // Test UMAX_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: imm8=8, Zdn=0, size=0
    let encoding: u32 = 0x2529C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_umax_z_zi_field_imm8_15_poweroftwominusone_c000_2529c1e0() {
    // Encoding: 0x2529C1E0
    // Test UMAX_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=15, size=0
    let encoding: u32 = 0x2529C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_umax_z_zi_field_imm8_16_poweroftwo_c000_2529c200() {
    // Encoding: 0x2529C200
    // Test UMAX_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: size=0, Zdn=0, imm8=16
    let encoding: u32 = 0x2529C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_umax_z_zi_field_imm8_31_poweroftwominusone_c000_2529c3e0() {
    // Encoding: 0x2529C3E0
    // Test UMAX_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: imm8=31, size=0, Zdn=0
    let encoding: u32 = 0x2529C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_umax_z_zi_field_imm8_32_poweroftwo_c000_2529c400() {
    // Encoding: 0x2529C400
    // Test UMAX_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: imm8=32, Zdn=0, size=0
    let encoding: u32 = 0x2529C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_umax_z_zi_field_imm8_63_poweroftwominusone_c000_2529c7e0() {
    // Encoding: 0x2529C7E0
    // Test UMAX_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, imm8=63
    let encoding: u32 = 0x2529C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_umax_z_zi_field_imm8_64_poweroftwo_c000_2529c800() {
    // Encoding: 0x2529C800
    // Test UMAX_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: Zdn=0, size=0, imm8=64
    let encoding: u32 = 0x2529C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_umax_z_zi_field_imm8_127_poweroftwominusone_c000_2529cfe0() {
    // Encoding: 0x2529CFE0
    // Test UMAX_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, imm8=127
    let encoding: u32 = 0x2529CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_umax_z_zi_field_imm8_128_poweroftwo_c000_2529d000() {
    // Encoding: 0x2529D000
    // Test UMAX_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: size=0, imm8=128, Zdn=0
    let encoding: u32 = 0x2529D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_umax_z_zi_field_imm8_255_max_c000_2529dfe0() {
    // Encoding: 0x2529DFE0
    // Test UMAX_Z.ZI__ field imm8 = 255 (Max)
    // Fields: size=0, Zdn=0, imm8=255
    let encoding: u32 = 0x2529DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_umax_z_zi_field_zdn_0_min_c000_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_umax_z_zi_field_zdn_1_poweroftwo_c000_2529c001() {
    // Encoding: 0x2529C001
    // Test UMAX_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm8=0, Zdn=1, size=0
    let encoding: u32 = 0x2529C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_umax_z_zi_field_zdn_15_poweroftwominusone_c000_2529c00f() {
    // Encoding: 0x2529C00F
    // Test UMAX_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=0, size=0, Zdn=15
    let encoding: u32 = 0x2529C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_umax_z_zi_field_zdn_31_max_c000_2529c01f() {
    // Encoding: 0x2529C01F
    // Test UMAX_Z.ZI__ field Zdn = 31 (Max)
    // Fields: imm8=0, size=0, Zdn=31
    let encoding: u32 = 0x2529C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umax_z_zi_combo_0_c000_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umax_z_zi_special_size_0_size_variant_0_49152_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umax_z_zi_special_size_1_size_variant_1_49152_2569c000() {
    // Encoding: 0x2569C000
    // Test UMAX_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: size=1, imm8=0, Zdn=0
    let encoding: u32 = 0x2569C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umax_z_zi_special_size_2_size_variant_2_49152_25a9c000() {
    // Encoding: 0x25A9C000
    // Test UMAX_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: imm8=0, Zdn=0, size=2
    let encoding: u32 = 0x25A9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umax_z_zi_special_size_3_size_variant_3_49152_25e9c000() {
    // Encoding: 0x25E9C000
    // Test UMAX_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: imm8=0, Zdn=0, size=3
    let encoding: u32 = 0x25E9C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umax_z_zi_invalid_0_c000_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umax_z_zi_invalid_1_c000_2529c000() {
    // Encoding: 0x2529C000
    // Test UMAX_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x2529C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMAX_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_umax_z_zi_reg_write_0_2529c000() {
    // Test UMAX_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x2529C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2529C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// REVB_Z.Z__ Tests
// ============================================================================

/// Provenance: REVB_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_revb_z_z_field_size_0_min_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_revb_z_z_field_size_1_poweroftwo_8000_05648000() {
    // Encoding: 0x05648000
    // Test REVB_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05648000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_revb_z_z_field_size_2_poweroftwo_8000_05a48000() {
    // Encoding: 0x05A48000
    // Test REVB_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=2, Zd=0
    let encoding: u32 = 0x05A48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_revb_z_z_field_size_3_max_8000_05e48000() {
    // Encoding: 0x05E48000
    // Test REVB_Z.Z__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x05E48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_revb_z_z_field_pg_0_min_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_revb_z_z_field_pg_1_poweroftwo_8000_05248400() {
    // Encoding: 0x05248400
    // Test REVB_Z.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05248400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_revb_z_z_field_zn_0_min_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_revb_z_z_field_zn_1_poweroftwo_8000_05248020() {
    // Encoding: 0x05248020
    // Test REVB_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x05248020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_revb_z_z_field_zn_30_poweroftwominusone_8000_052483c0() {
    // Encoding: 0x052483C0
    // Test REVB_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zn=30, Zd=0
    let encoding: u32 = 0x052483C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_revb_z_z_field_zn_31_max_8000_052483e0() {
    // Encoding: 0x052483E0
    // Test REVB_Z.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, size=0, Zn=31, Zd=0
    let encoding: u32 = 0x052483E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_revb_z_z_field_zd_0_min_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ field Zd = 0 (Min)
    // Fields: size=0, Pg=0, Zd=0, Zn=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_revb_z_z_field_zd_1_poweroftwo_8000_05248001() {
    // Encoding: 0x05248001
    // Test REVB_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x05248001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_revb_z_z_field_zd_30_poweroftwominusone_8000_0524801e() {
    // Encoding: 0x0524801E
    // Test REVB_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zd=30, Zn=0
    let encoding: u32 = 0x0524801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_revb_z_z_field_zd_31_max_8000_0524801f() {
    // Encoding: 0x0524801F
    // Test REVB_Z.Z__ field Zd = 31 (Max)
    // Fields: Pg=0, size=0, Zn=0, Zd=31
    let encoding: u32 = 0x0524801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_revb_z_z_combo_0_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0, size=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_revb_z_z_special_size_0_size_variant_0_32768_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_revb_z_z_special_size_1_size_variant_1_32768_05648000() {
    // Encoding: 0x05648000
    // Test REVB_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, size=1, Pg=0, Zn=0
    let encoding: u32 = 0x05648000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_revb_z_z_special_size_2_size_variant_2_32768_05a48000() {
    // Encoding: 0x05A48000
    // Test REVB_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, Zn=0, size=2, Pg=0
    let encoding: u32 = 0x05A48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_revb_z_z_special_size_3_size_variant_3_32768_05e48000() {
    // Encoding: 0x05E48000
    // Test REVB_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05E48000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_revb_z_z_invalid_0_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_revb_z_z_invalid_1_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_revb_z_z_invalid_2_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_revb_z_z_invalid_3_8000_05248000() {
    // Encoding: 0x05248000
    // Test REVB_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x05248000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_revh_z_z_field_size_0_min_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ field size = 0 (Min)
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_revh_z_z_field_size_1_poweroftwo_8000_05658000() {
    // Encoding: 0x05658000
    // Test REVH_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05658000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_revh_z_z_field_size_2_poweroftwo_8000_05a58000() {
    // Encoding: 0x05A58000
    // Test REVH_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x05A58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_revh_z_z_field_size_3_max_8000_05e58000() {
    // Encoding: 0x05E58000
    // Test REVH_Z.Z__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x05E58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_revh_z_z_field_pg_0_min_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_revh_z_z_field_pg_1_poweroftwo_8000_05258400() {
    // Encoding: 0x05258400
    // Test REVH_Z.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=1, Zn=0, size=0
    let encoding: u32 = 0x05258400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_revh_z_z_field_zn_0_min_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_revh_z_z_field_zn_1_poweroftwo_8000_05258020() {
    // Encoding: 0x05258020
    // Test REVH_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0, Pg=0
    let encoding: u32 = 0x05258020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_revh_z_z_field_zn_30_poweroftwominusone_8000_052583c0() {
    // Encoding: 0x052583C0
    // Test REVH_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x052583C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_revh_z_z_field_zn_31_max_8000_052583e0() {
    // Encoding: 0x052583E0
    // Test REVH_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, size=0, Zn=31
    let encoding: u32 = 0x052583E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_revh_z_z_field_zd_0_min_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ field Zd = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_revh_z_z_field_zd_1_poweroftwo_8000_05258001() {
    // Encoding: 0x05258001
    // Test REVH_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, size=0, Zn=0
    let encoding: u32 = 0x05258001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_revh_z_z_field_zd_30_poweroftwominusone_8000_0525801e() {
    // Encoding: 0x0525801E
    // Test REVH_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zd=30, Zn=0
    let encoding: u32 = 0x0525801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_revh_z_z_field_zd_31_max_8000_0525801f() {
    // Encoding: 0x0525801F
    // Test REVH_Z.Z__ field Zd = 31 (Max)
    // Fields: size=0, Zd=31, Zn=0, Pg=0
    let encoding: u32 = 0x0525801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_revh_z_z_combo_0_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Pg=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_revh_z_z_special_size_0_size_variant_0_32768_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_revh_z_z_special_size_1_size_variant_1_32768_05658000() {
    // Encoding: 0x05658000
    // Test REVH_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05658000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_revh_z_z_special_size_2_size_variant_2_32768_05a58000() {
    // Encoding: 0x05A58000
    // Test REVH_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, size=2, Pg=0, Zn=0
    let encoding: u32 = 0x05A58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_revh_z_z_special_size_3_size_variant_3_32768_05e58000() {
    // Encoding: 0x05E58000
    // Test REVH_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05E58000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_revh_z_z_invalid_0_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_revh_z_z_invalid_1_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([One, Either]) }" }
/// triggers Undefined
#[test]
fn test_revh_z_z_invalid_2_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([One, Either]) }
    // Fields: Pg=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVH_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_revh_z_z_invalid_3_8000_05258000() {
    // Encoding: 0x05258000
    // Test REVH_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05258000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_revw_z_z_field_size_0_min_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ field size = 0 (Min)
    // Fields: Zd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_revw_z_z_field_size_1_poweroftwo_8000_05668000() {
    // Encoding: 0x05668000
    // Test REVW_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zn=0, Zd=0
    let encoding: u32 = 0x05668000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_revw_z_z_field_size_2_poweroftwo_8000_05a68000() {
    // Encoding: 0x05A68000
    // Test REVW_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Zd=0, size=2
    let encoding: u32 = 0x05A68000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_revw_z_z_field_size_3_max_8000_05e68000() {
    // Encoding: 0x05E68000
    // Test REVW_Z.Z__ field size = 3 (Max)
    // Fields: Pg=0, Zd=0, size=3, Zn=0
    let encoding: u32 = 0x05E68000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_revw_z_z_field_pg_0_min_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ field Pg = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_revw_z_z_field_pg_1_poweroftwo_8000_05268400() {
    // Encoding: 0x05268400
    // Test REVW_Z.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zn=0, Zd=0
    let encoding: u32 = 0x05268400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_revw_z_z_field_zn_0_min_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_revw_z_z_field_zn_1_poweroftwo_8000_05268020() {
    // Encoding: 0x05268020
    // Test REVW_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x05268020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_revw_z_z_field_zn_30_poweroftwominusone_8000_052683c0() {
    // Encoding: 0x052683C0
    // Test REVW_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=0, Pg=0, Zn=30
    let encoding: u32 = 0x052683C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_revw_z_z_field_zn_31_max_8000_052683e0() {
    // Encoding: 0x052683E0
    // Test REVW_Z.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, Zd=0, size=0, Zn=31
    let encoding: u32 = 0x052683E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_revw_z_z_field_zd_0_min_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_revw_z_z_field_zd_1_poweroftwo_8000_05268001() {
    // Encoding: 0x05268001
    // Test REVW_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zd=1, Pg=0, Zn=0
    let encoding: u32 = 0x05268001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_revw_z_z_field_zd_30_poweroftwominusone_8000_0526801e() {
    // Encoding: 0x0526801E
    // Test REVW_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=0, Zd=30
    let encoding: u32 = 0x0526801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_revw_z_z_field_zd_31_max_8000_0526801f() {
    // Encoding: 0x0526801F
    // Test REVW_Z.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, size=0, Pg=0
    let encoding: u32 = 0x0526801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_revw_z_z_combo_0_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ field combination: size=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_revw_z_z_special_size_0_size_variant_0_32768_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_revw_z_z_special_size_1_size_variant_1_32768_05668000() {
    // Encoding: 0x05668000
    // Test REVW_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05668000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_revw_z_z_special_size_2_size_variant_2_32768_05a68000() {
    // Encoding: 0x05A68000
    // Test REVW_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05A68000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_revw_z_z_special_size_3_size_variant_3_32768_05e68000() {
    // Encoding: 0x05E68000
    // Test REVW_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, size=3, Zd=0, Zn=0
    let encoding: u32 = 0x05E68000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_revw_z_z_invalid_0_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_revw_z_z_invalid_1_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Pg=0, Zd=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_revw_z_z_invalid_2_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ invalid encoding: Binary { op: Ne, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVW_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_revw_z_z_invalid_3_8000_05268000() {
    // Encoding: 0x05268000
    // Test REVW_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x05268000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: REVB_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_revb_z_z_reg_write_0_05248000() {
    // Test REVB_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05248000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05248000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: REVH_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_revh_z_z_reg_write_0_05258000() {
    // Test REVH_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05258000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05258000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: REVW_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_revw_z_z_reg_write_0_05268000() {
    // Test REVW_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05268000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05268000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// PUNPKHI_P.P__ Tests
// ============================================================================

/// Provenance: PUNPKHI_P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_punpkhi_p_p_field_pn_0_min_4000_05314000() {
    // Encoding: 0x05314000
    // Test PUNPKHI_P.P__ field Pn = 0 (Min)
    // Fields: Pd=0, Pn=0
    let encoding: u32 = 0x05314000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_punpkhi_p_p_field_pn_1_poweroftwo_4000_05314020() {
    // Encoding: 0x05314020
    // Test PUNPKHI_P.P__ field Pn = 1 (PowerOfTwo)
    // Fields: Pn=1, Pd=0
    let encoding: u32 = 0x05314020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_punpkhi_p_p_field_pd_0_min_4000_05314000() {
    // Encoding: 0x05314000
    // Test PUNPKHI_P.P__ field Pd = 0 (Min)
    // Fields: Pn=0, Pd=0
    let encoding: u32 = 0x05314000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_punpkhi_p_p_field_pd_1_poweroftwo_4000_05314001() {
    // Encoding: 0x05314001
    // Test PUNPKHI_P.P__ field Pd = 1 (PowerOfTwo)
    // Fields: Pd=1, Pn=0
    let encoding: u32 = 0x05314001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=0 (register index 0 (first register))
#[test]
fn test_punpkhi_p_p_combo_0_4000_05314000() {
    // Encoding: 0x05314000
    // Test PUNPKHI_P.P__ field combination: Pn=0, Pd=0
    // Fields: Pn=0, Pd=0
    let encoding: u32 = 0x05314000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_punpkhi_p_p_invalid_0_4000_05314000() {
    // Encoding: 0x05314000
    // Test PUNPKHI_P.P__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pn=0, Pd=0
    let encoding: u32 = 0x05314000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_punpkhi_p_p_invalid_1_4000_05314000() {
    // Encoding: 0x05314000
    // Test PUNPKHI_P.P__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pn=0, Pd=0
    let encoding: u32 = 0x05314000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_punpklo_p_p_field_pn_0_min_4000_05304000() {
    // Encoding: 0x05304000
    // Test PUNPKLO_P.P__ field Pn = 0 (Min)
    // Fields: Pd=0, Pn=0
    let encoding: u32 = 0x05304000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_punpklo_p_p_field_pn_1_poweroftwo_4000_05304020() {
    // Encoding: 0x05304020
    // Test PUNPKLO_P.P__ field Pn = 1 (PowerOfTwo)
    // Fields: Pd=0, Pn=1
    let encoding: u32 = 0x05304020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_punpklo_p_p_field_pd_0_min_4000_05304000() {
    // Encoding: 0x05304000
    // Test PUNPKLO_P.P__ field Pd = 0 (Min)
    // Fields: Pn=0, Pd=0
    let encoding: u32 = 0x05304000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_punpklo_p_p_field_pd_1_poweroftwo_4000_05304001() {
    // Encoding: 0x05304001
    // Test PUNPKLO_P.P__ field Pd = 1 (PowerOfTwo)
    // Fields: Pn=0, Pd=1
    let encoding: u32 = 0x05304001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Pn=0 (register index 0 (first register))
#[test]
fn test_punpklo_p_p_combo_0_4000_05304000() {
    // Encoding: 0x05304000
    // Test PUNPKLO_P.P__ field combination: Pn=0, Pd=0
    // Fields: Pd=0, Pn=0
    let encoding: u32 = 0x05304000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_punpklo_p_p_invalid_0_4000_05304000() {
    // Encoding: 0x05304000
    // Test PUNPKLO_P.P__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pn=0, Pd=0
    let encoding: u32 = 0x05304000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_punpklo_p_p_invalid_1_4000_05304000() {
    // Encoding: 0x05304000
    // Test PUNPKLO_P.P__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pd=0, Pn=0
    let encoding: u32 = 0x05304000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: PUNPKHI_P.P__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_punpkhi_p_p_reg_write_0_05314000() {
    // Test PUNPKHI_P.P__ register write: SimdFromField("Pd")
    // Encoding: 0x05314000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05314000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: PUNPKLO_P.P__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_punpklo_p_p_reg_write_0_05304000() {
    // Test PUNPKLO_P.P__ register write: SimdFromField("Pd")
    // Encoding: 0x05304000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05304000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTA_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clasta_z_p_zz_field_size_0_min_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clasta_z_p_zz_field_size_1_poweroftwo_8000_05688000() {
    // Encoding: 0x05688000
    // Test CLASTA_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x05688000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clasta_z_p_zz_field_size_2_poweroftwo_8000_05a88000() {
    // Encoding: 0x05A88000
    // Test CLASTA_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=2, Zm=0
    let encoding: u32 = 0x05A88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clasta_z_p_zz_field_size_3_max_8000_05e88000() {
    // Encoding: 0x05E88000
    // Test CLASTA_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x05E88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clasta_z_p_zz_field_pg_0_min_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clasta_z_p_zz_field_pg_1_poweroftwo_8000_05288400() {
    // Encoding: 0x05288400
    // Test CLASTA_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Zm=0, Pg=1
    let encoding: u32 = 0x05288400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clasta_z_p_zz_field_zm_0_min_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clasta_z_p_zz_field_zm_1_poweroftwo_8000_05288020() {
    // Encoding: 0x05288020
    // Test CLASTA_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x05288020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clasta_z_p_zz_field_zm_30_poweroftwominusone_8000_052883c0() {
    // Encoding: 0x052883C0
    // Test CLASTA_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Zm=30, size=0, Pg=0
    let encoding: u32 = 0x052883C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clasta_z_p_zz_field_zm_31_max_8000_052883e0() {
    // Encoding: 0x052883E0
    // Test CLASTA_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zdn=0, Zm=31, size=0
    let encoding: u32 = 0x052883E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clasta_z_p_zz_field_zdn_0_min_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clasta_z_p_zz_field_zdn_1_poweroftwo_8000_05288001() {
    // Encoding: 0x05288001
    // Test CLASTA_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x05288001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clasta_z_p_zz_field_zdn_15_poweroftwominusone_8000_0528800f() {
    // Encoding: 0x0528800F
    // Test CLASTA_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=15, Zm=0
    let encoding: u32 = 0x0528800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clasta_z_p_zz_field_zdn_31_max_8000_0528801f() {
    // Encoding: 0x0528801F
    // Test CLASTA_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, size=0, Zdn=31
    let encoding: u32 = 0x0528801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clasta_z_p_zz_combo_0_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clasta_z_p_zz_special_size_0_size_variant_0_32768_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clasta_z_p_zz_special_size_1_size_variant_1_32768_05688000() {
    // Encoding: 0x05688000
    // Test CLASTA_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Pg=0, size=1, Zm=0
    let encoding: u32 = 0x05688000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clasta_z_p_zz_special_size_2_size_variant_2_32768_05a88000() {
    // Encoding: 0x05A88000
    // Test CLASTA_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, Zdn=0, size=2
    let encoding: u32 = 0x05A88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clasta_z_p_zz_special_size_3_size_variant_3_32768_05e88000() {
    // Encoding: 0x05E88000
    // Test CLASTA_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, Zdn=0, size=3
    let encoding: u32 = 0x05E88000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clasta_z_p_zz_invalid_0_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clasta_z_p_zz_invalid_1_8000_05288000() {
    // Encoding: 0x05288000
    // Test CLASTA_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x05288000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTA_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_clasta_z_p_zz_reg_write_0_05288000() {
    // Test CLASTA_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x05288000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05288000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SADDV_R.P.Z__ Tests
// ============================================================================

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_saddv_r_p_z_field_size_0_min_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_saddv_r_p_z_field_size_1_poweroftwo_2000_04402000() {
    // Encoding: 0x04402000
    // Test SADDV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Vd=0, Zn=0
    let encoding: u32 = 0x04402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_saddv_r_p_z_field_size_2_poweroftwo_2000_04802000() {
    // Encoding: 0x04802000
    // Test SADDV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Vd=0, size=2, Zn=0
    let encoding: u32 = 0x04802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_saddv_r_p_z_field_size_3_max_2000_04c02000() {
    // Encoding: 0x04C02000
    // Test SADDV_R.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Zn=0, Vd=0
    let encoding: u32 = 0x04C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_saddv_r_p_z_field_pg_0_min_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_saddv_r_p_z_field_pg_1_poweroftwo_2000_04002400() {
    // Encoding: 0x04002400
    // Test SADDV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Vd=0, Pg=1, Zn=0
    let encoding: u32 = 0x04002400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_saddv_r_p_z_field_zn_0_min_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Vd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_saddv_r_p_z_field_zn_1_poweroftwo_2000_04002020() {
    // Encoding: 0x04002020
    // Test SADDV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Pg=0, Vd=0
    let encoding: u32 = 0x04002020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_saddv_r_p_z_field_zn_30_poweroftwominusone_2000_040023c0() {
    // Encoding: 0x040023C0
    // Test SADDV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x040023C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_saddv_r_p_z_field_zn_31_max_2000_040023e0() {
    // Encoding: 0x040023E0
    // Test SADDV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Vd=0, Pg=0, Zn=31, size=0
    let encoding: u32 = 0x040023E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_saddv_r_p_z_field_vd_0_min_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ field Vd = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_saddv_r_p_z_field_vd_1_poweroftwo_2000_04002001() {
    // Encoding: 0x04002001
    // Test SADDV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Vd=1, Zn=0
    let encoding: u32 = 0x04002001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_saddv_r_p_z_field_vd_30_poweroftwominusone_2000_0400201e() {
    // Encoding: 0x0400201E
    // Test SADDV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vd=30, Pg=0, Zn=0
    let encoding: u32 = 0x0400201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_saddv_r_p_z_field_vd_31_max_2000_0400201f() {
    // Encoding: 0x0400201F
    // Test SADDV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Vd=31, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x0400201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_saddv_r_p_z_combo_0_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_saddv_r_p_z_special_size_0_size_variant_0_8192_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_saddv_r_p_z_special_size_1_size_variant_1_8192_04402000() {
    // Encoding: 0x04402000
    // Test SADDV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Pg=0, Vd=0
    let encoding: u32 = 0x04402000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_saddv_r_p_z_special_size_2_size_variant_2_8192_04802000() {
    // Encoding: 0x04802000
    // Test SADDV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Pg=0, size=2, Vd=0
    let encoding: u32 = 0x04802000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_saddv_r_p_z_special_size_3_size_variant_3_8192_04c02000() {
    // Encoding: 0x04C02000
    // Test SADDV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x04C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_saddv_r_p_z_invalid_0_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_saddv_r_p_z_invalid_1_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([true, true]) }" }
/// triggers Undefined
#[test]
fn test_saddv_r_p_z_invalid_2_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([true, true]) }
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_saddv_r_p_z_invalid_3_2000_04002000() {
    // Encoding: 0x04002000
    // Test SADDV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04002000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SADDV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_saddv_r_p_z_reg_write_0_04002000() {
    // Test SADDV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04002000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04002000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ADR_Z.AZ_SD.same.scaled Tests
// ============================================================================

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_adr_z_az_sd_same_scaled_field_sz_0_min_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled field sz = 0 (Min)
    // Fields: Zm=0, sz=0, msz=0, Zn=0, Zd=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_adr_z_az_sd_same_scaled_field_sz_1_max_a000_04e0a000() {
    // Encoding: 0x04E0A000
    // Test ADR_Z.AZ_SD.same.scaled field sz = 1 (Max)
    // Fields: Zm=0, sz=1, msz=0, Zn=0, Zd=0
    let encoding: u32 = 0x04E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_sd_same_scaled_field_zm_0_min_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled field Zm = 0 (Min)
    // Fields: Zd=0, msz=0, Zn=0, sz=0, Zm=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_sd_same_scaled_field_zm_1_poweroftwo_a000_04a1a000() {
    // Encoding: 0x04A1A000
    // Test ADR_Z.AZ_SD.same.scaled field Zm = 1 (PowerOfTwo)
    // Fields: msz=0, sz=0, Zn=0, Zd=0, Zm=1
    let encoding: u32 = 0x04A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_sd_same_scaled_field_zm_30_poweroftwominusone_a000_04bea000() {
    // Encoding: 0x04BEA000
    // Test ADR_Z.AZ_SD.same.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: msz=0, Zm=30, sz=0, Zn=0, Zd=0
    let encoding: u32 = 0x04BEA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_sd_same_scaled_field_zm_31_max_a000_04bfa000() {
    // Encoding: 0x04BFA000
    // Test ADR_Z.AZ_SD.same.scaled field Zm = 31 (Max)
    // Fields: Zn=0, msz=0, sz=0, Zm=31, Zd=0
    let encoding: u32 = 0x04BFA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_adr_z_az_sd_same_scaled_field_msz_0_min_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled field msz = 0 (Min)
    // Fields: Zn=0, Zd=0, sz=0, msz=0, Zm=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_adr_z_az_sd_same_scaled_field_msz_1_poweroftwo_a000_04a0a400() {
    // Encoding: 0x04A0A400
    // Test ADR_Z.AZ_SD.same.scaled field msz = 1 (PowerOfTwo)
    // Fields: Zd=0, msz=1, Zm=0, sz=0, Zn=0
    let encoding: u32 = 0x04A0A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_adr_z_az_sd_same_scaled_field_msz_3_max_a000_04a0ac00() {
    // Encoding: 0x04A0AC00
    // Test ADR_Z.AZ_SD.same.scaled field msz = 3 (Max)
    // Fields: sz=0, Zd=0, msz=3, Zn=0, Zm=0
    let encoding: u32 = 0x04A0AC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_sd_same_scaled_field_zn_0_min_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled field Zn = 0 (Min)
    // Fields: Zd=0, Zm=0, sz=0, msz=0, Zn=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_sd_same_scaled_field_zn_1_poweroftwo_a000_04a0a020() {
    // Encoding: 0x04A0A020
    // Test ADR_Z.AZ_SD.same.scaled field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Zm=0, sz=0, Zd=0, msz=0
    let encoding: u32 = 0x04A0A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_sd_same_scaled_field_zn_30_poweroftwominusone_a000_04a0a3c0() {
    // Encoding: 0x04A0A3C0
    // Test ADR_Z.AZ_SD.same.scaled field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zd=0, sz=0, msz=0, Zm=0
    let encoding: u32 = 0x04A0A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_sd_same_scaled_field_zn_31_max_a000_04a0a3e0() {
    // Encoding: 0x04A0A3E0
    // Test ADR_Z.AZ_SD.same.scaled field Zn = 31 (Max)
    // Fields: msz=0, Zm=0, Zn=31, Zd=0, sz=0
    let encoding: u32 = 0x04A0A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_sd_same_scaled_field_zd_0_min_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled field Zd = 0 (Min)
    // Fields: sz=0, Zd=0, Zn=0, Zm=0, msz=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_sd_same_scaled_field_zd_1_poweroftwo_a000_04a0a001() {
    // Encoding: 0x04A0A001
    // Test ADR_Z.AZ_SD.same.scaled field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, Zm=0, Zd=1, sz=0, msz=0
    let encoding: u32 = 0x04A0A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_sd_same_scaled_field_zd_30_poweroftwominusone_a000_04a0a01e() {
    // Encoding: 0x04A0A01E
    // Test ADR_Z.AZ_SD.same.scaled field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, sz=0, Zn=0, msz=0, Zm=0
    let encoding: u32 = 0x04A0A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_sd_same_scaled_field_zd_31_max_a000_04a0a01f() {
    // Encoding: 0x04A0A01F
    // Test ADR_Z.AZ_SD.same.scaled field Zd = 31 (Max)
    // Fields: Zn=0, msz=0, sz=0, Zd=31, Zm=0
    let encoding: u32 = 0x04A0A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_adr_z_az_sd_same_scaled_combo_0_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled field combination: sz=0, Zm=0, msz=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, Zm=0, sz=0, msz=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_adr_z_az_sd_same_scaled_special_sz_0_size_variant_0_40960_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled special value sz = 0 (Size variant 0)
    // Fields: Zn=0, Zm=0, msz=0, sz=0, Zd=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_adr_z_az_sd_same_scaled_special_sz_1_size_variant_1_40960_04e0a000() {
    // Encoding: 0x04E0A000
    // Test ADR_Z.AZ_SD.same.scaled special value sz = 1 (Size variant 1)
    // Fields: Zd=0, Zn=0, sz=1, msz=0, Zm=0
    let encoding: u32 = 0x04E0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_adr_z_az_sd_same_scaled_invalid_0_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zd=0, sz=0, Zn=0, msz=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_adr_z_az_sd_same_scaled_invalid_1_a000_04a0a000() {
    // Encoding: 0x04A0A000
    // Test ADR_Z.AZ_SD.same.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zm=0, sz=0, msz=0, Zd=0
    let encoding: u32 = 0x04A0A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_d_s32_scaled_field_zm_0_min_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled field Zm = 0 (Min)
    // Fields: Zn=0, Zd=0, msz=0, Zm=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_d_s32_scaled_field_zm_1_poweroftwo_a000_0421a000() {
    // Encoding: 0x0421A000
    // Test ADR_Z.AZ_D.s32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: msz=0, Zm=1, Zn=0, Zd=0
    let encoding: u32 = 0x0421A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_d_s32_scaled_field_zm_30_poweroftwominusone_a000_043ea000() {
    // Encoding: 0x043EA000
    // Test ADR_Z.AZ_D.s32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, msz=0, Zm=30, Zn=0
    let encoding: u32 = 0x043EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_d_s32_scaled_field_zm_31_max_a000_043fa000() {
    // Encoding: 0x043FA000
    // Test ADR_Z.AZ_D.s32.scaled field Zm = 31 (Max)
    // Fields: msz=0, Zn=0, Zd=0, Zm=31
    let encoding: u32 = 0x043FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_adr_z_az_d_s32_scaled_field_msz_0_min_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled field msz = 0 (Min)
    // Fields: Zn=0, msz=0, Zm=0, Zd=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_adr_z_az_d_s32_scaled_field_msz_1_poweroftwo_a000_0420a400() {
    // Encoding: 0x0420A400
    // Test ADR_Z.AZ_D.s32.scaled field msz = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, msz=1, Zd=0
    let encoding: u32 = 0x0420A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_adr_z_az_d_s32_scaled_field_msz_3_max_a000_0420ac00() {
    // Encoding: 0x0420AC00
    // Test ADR_Z.AZ_D.s32.scaled field msz = 3 (Max)
    // Fields: Zd=0, Zn=0, msz=3, Zm=0
    let encoding: u32 = 0x0420AC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_d_s32_scaled_field_zn_0_min_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled field Zn = 0 (Min)
    // Fields: msz=0, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_d_s32_scaled_field_zn_1_poweroftwo_a000_0420a020() {
    // Encoding: 0x0420A020
    // Test ADR_Z.AZ_D.s32.scaled field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, msz=0, Zm=0, Zd=0
    let encoding: u32 = 0x0420A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_d_s32_scaled_field_zn_30_poweroftwominusone_a000_0420a3c0() {
    // Encoding: 0x0420A3C0
    // Test ADR_Z.AZ_D.s32.scaled field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zm=0, msz=0, Zd=0
    let encoding: u32 = 0x0420A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_d_s32_scaled_field_zn_31_max_a000_0420a3e0() {
    // Encoding: 0x0420A3E0
    // Test ADR_Z.AZ_D.s32.scaled field Zn = 31 (Max)
    // Fields: Zn=31, Zm=0, Zd=0, msz=0
    let encoding: u32 = 0x0420A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_d_s32_scaled_field_zd_0_min_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled field Zd = 0 (Min)
    // Fields: Zn=0, Zd=0, Zm=0, msz=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_d_s32_scaled_field_zd_1_poweroftwo_a000_0420a001() {
    // Encoding: 0x0420A001
    // Test ADR_Z.AZ_D.s32.scaled field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, msz=0, Zm=0, Zd=1
    let encoding: u32 = 0x0420A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_d_s32_scaled_field_zd_30_poweroftwominusone_a000_0420a01e() {
    // Encoding: 0x0420A01E
    // Test ADR_Z.AZ_D.s32.scaled field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, msz=0, Zd=30, Zm=0
    let encoding: u32 = 0x0420A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_d_s32_scaled_field_zd_31_max_a000_0420a01f() {
    // Encoding: 0x0420A01F
    // Test ADR_Z.AZ_D.s32.scaled field Zd = 31 (Max)
    // Fields: Zn=0, msz=0, Zm=0, Zd=31
    let encoding: u32 = 0x0420A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_adr_z_az_d_s32_scaled_combo_0_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled field combination: Zm=0, msz=0, Zn=0, Zd=0
    // Fields: Zn=0, msz=0, Zm=0, Zd=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_adr_z_az_d_s32_scaled_invalid_0_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: msz=0, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_adr_z_az_d_s32_scaled_invalid_1_a000_0420a000() {
    // Encoding: 0x0420A000
    // Test ADR_Z.AZ_D.s32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, Zd=0, Zn=0, msz=0
    let encoding: u32 = 0x0420A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_d_u32_scaled_field_zm_0_min_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled field Zm = 0 (Min)
    // Fields: Zm=0, Zd=0, msz=0, Zn=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_d_u32_scaled_field_zm_1_poweroftwo_a000_0461a000() {
    // Encoding: 0x0461A000
    // Test ADR_Z.AZ_D.u32.scaled field Zm = 1 (PowerOfTwo)
    // Fields: Zn=0, msz=0, Zm=1, Zd=0
    let encoding: u32 = 0x0461A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_d_u32_scaled_field_zm_30_poweroftwominusone_a000_047ea000() {
    // Encoding: 0x047EA000
    // Test ADR_Z.AZ_D.u32.scaled field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, msz=0, Zn=0, Zm=30
    let encoding: u32 = 0x047EA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_d_u32_scaled_field_zm_31_max_a000_047fa000() {
    // Encoding: 0x047FA000
    // Test ADR_Z.AZ_D.u32.scaled field Zm = 31 (Max)
    // Fields: Zn=0, Zm=31, msz=0, Zd=0
    let encoding: u32 = 0x047FA000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_adr_z_az_d_u32_scaled_field_msz_0_min_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled field msz = 0 (Min)
    // Fields: Zd=0, msz=0, Zm=0, Zn=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_adr_z_az_d_u32_scaled_field_msz_1_poweroftwo_a000_0460a400() {
    // Encoding: 0x0460A400
    // Test ADR_Z.AZ_D.u32.scaled field msz = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=0, Zn=0, msz=1
    let encoding: u32 = 0x0460A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field msz 10 +: 2`
/// Requirement: FieldBoundary { field: "msz", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_adr_z_az_d_u32_scaled_field_msz_3_max_a000_0460ac00() {
    // Encoding: 0x0460AC00
    // Test ADR_Z.AZ_D.u32.scaled field msz = 3 (Max)
    // Fields: Zm=0, msz=3, Zn=0, Zd=0
    let encoding: u32 = 0x0460AC00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_d_u32_scaled_field_zn_0_min_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled field Zn = 0 (Min)
    // Fields: Zd=0, Zm=0, Zn=0, msz=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_d_u32_scaled_field_zn_1_poweroftwo_a000_0460a020() {
    // Encoding: 0x0460A020
    // Test ADR_Z.AZ_D.u32.scaled field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=1, msz=0, Zd=0
    let encoding: u32 = 0x0460A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_d_u32_scaled_field_zn_30_poweroftwominusone_a000_0460a3c0() {
    // Encoding: 0x0460A3C0
    // Test ADR_Z.AZ_D.u32.scaled field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, Zm=0, msz=0
    let encoding: u32 = 0x0460A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_d_u32_scaled_field_zn_31_max_a000_0460a3e0() {
    // Encoding: 0x0460A3E0
    // Test ADR_Z.AZ_D.u32.scaled field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, Zm=0, msz=0
    let encoding: u32 = 0x0460A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_adr_z_az_d_u32_scaled_field_zd_0_min_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled field Zd = 0 (Min)
    // Fields: Zn=0, msz=0, Zd=0, Zm=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_adr_z_az_d_u32_scaled_field_zd_1_poweroftwo_a000_0460a001() {
    // Encoding: 0x0460A001
    // Test ADR_Z.AZ_D.u32.scaled field Zd = 1 (PowerOfTwo)
    // Fields: Zm=0, Zd=1, msz=0, Zn=0
    let encoding: u32 = 0x0460A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_adr_z_az_d_u32_scaled_field_zd_30_poweroftwominusone_a000_0460a01e() {
    // Encoding: 0x0460A01E
    // Test ADR_Z.AZ_D.u32.scaled field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, msz=0, Zn=0, Zd=30
    let encoding: u32 = 0x0460A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_adr_z_az_d_u32_scaled_field_zd_31_max_a000_0460a01f() {
    // Encoding: 0x0460A01F
    // Test ADR_Z.AZ_D.u32.scaled field Zd = 31 (Max)
    // Fields: Zd=31, Zn=0, Zm=0, msz=0
    let encoding: u32 = 0x0460A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// Zm=0 (SIMD register V0)
#[test]
fn test_adr_z_az_d_u32_scaled_combo_0_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled field combination: Zm=0, msz=0, Zn=0, Zd=0
    // Fields: Zm=0, msz=0, Zd=0, Zn=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_adr_z_az_d_u32_scaled_invalid_0_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, msz=0, Zm=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_adr_z_az_d_u32_scaled_invalid_1_a000_0460a000() {
    // Encoding: 0x0460A000
    // Test ADR_Z.AZ_D.u32.scaled invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, msz=0, Zn=0, Zd=0
    let encoding: u32 = 0x0460A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ADR_Z.AZ_SD.same.scaled
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_adr_z_az_sd_same_scaled_reg_write_0_04a0a000() {
    // Test ADR_Z.AZ_SD.same.scaled register write: SimdFromField("d")
    // Encoding: 0x04A0A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04A0A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ADR_Z.AZ_D.s32.scaled
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_adr_z_az_d_s32_scaled_reg_write_0_0420a000() {
    // Test ADR_Z.AZ_D.s32.scaled register write: SimdFromField("d")
    // Encoding: 0x0420A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0420A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: ADR_Z.AZ_D.u32.scaled
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_adr_z_az_d_u32_scaled_reg_write_0_0460a000() {
    // Test ADR_Z.AZ_D.u32.scaled register write: SimdFromField("d")
    // Encoding: 0x0460A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0460A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// TBL_Z.ZZ_1 Tests
// ============================================================================

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_tbl_z_zz_1_field_size_0_min_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 field size = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_tbl_z_zz_1_field_size_1_poweroftwo_3000_05603000() {
    // Encoding: 0x05603000
    // Test TBL_Z.ZZ_1 field size = 1 (PowerOfTwo)
    // Fields: Zn=0, Zd=0, size=1, Zm=0
    let encoding: u32 = 0x05603000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_tbl_z_zz_1_field_size_2_poweroftwo_3000_05a03000() {
    // Encoding: 0x05A03000
    // Test TBL_Z.ZZ_1 field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x05A03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_tbl_z_zz_1_field_size_3_max_3000_05e03000() {
    // Encoding: 0x05E03000
    // Test TBL_Z.ZZ_1 field size = 3 (Max)
    // Fields: size=3, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x05E03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_tbl_z_zz_1_field_zm_0_min_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_tbl_z_zz_1_field_zm_1_poweroftwo_3000_05213000() {
    // Encoding: 0x05213000
    // Test TBL_Z.ZZ_1 field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=0, Zm=1, size=0
    let encoding: u32 = 0x05213000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_tbl_z_zz_1_field_zm_30_poweroftwominusone_3000_053e3000() {
    // Encoding: 0x053E3000
    // Test TBL_Z.ZZ_1 field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Zn=0, Zd=0
    let encoding: u32 = 0x053E3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_tbl_z_zz_1_field_zm_31_max_3000_053f3000() {
    // Encoding: 0x053F3000
    // Test TBL_Z.ZZ_1 field Zm = 31 (Max)
    // Fields: Zm=31, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x053F3000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_tbl_z_zz_1_field_zn_0_min_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 field Zn = 0 (Min)
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_tbl_z_zz_1_field_zn_1_poweroftwo_3000_05203020() {
    // Encoding: 0x05203020
    // Test TBL_Z.ZZ_1 field Zn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zd=0, Zn=1
    let encoding: u32 = 0x05203020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_tbl_z_zz_1_field_zn_30_poweroftwominusone_3000_052033c0() {
    // Encoding: 0x052033C0
    // Test TBL_Z.ZZ_1 field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zm=0, Zd=0
    let encoding: u32 = 0x052033C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_tbl_z_zz_1_field_zn_31_max_3000_052033e0() {
    // Encoding: 0x052033E0
    // Test TBL_Z.ZZ_1 field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x052033E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_tbl_z_zz_1_field_zd_0_min_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 field Zd = 0 (Min)
    // Fields: size=0, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_tbl_z_zz_1_field_zd_1_poweroftwo_3000_05203001() {
    // Encoding: 0x05203001
    // Test TBL_Z.ZZ_1 field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x05203001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_tbl_z_zz_1_field_zd_30_poweroftwominusone_3000_0520301e() {
    // Encoding: 0x0520301E
    // Test TBL_Z.ZZ_1 field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, Zn=0, Zm=0, size=0
    let encoding: u32 = 0x0520301E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_tbl_z_zz_1_field_zd_31_max_3000_0520301f() {
    // Encoding: 0x0520301F
    // Test TBL_Z.ZZ_1 field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, Zm=0, size=0
    let encoding: u32 = 0x0520301F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_tbl_z_zz_1_combo_0_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zm=0, Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_tbl_z_zz_1_special_size_0_size_variant_0_12288_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 special value size = 0 (Size variant 0)
    // Fields: Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_tbl_z_zz_1_special_size_1_size_variant_1_12288_05603000() {
    // Encoding: 0x05603000
    // Test TBL_Z.ZZ_1 special value size = 1 (Size variant 1)
    // Fields: Zd=0, size=1, Zm=0, Zn=0
    let encoding: u32 = 0x05603000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_tbl_z_zz_1_special_size_2_size_variant_2_12288_05a03000() {
    // Encoding: 0x05A03000
    // Test TBL_Z.ZZ_1 special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Zn=0, Zd=0
    let encoding: u32 = 0x05A03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_tbl_z_zz_1_special_size_3_size_variant_3_12288_05e03000() {
    // Encoding: 0x05E03000
    // Test TBL_Z.ZZ_1 special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0, Zm=0
    let encoding: u32 = 0x05E03000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_tbl_z_zz_1_invalid_0_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_tbl_z_zz_1_invalid_1_3000_05203000() {
    // Encoding: 0x05203000
    // Test TBL_Z.ZZ_1 invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x05203000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TBL_Z.ZZ_1
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_tbl_z_zz_1_reg_write_0_05203000() {
    // Test TBL_Z.ZZ_1 register write: SimdFromField("d")
    // Encoding: 0x05203000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05203000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// TRN1_Z.ZZ__ Tests
// ============================================================================

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_trn1_z_zz_field_size_0_min_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_trn1_z_zz_field_size_1_poweroftwo_7000_05607000() {
    // Encoding: 0x05607000
    // Test TRN1_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zn=0, Zd=0, size=1
    let encoding: u32 = 0x05607000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_trn1_z_zz_field_size_2_poweroftwo_7000_05a07000() {
    // Encoding: 0x05A07000
    // Test TRN1_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x05A07000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_trn1_z_zz_field_size_3_max_7000_05e07000() {
    // Encoding: 0x05E07000
    // Test TRN1_Z.ZZ__ field size = 3 (Max)
    // Fields: Zn=0, Zm=0, Zd=0, size=3
    let encoding: u32 = 0x05E07000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_trn1_z_zz_field_zm_0_min_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_trn1_z_zz_field_zm_1_poweroftwo_7000_05217000() {
    // Encoding: 0x05217000
    // Test TRN1_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, Zm=1, size=0, Zn=0
    let encoding: u32 = 0x05217000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_trn1_z_zz_field_zm_30_poweroftwominusone_7000_053e7000() {
    // Encoding: 0x053E7000
    // Test TRN1_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Zn=0, Zd=0
    let encoding: u32 = 0x053E7000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_trn1_z_zz_field_zm_31_max_7000_053f7000() {
    // Encoding: 0x053F7000
    // Test TRN1_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zn=0, size=0, Zd=0, Zm=31
    let encoding: u32 = 0x053F7000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_trn1_z_zz_field_zn_0_min_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zd=0, Zn=0, Zm=0, size=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_trn1_z_zz_field_zn_1_poweroftwo_7000_05207020() {
    // Encoding: 0x05207020
    // Test TRN1_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zm=0, Zd=0
    let encoding: u32 = 0x05207020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_trn1_z_zz_field_zn_30_poweroftwominusone_7000_052073c0() {
    // Encoding: 0x052073C0
    // Test TRN1_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zm=0, Zd=0
    let encoding: u32 = 0x052073C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_trn1_z_zz_field_zn_31_max_7000_052073e0() {
    // Encoding: 0x052073E0
    // Test TRN1_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, Zn=31, Zd=0, size=0
    let encoding: u32 = 0x052073E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_trn1_z_zz_field_zd_0_min_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_trn1_z_zz_field_zd_1_poweroftwo_7000_05207001() {
    // Encoding: 0x05207001
    // Test TRN1_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zd=1, Zn=0, Zm=0
    let encoding: u32 = 0x05207001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_trn1_z_zz_field_zd_30_poweroftwominusone_7000_0520701e() {
    // Encoding: 0x0520701E
    // Test TRN1_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zn=0, Zd=30, size=0
    let encoding: u32 = 0x0520701E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_trn1_z_zz_field_zd_31_max_7000_0520701f() {
    // Encoding: 0x0520701F
    // Test TRN1_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zn=0, size=0, Zd=31
    let encoding: u32 = 0x0520701F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_trn1_z_zz_combo_0_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: Zn=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_trn1_z_zz_special_size_0_size_variant_0_28672_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_trn1_z_zz_special_size_1_size_variant_1_28672_05607000() {
    // Encoding: 0x05607000
    // Test TRN1_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Zd=0, Zn=0
    let encoding: u32 = 0x05607000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_trn1_z_zz_special_size_2_size_variant_2_28672_05a07000() {
    // Encoding: 0x05A07000
    // Test TRN1_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x05A07000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_trn1_z_zz_special_size_3_size_variant_3_28672_05e07000() {
    // Encoding: 0x05E07000
    // Test TRN1_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zm=0, Zd=0, size=3
    let encoding: u32 = 0x05E07000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_trn1_z_zz_invalid_0_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_trn1_z_zz_invalid_1_7000_05207000() {
    // Encoding: 0x05207000
    // Test TRN1_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x05207000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_trn2_z_zz_field_size_0_min_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_trn2_z_zz_field_size_1_poweroftwo_7400_05607400() {
    // Encoding: 0x05607400
    // Test TRN2_Z.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Zd=0, Zn=0
    let encoding: u32 = 0x05607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_trn2_z_zz_field_size_2_poweroftwo_7400_05a07400() {
    // Encoding: 0x05A07400
    // Test TRN2_Z.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, size=2, Zd=0, Zm=0
    let encoding: u32 = 0x05A07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_trn2_z_zz_field_size_3_max_7400_05e07400() {
    // Encoding: 0x05E07400
    // Test TRN2_Z.ZZ__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Zm=0, Zn=0
    let encoding: u32 = 0x05E07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_trn2_z_zz_field_zm_0_min_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zn=0, Zd=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_trn2_z_zz_field_zm_1_poweroftwo_7400_05217400() {
    // Encoding: 0x05217400
    // Test TRN2_Z.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Zm=1, Zn=0
    let encoding: u32 = 0x05217400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_trn2_z_zz_field_zm_30_poweroftwominusone_7400_053e7400() {
    // Encoding: 0x053E7400
    // Test TRN2_Z.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x053E7400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_trn2_z_zz_field_zm_31_max_7400_053f7400() {
    // Encoding: 0x053F7400
    // Test TRN2_Z.ZZ__ field Zm = 31 (Max)
    // Fields: Zd=0, Zm=31, Zn=0, size=0
    let encoding: u32 = 0x053F7400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_trn2_z_zz_field_zn_0_min_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0, Zm=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_trn2_z_zz_field_zn_1_poweroftwo_7400_05207420() {
    // Encoding: 0x05207420
    // Test TRN2_Z.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zn=1, Zm=0, size=0
    let encoding: u32 = 0x05207420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_trn2_z_zz_field_zn_30_poweroftwominusone_7400_052077c0() {
    // Encoding: 0x052077C0
    // Test TRN2_Z.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=30, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x052077C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_trn2_z_zz_field_zn_31_max_7400_052077e0() {
    // Encoding: 0x052077E0
    // Test TRN2_Z.ZZ__ field Zn = 31 (Max)
    // Fields: Zm=0, size=0, Zd=0, Zn=31
    let encoding: u32 = 0x052077E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_trn2_z_zz_field_zd_0_min_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ field Zd = 0 (Min)
    // Fields: Zm=0, Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_trn2_z_zz_field_zd_1_poweroftwo_7400_05207401() {
    // Encoding: 0x05207401
    // Test TRN2_Z.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zm=0, Zd=1, Zn=0
    let encoding: u32 = 0x05207401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_trn2_z_zz_field_zd_30_poweroftwominusone_7400_0520741e() {
    // Encoding: 0x0520741E
    // Test TRN2_Z.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Zn=0, Zd=30
    let encoding: u32 = 0x0520741E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_trn2_z_zz_field_zd_31_max_7400_0520741f() {
    // Encoding: 0x0520741F
    // Test TRN2_Z.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zd=31, size=0, Zn=0
    let encoding: u32 = 0x0520741F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_trn2_z_zz_combo_0_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ field combination: size=0, Zm=0, Zn=0, Zd=0
    // Fields: size=0, Zd=0, Zn=0, Zm=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_trn2_z_zz_special_size_0_size_variant_0_29696_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zm=0, Zn=0, size=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_trn2_z_zz_special_size_1_size_variant_1_29696_05607400() {
    // Encoding: 0x05607400
    // Test TRN2_Z.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x05607400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_trn2_z_zz_special_size_2_size_variant_2_29696_05a07400() {
    // Encoding: 0x05A07400
    // Test TRN2_Z.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zd=0, Zm=0, Zn=0
    let encoding: u32 = 0x05A07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_trn2_z_zz_special_size_3_size_variant_3_29696_05e07400() {
    // Encoding: 0x05E07400
    // Test TRN2_Z.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, size=3, Zd=0, Zn=0
    let encoding: u32 = 0x05E07400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_trn2_z_zz_invalid_0_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zm=0, Zd=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_trn2_z_zz_invalid_1_7400_05207400() {
    // Encoding: 0x05207400
    // Test TRN2_Z.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, size=0, Zm=0
    let encoding: u32 = 0x05207400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: TRN1_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_trn1_z_zz_reg_write_0_05207000() {
    // Test TRN1_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x05207000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05207000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: TRN2_Z.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_trn2_z_zz_reg_write_0_05207400() {
    // Test TRN2_Z.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x05207400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05207400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SDOT_Z.ZZZi_S Tests
// ============================================================================

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdot_z_zzzi_s_field_i2_0_min_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S field i2 = 0 (Min)
    // Fields: Zda=0, i2=0, Zn=0, Zm=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sdot_z_zzzi_s_field_i2_1_poweroftwo_0_44a80000() {
    // Encoding: 0x44A80000
    // Test SDOT_Z.ZZZi_S field i2 = 1 (PowerOfTwo)
    // Fields: Zda=0, Zm=0, i2=1, Zn=0
    let encoding: u32 = 0x44A80000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field i2 19 +: 2`
/// Requirement: FieldBoundary { field: "i2", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_sdot_z_zzzi_s_field_i2_3_max_0_44b80000() {
    // Encoding: 0x44B80000
    // Test SDOT_Z.ZZZi_S field i2 = 3 (Max)
    // Fields: Zn=0, Zda=0, i2=3, Zm=0
    let encoding: u32 = 0x44B80000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdot_z_zzzi_s_field_zm_0_min_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S field Zm = 0 (Min)
    // Fields: i2=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zm 16 +: 3`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdot_z_zzzi_s_field_zm_1_poweroftwo_0_44a10000() {
    // Encoding: 0x44A10000
    // Test SDOT_Z.ZZZi_S field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zn=0, i2=0, Zda=0
    let encoding: u32 = 0x44A10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdot_z_zzzi_s_field_zn_0_min_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S field Zn = 0 (Min)
    // Fields: Zm=0, i2=0, Zn=0, Zda=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdot_z_zzzi_s_field_zn_1_poweroftwo_0_44a00020() {
    // Encoding: 0x44A00020
    // Test SDOT_Z.ZZZi_S field Zn = 1 (PowerOfTwo)
    // Fields: i2=0, Zn=1, Zm=0, Zda=0
    let encoding: u32 = 0x44A00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sdot_z_zzzi_s_field_zn_30_poweroftwominusone_0_44a003c0() {
    // Encoding: 0x44A003C0
    // Test SDOT_Z.ZZZi_S field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Zda=0, Zn=30, i2=0
    let encoding: u32 = 0x44A003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sdot_z_zzzi_s_field_zn_31_max_0_44a003e0() {
    // Encoding: 0x44A003E0
    // Test SDOT_Z.ZZZi_S field Zn = 31 (Max)
    // Fields: Zda=0, Zn=31, i2=0, Zm=0
    let encoding: u32 = 0x44A003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdot_z_zzzi_s_field_zda_0_min_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S field Zda = 0 (Min)
    // Fields: i2=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sdot_z_zzzi_s_field_zda_1_poweroftwo_0_44a00001() {
    // Encoding: 0x44A00001
    // Test SDOT_Z.ZZZi_S field Zda = 1 (PowerOfTwo)
    // Fields: i2=0, Zm=0, Zda=1, Zn=0
    let encoding: u32 = 0x44A00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sdot_z_zzzi_s_field_zda_15_poweroftwominusone_0_44a0000f() {
    // Encoding: 0x44A0000F
    // Test SDOT_Z.ZZZi_S field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: i2=0, Zm=0, Zda=15, Zn=0
    let encoding: u32 = 0x44A0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sdot_z_zzzi_s_field_zda_31_max_0_44a0001f() {
    // Encoding: 0x44A0001F
    // Test SDOT_Z.ZZZi_S field Zda = 31 (Max)
    // Fields: Zda=31, Zm=0, i2=0, Zn=0
    let encoding: u32 = 0x44A0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i2=0 (minimum value)
#[test]
fn test_sdot_z_zzzi_s_combo_0_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S field combination: i2=0, Zm=0, Zn=0, Zda=0
    // Fields: i2=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzzi_s_invalid_0_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zda=0, Zn=0, i2=0, Zm=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzzi_s_invalid_1_0_44a00000() {
    // Encoding: 0x44A00000
    // Test SDOT_Z.ZZZi_S invalid encoding: Unconditional UNDEFINED
    // Fields: i2=0, Zm=0, Zn=0, Zda=0
    let encoding: u32 = 0x44A00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdot_z_zzzi_d_field_i1_0_min_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D field i1 = 0 (Min)
    // Fields: Zn=0, i1=0, Zm=0, Zda=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field i1 20 +: 1`
/// Requirement: FieldBoundary { field: "i1", value: 1, boundary: Max }
/// maximum value (1)
#[test]
fn test_sdot_z_zzzi_d_field_i1_1_max_0_44f00000() {
    // Encoding: 0x44F00000
    // Test SDOT_Z.ZZZi_D field i1 = 1 (Max)
    // Fields: Zda=0, i1=1, Zn=0, Zm=0
    let encoding: u32 = 0x44F00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdot_z_zzzi_d_field_zm_0_min_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D field Zm = 0 (Min)
    // Fields: Zm=0, Zn=0, i1=0, Zda=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zm 16 +: 4`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdot_z_zzzi_d_field_zm_1_poweroftwo_0_44e10000() {
    // Encoding: 0x44E10000
    // Test SDOT_Z.ZZZi_D field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zda=0, i1=0, Zn=0
    let encoding: u32 = 0x44E10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdot_z_zzzi_d_field_zn_0_min_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D field Zn = 0 (Min)
    // Fields: i1=0, Zn=0, Zda=0, Zm=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdot_z_zzzi_d_field_zn_1_poweroftwo_0_44e00020() {
    // Encoding: 0x44E00020
    // Test SDOT_Z.ZZZi_D field Zn = 1 (PowerOfTwo)
    // Fields: Zda=0, Zn=1, Zm=0, i1=0
    let encoding: u32 = 0x44E00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sdot_z_zzzi_d_field_zn_30_poweroftwominusone_0_44e003c0() {
    // Encoding: 0x44E003C0
    // Test SDOT_Z.ZZZi_D field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zda=0, i1=0, Zm=0, Zn=30
    let encoding: u32 = 0x44E003C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sdot_z_zzzi_d_field_zn_31_max_0_44e003e0() {
    // Encoding: 0x44E003E0
    // Test SDOT_Z.ZZZi_D field Zn = 31 (Max)
    // Fields: Zda=0, i1=0, Zm=0, Zn=31
    let encoding: u32 = 0x44E003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdot_z_zzzi_d_field_zda_0_min_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D field Zda = 0 (Min)
    // Fields: Zda=0, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sdot_z_zzzi_d_field_zda_1_poweroftwo_0_44e00001() {
    // Encoding: 0x44E00001
    // Test SDOT_Z.ZZZi_D field Zda = 1 (PowerOfTwo)
    // Fields: Zda=1, i1=0, Zm=0, Zn=0
    let encoding: u32 = 0x44E00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sdot_z_zzzi_d_field_zda_15_poweroftwominusone_0_44e0000f() {
    // Encoding: 0x44E0000F
    // Test SDOT_Z.ZZZi_D field Zda = 15 (PowerOfTwoMinusOne)
    // Fields: Zn=0, i1=0, Zda=15, Zm=0
    let encoding: u32 = 0x44E0000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field Zda 0 +: 5`
/// Requirement: FieldBoundary { field: "Zda", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sdot_z_zzzi_d_field_zda_31_max_0_44e0001f() {
    // Encoding: 0x44E0001F
    // Test SDOT_Z.ZZZi_D field Zda = 31 (Max)
    // Fields: i1=0, Zn=0, Zm=0, Zda=31
    let encoding: u32 = 0x44E0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// i1=0 (minimum value)
#[test]
fn test_sdot_z_zzzi_d_combo_0_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D field combination: i1=0, Zm=0, Zn=0, Zda=0
    // Fields: Zm=0, i1=0, Zda=0, Zn=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzzi_d_invalid_0_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zda=0, Zn=0, i1=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdot_z_zzzi_d_invalid_1_0_44e00000() {
    // Encoding: 0x44E00000
    // Test SDOT_Z.ZZZi_D invalid encoding: Unconditional UNDEFINED
    // Fields: i1=0, Zda=0, Zm=0, Zn=0
    let encoding: u32 = 0x44E00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDOT_Z.ZZZi_S
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_sdot_z_zzzi_s_reg_write_0_44a00000() {
    // Test SDOT_Z.ZZZi_S register write: SimdFromField("da")
    // Encoding: 0x44A00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x44A00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SDOT_Z.ZZZi_D
/// ASL: `SimdFromField("da") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("da")
#[test]
fn test_sdot_z_zzzi_d_reg_write_0_44e00000() {
    // Test SDOT_Z.ZZZi_D register write: SimdFromField("da")
    // Encoding: 0x44E00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x44E00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SUNPKHI_Z.Z__ Tests
// ============================================================================

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sunpkhi_z_z_field_size_0_min_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ field size = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sunpkhi_z_z_field_size_1_poweroftwo_3800_05713800() {
    // Encoding: 0x05713800
    // Test SUNPKHI_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0
    let encoding: u32 = 0x05713800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sunpkhi_z_z_field_size_2_poweroftwo_3800_05b13800() {
    // Encoding: 0x05B13800
    // Test SUNPKHI_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zn=0, Zd=0
    let encoding: u32 = 0x05B13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sunpkhi_z_z_field_size_3_max_3800_05f13800() {
    // Encoding: 0x05F13800
    // Test SUNPKHI_Z.Z__ field size = 3 (Max)
    // Fields: Zd=0, size=3, Zn=0
    let encoding: u32 = 0x05F13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sunpkhi_z_z_field_zn_0_min_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ field Zn = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sunpkhi_z_z_field_zn_1_poweroftwo_3800_05313820() {
    // Encoding: 0x05313820
    // Test SUNPKHI_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Zd=0
    let encoding: u32 = 0x05313820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sunpkhi_z_z_field_zn_30_poweroftwominusone_3800_05313bc0() {
    // Encoding: 0x05313BC0
    // Test SUNPKHI_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Zd=0
    let encoding: u32 = 0x05313BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sunpkhi_z_z_field_zn_31_max_3800_05313be0() {
    // Encoding: 0x05313BE0
    // Test SUNPKHI_Z.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, Zd=0, size=0
    let encoding: u32 = 0x05313BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sunpkhi_z_z_field_zd_0_min_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sunpkhi_z_z_field_zd_1_poweroftwo_3800_05313801() {
    // Encoding: 0x05313801
    // Test SUNPKHI_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1
    let encoding: u32 = 0x05313801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sunpkhi_z_z_field_zd_30_poweroftwominusone_3800_0531381e() {
    // Encoding: 0x0531381E
    // Test SUNPKHI_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zd=30, Zn=0
    let encoding: u32 = 0x0531381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sunpkhi_z_z_field_zd_31_max_3800_0531381f() {
    // Encoding: 0x0531381F
    // Test SUNPKHI_Z.Z__ field Zd = 31 (Max)
    // Fields: Zn=0, Zd=31, size=0
    let encoding: u32 = 0x0531381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sunpkhi_z_z_combo_0_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sunpkhi_z_z_special_size_0_size_variant_0_14336_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sunpkhi_z_z_special_size_1_size_variant_1_14336_05713800() {
    // Encoding: 0x05713800
    // Test SUNPKHI_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, size=1, Zd=0
    let encoding: u32 = 0x05713800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sunpkhi_z_z_special_size_2_size_variant_2_14336_05b13800() {
    // Encoding: 0x05B13800
    // Test SUNPKHI_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, Zd=0, size=2
    let encoding: u32 = 0x05B13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sunpkhi_z_z_special_size_3_size_variant_3_14336_05f13800() {
    // Encoding: 0x05F13800
    // Test SUNPKHI_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x05F13800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sunpkhi_z_z_invalid_0_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sunpkhi_z_z_invalid_1_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_sunpkhi_z_z_invalid_2_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: size=0, Zd=0, Zn=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sunpkhi_z_z_invalid_3_3800_05313800() {
    // Encoding: 0x05313800
    // Test SUNPKHI_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05313800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sunpklo_z_z_field_size_0_min_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ field size = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sunpklo_z_z_field_size_1_poweroftwo_3800_05703800() {
    // Encoding: 0x05703800
    // Test SUNPKLO_Z.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zn=0, Zd=0
    let encoding: u32 = 0x05703800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sunpklo_z_z_field_size_2_poweroftwo_3800_05b03800() {
    // Encoding: 0x05B03800
    // Test SUNPKLO_Z.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zd=0, Zn=0
    let encoding: u32 = 0x05B03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sunpklo_z_z_field_size_3_max_3800_05f03800() {
    // Encoding: 0x05F03800
    // Test SUNPKLO_Z.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x05F03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sunpklo_z_z_field_zn_0_min_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ field Zn = 0 (Min)
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sunpklo_z_z_field_zn_1_poweroftwo_3800_05303820() {
    // Encoding: 0x05303820
    // Test SUNPKLO_Z.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Zn=1, Zd=0
    let encoding: u32 = 0x05303820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sunpklo_z_z_field_zn_30_poweroftwominusone_3800_05303bc0() {
    // Encoding: 0x05303BC0
    // Test SUNPKLO_Z.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, size=0
    let encoding: u32 = 0x05303BC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sunpklo_z_z_field_zn_31_max_3800_05303be0() {
    // Encoding: 0x05303BE0
    // Test SUNPKLO_Z.Z__ field Zn = 31 (Max)
    // Fields: Zd=0, Zn=31, size=0
    let encoding: u32 = 0x05303BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sunpklo_z_z_field_zd_0_min_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ field Zd = 0 (Min)
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sunpklo_z_z_field_zd_1_poweroftwo_3800_05303801() {
    // Encoding: 0x05303801
    // Test SUNPKLO_Z.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Zd=1
    let encoding: u32 = 0x05303801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sunpklo_z_z_field_zd_30_poweroftwominusone_3800_0530381e() {
    // Encoding: 0x0530381E
    // Test SUNPKLO_Z.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, Zd=30, size=0
    let encoding: u32 = 0x0530381E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sunpklo_z_z_field_zd_31_max_3800_0530381f() {
    // Encoding: 0x0530381F
    // Test SUNPKLO_Z.Z__ field Zd = 31 (Max)
    // Fields: size=0, Zn=0, Zd=31
    let encoding: u32 = 0x0530381F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sunpklo_z_z_combo_0_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ field combination: size=0, Zn=0, Zd=0
    // Fields: Zn=0, size=0, Zd=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sunpklo_z_z_special_size_0_size_variant_0_14336_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ special value size = 0 (Size variant 0)
    // Fields: Zd=0, Zn=0, size=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sunpklo_z_z_special_size_1_size_variant_1_14336_05703800() {
    // Encoding: 0x05703800
    // Test SUNPKLO_Z.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zn=0
    let encoding: u32 = 0x05703800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sunpklo_z_z_special_size_2_size_variant_2_14336_05b03800() {
    // Encoding: 0x05B03800
    // Test SUNPKLO_Z.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Zd=0
    let encoding: u32 = 0x05B03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sunpklo_z_z_special_size_3_size_variant_3_14336_05f03800() {
    // Encoding: 0x05F03800
    // Test SUNPKLO_Z.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zn=0, Zd=0
    let encoding: u32 = 0x05F03800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sunpklo_z_z_invalid_0_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zn=0, Zd=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sunpklo_z_z_invalid_1_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, size=0, Zn=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitBits([false, false]) }" }
/// triggers Undefined
#[test]
fn test_sunpklo_z_z_invalid_2_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitBits([false, false]) }
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sunpklo_z_z_invalid_3_3800_05303800() {
    // Encoding: 0x05303800
    // Test SUNPKLO_Z.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Zd=0, size=0
    let encoding: u32 = 0x05303800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SUNPKHI_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sunpkhi_z_z_reg_write_0_05313800() {
    // Test SUNPKHI_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05313800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05313800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: SUNPKLO_Z.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sunpklo_z_z_reg_write_0_05303800() {
    // Test SUNPKLO_Z.Z__ register write: SimdFromField("d")
    // Encoding: 0x05303800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05303800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DUPM_Z.I__ Tests
// ============================================================================

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_dupm_z_i_field_imm13_0_zero_0_05c00000() {
    // Encoding: 0x05C00000
    // Test DUPM_Z.I__ field imm13 = 0 (Zero)
    // Fields: Zd=0, imm13=0
    let encoding: u32 = 0x05C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_dupm_z_i_field_imm13_1_poweroftwo_0_05c00020() {
    // Encoding: 0x05C00020
    // Test DUPM_Z.I__ field imm13 = 1 (PowerOfTwo)
    // Fields: imm13=1, Zd=0
    let encoding: u32 = 0x05C00020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_dupm_z_i_field_imm13_3_poweroftwominusone_0_05c00060() {
    // Encoding: 0x05C00060
    // Test DUPM_Z.I__ field imm13 = 3 (PowerOfTwoMinusOne)
    // Fields: imm13=3, Zd=0
    let encoding: u32 = 0x05C00060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_dupm_z_i_field_imm13_4_poweroftwo_0_05c00080() {
    // Encoding: 0x05C00080
    // Test DUPM_Z.I__ field imm13 = 4 (PowerOfTwo)
    // Fields: Zd=0, imm13=4
    let encoding: u32 = 0x05C00080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_dupm_z_i_field_imm13_7_poweroftwominusone_0_05c000e0() {
    // Encoding: 0x05C000E0
    // Test DUPM_Z.I__ field imm13 = 7 (PowerOfTwoMinusOne)
    // Fields: imm13=7, Zd=0
    let encoding: u32 = 0x05C000E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_dupm_z_i_field_imm13_8_poweroftwo_0_05c00100() {
    // Encoding: 0x05C00100
    // Test DUPM_Z.I__ field imm13 = 8 (PowerOfTwo)
    // Fields: Zd=0, imm13=8
    let encoding: u32 = 0x05C00100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_dupm_z_i_field_imm13_15_poweroftwominusone_0_05c001e0() {
    // Encoding: 0x05C001E0
    // Test DUPM_Z.I__ field imm13 = 15 (PowerOfTwoMinusOne)
    // Fields: Zd=0, imm13=15
    let encoding: u32 = 0x05C001E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_dupm_z_i_field_imm13_16_poweroftwo_0_05c00200() {
    // Encoding: 0x05C00200
    // Test DUPM_Z.I__ field imm13 = 16 (PowerOfTwo)
    // Fields: Zd=0, imm13=16
    let encoding: u32 = 0x05C00200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_dupm_z_i_field_imm13_31_poweroftwominusone_0_05c003e0() {
    // Encoding: 0x05C003E0
    // Test DUPM_Z.I__ field imm13 = 31 (PowerOfTwoMinusOne)
    // Fields: Zd=0, imm13=31
    let encoding: u32 = 0x05C003E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_dupm_z_i_field_imm13_32_poweroftwo_0_05c00400() {
    // Encoding: 0x05C00400
    // Test DUPM_Z.I__ field imm13 = 32 (PowerOfTwo)
    // Fields: imm13=32, Zd=0
    let encoding: u32 = 0x05C00400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_dupm_z_i_field_imm13_63_poweroftwominusone_0_05c007e0() {
    // Encoding: 0x05C007E0
    // Test DUPM_Z.I__ field imm13 = 63 (PowerOfTwoMinusOne)
    // Fields: imm13=63, Zd=0
    let encoding: u32 = 0x05C007E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_dupm_z_i_field_imm13_64_poweroftwo_0_05c00800() {
    // Encoding: 0x05C00800
    // Test DUPM_Z.I__ field imm13 = 64 (PowerOfTwo)
    // Fields: imm13=64, Zd=0
    let encoding: u32 = 0x05C00800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 127, boundary: PowerOfTwoMinusOne }
/// 2^7 - 1 = 127
#[test]
fn test_dupm_z_i_field_imm13_127_poweroftwominusone_0_05c00fe0() {
    // Encoding: 0x05C00FE0
    // Test DUPM_Z.I__ field imm13 = 127 (PowerOfTwoMinusOne)
    // Fields: imm13=127, Zd=0
    let encoding: u32 = 0x05C00FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_dupm_z_i_field_imm13_128_poweroftwo_0_05c01000() {
    // Encoding: 0x05C01000
    // Test DUPM_Z.I__ field imm13 = 128 (PowerOfTwo)
    // Fields: imm13=128, Zd=0
    let encoding: u32 = 0x05C01000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 255, boundary: PowerOfTwoMinusOne }
/// 2^8 - 1 = 255
#[test]
fn test_dupm_z_i_field_imm13_255_poweroftwominusone_0_05c01fe0() {
    // Encoding: 0x05C01FE0
    // Test DUPM_Z.I__ field imm13 = 255 (PowerOfTwoMinusOne)
    // Fields: imm13=255, Zd=0
    let encoding: u32 = 0x05C01FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 256, boundary: PowerOfTwo }
/// power of 2 (2^8 = 256)
#[test]
fn test_dupm_z_i_field_imm13_256_poweroftwo_0_05c02000() {
    // Encoding: 0x05C02000
    // Test DUPM_Z.I__ field imm13 = 256 (PowerOfTwo)
    // Fields: Zd=0, imm13=256
    let encoding: u32 = 0x05C02000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 511, boundary: PowerOfTwoMinusOne }
/// 2^9 - 1 = 511
#[test]
fn test_dupm_z_i_field_imm13_511_poweroftwominusone_0_05c03fe0() {
    // Encoding: 0x05C03FE0
    // Test DUPM_Z.I__ field imm13 = 511 (PowerOfTwoMinusOne)
    // Fields: imm13=511, Zd=0
    let encoding: u32 = 0x05C03FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 512, boundary: PowerOfTwo }
/// power of 2 (2^9 = 512)
#[test]
fn test_dupm_z_i_field_imm13_512_poweroftwo_0_05c04000() {
    // Encoding: 0x05C04000
    // Test DUPM_Z.I__ field imm13 = 512 (PowerOfTwo)
    // Fields: imm13=512, Zd=0
    let encoding: u32 = 0x05C04000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 1023, boundary: PowerOfTwoMinusOne }
/// 2^10 - 1 = 1023
#[test]
fn test_dupm_z_i_field_imm13_1023_poweroftwominusone_0_05c07fe0() {
    // Encoding: 0x05C07FE0
    // Test DUPM_Z.I__ field imm13 = 1023 (PowerOfTwoMinusOne)
    // Fields: imm13=1023, Zd=0
    let encoding: u32 = 0x05C07FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 1024, boundary: PowerOfTwo }
/// power of 2 (2^10 = 1024)
#[test]
fn test_dupm_z_i_field_imm13_1024_poweroftwo_0_05c08000() {
    // Encoding: 0x05C08000
    // Test DUPM_Z.I__ field imm13 = 1024 (PowerOfTwo)
    // Fields: Zd=0, imm13=1024
    let encoding: u32 = 0x05C08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 2047, boundary: PowerOfTwoMinusOne }
/// 2^11 - 1 = 2047
#[test]
fn test_dupm_z_i_field_imm13_2047_poweroftwominusone_0_05c0ffe0() {
    // Encoding: 0x05C0FFE0
    // Test DUPM_Z.I__ field imm13 = 2047 (PowerOfTwoMinusOne)
    // Fields: Zd=0, imm13=2047
    let encoding: u32 = 0x05C0FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 2048, boundary: PowerOfTwo }
/// power of 2 (2^11 = 2048)
#[test]
fn test_dupm_z_i_field_imm13_2048_poweroftwo_0_05c10000() {
    // Encoding: 0x05C10000
    // Test DUPM_Z.I__ field imm13 = 2048 (PowerOfTwo)
    // Fields: imm13=2048, Zd=0
    let encoding: u32 = 0x05C10000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 4095, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (4095)
#[test]
fn test_dupm_z_i_field_imm13_4095_poweroftwominusone_0_05c1ffe0() {
    // Encoding: 0x05C1FFE0
    // Test DUPM_Z.I__ field imm13 = 4095 (PowerOfTwoMinusOne)
    // Fields: imm13=4095, Zd=0
    let encoding: u32 = 0x05C1FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 4096, boundary: PowerOfTwo }
/// power of 2 (2^12 = 4096)
#[test]
fn test_dupm_z_i_field_imm13_4096_poweroftwo_0_05c20000() {
    // Encoding: 0x05C20000
    // Test DUPM_Z.I__ field imm13 = 4096 (PowerOfTwo)
    // Fields: Zd=0, imm13=4096
    let encoding: u32 = 0x05C20000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field imm13 5 +: 13`
/// Requirement: FieldBoundary { field: "imm13", value: 8191, boundary: Max }
/// maximum immediate (8191)
#[test]
fn test_dupm_z_i_field_imm13_8191_max_0_05c3ffe0() {
    // Encoding: 0x05C3FFE0
    // Test DUPM_Z.I__ field imm13 = 8191 (Max)
    // Fields: Zd=0, imm13=8191
    let encoding: u32 = 0x05C3FFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_dupm_z_i_field_zd_0_min_0_05c00000() {
    // Encoding: 0x05C00000
    // Test DUPM_Z.I__ field Zd = 0 (Min)
    // Fields: imm13=0, Zd=0
    let encoding: u32 = 0x05C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_dupm_z_i_field_zd_1_poweroftwo_0_05c00001() {
    // Encoding: 0x05C00001
    // Test DUPM_Z.I__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, imm13=0
    let encoding: u32 = 0x05C00001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_dupm_z_i_field_zd_30_poweroftwominusone_0_05c0001e() {
    // Encoding: 0x05C0001E
    // Test DUPM_Z.I__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, imm13=0
    let encoding: u32 = 0x05C0001E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_dupm_z_i_field_zd_31_max_0_05c0001f() {
    // Encoding: 0x05C0001F
    // Test DUPM_Z.I__ field Zd = 31 (Max)
    // Fields: Zd=31, imm13=0
    let encoding: u32 = 0x05C0001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// imm13=0 (immediate value 0)
#[test]
fn test_dupm_z_i_combo_0_0_05c00000() {
    // Encoding: 0x05C00000
    // Test DUPM_Z.I__ field combination: imm13=0, Zd=0
    // Fields: Zd=0, imm13=0
    let encoding: u32 = 0x05C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_dupm_z_i_invalid_0_0_05c00000() {
    // Encoding: 0x05C00000
    // Test DUPM_Z.I__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm13=0, Zd=0
    let encoding: u32 = 0x05C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dupm_z_i_invalid_1_0_05c00000() {
    // Encoding: 0x05C00000
    // Test DUPM_Z.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, imm13=0
    let encoding: u32 = 0x05C00000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUPM_Z.I__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_dupm_z_i_reg_write_0_05c00000() {
    // Test DUPM_Z.I__ register write: SimdFromField("d")
    // Encoding: 0x05C00000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05C00000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// DUP_Z.I__ Tests
// ============================================================================

/// Provenance: DUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_dup_z_i_field_size_0_min_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ field size = 0 (Min)
    // Fields: Zd=0, imm8=0, size=0, sh=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_dup_z_i_field_size_1_poweroftwo_c000_2578c000() {
    // Encoding: 0x2578C000
    // Test DUP_Z.I__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, size=1, sh=0, imm8=0
    let encoding: u32 = 0x2578C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_dup_z_i_field_size_2_poweroftwo_c000_25b8c000() {
    // Encoding: 0x25B8C000
    // Test DUP_Z.I__ field size = 2 (PowerOfTwo)
    // Fields: size=2, imm8=0, sh=0, Zd=0
    let encoding: u32 = 0x25B8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_dup_z_i_field_size_3_max_c000_25f8c000() {
    // Encoding: 0x25F8C000
    // Test DUP_Z.I__ field size = 3 (Max)
    // Fields: size=3, sh=0, imm8=0, Zd=0
    let encoding: u32 = 0x25F8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 0, boundary: Min }
/// shift type LSL (logical shift left)
#[test]
fn test_dup_z_i_field_sh_0_min_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ field sh = 0 (Min)
    // Fields: Zd=0, sh=0, size=0, imm8=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field sh 13 +: 1`
/// Requirement: FieldBoundary { field: "sh", value: 1, boundary: Max }
/// shift type LSR (logical shift right)
#[test]
fn test_dup_z_i_field_sh_1_max_c000_2538e000() {
    // Encoding: 0x2538E000
    // Test DUP_Z.I__ field sh = 1 (Max)
    // Fields: size=0, sh=1, Zd=0, imm8=0
    let encoding: u32 = 0x2538E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_dup_z_i_field_imm8_0_zero_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ field imm8 = 0 (Zero)
    // Fields: size=0, sh=0, imm8=0, Zd=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_dup_z_i_field_imm8_1_poweroftwo_c000_2538c020() {
    // Encoding: 0x2538C020
    // Test DUP_Z.I__ field imm8 = 1 (PowerOfTwo)
    // Fields: Zd=0, sh=0, size=0, imm8=1
    let encoding: u32 = 0x2538C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_dup_z_i_field_imm8_3_poweroftwominusone_c000_2538c060() {
    // Encoding: 0x2538C060
    // Test DUP_Z.I__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=3, sh=0, Zd=0
    let encoding: u32 = 0x2538C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_dup_z_i_field_imm8_4_poweroftwo_c000_2538c080() {
    // Encoding: 0x2538C080
    // Test DUP_Z.I__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, imm8=4, sh=0, Zd=0
    let encoding: u32 = 0x2538C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_dup_z_i_field_imm8_7_poweroftwominusone_c000_2538c0e0() {
    // Encoding: 0x2538C0E0
    // Test DUP_Z.I__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: sh=0, size=0, imm8=7, Zd=0
    let encoding: u32 = 0x2538C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_dup_z_i_field_imm8_8_poweroftwo_c000_2538c100() {
    // Encoding: 0x2538C100
    // Test DUP_Z.I__ field imm8 = 8 (PowerOfTwo)
    // Fields: sh=0, imm8=8, size=0, Zd=0
    let encoding: u32 = 0x2538C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_dup_z_i_field_imm8_15_poweroftwominusone_c000_2538c1e0() {
    // Encoding: 0x2538C1E0
    // Test DUP_Z.I__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=15, size=0, sh=0, Zd=0
    let encoding: u32 = 0x2538C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_dup_z_i_field_imm8_16_poweroftwo_c000_2538c200() {
    // Encoding: 0x2538C200
    // Test DUP_Z.I__ field imm8 = 16 (PowerOfTwo)
    // Fields: size=0, sh=0, imm8=16, Zd=0
    let encoding: u32 = 0x2538C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_dup_z_i_field_imm8_31_poweroftwominusone_c000_2538c3e0() {
    // Encoding: 0x2538C3E0
    // Test DUP_Z.I__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: Zd=0, sh=0, size=0, imm8=31
    let encoding: u32 = 0x2538C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_dup_z_i_field_imm8_32_poweroftwo_c000_2538c400() {
    // Encoding: 0x2538C400
    // Test DUP_Z.I__ field imm8 = 32 (PowerOfTwo)
    // Fields: imm8=32, size=0, sh=0, Zd=0
    let encoding: u32 = 0x2538C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_dup_z_i_field_imm8_63_poweroftwominusone_c000_2538c7e0() {
    // Encoding: 0x2538C7E0
    // Test DUP_Z.I__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: sh=0, imm8=63, Zd=0, size=0
    let encoding: u32 = 0x2538C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_dup_z_i_field_imm8_64_poweroftwo_c000_2538c800() {
    // Encoding: 0x2538C800
    // Test DUP_Z.I__ field imm8 = 64 (PowerOfTwo)
    // Fields: Zd=0, size=0, imm8=64, sh=0
    let encoding: u32 = 0x2538C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_dup_z_i_field_imm8_127_poweroftwominusone_c000_2538cfe0() {
    // Encoding: 0x2538CFE0
    // Test DUP_Z.I__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=127, Zd=0, sh=0
    let encoding: u32 = 0x2538CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_dup_z_i_field_imm8_128_poweroftwo_c000_2538d000() {
    // Encoding: 0x2538D000
    // Test DUP_Z.I__ field imm8 = 128 (PowerOfTwo)
    // Fields: imm8=128, size=0, Zd=0, sh=0
    let encoding: u32 = 0x2538D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_dup_z_i_field_imm8_255_max_c000_2538dfe0() {
    // Encoding: 0x2538DFE0
    // Test DUP_Z.I__ field imm8 = 255 (Max)
    // Fields: size=0, sh=0, Zd=0, imm8=255
    let encoding: u32 = 0x2538DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_dup_z_i_field_zd_0_min_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, imm8=0, sh=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_dup_z_i_field_zd_1_poweroftwo_c000_2538c001() {
    // Encoding: 0x2538C001
    // Test DUP_Z.I__ field Zd = 1 (PowerOfTwo)
    // Fields: imm8=0, size=0, sh=0, Zd=1
    let encoding: u32 = 0x2538C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_dup_z_i_field_zd_30_poweroftwominusone_c000_2538c01e() {
    // Encoding: 0x2538C01E
    // Test DUP_Z.I__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: sh=0, Zd=30, size=0, imm8=0
    let encoding: u32 = 0x2538C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_dup_z_i_field_zd_31_max_c000_2538c01f() {
    // Encoding: 0x2538C01F
    // Test DUP_Z.I__ field Zd = 31 (Max)
    // Fields: Zd=31, sh=0, size=0, imm8=0
    let encoding: u32 = 0x2538C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_dup_z_i_combo_0_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ field combination: size=0, sh=0, imm8=0, Zd=0
    // Fields: imm8=0, size=0, Zd=0, sh=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_dup_z_i_special_size_0_size_variant_0_49152_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ special value size = 0 (Size variant 0)
    // Fields: imm8=0, size=0, sh=0, Zd=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_dup_z_i_special_size_1_size_variant_1_49152_2578c000() {
    // Encoding: 0x2578C000
    // Test DUP_Z.I__ special value size = 1 (Size variant 1)
    // Fields: size=1, sh=0, imm8=0, Zd=0
    let encoding: u32 = 0x2578C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_dup_z_i_special_size_2_size_variant_2_49152_25b8c000() {
    // Encoding: 0x25B8C000
    // Test DUP_Z.I__ special value size = 2 (Size variant 2)
    // Fields: size=2, sh=0, imm8=0, Zd=0
    let encoding: u32 = 0x25B8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_dup_z_i_special_size_3_size_variant_3_49152_25f8c000() {
    // Encoding: 0x25F8C000
    // Test DUP_Z.I__ special value size = 3 (Size variant 3)
    // Fields: Zd=0, sh=0, imm8=0, size=3
    let encoding: u32 = 0x25F8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field sh = 0 (Shift type LSL)`
/// Requirement: FieldSpecial { field: "sh", value: 0, meaning: "Shift type LSL" }
/// Shift type LSL
#[test]
fn test_dup_z_i_special_sh_0_shift_type_lsl_49152_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ special value sh = 0 (Shift type LSL)
    // Fields: size=0, sh=0, Zd=0, imm8=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field sh = 1 (Shift type LSR)`
/// Requirement: FieldSpecial { field: "sh", value: 1, meaning: "Shift type LSR" }
/// Shift type LSR
#[test]
fn test_dup_z_i_special_sh_1_shift_type_lsr_49152_2538e000() {
    // Encoding: 0x2538E000
    // Test DUP_Z.I__ special value sh = 1 (Shift type LSR)
    // Fields: imm8=0, Zd=0, size=0, sh=1
    let encoding: u32 = 0x2538E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field sh = 2 (Shift type ASR)`
/// Requirement: FieldSpecial { field: "sh", value: 2, meaning: "Shift type ASR" }
/// Shift type ASR
#[test]
fn test_dup_z_i_special_sh_2_shift_type_asr_49152_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ special value sh = 2 (Shift type ASR)
    // Fields: size=0, Zd=0, sh=2, imm8=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `field sh = 3 (Shift type ROR)`
/// Requirement: FieldSpecial { field: "sh", value: 3, meaning: "Shift type ROR" }
/// Shift type ROR
#[test]
fn test_dup_z_i_special_sh_3_shift_type_ror_49152_2538e000() {
    // Encoding: 0x2538E000
    // Test DUP_Z.I__ special value sh = 3 (Shift type ROR)
    // Fields: imm8=0, sh=3, size=0, Zd=0
    let encoding: u32 = 0x2538E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_dup_z_i_invalid_0_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zd=0, sh=0, imm8=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dup_z_i_invalid_1_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, sh=0, imm8=0, Zd=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"sh\" }), rhs: LitBits([false, false, true]) } }" }
/// triggers Undefined
#[test]
fn test_dup_z_i_invalid_2_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ invalid encoding: Binary { op: BitConcat, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "sh" }), rhs: LitBits([false, false, true]) } }
    // Fields: Zd=0, sh=0, size=0, imm8=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_dup_z_i_invalid_3_c000_2538c000() {
    // Encoding: 0x2538C000
    // Test DUP_Z.I__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, imm8=0, Zd=0, sh=0
    let encoding: u32 = 0x2538C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: DUP_Z.I__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_dup_z_i_reg_write_0_2538c000() {
    // Test DUP_Z.I__ register write: SimdFromField("d")
    // Encoding: 0x2538C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2538C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMIN_Z.ZI__ Tests
// ============================================================================

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_smin_z_zi_field_size_0_min_c000_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ field size = 0 (Min)
    // Fields: imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_smin_z_zi_field_size_1_poweroftwo_c000_256ac000() {
    // Encoding: 0x256AC000
    // Test SMIN_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zdn=0, imm8=0
    let encoding: u32 = 0x256AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_smin_z_zi_field_size_2_poweroftwo_c000_25aac000() {
    // Encoding: 0x25AAC000
    // Test SMIN_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, imm8=0
    let encoding: u32 = 0x25AAC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_smin_z_zi_field_size_3_max_c000_25eac000() {
    // Encoding: 0x25EAC000
    // Test SMIN_Z.ZI__ field size = 3 (Max)
    // Fields: size=3, Zdn=0, imm8=0
    let encoding: u32 = 0x25EAC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_smin_z_zi_field_imm8_0_zero_c000_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_smin_z_zi_field_imm8_1_poweroftwo_c000_252ac020() {
    // Encoding: 0x252AC020
    // Test SMIN_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: imm8=1, size=0, Zdn=0
    let encoding: u32 = 0x252AC020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_smin_z_zi_field_imm8_3_poweroftwominusone_c000_252ac060() {
    // Encoding: 0x252AC060
    // Test SMIN_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: imm8=3, size=0, Zdn=0
    let encoding: u32 = 0x252AC060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_smin_z_zi_field_imm8_4_poweroftwo_c000_252ac080() {
    // Encoding: 0x252AC080
    // Test SMIN_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, Zdn=0, imm8=4
    let encoding: u32 = 0x252AC080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_smin_z_zi_field_imm8_7_poweroftwominusone_c000_252ac0e0() {
    // Encoding: 0x252AC0E0
    // Test SMIN_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=7, size=0
    let encoding: u32 = 0x252AC0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_smin_z_zi_field_imm8_8_poweroftwo_c000_252ac100() {
    // Encoding: 0x252AC100
    // Test SMIN_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: imm8=8, size=0, Zdn=0
    let encoding: u32 = 0x252AC100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_smin_z_zi_field_imm8_15_poweroftwominusone_c000_252ac1e0() {
    // Encoding: 0x252AC1E0
    // Test SMIN_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=15, Zdn=0, size=0
    let encoding: u32 = 0x252AC1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_smin_z_zi_field_imm8_16_poweroftwo_c000_252ac200() {
    // Encoding: 0x252AC200
    // Test SMIN_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: imm8=16, Zdn=0, size=0
    let encoding: u32 = 0x252AC200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_smin_z_zi_field_imm8_31_poweroftwominusone_c000_252ac3e0() {
    // Encoding: 0x252AC3E0
    // Test SMIN_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=31, Zdn=0
    let encoding: u32 = 0x252AC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_smin_z_zi_field_imm8_32_poweroftwo_c000_252ac400() {
    // Encoding: 0x252AC400
    // Test SMIN_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: Zdn=0, size=0, imm8=32
    let encoding: u32 = 0x252AC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_smin_z_zi_field_imm8_63_poweroftwominusone_c000_252ac7e0() {
    // Encoding: 0x252AC7E0
    // Test SMIN_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=63, size=0
    let encoding: u32 = 0x252AC7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_smin_z_zi_field_imm8_64_poweroftwo_c000_252ac800() {
    // Encoding: 0x252AC800
    // Test SMIN_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: Zdn=0, size=0, imm8=64
    let encoding: u32 = 0x252AC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_smin_z_zi_field_imm8_127_poweroftwominusone_c000_252acfe0() {
    // Encoding: 0x252ACFE0
    // Test SMIN_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, imm8=127
    let encoding: u32 = 0x252ACFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_smin_z_zi_field_imm8_128_poweroftwo_c000_252ad000() {
    // Encoding: 0x252AD000
    // Test SMIN_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: size=0, imm8=128, Zdn=0
    let encoding: u32 = 0x252AD000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_smin_z_zi_field_imm8_255_max_c000_252adfe0() {
    // Encoding: 0x252ADFE0
    // Test SMIN_Z.ZI__ field imm8 = 255 (Max)
    // Fields: size=0, imm8=255, Zdn=0
    let encoding: u32 = 0x252ADFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_smin_z_zi_field_zdn_0_min_c000_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ field Zdn = 0 (Min)
    // Fields: imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_smin_z_zi_field_zdn_1_poweroftwo_c000_252ac001() {
    // Encoding: 0x252AC001
    // Test SMIN_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: imm8=0, Zdn=1, size=0
    let encoding: u32 = 0x252AC001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_smin_z_zi_field_zdn_15_poweroftwominusone_c000_252ac00f() {
    // Encoding: 0x252AC00F
    // Test SMIN_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, size=0, imm8=0
    let encoding: u32 = 0x252AC00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_smin_z_zi_field_zdn_31_max_c000_252ac01f() {
    // Encoding: 0x252AC01F
    // Test SMIN_Z.ZI__ field Zdn = 31 (Max)
    // Fields: size=0, imm8=0, Zdn=31
    let encoding: u32 = 0x252AC01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_smin_z_zi_combo_0_c000_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_smin_z_zi_special_size_0_size_variant_0_49152_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: size=0, Zdn=0, imm8=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_smin_z_zi_special_size_1_size_variant_1_49152_256ac000() {
    // Encoding: 0x256AC000
    // Test SMIN_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: imm8=0, Zdn=0, size=1
    let encoding: u32 = 0x256AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_smin_z_zi_special_size_2_size_variant_2_49152_25aac000() {
    // Encoding: 0x25AAC000
    // Test SMIN_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: imm8=0, Zdn=0, size=2
    let encoding: u32 = 0x25AAC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_smin_z_zi_special_size_3_size_variant_3_49152_25eac000() {
    // Encoding: 0x25EAC000
    // Test SMIN_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, imm8=0
    let encoding: u32 = 0x25EAC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_smin_z_zi_invalid_0_c000_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_smin_z_zi_invalid_1_c000_252ac000() {
    // Encoding: 0x252AC000
    // Test SMIN_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x252AC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMIN_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_smin_z_zi_reg_write_0_252ac000() {
    // Test SMIN_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x252AC000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252AC000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ASR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_asr_z_p_zz_field_size_0_min_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_asr_z_p_zz_field_size_1_poweroftwo_8000_04508000() {
    // Encoding: 0x04508000
    // Test ASR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, Zm=0, Pg=0
    let encoding: u32 = 0x04508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_asr_z_p_zz_field_size_2_poweroftwo_8000_04908000() {
    // Encoding: 0x04908000
    // Test ASR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04908000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_asr_z_p_zz_field_size_3_max_8000_04d08000() {
    // Encoding: 0x04D08000
    // Test ASR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zdn=0, Zm=0, Pg=0, size=3
    let encoding: u32 = 0x04D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_asr_z_p_zz_field_pg_0_min_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_asr_z_p_zz_field_pg_1_poweroftwo_8000_04108400() {
    // Encoding: 0x04108400
    // Test ASR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04108400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_p_zz_field_zm_0_min_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zm=0, size=0, Zdn=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_p_zz_field_zm_1_poweroftwo_8000_04108020() {
    // Encoding: 0x04108020
    // Test ASR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=1, Zdn=0
    let encoding: u32 = 0x04108020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_p_zz_field_zm_30_poweroftwominusone_8000_041083c0() {
    // Encoding: 0x041083C0
    // Test ASR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=0, size=0, Zm=30
    let encoding: u32 = 0x041083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_p_zz_field_zm_31_max_8000_041083e0() {
    // Encoding: 0x041083E0
    // Test ASR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Zdn=0, Pg=0
    let encoding: u32 = 0x041083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_p_zz_field_zdn_0_min_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_p_zz_field_zdn_1_poweroftwo_8000_04108001() {
    // Encoding: 0x04108001
    // Test ASR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, Pg=0, Zm=0
    let encoding: u32 = 0x04108001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_asr_z_p_zz_field_zdn_15_poweroftwominusone_8000_0410800f() {
    // Encoding: 0x0410800F
    // Test ASR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x0410800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_asr_z_p_zz_field_zdn_31_max_8000_0410801f() {
    // Encoding: 0x0410801F
    // Test ASR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zm=0, Zdn=31
    let encoding: u32 = 0x0410801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_asr_z_p_zz_combo_0_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_asr_z_p_zz_special_size_0_size_variant_0_32768_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_asr_z_p_zz_special_size_1_size_variant_1_32768_04508000() {
    // Encoding: 0x04508000
    // Test ASR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04508000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_asr_z_p_zz_special_size_2_size_variant_2_32768_04908000() {
    // Encoding: 0x04908000
    // Test ASR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x04908000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_asr_z_p_zz_special_size_3_size_variant_3_32768_04d08000() {
    // Encoding: 0x04D08000
    // Test ASR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x04D08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zz_invalid_0_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_p_zz_invalid_1_8000_04108000() {
    // Encoding: 0x04108000
    // Test ASR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04108000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_asr_z_p_zz_reg_write_0_04108000() {
    // Test ASR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04108000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04108000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SDIV_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sdiv_z_p_zz_field_size_0_min_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sdiv_z_p_zz_field_size_1_poweroftwo_0_04540000() {
    // Encoding: 0x04540000
    // Test SDIV_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04540000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sdiv_z_p_zz_field_size_2_poweroftwo_0_04940000() {
    // Encoding: 0x04940000
    // Test SDIV_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04940000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sdiv_z_p_zz_field_size_3_max_0_04d40000() {
    // Encoding: 0x04D40000
    // Test SDIV_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Zdn=0, Pg=0
    let encoding: u32 = 0x04D40000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sdiv_z_p_zz_field_pg_0_min_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sdiv_z_p_zz_field_pg_1_poweroftwo_0_04140400() {
    // Encoding: 0x04140400
    // Test SDIV_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zdn=0, Zm=0
    let encoding: u32 = 0x04140400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sdiv_z_p_zz_field_zm_0_min_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sdiv_z_p_zz_field_zm_1_poweroftwo_0_04140020() {
    // Encoding: 0x04140020
    // Test SDIV_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=0, Zm=1
    let encoding: u32 = 0x04140020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sdiv_z_p_zz_field_zm_30_poweroftwominusone_0_041403c0() {
    // Encoding: 0x041403C0
    // Test SDIV_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x041403C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sdiv_z_p_zz_field_zm_31_max_0_041403e0() {
    // Encoding: 0x041403E0
    // Test SDIV_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Zdn=0, Pg=0, Zm=31
    let encoding: u32 = 0x041403E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_sdiv_z_p_zz_field_zdn_0_min_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Pg=0, Zdn=0, Zm=0, size=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_sdiv_z_p_zz_field_zdn_1_poweroftwo_0_04140001() {
    // Encoding: 0x04140001
    // Test SDIV_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x04140001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_sdiv_z_p_zz_field_zdn_15_poweroftwominusone_0_0414000f() {
    // Encoding: 0x0414000F
    // Test SDIV_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zdn=15, size=0, Zm=0
    let encoding: u32 = 0x0414000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_sdiv_z_p_zz_field_zdn_31_max_0_0414001f() {
    // Encoding: 0x0414001F
    // Test SDIV_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, size=0, Zdn=31, Zm=0
    let encoding: u32 = 0x0414001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sdiv_z_p_zz_combo_0_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sdiv_z_p_zz_special_size_0_size_variant_0_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, Zdn=0, size=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sdiv_z_p_zz_special_size_1_size_variant_1_0_04540000() {
    // Encoding: 0x04540000
    // Test SDIV_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zdn=0, Zm=0
    let encoding: u32 = 0x04540000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sdiv_z_p_zz_special_size_2_size_variant_2_0_04940000() {
    // Encoding: 0x04940000
    // Test SDIV_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zdn=0, size=2, Pg=0
    let encoding: u32 = 0x04940000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sdiv_z_p_zz_special_size_3_size_variant_3_0_04d40000() {
    // Encoding: 0x04D40000
    // Test SDIV_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x04D40000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sdiv_z_p_zz_invalid_0_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdiv_z_p_zz_invalid_1_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }`
/// Requirement: UndefinedEncoding { condition: "Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: \"size\" }), rhs: LitMask([Zero, Either]) }" }
/// triggers Undefined
#[test]
fn test_sdiv_z_p_zz_invalid_2_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ invalid encoding: Binary { op: Eq, lhs: Var(QualifiedIdentifier { qualifier: Any, name: "size" }), rhs: LitMask([Zero, Either]) }
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sdiv_z_p_zz_invalid_3_0_04140000() {
    // Encoding: 0x04140000
    // Test SDIV_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04140000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SDIV_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_sdiv_z_p_zz_reg_write_0_04140000() {
    // Test SDIV_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04140000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04140000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMAXV_R.P.Z__ Tests
// ============================================================================

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_smaxv_r_p_z_field_size_0_min_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_smaxv_r_p_z_field_size_1_poweroftwo_2000_04482000() {
    // Encoding: 0x04482000
    // Test SMAXV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Vd=0, Pg=0, Zn=0, size=1
    let encoding: u32 = 0x04482000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_smaxv_r_p_z_field_size_2_poweroftwo_2000_04882000() {
    // Encoding: 0x04882000
    // Test SMAXV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zn=0, Vd=0
    let encoding: u32 = 0x04882000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_smaxv_r_p_z_field_size_3_max_2000_04c82000() {
    // Encoding: 0x04C82000
    // Test SMAXV_R.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Vd=0, Zn=0
    let encoding: u32 = 0x04C82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_smaxv_r_p_z_field_pg_0_min_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, Pg=0, size=0, Vd=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_smaxv_r_p_z_field_pg_1_poweroftwo_2000_04082400() {
    // Encoding: 0x04082400
    // Test SMAXV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Vd=0, Zn=0, Pg=1
    let encoding: u32 = 0x04082400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_smaxv_r_p_z_field_zn_0_min_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_smaxv_r_p_z_field_zn_1_poweroftwo_2000_04082020() {
    // Encoding: 0x04082020
    // Test SMAXV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Vd=0, Zn=1
    let encoding: u32 = 0x04082020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_smaxv_r_p_z_field_zn_30_poweroftwominusone_2000_040823c0() {
    // Encoding: 0x040823C0
    // Test SMAXV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Vd=0, Pg=0, Zn=30
    let encoding: u32 = 0x040823C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_smaxv_r_p_z_field_zn_31_max_2000_040823e0() {
    // Encoding: 0x040823E0
    // Test SMAXV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Zn=31, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x040823E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_smaxv_r_p_z_field_vd_0_min_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Zn=0, size=0, Vd=0, Pg=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_smaxv_r_p_z_field_vd_1_poweroftwo_2000_04082001() {
    // Encoding: 0x04082001
    // Test SMAXV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, Vd=1, size=0
    let encoding: u32 = 0x04082001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_smaxv_r_p_z_field_vd_30_poweroftwominusone_2000_0408201e() {
    // Encoding: 0x0408201E
    // Test SMAXV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zn=0, Vd=30
    let encoding: u32 = 0x0408201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_smaxv_r_p_z_field_vd_31_max_2000_0408201f() {
    // Encoding: 0x0408201F
    // Test SMAXV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Pg=0, size=0, Vd=31, Zn=0
    let encoding: u32 = 0x0408201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_smaxv_r_p_z_combo_0_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_smaxv_r_p_z_special_size_0_size_variant_0_8192_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_smaxv_r_p_z_special_size_1_size_variant_1_8192_04482000() {
    // Encoding: 0x04482000
    // Test SMAXV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zn=0, Pg=0, size=1, Vd=0
    let encoding: u32 = 0x04482000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_smaxv_r_p_z_special_size_2_size_variant_2_8192_04882000() {
    // Encoding: 0x04882000
    // Test SMAXV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Vd=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x04882000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_smaxv_r_p_z_special_size_3_size_variant_3_8192_04c82000() {
    // Encoding: 0x04C82000
    // Test SMAXV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Vd=0, Zn=0, size=3
    let encoding: u32 = 0x04C82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_smaxv_r_p_z_invalid_0_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_smaxv_r_p_z_invalid_1_2000_04082000() {
    // Encoding: 0x04082000
    // Test SMAXV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x04082000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMAXV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_smaxv_r_p_z_reg_write_0_04082000() {
    // Test SMAXV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04082000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04082000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CPY_Z.P.R__ Tests
// ============================================================================

/// Provenance: CPY_Z.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cpy_z_p_r_field_size_0_min_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ field size = 0 (Min)
    // Fields: size=0, Zd=0, Pg=0, Rn=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cpy_z_p_r_field_size_1_poweroftwo_a000_0568a000() {
    // Encoding: 0x0568A000
    // Test CPY_Z.P.R__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, Rn=0, size=1
    let encoding: u32 = 0x0568A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cpy_z_p_r_field_size_2_poweroftwo_a000_05a8a000() {
    // Encoding: 0x05A8A000
    // Test CPY_Z.P.R__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Rn=0, Pg=0, Zd=0
    let encoding: u32 = 0x05A8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cpy_z_p_r_field_size_3_max_a000_05e8a000() {
    // Encoding: 0x05E8A000
    // Test CPY_Z.P.R__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Zd=0, Rn=0
    let encoding: u32 = 0x05E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cpy_z_p_r_field_pg_0_min_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Rn=0, Zd=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cpy_z_p_r_field_pg_1_poweroftwo_a000_0528a400() {
    // Encoding: 0x0528A400
    // Test CPY_Z.P.R__ field Pg = 1 (PowerOfTwo)
    // Fields: Zd=0, Rn=0, size=0, Pg=1
    let encoding: u32 = 0x0528A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cpy_z_p_r_field_rn_0_min_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ field Rn = 0 (Min)
    // Fields: Rn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cpy_z_p_r_field_rn_1_poweroftwo_a000_0528a020() {
    // Encoding: 0x0528A020
    // Test CPY_Z.P.R__ field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, size=0, Pg=0, Zd=0
    let encoding: u32 = 0x0528A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_cpy_z_p_r_field_rn_30_poweroftwominusone_a000_0528a3c0() {
    // Encoding: 0x0528A3C0
    // Test CPY_Z.P.R__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zd=0, Rn=30
    let encoding: u32 = 0x0528A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_cpy_z_p_r_field_rn_31_max_a000_0528a3e0() {
    // Encoding: 0x0528A3E0
    // Test CPY_Z.P.R__ field Rn = 31 (Max)
    // Fields: size=0, Rn=31, Zd=0, Pg=0
    let encoding: u32 = 0x0528A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cpy_z_p_r_field_zd_0_min_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ field Zd = 0 (Min)
    // Fields: size=0, Pg=0, Rn=0, Zd=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cpy_z_p_r_field_zd_1_poweroftwo_a000_0528a001() {
    // Encoding: 0x0528A001
    // Test CPY_Z.P.R__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, Rn=0, Pg=0
    let encoding: u32 = 0x0528A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cpy_z_p_r_field_zd_30_poweroftwominusone_a000_0528a01e() {
    // Encoding: 0x0528A01E
    // Test CPY_Z.P.R__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Rn=0, Zd=30, size=0
    let encoding: u32 = 0x0528A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cpy_z_p_r_field_zd_31_max_a000_0528a01f() {
    // Encoding: 0x0528A01F
    // Test CPY_Z.P.R__ field Zd = 31 (Max)
    // Fields: Rn=0, Zd=31, Pg=0, size=0
    let encoding: u32 = 0x0528A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cpy_z_p_r_combo_0_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ field combination: size=0, Pg=0, Rn=0, Zd=0
    // Fields: size=0, Pg=0, Zd=0, Rn=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cpy_z_p_r_special_size_0_size_variant_0_40960_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ special value size = 0 (Size variant 0)
    // Fields: Rn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cpy_z_p_r_special_size_1_size_variant_1_40960_0568a000() {
    // Encoding: 0x0568A000
    // Test CPY_Z.P.R__ special value size = 1 (Size variant 1)
    // Fields: Rn=0, Zd=0, Pg=0, size=1
    let encoding: u32 = 0x0568A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cpy_z_p_r_special_size_2_size_variant_2_40960_05a8a000() {
    // Encoding: 0x05A8A000
    // Test CPY_Z.P.R__ special value size = 2 (Size variant 2)
    // Fields: Rn=0, Zd=0, size=2, Pg=0
    let encoding: u32 = 0x05A8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cpy_z_p_r_special_size_3_size_variant_3_40960_05e8a000() {
    // Encoding: 0x05E8A000
    // Test CPY_Z.P.R__ special value size = 3 (Size variant 3)
    // Fields: size=3, Rn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05E8A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_cpy_z_p_r_special_rn_31_stack_pointer_sp_may_require_alignment_40960_0528a3e0() {
    // Encoding: 0x0528A3E0
    // Test CPY_Z.P.R__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Rn=31, Zd=0, Pg=0, size=0
    let encoding: u32 = 0x0528A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_r_invalid_0_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, size=0, Rn=0, Pg=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_r_invalid_1_a000_0528a000() {
    // Encoding: 0x0528A000
    // Test CPY_Z.P.R__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Rn=0, size=0
    let encoding: u32 = 0x0528A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.R__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cpy_z_p_r_reg_write_0_0528a000() {
    // Test CPY_Z.P.R__ register write: SimdFromField("d")
    // Encoding: 0x0528A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0528A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: CPY_Z.P.R__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_cpy_z_p_r_sp_rn_0528a3e0() {
    // Test CPY_Z.P.R__ with Rn = SP (31)
    // Encoding: 0x0528A3E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0528A3E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsl_z_p_zz_field_size_0_min_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsl_z_p_zz_field_size_1_poweroftwo_8000_04538000() {
    // Encoding: 0x04538000
    // Test LSL_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zdn=0, Zm=0
    let encoding: u32 = 0x04538000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsl_z_p_zz_field_size_2_poweroftwo_8000_04938000() {
    // Encoding: 0x04938000
    // Test LSL_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04938000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsl_z_p_zz_field_size_3_max_8000_04d38000() {
    // Encoding: 0x04D38000
    // Test LSL_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04D38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsl_z_p_zz_field_pg_0_min_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, Zdn=0, Pg=0, size=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsl_z_p_zz_field_pg_1_poweroftwo_8000_04138400() {
    // Encoding: 0x04138400
    // Test LSL_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=1, size=0, Zm=0
    let encoding: u32 = 0x04138400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_p_zz_field_zm_0_min_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_p_zz_field_zm_1_poweroftwo_8000_04138020() {
    // Encoding: 0x04138020
    // Test LSL_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zm=1, Zdn=0, size=0
    let encoding: u32 = 0x04138020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_p_zz_field_zm_30_poweroftwominusone_8000_041383c0() {
    // Encoding: 0x041383C0
    // Test LSL_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zm=30, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x041383C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_p_zz_field_zm_31_max_8000_041383e0() {
    // Encoding: 0x041383E0
    // Test LSL_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x041383E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zz_field_zdn_0_min_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zz_field_zdn_1_poweroftwo_8000_04138001() {
    // Encoding: 0x04138001
    // Test LSL_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04138001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsl_z_p_zz_field_zdn_15_poweroftwominusone_8000_0413800f() {
    // Encoding: 0x0413800F
    // Test LSL_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zdn=15, Zm=0
    let encoding: u32 = 0x0413800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsl_z_p_zz_field_zdn_31_max_8000_0413801f() {
    // Encoding: 0x0413801F
    // Test LSL_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Zm=0, Pg=0, Zdn=31
    let encoding: u32 = 0x0413801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsl_z_p_zz_combo_0_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsl_z_p_zz_special_size_0_size_variant_0_32768_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsl_z_p_zz_special_size_1_size_variant_1_32768_04538000() {
    // Encoding: 0x04538000
    // Test LSL_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04538000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsl_z_p_zz_special_size_2_size_variant_2_32768_04938000() {
    // Encoding: 0x04938000
    // Test LSL_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Zdn=0, Pg=0, size=2
    let encoding: u32 = 0x04938000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsl_z_p_zz_special_size_3_size_variant_3_32768_04d38000() {
    // Encoding: 0x04D38000
    // Test LSL_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04D38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zz_invalid_0_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zz_invalid_1_8000_04138000() {
    // Encoding: 0x04138000
    // Test LSL_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x04138000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsl_z_p_zz_reg_write_0_04138000() {
    // Test LSL_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04138000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04138000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UZP1_P.PP__ Tests
// ============================================================================

/// Provenance: UZP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uzp1_p_pp_field_size_0_min_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ field size = 0 (Min)
    // Fields: Pm=0, size=0, Pd=0, Pn=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uzp1_p_pp_field_size_1_poweroftwo_4800_05604800() {
    // Encoding: 0x05604800
    // Test UZP1_P.PP__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uzp1_p_pp_field_size_2_poweroftwo_4800_05a04800() {
    // Encoding: 0x05A04800
    // Test UZP1_P.PP__ field size = 2 (PowerOfTwo)
    // Fields: Pm=0, size=2, Pd=0, Pn=0
    let encoding: u32 = 0x05A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uzp1_p_pp_field_size_3_max_4800_05e04800() {
    // Encoding: 0x05E04800
    // Test UZP1_P.PP__ field size = 3 (Max)
    // Fields: size=3, Pn=0, Pd=0, Pm=0
    let encoding: u32 = 0x05E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uzp1_p_pp_field_pm_0_min_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ field Pm = 0 (Min)
    // Fields: size=0, Pm=0, Pd=0, Pn=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uzp1_p_pp_field_pm_1_poweroftwo_4800_05214800() {
    // Encoding: 0x05214800
    // Test UZP1_P.PP__ field Pm = 1 (PowerOfTwo)
    // Fields: Pm=1, size=0, Pd=0, Pn=0
    let encoding: u32 = 0x05214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uzp1_p_pp_field_pn_0_min_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ field Pn = 0 (Min)
    // Fields: Pm=0, Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uzp1_p_pp_field_pn_1_poweroftwo_4800_05204820() {
    // Encoding: 0x05204820
    // Test UZP1_P.PP__ field Pn = 1 (PowerOfTwo)
    // Fields: Pm=0, size=0, Pn=1, Pd=0
    let encoding: u32 = 0x05204820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uzp1_p_pp_field_pd_0_min_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ field Pd = 0 (Min)
    // Fields: Pd=0, Pm=0, Pn=0, size=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uzp1_p_pp_field_pd_1_poweroftwo_4800_05204801() {
    // Encoding: 0x05204801
    // Test UZP1_P.PP__ field Pd = 1 (PowerOfTwo)
    // Fields: Pn=0, Pm=0, Pd=1, size=0
    let encoding: u32 = 0x05204801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uzp1_p_pp_combo_0_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ field combination: size=0, Pm=0, Pn=0, Pd=0
    // Fields: size=0, Pd=0, Pn=0, Pm=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uzp1_p_pp_special_size_0_size_variant_0_18432_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ special value size = 0 (Size variant 0)
    // Fields: Pm=0, size=0, Pd=0, Pn=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uzp1_p_pp_special_size_1_size_variant_1_18432_05604800() {
    // Encoding: 0x05604800
    // Test UZP1_P.PP__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pn=0, Pm=0, Pd=0
    let encoding: u32 = 0x05604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uzp1_p_pp_special_size_2_size_variant_2_18432_05a04800() {
    // Encoding: 0x05A04800
    // Test UZP1_P.PP__ special value size = 2 (Size variant 2)
    // Fields: size=2, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uzp1_p_pp_special_size_3_size_variant_3_18432_05e04800() {
    // Encoding: 0x05E04800
    // Test UZP1_P.PP__ special value size = 3 (Size variant 3)
    // Fields: Pd=0, Pn=0, size=3, Pm=0
    let encoding: u32 = 0x05E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uzp1_p_pp_invalid_0_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pd=0, Pn=0, size=0, Pm=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uzp1_p_pp_invalid_1_4800_05204800() {
    // Encoding: 0x05204800
    // Test UZP1_P.PP__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pn=0, Pm=0, size=0, Pd=0
    let encoding: u32 = 0x05204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uzp2_p_pp_field_size_0_min_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ field size = 0 (Min)
    // Fields: Pn=0, Pd=0, Pm=0, size=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uzp2_p_pp_field_size_1_poweroftwo_4c00_05604c00() {
    // Encoding: 0x05604C00
    // Test UZP2_P.PP__ field size = 1 (PowerOfTwo)
    // Fields: Pn=0, size=1, Pm=0, Pd=0
    let encoding: u32 = 0x05604C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uzp2_p_pp_field_size_2_poweroftwo_4c00_05a04c00() {
    // Encoding: 0x05A04C00
    // Test UZP2_P.PP__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pm=0, Pd=0, Pn=0
    let encoding: u32 = 0x05A04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uzp2_p_pp_field_size_3_max_4c00_05e04c00() {
    // Encoding: 0x05E04C00
    // Test UZP2_P.PP__ field size = 3 (Max)
    // Fields: Pn=0, size=3, Pd=0, Pm=0
    let encoding: u32 = 0x05E04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uzp2_p_pp_field_pm_0_min_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ field Pm = 0 (Min)
    // Fields: size=0, Pd=0, Pn=0, Pm=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field Pm 16 +: 4`
/// Requirement: FieldBoundary { field: "Pm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uzp2_p_pp_field_pm_1_poweroftwo_4c00_05214c00() {
    // Encoding: 0x05214C00
    // Test UZP2_P.PP__ field Pm = 1 (PowerOfTwo)
    // Fields: Pm=1, Pd=0, Pn=0, size=0
    let encoding: u32 = 0x05214C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uzp2_p_pp_field_pn_0_min_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ field Pn = 0 (Min)
    // Fields: size=0, Pn=0, Pm=0, Pd=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field Pn 5 +: 4`
/// Requirement: FieldBoundary { field: "Pn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uzp2_p_pp_field_pn_1_poweroftwo_4c00_05204c20() {
    // Encoding: 0x05204C20
    // Test UZP2_P.PP__ field Pn = 1 (PowerOfTwo)
    // Fields: Pd=0, Pm=0, size=0, Pn=1
    let encoding: u32 = 0x05204C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uzp2_p_pp_field_pd_0_min_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ field Pd = 0 (Min)
    // Fields: Pm=0, Pd=0, size=0, Pn=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field Pd 0 +: 4`
/// Requirement: FieldBoundary { field: "Pd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uzp2_p_pp_field_pd_1_poweroftwo_4c00_05204c01() {
    // Encoding: 0x05204C01
    // Test UZP2_P.PP__ field Pd = 1 (PowerOfTwo)
    // Fields: Pm=0, Pd=1, size=0, Pn=0
    let encoding: u32 = 0x05204C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uzp2_p_pp_combo_0_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ field combination: size=0, Pm=0, Pn=0, Pd=0
    // Fields: Pd=0, Pn=0, size=0, Pm=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uzp2_p_pp_special_size_0_size_variant_0_19456_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ special value size = 0 (Size variant 0)
    // Fields: Pd=0, Pm=0, Pn=0, size=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uzp2_p_pp_special_size_1_size_variant_1_19456_05604c00() {
    // Encoding: 0x05604C00
    // Test UZP2_P.PP__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pn=0, Pm=0, Pd=0
    let encoding: u32 = 0x05604C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uzp2_p_pp_special_size_2_size_variant_2_19456_05a04c00() {
    // Encoding: 0x05A04C00
    // Test UZP2_P.PP__ special value size = 2 (Size variant 2)
    // Fields: Pn=0, size=2, Pm=0, Pd=0
    let encoding: u32 = 0x05A04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uzp2_p_pp_special_size_3_size_variant_3_19456_05e04c00() {
    // Encoding: 0x05E04C00
    // Test UZP2_P.PP__ special value size = 3 (Size variant 3)
    // Fields: Pm=0, Pd=0, size=3, Pn=0
    let encoding: u32 = 0x05E04C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uzp2_p_pp_invalid_0_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pm=0, Pn=0, Pd=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP2_P.PP__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uzp2_p_pp_invalid_1_4c00_05204c00() {
    // Encoding: 0x05204C00
    // Test UZP2_P.PP__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pm=0, Pd=0, Pn=0
    let encoding: u32 = 0x05204C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UZP1_P.PP__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_uzp1_p_pp_reg_write_0_05204800() {
    // Test UZP1_P.PP__ register write: SimdFromField("Pd")
    // Encoding: 0x05204800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05204800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: UZP2_P.PP__
/// ASL: `SimdFromField("Pd") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("Pd")
#[test]
fn test_uzp2_p_pp_reg_write_0_05204c00() {
    // Test UZP2_P.PP__ register write: SimdFromField("Pd")
    // Encoding: 0x05204C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05204C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SEL_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_sel_z_p_zz_field_size_0_min_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Pg=0, Zn=0, Zm=0, Zd=0, size=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_sel_z_p_zz_field_size_1_poweroftwo_c000_0560c000() {
    // Encoding: 0x0560C000
    // Test SEL_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, Pg=0, Zm=0, size=1, Zn=0
    let encoding: u32 = 0x0560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_sel_z_p_zz_field_size_2_poweroftwo_c000_05a0c000() {
    // Encoding: 0x05A0C000
    // Test SEL_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, size=2, Zm=0, Zn=0, Pg=0
    let encoding: u32 = 0x05A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_sel_z_p_zz_field_size_3_max_c000_05e0c000() {
    // Encoding: 0x05E0C000
    // Test SEL_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zn=0, Zd=0, size=3, Pg=0, Zm=0
    let encoding: u32 = 0x05E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sel_z_p_zz_field_zm_0_min_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zd=0, size=0, Zm=0, Pg=0, Zn=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sel_z_p_zz_field_zm_1_poweroftwo_c000_0521c000() {
    // Encoding: 0x0521C000
    // Test SEL_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x0521C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sel_z_p_zz_field_zm_30_poweroftwominusone_c000_053ec000() {
    // Encoding: 0x053EC000
    // Test SEL_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zd=0, Zm=30, Zn=0
    let encoding: u32 = 0x053EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sel_z_p_zz_field_zm_31_max_c000_053fc000() {
    // Encoding: 0x053FC000
    // Test SEL_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zm=31, Zn=0, size=0, Zd=0, Pg=0
    let encoding: u32 = 0x053FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_sel_z_p_zz_field_pg_0_min_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Pg 10 +: 4`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_sel_z_p_zz_field_pg_1_poweroftwo_c000_0520c400() {
    // Encoding: 0x0520C400
    // Test SEL_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zn=0, Zd=0, Pg=1
    let encoding: u32 = 0x0520C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sel_z_p_zz_field_zn_0_min_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ field Zn = 0 (Min)
    // Fields: Pg=0, Zm=0, Zd=0, Zn=0, size=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sel_z_p_zz_field_zn_1_poweroftwo_c000_0520c020() {
    // Encoding: 0x0520C020
    // Test SEL_Z.P.ZZ__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, Zm=0, Pg=0, size=0, Zn=1
    let encoding: u32 = 0x0520C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sel_z_p_zz_field_zn_30_poweroftwominusone_c000_0520c3c0() {
    // Encoding: 0x0520C3C0
    // Test SEL_Z.P.ZZ__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x0520C3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sel_z_p_zz_field_zn_31_max_c000_0520c3e0() {
    // Encoding: 0x0520C3E0
    // Test SEL_Z.P.ZZ__ field Zn = 31 (Max)
    // Fields: Zd=0, Pg=0, Zn=31, size=0, Zm=0
    let encoding: u32 = 0x0520C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_sel_z_p_zz_field_zd_0_min_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ field Zd = 0 (Min)
    // Fields: Zd=0, size=0, Pg=0, Zm=0, Zn=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_sel_z_p_zz_field_zd_1_poweroftwo_c000_0520c001() {
    // Encoding: 0x0520C001
    // Test SEL_Z.P.ZZ__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Zm=0, Zn=0, Zd=1
    let encoding: u32 = 0x0520C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_sel_z_p_zz_field_zd_30_poweroftwominusone_c000_0520c01e() {
    // Encoding: 0x0520C01E
    // Test SEL_Z.P.ZZ__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Zm=0, Pg=0, Zd=30
    let encoding: u32 = 0x0520C01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_sel_z_p_zz_field_zd_31_max_c000_0520c01f() {
    // Encoding: 0x0520C01F
    // Test SEL_Z.P.ZZ__ field Zd = 31 (Max)
    // Fields: Zm=0, Zd=31, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0520C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_sel_z_p_zz_combo_0_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ field combination: size=0, Zm=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, Pg=0, Zd=0, Zm=0, size=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_sel_z_p_zz_special_size_0_size_variant_0_49152_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Pg=0, Zd=0, size=0, Zm=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_sel_z_p_zz_special_size_1_size_variant_1_49152_0560c000() {
    // Encoding: 0x0560C000
    // Test SEL_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zd=0, Zm=0, Zn=0, Pg=0
    let encoding: u32 = 0x0560C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_sel_z_p_zz_special_size_2_size_variant_2_49152_05a0c000() {
    // Encoding: 0x05A0C000
    // Test SEL_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Zm=0, Pg=0, Zd=0
    let encoding: u32 = 0x05A0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_sel_z_p_zz_special_size_3_size_variant_3_49152_05e0c000() {
    // Encoding: 0x05E0C000
    // Test SEL_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, Zd=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x05E0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_sel_z_p_zz_invalid_0_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zm=0, Zn=0, size=0, Zd=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_sel_z_p_zz_invalid_1_c000_0520c000() {
    // Encoding: 0x0520C000
    // Test SEL_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, Pg=0, Zm=0, size=0, Zd=0
    let encoding: u32 = 0x0520C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SEL_Z.P.ZZ__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_sel_z_p_zz_reg_write_0_0520c000() {
    // Test SEL_Z.P.ZZ__ register write: SimdFromField("d")
    // Encoding: 0x0520C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0520C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lsr_z_p_zz_field_size_0_min_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lsr_z_p_zz_field_size_1_poweroftwo_8000_04518000() {
    // Encoding: 0x04518000
    // Test LSR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, Zdn=0, size=1
    let encoding: u32 = 0x04518000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lsr_z_p_zz_field_size_2_poweroftwo_8000_04918000() {
    // Encoding: 0x04918000
    // Test LSR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=2, Pg=0
    let encoding: u32 = 0x04918000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lsr_z_p_zz_field_size_3_max_8000_04d18000() {
    // Encoding: 0x04D18000
    // Test LSR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Zm=0, size=3, Pg=0, Zdn=0
    let encoding: u32 = 0x04D18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsr_z_p_zz_field_pg_0_min_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsr_z_p_zz_field_pg_1_poweroftwo_8000_04118400() {
    // Encoding: 0x04118400
    // Test LSR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, Pg=1, size=0
    let encoding: u32 = 0x04118400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_p_zz_field_zm_0_min_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_p_zz_field_zm_1_poweroftwo_8000_04118020() {
    // Encoding: 0x04118020
    // Test LSR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, Zdn=0, size=0, Zm=1
    let encoding: u32 = 0x04118020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_p_zz_field_zm_30_poweroftwominusone_8000_041183c0() {
    // Encoding: 0x041183C0
    // Test LSR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=30, Zdn=0
    let encoding: u32 = 0x041183C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_p_zz_field_zm_31_max_8000_041183e0() {
    // Encoding: 0x041183E0
    // Test LSR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zdn=0, size=0
    let encoding: u32 = 0x041183E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zz_field_zdn_0_min_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zz_field_zdn_1_poweroftwo_8000_04118001() {
    // Encoding: 0x04118001
    // Test LSR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, size=0, Zdn=1
    let encoding: u32 = 0x04118001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsr_z_p_zz_field_zdn_15_poweroftwominusone_8000_0411800f() {
    // Encoding: 0x0411800F
    // Test LSR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=0, Zdn=15
    let encoding: u32 = 0x0411800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsr_z_p_zz_field_zdn_31_max_8000_0411801f() {
    // Encoding: 0x0411801F
    // Test LSR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Zdn=31, Pg=0, size=0
    let encoding: u32 = 0x0411801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lsr_z_p_zz_combo_0_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, Zdn=0, size=0, Zm=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lsr_z_p_zz_special_size_0_size_variant_0_32768_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lsr_z_p_zz_special_size_1_size_variant_1_32768_04518000() {
    // Encoding: 0x04518000
    // Test LSR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04518000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lsr_z_p_zz_special_size_2_size_variant_2_32768_04918000() {
    // Encoding: 0x04918000
    // Test LSR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, size=2, Pg=0, Zdn=0
    let encoding: u32 = 0x04918000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lsr_z_p_zz_special_size_3_size_variant_3_32768_04d18000() {
    // Encoding: 0x04D18000
    // Test LSR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zdn=0, size=3, Zm=0
    let encoding: u32 = 0x04D18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zz_invalid_0_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Pg=0, Zdn=0, size=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zz_invalid_1_8000_04118000() {
    // Encoding: 0x04118000
    // Test LSR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04118000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsr_z_p_zz_reg_write_0_04118000() {
    // Test LSR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04118000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04118000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ASR_Z.ZI__ Tests
// ============================================================================

/// Provenance: ASR_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_zi_field_tszh_0_min_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ field tszh = 0 (Min)
    // Fields: tszh=0, tszl=0, Zd=0, Zn=0, imm3=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_zi_field_tszh_1_poweroftwo_9000_04609000() {
    // Encoding: 0x04609000
    // Test ASR_Z.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: tszl=0, Zd=0, tszh=1, Zn=0, imm3=0
    let encoding: u32 = 0x04609000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_asr_z_zi_field_tszh_3_max_9000_04e09000() {
    // Encoding: 0x04E09000
    // Test ASR_Z.ZI__ field tszh = 3 (Max)
    // Fields: tszl=0, tszh=3, Zn=0, Zd=0, imm3=0
    let encoding: u32 = 0x04E09000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_asr_z_zi_field_tszl_0_min_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ field tszl = 0 (Min)
    // Fields: tszl=0, Zd=0, tszh=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_asr_z_zi_field_tszl_1_poweroftwo_9000_04289000() {
    // Encoding: 0x04289000
    // Test ASR_Z.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: Zd=0, tszh=0, tszl=1, imm3=0, Zn=0
    let encoding: u32 = 0x04289000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_asr_z_zi_field_tszl_3_max_9000_04389000() {
    // Encoding: 0x04389000
    // Test ASR_Z.ZI__ field tszl = 3 (Max)
    // Fields: imm3=0, tszl=3, tszh=0, Zn=0, Zd=0
    let encoding: u32 = 0x04389000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_asr_z_zi_field_imm3_0_zero_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ field imm3 = 0 (Zero)
    // Fields: Zn=0, imm3=0, Zd=0, tszh=0, tszl=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_asr_z_zi_field_imm3_1_poweroftwo_9000_04219000() {
    // Encoding: 0x04219000
    // Test ASR_Z.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: Zd=0, tszl=0, imm3=1, Zn=0, tszh=0
    let encoding: u32 = 0x04219000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_asr_z_zi_field_imm3_3_poweroftwominusone_9000_04239000() {
    // Encoding: 0x04239000
    // Test ASR_Z.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Zn=0, imm3=3, Zd=0, tszh=0
    let encoding: u32 = 0x04239000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_asr_z_zi_field_imm3_7_max_9000_04279000() {
    // Encoding: 0x04279000
    // Test ASR_Z.ZI__ field imm3 = 7 (Max)
    // Fields: Zd=0, tszh=0, tszl=0, Zn=0, imm3=7
    let encoding: u32 = 0x04279000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_zi_field_zn_0_min_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ field Zn = 0 (Min)
    // Fields: tszl=0, Zn=0, imm3=0, tszh=0, Zd=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_zi_field_zn_1_poweroftwo_9000_04209020() {
    // Encoding: 0x04209020
    // Test ASR_Z.ZI__ field Zn = 1 (PowerOfTwo)
    // Fields: imm3=0, tszl=0, tszh=0, Zd=0, Zn=1
    let encoding: u32 = 0x04209020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_zi_field_zn_30_poweroftwominusone_9000_042093c0() {
    // Encoding: 0x042093C0
    // Test ASR_Z.ZI__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, imm3=0, Zn=30, tszh=0, tszl=0
    let encoding: u32 = 0x042093C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_zi_field_zn_31_max_9000_042093e0() {
    // Encoding: 0x042093E0
    // Test ASR_Z.ZI__ field Zn = 31 (Max)
    // Fields: Zn=31, tszh=0, imm3=0, Zd=0, tszl=0
    let encoding: u32 = 0x042093E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_asr_z_zi_field_zd_0_min_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ field Zd = 0 (Min)
    // Fields: imm3=0, Zn=0, Zd=0, tszh=0, tszl=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_asr_z_zi_field_zd_1_poweroftwo_9000_04209001() {
    // Encoding: 0x04209001
    // Test ASR_Z.ZI__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, imm3=0, tszh=0, tszl=0, Zn=0
    let encoding: u32 = 0x04209001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_asr_z_zi_field_zd_30_poweroftwominusone_9000_0420901e() {
    // Encoding: 0x0420901E
    // Test ASR_Z.ZI__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: imm3=0, tszh=0, tszl=0, Zn=0, Zd=30
    let encoding: u32 = 0x0420901E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_asr_z_zi_field_zd_31_max_9000_0420901f() {
    // Encoding: 0x0420901F
    // Test ASR_Z.ZI__ field Zd = 31 (Max)
    // Fields: tszh=0, imm3=0, Zn=0, Zd=31, tszl=0
    let encoding: u32 = 0x0420901F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_asr_z_zi_combo_0_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: Zd=0, imm3=0, tszl=0, tszh=0, Zn=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_asr_z_zi_invalid_0_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszh=0, imm3=0, tszl=0, Zd=0, Zn=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_zi_invalid_1_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Zn=0, imm3=0, tszh=0, tszl=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_asr_z_zi_invalid_2_9000_04209000() {
    // Encoding: 0x04209000
    // Test ASR_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm3=0, Zd=0, tszh=0, Zn=0, tszl=0
    let encoding: u32 = 0x04209000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ASR_Z.ZI__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_asr_z_zi_reg_write_0_04209000() {
    // Test ASR_Z.ZI__ register write: SimdFromField("d")
    // Encoding: 0x04209000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04209000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// MAD_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_mad_z_p_zzz_field_size_0_min_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Za=0, Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_mad_z_p_zzz_field_size_1_poweroftwo_c000_0440c000() {
    // Encoding: 0x0440C000
    // Test MAD_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zdn=0, Pg=0, Zm=0, Za=0
    let encoding: u32 = 0x0440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_mad_z_p_zzz_field_size_2_poweroftwo_c000_0480c000() {
    // Encoding: 0x0480C000
    // Test MAD_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Za=0, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x0480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_mad_z_p_zzz_field_size_3_max_c000_04c0c000() {
    // Encoding: 0x04C0C000
    // Test MAD_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Zdn=0, Zm=0, Za=0, Pg=0, size=3
    let encoding: u32 = 0x04C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_mad_z_p_zzz_field_zm_0_min_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Za=0, Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_mad_z_p_zzz_field_zm_1_poweroftwo_c000_0401c000() {
    // Encoding: 0x0401C000
    // Test MAD_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, size=0, Za=0, Zdn=0
    let encoding: u32 = 0x0401C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_mad_z_p_zzz_field_zm_30_poweroftwominusone_c000_041ec000() {
    // Encoding: 0x041EC000
    // Test MAD_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Zm=30, Pg=0, Za=0, size=0
    let encoding: u32 = 0x041EC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_mad_z_p_zzz_field_zm_31_max_c000_041fc000() {
    // Encoding: 0x041FC000
    // Test MAD_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Za=0, Zdn=0, size=0, Pg=0, Zm=31
    let encoding: u32 = 0x041FC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_mad_z_p_zzz_field_pg_0_min_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Pg=0, Zdn=0, Za=0, Zm=0, size=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_mad_z_p_zzz_field_pg_1_poweroftwo_c000_0400c400() {
    // Encoding: 0x0400C400
    // Test MAD_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zm=0, Za=0, Zdn=0
    let encoding: u32 = 0x0400C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_mad_z_p_zzz_field_za_0_min_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: Zm=0, size=0, Za=0, Zdn=0, Pg=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_mad_z_p_zzz_field_za_1_poweroftwo_c000_0400c020() {
    // Encoding: 0x0400C020
    // Test MAD_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, Za=1, size=0, Pg=0
    let encoding: u32 = 0x0400C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_mad_z_p_zzz_field_za_15_poweroftwominusone_c000_0400c1e0() {
    // Encoding: 0x0400C1E0
    // Test MAD_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, size=0, Pg=0, Za=15, Zdn=0
    let encoding: u32 = 0x0400C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_mad_z_p_zzz_field_za_31_max_c000_0400c3e0() {
    // Encoding: 0x0400C3E0
    // Test MAD_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: Za=31, Zm=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x0400C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_mad_z_p_zzz_field_zdn_0_min_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Za=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_mad_z_p_zzz_field_zdn_1_poweroftwo_c000_0400c001() {
    // Encoding: 0x0400C001
    // Test MAD_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, Pg=0, Zm=0, Za=0, size=0
    let encoding: u32 = 0x0400C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_mad_z_p_zzz_field_zdn_15_poweroftwominusone_c000_0400c00f() {
    // Encoding: 0x0400C00F
    // Test MAD_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=0, Za=0, Zdn=15, Pg=0
    let encoding: u32 = 0x0400C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_mad_z_p_zzz_field_zdn_31_max_c000_0400c01f() {
    // Encoding: 0x0400C01F
    // Test MAD_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, size=0, Pg=0, Zdn=31, Za=0
    let encoding: u32 = 0x0400C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_mad_z_p_zzz_combo_0_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: Zdn=0, size=0, Pg=0, Za=0, Zm=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_mad_z_p_zzz_special_size_0_size_variant_0_49152_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: size=0, Za=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_mad_z_p_zzz_special_size_1_size_variant_1_49152_0440c000() {
    // Encoding: 0x0440C000
    // Test MAD_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zdn=0, Zm=0, Za=0
    let encoding: u32 = 0x0440C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_mad_z_p_zzz_special_size_2_size_variant_2_49152_0480c000() {
    // Encoding: 0x0480C000
    // Test MAD_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, size=2, Zdn=0, Za=0
    let encoding: u32 = 0x0480C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_mad_z_p_zzz_special_size_3_size_variant_3_49152_04c0c000() {
    // Encoding: 0x04C0C000
    // Test MAD_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Za=0, Zdn=0, size=3, Zm=0
    let encoding: u32 = 0x04C0C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_mad_z_p_zzz_invalid_0_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, Za=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_mad_z_p_zzz_invalid_1_c000_0400c000() {
    // Encoding: 0x0400C000
    // Test MAD_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Za=0, Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x0400C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MAD_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_mad_z_p_zzz_reg_write_0_0400c000() {
    // Test MAD_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x0400C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0400C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSR_Z.ZI__ Tests
// ============================================================================

/// Provenance: LSR_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_zi_field_tszh_0_min_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ field tszh = 0 (Min)
    // Fields: Zd=0, tszh=0, tszl=0, Zn=0, imm3=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_zi_field_tszh_1_poweroftwo_9400_04609400() {
    // Encoding: 0x04609400
    // Test LSR_Z.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: imm3=0, tszh=1, Zd=0, Zn=0, tszl=0
    let encoding: u32 = 0x04609400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsr_z_zi_field_tszh_3_max_9400_04e09400() {
    // Encoding: 0x04E09400
    // Test LSR_Z.ZI__ field tszh = 3 (Max)
    // Fields: Zn=0, Zd=0, tszl=0, tszh=3, imm3=0
    let encoding: u32 = 0x04E09400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_zi_field_tszl_0_min_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ field tszl = 0 (Min)
    // Fields: imm3=0, tszh=0, Zd=0, Zn=0, tszl=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_zi_field_tszl_1_poweroftwo_9400_04289400() {
    // Encoding: 0x04289400
    // Test LSR_Z.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: imm3=0, tszh=0, Zn=0, Zd=0, tszl=1
    let encoding: u32 = 0x04289400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsr_z_zi_field_tszl_3_max_9400_04389400() {
    // Encoding: 0x04389400
    // Test LSR_Z.ZI__ field tszl = 3 (Max)
    // Fields: Zn=0, tszh=0, Zd=0, tszl=3, imm3=0
    let encoding: u32 = 0x04389400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsr_z_zi_field_imm3_0_zero_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ field imm3 = 0 (Zero)
    // Fields: Zn=0, Zd=0, tszl=0, imm3=0, tszh=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsr_z_zi_field_imm3_1_poweroftwo_9400_04219400() {
    // Encoding: 0x04219400
    // Test LSR_Z.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: Zn=0, imm3=1, tszl=0, Zd=0, tszh=0
    let encoding: u32 = 0x04219400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsr_z_zi_field_imm3_3_poweroftwominusone_9400_04239400() {
    // Encoding: 0x04239400
    // Test LSR_Z.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: imm3=3, Zd=0, tszh=0, Zn=0, tszl=0
    let encoding: u32 = 0x04239400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsr_z_zi_field_imm3_7_max_9400_04279400() {
    // Encoding: 0x04279400
    // Test LSR_Z.ZI__ field imm3 = 7 (Max)
    // Fields: Zn=0, Zd=0, tszl=0, tszh=0, imm3=7
    let encoding: u32 = 0x04279400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_zi_field_zn_0_min_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ field Zn = 0 (Min)
    // Fields: tszl=0, imm3=0, tszh=0, Zd=0, Zn=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_zi_field_zn_1_poweroftwo_9400_04209420() {
    // Encoding: 0x04209420
    // Test LSR_Z.ZI__ field Zn = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, imm3=0, Zd=0, Zn=1
    let encoding: u32 = 0x04209420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_zi_field_zn_30_poweroftwominusone_9400_042097c0() {
    // Encoding: 0x042097C0
    // Test LSR_Z.ZI__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: tszh=0, Zn=30, Zd=0, imm3=0, tszl=0
    let encoding: u32 = 0x042097C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_zi_field_zn_31_max_9400_042097e0() {
    // Encoding: 0x042097E0
    // Test LSR_Z.ZI__ field Zn = 31 (Max)
    // Fields: imm3=0, Zd=0, tszh=0, tszl=0, Zn=31
    let encoding: u32 = 0x042097E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsr_z_zi_field_zd_0_min_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ field Zd = 0 (Min)
    // Fields: Zd=0, tszl=0, tszh=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsr_z_zi_field_zd_1_poweroftwo_9400_04209401() {
    // Encoding: 0x04209401
    // Test LSR_Z.ZI__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, imm3=0, tszl=0, Zd=1, tszh=0
    let encoding: u32 = 0x04209401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsr_z_zi_field_zd_30_poweroftwominusone_9400_0420941e() {
    // Encoding: 0x0420941E
    // Test LSR_Z.ZI__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zn=0, imm3=0, tszl=0, tszh=0, Zd=30
    let encoding: u32 = 0x0420941E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsr_z_zi_field_zd_31_max_9400_0420941f() {
    // Encoding: 0x0420941F
    // Test LSR_Z.ZI__ field Zd = 31 (Max)
    // Fields: imm3=0, tszh=0, Zd=31, tszl=0, Zn=0
    let encoding: u32 = 0x0420941F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsr_z_zi_combo_0_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: tszh=0, Zn=0, imm3=0, tszl=0, Zd=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsr_z_zi_invalid_0_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: imm3=0, Zd=0, tszh=0, Zn=0, tszl=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_zi_invalid_1_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zn=0, tszh=0, Zd=0, tszl=0, imm3=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_zi_invalid_2_9400_04209400() {
    // Encoding: 0x04209400
    // Test LSR_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszh=0, Zd=0, imm3=0, tszl=0, Zn=0
    let encoding: u32 = 0x04209400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.ZI__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lsr_z_zi_reg_write_0_04209400() {
    // Test LSR_Z.ZI__ register write: SimdFromField("d")
    // Encoding: 0x04209400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04209400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMIN_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_smin_z_p_zz_field_size_0_min_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_smin_z_p_zz_field_size_1_poweroftwo_0_044a0000() {
    // Encoding: 0x044A0000
    // Test SMIN_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, Zdn=0, Pg=0, size=1
    let encoding: u32 = 0x044A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_smin_z_p_zz_field_size_2_poweroftwo_0_048a0000() {
    // Encoding: 0x048A0000
    // Test SMIN_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x048A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_smin_z_p_zz_field_size_3_max_0_04ca0000() {
    // Encoding: 0x04CA0000
    // Test SMIN_Z.P.ZZ__ field size = 3 (Max)
    // Fields: Pg=0, Zm=0, size=3, Zdn=0
    let encoding: u32 = 0x04CA0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_smin_z_p_zz_field_pg_0_min_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_smin_z_p_zz_field_pg_1_poweroftwo_0_040a0400() {
    // Encoding: 0x040A0400
    // Test SMIN_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=1, Zdn=0
    let encoding: u32 = 0x040A0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_smin_z_p_zz_field_zm_0_min_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_smin_z_p_zz_field_zm_1_poweroftwo_0_040a0020() {
    // Encoding: 0x040A0020
    // Test SMIN_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x040A0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_smin_z_p_zz_field_zm_30_poweroftwominusone_0_040a03c0() {
    // Encoding: 0x040A03C0
    // Test SMIN_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Zm=30, size=0, Pg=0
    let encoding: u32 = 0x040A03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_smin_z_p_zz_field_zm_31_max_0_040a03e0() {
    // Encoding: 0x040A03E0
    // Test SMIN_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: size=0, Pg=0, Zdn=0, Zm=31
    let encoding: u32 = 0x040A03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_smin_z_p_zz_field_zdn_0_min_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_smin_z_p_zz_field_zdn_1_poweroftwo_0_040a0001() {
    // Encoding: 0x040A0001
    // Test SMIN_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Zdn=1, Pg=0
    let encoding: u32 = 0x040A0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_smin_z_p_zz_field_zdn_15_poweroftwominusone_0_040a000f() {
    // Encoding: 0x040A000F
    // Test SMIN_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, Zdn=15, size=0
    let encoding: u32 = 0x040A000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_smin_z_p_zz_field_zdn_31_max_0_040a001f() {
    // Encoding: 0x040A001F
    // Test SMIN_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: size=0, Pg=0, Zm=0, Zdn=31
    let encoding: u32 = 0x040A001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_smin_z_p_zz_combo_0_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Pg=0, size=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_smin_z_p_zz_special_size_0_size_variant_0_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_smin_z_p_zz_special_size_1_size_variant_1_0_044a0000() {
    // Encoding: 0x044A0000
    // Test SMIN_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zm=0, size=1, Zdn=0
    let encoding: u32 = 0x044A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_smin_z_p_zz_special_size_2_size_variant_2_0_048a0000() {
    // Encoding: 0x048A0000
    // Test SMIN_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Zm=0, Pg=0, Zdn=0, size=2
    let encoding: u32 = 0x048A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_smin_z_p_zz_special_size_3_size_variant_3_0_04ca0000() {
    // Encoding: 0x04CA0000
    // Test SMIN_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, Zm=0, Pg=0
    let encoding: u32 = 0x04CA0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_smin_z_p_zz_invalid_0_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_smin_z_p_zz_invalid_1_0_040a0000() {
    // Encoding: 0x040A0000
    // Test SMIN_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zm=0, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x040A0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMIN_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_smin_z_p_zz_reg_write_0_040a0000() {
    // Test SMIN_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x040A0000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040A0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// SMAX_Z.ZI__ Tests
// ============================================================================

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_smax_z_zi_field_size_0_min_c000_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ field size = 0 (Min)
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_smax_z_zi_field_size_1_poweroftwo_c000_2568c000() {
    // Encoding: 0x2568C000
    // Test SMAX_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=1, imm8=0
    let encoding: u32 = 0x2568C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_smax_z_zi_field_size_2_poweroftwo_c000_25a8c000() {
    // Encoding: 0x25A8C000
    // Test SMAX_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, imm8=0
    let encoding: u32 = 0x25A8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_smax_z_zi_field_size_3_max_c000_25e8c000() {
    // Encoding: 0x25E8C000
    // Test SMAX_Z.ZI__ field size = 3 (Max)
    // Fields: Zdn=0, imm8=0, size=3
    let encoding: u32 = 0x25E8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_smax_z_zi_field_imm8_0_zero_c000_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_smax_z_zi_field_imm8_1_poweroftwo_c000_2528c020() {
    // Encoding: 0x2528C020
    // Test SMAX_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, imm8=1
    let encoding: u32 = 0x2528C020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_smax_z_zi_field_imm8_3_poweroftwominusone_c000_2528c060() {
    // Encoding: 0x2528C060
    // Test SMAX_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=0, imm8=3
    let encoding: u32 = 0x2528C060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_smax_z_zi_field_imm8_4_poweroftwo_c000_2528c080() {
    // Encoding: 0x2528C080
    // Test SMAX_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: imm8=4, Zdn=0, size=0
    let encoding: u32 = 0x2528C080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_smax_z_zi_field_imm8_7_poweroftwominusone_c000_2528c0e0() {
    // Encoding: 0x2528C0E0
    // Test SMAX_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: imm8=7, size=0, Zdn=0
    let encoding: u32 = 0x2528C0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_smax_z_zi_field_imm8_8_poweroftwo_c000_2528c100() {
    // Encoding: 0x2528C100
    // Test SMAX_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: Zdn=0, size=0, imm8=8
    let encoding: u32 = 0x2528C100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_smax_z_zi_field_imm8_15_poweroftwominusone_c000_2528c1e0() {
    // Encoding: 0x2528C1E0
    // Test SMAX_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=15, Zdn=0
    let encoding: u32 = 0x2528C1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_smax_z_zi_field_imm8_16_poweroftwo_c000_2528c200() {
    // Encoding: 0x2528C200
    // Test SMAX_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: size=0, imm8=16, Zdn=0
    let encoding: u32 = 0x2528C200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_smax_z_zi_field_imm8_31_poweroftwominusone_c000_2528c3e0() {
    // Encoding: 0x2528C3E0
    // Test SMAX_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=31, Zdn=0
    let encoding: u32 = 0x2528C3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_smax_z_zi_field_imm8_32_poweroftwo_c000_2528c400() {
    // Encoding: 0x2528C400
    // Test SMAX_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: Zdn=0, imm8=32, size=0
    let encoding: u32 = 0x2528C400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_smax_z_zi_field_imm8_63_poweroftwominusone_c000_2528c7e0() {
    // Encoding: 0x2528C7E0
    // Test SMAX_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, imm8=63, size=0
    let encoding: u32 = 0x2528C7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_smax_z_zi_field_imm8_64_poweroftwo_c000_2528c800() {
    // Encoding: 0x2528C800
    // Test SMAX_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: size=0, imm8=64, Zdn=0
    let encoding: u32 = 0x2528C800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_smax_z_zi_field_imm8_127_poweroftwominusone_c000_2528cfe0() {
    // Encoding: 0x2528CFE0
    // Test SMAX_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=127, Zdn=0
    let encoding: u32 = 0x2528CFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_smax_z_zi_field_imm8_128_poweroftwo_c000_2528d000() {
    // Encoding: 0x2528D000
    // Test SMAX_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: size=0, imm8=128, Zdn=0
    let encoding: u32 = 0x2528D000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_smax_z_zi_field_imm8_255_max_c000_2528dfe0() {
    // Encoding: 0x2528DFE0
    // Test SMAX_Z.ZI__ field imm8 = 255 (Max)
    // Fields: Zdn=0, size=0, imm8=255
    let encoding: u32 = 0x2528DFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_smax_z_zi_field_zdn_0_min_c000_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ field Zdn = 0 (Min)
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_smax_z_zi_field_zdn_1_poweroftwo_c000_2528c001() {
    // Encoding: 0x2528C001
    // Test SMAX_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=1, imm8=0
    let encoding: u32 = 0x2528C001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_smax_z_zi_field_zdn_15_poweroftwominusone_c000_2528c00f() {
    // Encoding: 0x2528C00F
    // Test SMAX_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Zdn=15, imm8=0
    let encoding: u32 = 0x2528C00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_smax_z_zi_field_zdn_31_max_c000_2528c01f() {
    // Encoding: 0x2528C01F
    // Test SMAX_Z.ZI__ field Zdn = 31 (Max)
    // Fields: size=0, imm8=0, Zdn=31
    let encoding: u32 = 0x2528C01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_smax_z_zi_combo_0_c000_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_smax_z_zi_special_size_0_size_variant_0_49152_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_smax_z_zi_special_size_1_size_variant_1_49152_2568c000() {
    // Encoding: 0x2568C000
    // Test SMAX_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: imm8=0, Zdn=0, size=1
    let encoding: u32 = 0x2568C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_smax_z_zi_special_size_2_size_variant_2_49152_25a8c000() {
    // Encoding: 0x25A8C000
    // Test SMAX_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zdn=0, imm8=0
    let encoding: u32 = 0x25A8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_smax_z_zi_special_size_3_size_variant_3_49152_25e8c000() {
    // Encoding: 0x25E8C000
    // Test SMAX_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, size=3, imm8=0
    let encoding: u32 = 0x25E8C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_smax_z_zi_invalid_0_c000_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_smax_z_zi_invalid_1_c000_2528c000() {
    // Encoding: 0x2528C000
    // Test SMAX_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm8=0, size=0, Zdn=0
    let encoding: u32 = 0x2528C000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: SMAX_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_smax_z_zi_reg_write_0_2528c000() {
    // Test SMAX_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x2528C000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x2528C000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// COMPACT_Z.P.Z__ Tests
// ============================================================================

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_compact_z_p_z_field_sz_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field sz = 0 (Min)
    // Fields: sz=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz 22 +: 1`
/// Requirement: FieldBoundary { field: "sz", value: 1, boundary: Max }
/// 16-bit / halfword size
#[test]
fn test_compact_z_p_z_field_sz_1_max_8000_05e18000() {
    // Encoding: 0x05E18000
    // Test COMPACT_Z.P.Z__ field sz = 1 (Max)
    // Fields: Zd=0, Zn=0, sz=1, Pg=0
    let encoding: u32 = 0x05E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_compact_z_p_z_field_pg_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field Pg = 0 (Min)
    // Fields: sz=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_compact_z_p_z_field_pg_1_poweroftwo_8000_05a18400() {
    // Encoding: 0x05A18400
    // Test COMPACT_Z.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, sz=0, Pg=1, Zd=0
    let encoding: u32 = 0x05A18400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_compact_z_p_z_field_zn_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field Zn = 0 (Min)
    // Fields: sz=0, Pg=0, Zn=0, Zd=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_compact_z_p_z_field_zn_1_poweroftwo_8000_05a18020() {
    // Encoding: 0x05A18020
    // Test COMPACT_Z.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zd=0, sz=0, Pg=0, Zn=1
    let encoding: u32 = 0x05A18020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_compact_z_p_z_field_zn_30_poweroftwominusone_8000_05a183c0() {
    // Encoding: 0x05A183C0
    // Test COMPACT_Z.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, Zn=30, sz=0, Pg=0
    let encoding: u32 = 0x05A183C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_compact_z_p_z_field_zn_31_max_8000_05a183e0() {
    // Encoding: 0x05A183E0
    // Test COMPACT_Z.P.Z__ field Zn = 31 (Max)
    // Fields: sz=0, Zn=31, Pg=0, Zd=0
    let encoding: u32 = 0x05A183E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_compact_z_p_z_field_zd_0_min_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field Zd = 0 (Min)
    // Fields: sz=0, Zd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_compact_z_p_z_field_zd_1_poweroftwo_8000_05a18001() {
    // Encoding: 0x05A18001
    // Test COMPACT_Z.P.Z__ field Zd = 1 (PowerOfTwo)
    // Fields: Zn=0, sz=0, Pg=0, Zd=1
    let encoding: u32 = 0x05A18001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_compact_z_p_z_field_zd_30_poweroftwominusone_8000_05a1801e() {
    // Encoding: 0x05A1801E
    // Test COMPACT_Z.P.Z__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: sz=0, Zn=0, Pg=0, Zd=30
    let encoding: u32 = 0x05A1801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_compact_z_p_z_field_zd_31_max_8000_05a1801f() {
    // Encoding: 0x05A1801F
    // Test COMPACT_Z.P.Z__ field Zd = 31 (Max)
    // Fields: sz=0, Zd=31, Zn=0, Pg=0
    let encoding: u32 = 0x05A1801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// sz=0 (8-bit / byte size)
#[test]
fn test_compact_z_p_z_combo_0_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ field combination: sz=0, Pg=0, Zn=0, Zd=0
    // Fields: Zn=0, sz=0, Zd=0, Pg=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "sz", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_compact_z_p_z_special_sz_0_size_variant_0_32768_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ special value sz = 0 (Size variant 0)
    // Fields: Pg=0, Zd=0, Zn=0, sz=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `field sz = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "sz", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_compact_z_p_z_special_sz_1_size_variant_1_32768_05e18000() {
    // Encoding: 0x05E18000
    // Test COMPACT_Z.P.Z__ special value sz = 1 (Size variant 1)
    // Fields: Zn=0, Pg=0, sz=1, Zd=0
    let encoding: u32 = 0x05E18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_compact_z_p_z_invalid_0_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, sz=0, Zd=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_compact_z_p_z_invalid_1_8000_05a18000() {
    // Encoding: 0x05A18000
    // Test COMPACT_Z.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, sz=0, Pg=0, Zn=0
    let encoding: u32 = 0x05A18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: COMPACT_Z.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_compact_z_p_z_reg_write_0_05a18000() {
    // Test COMPACT_Z.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x05A18000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05A18000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INDEX_Z.RI__ Tests
// ============================================================================

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_index_z_ri_field_size_0_min_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field size = 0 (Min)
    // Fields: imm5=0, Rn=0, Zd=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_index_z_ri_field_size_1_poweroftwo_4400_04604400() {
    // Encoding: 0x04604400
    // Test INDEX_Z.RI__ field size = 1 (PowerOfTwo)
    // Fields: imm5=0, Zd=0, size=1, Rn=0
    let encoding: u32 = 0x04604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_index_z_ri_field_size_2_poweroftwo_4400_04a04400() {
    // Encoding: 0x04A04400
    // Test INDEX_Z.RI__ field size = 2 (PowerOfTwo)
    // Fields: Zd=0, Rn=0, size=2, imm5=0
    let encoding: u32 = 0x04A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_index_z_ri_field_size_3_max_4400_04e04400() {
    // Encoding: 0x04E04400
    // Test INDEX_Z.RI__ field size = 3 (Max)
    // Fields: size=3, Zd=0, imm5=0, Rn=0
    let encoding: u32 = 0x04E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_index_z_ri_field_imm5_0_zero_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field imm5 = 0 (Zero)
    // Fields: imm5=0, Zd=0, Rn=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_index_z_ri_field_imm5_1_poweroftwo_4400_04214400() {
    // Encoding: 0x04214400
    // Test INDEX_Z.RI__ field imm5 = 1 (PowerOfTwo)
    // Fields: size=0, Rn=0, Zd=0, imm5=1
    let encoding: u32 = 0x04214400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_index_z_ri_field_imm5_3_poweroftwominusone_4400_04234400() {
    // Encoding: 0x04234400
    // Test INDEX_Z.RI__ field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: imm5=3, size=0, Rn=0, Zd=0
    let encoding: u32 = 0x04234400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_index_z_ri_field_imm5_4_poweroftwo_4400_04244400() {
    // Encoding: 0x04244400
    // Test INDEX_Z.RI__ field imm5 = 4 (PowerOfTwo)
    // Fields: Zd=0, Rn=0, size=0, imm5=4
    let encoding: u32 = 0x04244400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_index_z_ri_field_imm5_7_poweroftwominusone_4400_04274400() {
    // Encoding: 0x04274400
    // Test INDEX_Z.RI__ field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: Rn=0, size=0, imm5=7, Zd=0
    let encoding: u32 = 0x04274400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_index_z_ri_field_imm5_8_poweroftwo_4400_04284400() {
    // Encoding: 0x04284400
    // Test INDEX_Z.RI__ field imm5 = 8 (PowerOfTwo)
    // Fields: imm5=8, Rn=0, Zd=0, size=0
    let encoding: u32 = 0x04284400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_index_z_ri_field_imm5_15_poweroftwominusone_4400_042f4400() {
    // Encoding: 0x042F4400
    // Test INDEX_Z.RI__ field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: imm5=15, Rn=0, size=0, Zd=0
    let encoding: u32 = 0x042F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_index_z_ri_field_imm5_16_poweroftwo_4400_04304400() {
    // Encoding: 0x04304400
    // Test INDEX_Z.RI__ field imm5 = 16 (PowerOfTwo)
    // Fields: imm5=16, Zd=0, Rn=0, size=0
    let encoding: u32 = 0x04304400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field imm5 16 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_index_z_ri_field_imm5_31_max_4400_043f4400() {
    // Encoding: 0x043F4400
    // Test INDEX_Z.RI__ field imm5 = 31 (Max)
    // Fields: Rn=0, imm5=31, size=0, Zd=0
    let encoding: u32 = 0x043F4400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_index_z_ri_field_rn_0_min_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field Rn = 0 (Min)
    // Fields: Zd=0, imm5=0, Rn=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_index_z_ri_field_rn_1_poweroftwo_4400_04204420() {
    // Encoding: 0x04204420
    // Test INDEX_Z.RI__ field Rn = 1 (PowerOfTwo)
    // Fields: Rn=1, Zd=0, size=0, imm5=0
    let encoding: u32 = 0x04204420;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_index_z_ri_field_rn_30_poweroftwominusone_4400_042047c0() {
    // Encoding: 0x042047C0
    // Test INDEX_Z.RI__ field Rn = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, Rn=30, imm5=0
    let encoding: u32 = 0x042047C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn 5 +: 5`
/// Requirement: FieldBoundary { field: "Rn", value: 31, boundary: Max }
/// register index 31 (SP - stack pointer)
#[test]
fn test_index_z_ri_field_rn_31_max_4400_042047e0() {
    // Encoding: 0x042047E0
    // Test INDEX_Z.RI__ field Rn = 31 (Max)
    // Fields: Zd=0, Rn=31, imm5=0, size=0
    let encoding: u32 = 0x042047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_index_z_ri_field_zd_0_min_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field Zd = 0 (Min)
    // Fields: Zd=0, Rn=0, imm5=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_index_z_ri_field_zd_1_poweroftwo_4400_04204401() {
    // Encoding: 0x04204401
    // Test INDEX_Z.RI__ field Zd = 1 (PowerOfTwo)
    // Fields: Zd=1, size=0, imm5=0, Rn=0
    let encoding: u32 = 0x04204401;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_index_z_ri_field_zd_30_poweroftwominusone_4400_0420441e() {
    // Encoding: 0x0420441E
    // Test INDEX_Z.RI__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Rn=0, imm5=0, Zd=30, size=0
    let encoding: u32 = 0x0420441E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_index_z_ri_field_zd_31_max_4400_0420441f() {
    // Encoding: 0x0420441F
    // Test INDEX_Z.RI__ field Zd = 31 (Max)
    // Fields: Rn=0, imm5=0, size=0, Zd=31
    let encoding: u32 = 0x0420441F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_index_z_ri_combo_0_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ field combination: size=0, imm5=0, Rn=0, Zd=0
    // Fields: imm5=0, Rn=0, size=0, Zd=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_index_z_ri_special_size_0_size_variant_0_17408_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ special value size = 0 (Size variant 0)
    // Fields: imm5=0, Rn=0, Zd=0, size=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_index_z_ri_special_size_1_size_variant_1_17408_04604400() {
    // Encoding: 0x04604400
    // Test INDEX_Z.RI__ special value size = 1 (Size variant 1)
    // Fields: Zd=0, size=1, Rn=0, imm5=0
    let encoding: u32 = 0x04604400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_index_z_ri_special_size_2_size_variant_2_17408_04a04400() {
    // Encoding: 0x04A04400
    // Test INDEX_Z.RI__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, Rn=0, size=2, imm5=0
    let encoding: u32 = 0x04A04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_index_z_ri_special_size_3_size_variant_3_17408_04e04400() {
    // Encoding: 0x04E04400
    // Test INDEX_Z.RI__ special value size = 3 (Size variant 3)
    // Fields: imm5=0, Zd=0, size=3, Rn=0
    let encoding: u32 = 0x04E04400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `field Rn = 31 (Stack pointer (SP) - may require alignment)`
/// Requirement: FieldSpecial { field: "Rn", value: 31, meaning: "Stack pointer (SP) - may require alignment" }
/// Stack pointer (SP) - may require alignment
#[test]
fn test_index_z_ri_special_rn_31_stack_pointer_sp_may_require_alignment_17408_042047e0() {
    // Encoding: 0x042047E0
    // Test INDEX_Z.RI__ special value Rn = 31 (Stack pointer (SP) - may require alignment)
    // Fields: Zd=0, imm5=0, Rn=31, size=0
    let encoding: u32 = 0x042047E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_index_z_ri_invalid_0_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, imm5=0, size=0, Rn=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_index_z_ri_invalid_1_4400_04204400() {
    // Encoding: 0x04204400
    // Test INDEX_Z.RI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Rn=0, Zd=0, imm5=0
    let encoding: u32 = 0x04204400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.RI__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_index_z_ri_reg_write_0_04204400() {
    // Test INDEX_Z.RI__ register write: SimdFromField("d")
    // Encoding: 0x04204400
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204400;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: INDEX_Z.RI__
/// ASL: `Rn = 31 (SP)`
/// Requirement: RegisterSpecial { reg: Sp, behavior: "stack pointer with alignment requirements" }
/// stack pointer (Rn = 31)
#[test]
fn test_index_z_ri_sp_rn_042047e0() {
    // Test INDEX_Z.RI__ with Rn = SP (31)
    // Encoding: 0x042047E0
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x042047E0;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// ORV_R.P.Z__ Tests
// ============================================================================

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_orv_r_p_z_field_size_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_orv_r_p_z_field_size_1_poweroftwo_2000_04582000() {
    // Encoding: 0x04582000
    // Test ORV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_orv_r_p_z_field_size_2_poweroftwo_2000_04982000() {
    // Encoding: 0x04982000
    // Test ORV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zn=0, Vd=0
    let encoding: u32 = 0x04982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_orv_r_p_z_field_size_3_max_2000_04d82000() {
    // Encoding: 0x04D82000
    // Test ORV_R.P.Z__ field size = 3 (Max)
    // Fields: Zn=0, size=3, Pg=0, Vd=0
    let encoding: u32 = 0x04D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_orv_r_p_z_field_pg_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_orv_r_p_z_field_pg_1_poweroftwo_2000_04182400() {
    // Encoding: 0x04182400
    // Test ORV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Zn=0, Pg=1, Vd=0, size=0
    let encoding: u32 = 0x04182400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_orv_r_p_z_field_zn_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field Zn = 0 (Min)
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_orv_r_p_z_field_zn_1_poweroftwo_2000_04182020() {
    // Encoding: 0x04182020
    // Test ORV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Vd=0, Zn=1
    let encoding: u32 = 0x04182020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_orv_r_p_z_field_zn_30_poweroftwominusone_2000_041823c0() {
    // Encoding: 0x041823C0
    // Test ORV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Pg=0, Vd=0
    let encoding: u32 = 0x041823C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_orv_r_p_z_field_zn_31_max_2000_041823e0() {
    // Encoding: 0x041823E0
    // Test ORV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, Vd=0, size=0, Zn=31
    let encoding: u32 = 0x041823E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_orv_r_p_z_field_vd_0_min_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field Vd = 0 (Min)
    // Fields: Zn=0, Pg=0, Vd=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_orv_r_p_z_field_vd_1_poweroftwo_2000_04182001() {
    // Encoding: 0x04182001
    // Test ORV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zn=0, size=0, Vd=1
    let encoding: u32 = 0x04182001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_orv_r_p_z_field_vd_30_poweroftwominusone_2000_0418201e() {
    // Encoding: 0x0418201E
    // Test ORV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Pg=0, Vd=30
    let encoding: u32 = 0x0418201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_orv_r_p_z_field_vd_31_max_2000_0418201f() {
    // Encoding: 0x0418201F
    // Test ORV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Zn=0, size=0, Vd=31, Pg=0
    let encoding: u32 = 0x0418201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_orv_r_p_z_combo_0_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_orv_r_p_z_special_size_0_size_variant_0_8192_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Vd=0, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_orv_r_p_z_special_size_1_size_variant_1_8192_04582000() {
    // Encoding: 0x04582000
    // Test ORV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, size=1, Zn=0, Vd=0
    let encoding: u32 = 0x04582000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_orv_r_p_z_special_size_2_size_variant_2_8192_04982000() {
    // Encoding: 0x04982000
    // Test ORV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zn=0, size=2, Vd=0
    let encoding: u32 = 0x04982000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_orv_r_p_z_special_size_3_size_variant_3_8192_04d82000() {
    // Encoding: 0x04D82000
    // Test ORV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Zn=0, size=3, Pg=0, Vd=0
    let encoding: u32 = 0x04D82000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_orv_r_p_z_invalid_0_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Vd=0, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_orv_r_p_z_invalid_1_2000_04182000() {
    // Encoding: 0x04182000
    // Test ORV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x04182000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: ORV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_orv_r_p_z_reg_write_0_04182000() {
    // Test ORV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x04182000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04182000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.ZI__ Tests
// ============================================================================

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_zi_field_tszh_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field tszh = 0 (Min)
    // Fields: Zd=0, tszl=0, imm3=0, Zn=0, tszh=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_zi_field_tszh_1_poweroftwo_9c00_04609c00() {
    // Encoding: 0x04609C00
    // Test LSL_Z.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: imm3=0, Zn=0, tszh=1, Zd=0, tszl=0
    let encoding: u32 = 0x04609C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_zi_field_tszh_3_max_9c00_04e09c00() {
    // Encoding: 0x04E09C00
    // Test LSL_Z.ZI__ field tszh = 3 (Max)
    // Fields: Zn=0, tszh=3, Zd=0, imm3=0, tszl=0
    let encoding: u32 = 0x04E09C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_zi_field_tszl_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field tszl = 0 (Min)
    // Fields: tszh=0, imm3=0, Zd=0, tszl=0, Zn=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_zi_field_tszl_1_poweroftwo_9c00_04289c00() {
    // Encoding: 0x04289C00
    // Test LSL_Z.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: Zd=0, tszl=1, imm3=0, tszh=0, Zn=0
    let encoding: u32 = 0x04289C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field tszl 19 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_zi_field_tszl_3_max_9c00_04389c00() {
    // Encoding: 0x04389C00
    // Test LSL_Z.ZI__ field tszl = 3 (Max)
    // Fields: imm3=0, tszh=0, tszl=3, Zd=0, Zn=0
    let encoding: u32 = 0x04389C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsl_z_zi_field_imm3_0_zero_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field imm3 = 0 (Zero)
    // Fields: Zd=0, imm3=0, Zn=0, tszh=0, tszl=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsl_z_zi_field_imm3_1_poweroftwo_9c00_04219c00() {
    // Encoding: 0x04219C00
    // Test LSL_Z.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszl=0, tszh=0, imm3=1, Zn=0, Zd=0
    let encoding: u32 = 0x04219C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsl_z_zi_field_imm3_3_poweroftwominusone_9c00_04239c00() {
    // Encoding: 0x04239C00
    // Test LSL_Z.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszh=0, imm3=3, Zn=0, Zd=0, tszl=0
    let encoding: u32 = 0x04239C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field imm3 16 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsl_z_zi_field_imm3_7_max_9c00_04279c00() {
    // Encoding: 0x04279C00
    // Test LSL_Z.ZI__ field imm3 = 7 (Max)
    // Fields: Zd=0, tszl=0, imm3=7, Zn=0, tszh=0
    let encoding: u32 = 0x04279C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zi_field_zn_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field Zn = 0 (Min)
    // Fields: tszl=0, Zd=0, tszh=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zi_field_zn_1_poweroftwo_9c00_04209c20() {
    // Encoding: 0x04209C20
    // Test LSL_Z.ZI__ field Zn = 1 (PowerOfTwo)
    // Fields: tszl=0, Zd=0, Zn=1, imm3=0, tszh=0
    let encoding: u32 = 0x04209C20;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zi_field_zn_30_poweroftwominusone_9c00_04209fc0() {
    // Encoding: 0x04209FC0
    // Test LSL_Z.ZI__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: imm3=0, tszh=0, Zn=30, Zd=0, tszl=0
    let encoding: u32 = 0x04209FC0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zi_field_zn_31_max_9c00_04209fe0() {
    // Encoding: 0x04209FE0
    // Test LSL_Z.ZI__ field Zn = 31 (Max)
    // Fields: imm3=0, tszh=0, Zn=31, Zd=0, tszl=0
    let encoding: u32 = 0x04209FE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lsl_z_zi_field_zd_0_min_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field Zd = 0 (Min)
    // Fields: tszh=0, Zd=0, Zn=0, tszl=0, imm3=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lsl_z_zi_field_zd_1_poweroftwo_9c00_04209c01() {
    // Encoding: 0x04209C01
    // Test LSL_Z.ZI__ field Zd = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, Zn=0, imm3=0, Zd=1
    let encoding: u32 = 0x04209C01;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lsl_z_zi_field_zd_30_poweroftwominusone_9c00_04209c1e() {
    // Encoding: 0x04209C1E
    // Test LSL_Z.ZI__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: Zd=30, tszl=0, tszh=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209C1E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lsl_z_zi_field_zd_31_max_9c00_04209c1f() {
    // Encoding: 0x04209C1F
    // Test LSL_Z.ZI__ field Zd = 31 (Max)
    // Fields: tszh=0, imm3=0, tszl=0, Zd=31, Zn=0
    let encoding: u32 = 0x04209C1F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsl_z_zi_combo_0_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ field combination: tszh=0, tszl=0, imm3=0, Zn=0, Zd=0
    // Fields: imm3=0, Zd=0, Zn=0, tszl=0, tszh=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_zi_invalid_0_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszh=0, Zd=0, tszl=0, imm3=0, Zn=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_zi_invalid_1_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszl=0, imm3=0, Zn=0, tszh=0, Zd=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_zi_invalid_2_9c00_04209c00() {
    // Encoding: 0x04209C00
    // Test LSL_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: tszl=0, imm3=0, tszh=0, Zn=0, Zd=0
    let encoding: u32 = 0x04209C00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.ZI__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lsl_z_zi_reg_write_0_04209c00() {
    // Test LSL_Z.ZI__ register write: SimdFromField("d")
    // Encoding: 0x04209C00
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04209C00;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UABD_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uabd_z_p_zz_field_size_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field size = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uabd_z_p_zz_field_size_1_poweroftwo_0_044d0000() {
    // Encoding: 0x044D0000
    // Test UABD_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zm=0, Zdn=0
    let encoding: u32 = 0x044D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uabd_z_p_zz_field_size_2_poweroftwo_0_048d0000() {
    // Encoding: 0x048D0000
    // Test UABD_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, Zm=0, size=2, Zdn=0
    let encoding: u32 = 0x048D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uabd_z_p_zz_field_size_3_max_0_04cd0000() {
    // Encoding: 0x04CD0000
    // Test UABD_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04CD0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uabd_z_p_zz_field_pg_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: Zdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uabd_z_p_zz_field_pg_1_poweroftwo_0_040d0400() {
    // Encoding: 0x040D0400
    // Test UABD_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Zdn=0, Pg=1, Zm=0
    let encoding: u32 = 0x040D0400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uabd_z_p_zz_field_zm_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Zdn=0, Pg=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uabd_z_p_zz_field_zm_1_poweroftwo_0_040d0020() {
    // Encoding: 0x040D0020
    // Test UABD_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Pg=0, size=0, Zm=1, Zdn=0
    let encoding: u32 = 0x040D0020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uabd_z_p_zz_field_zm_30_poweroftwominusone_0_040d03c0() {
    // Encoding: 0x040D03C0
    // Test UABD_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, Pg=0, size=0, Zm=30
    let encoding: u32 = 0x040D03C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uabd_z_p_zz_field_zm_31_max_0_040d03e0() {
    // Encoding: 0x040D03E0
    // Test UABD_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Zdn=0, Pg=0, Zm=31, size=0
    let encoding: u32 = 0x040D03E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_uabd_z_p_zz_field_zdn_0_min_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: Zm=0, Zdn=0, size=0, Pg=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_uabd_z_p_zz_field_zdn_1_poweroftwo_0_040d0001() {
    // Encoding: 0x040D0001
    // Test UABD_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x040D0001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_uabd_z_p_zz_field_zdn_15_poweroftwominusone_0_040d000f() {
    // Encoding: 0x040D000F
    // Test UABD_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zm=0, Pg=0, size=0, Zdn=15
    let encoding: u32 = 0x040D000F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_uabd_z_p_zz_field_zdn_31_max_0_040d001f() {
    // Encoding: 0x040D001F
    // Test UABD_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zm=0, size=0, Zdn=31
    let encoding: u32 = 0x040D001F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uabd_z_p_zz_combo_0_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Pg=0, size=0, Zm=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uabd_z_p_zz_special_size_0_size_variant_0_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uabd_z_p_zz_special_size_1_size_variant_1_0_044d0000() {
    // Encoding: 0x044D0000
    // Test UABD_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, Pg=0, size=1, Zdn=0
    let encoding: u32 = 0x044D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uabd_z_p_zz_special_size_2_size_variant_2_0_048d0000() {
    // Encoding: 0x048D0000
    // Test UABD_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Zm=0, size=2, Zdn=0
    let encoding: u32 = 0x048D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uabd_z_p_zz_special_size_3_size_variant_3_0_04cd0000() {
    // Encoding: 0x04CD0000
    // Test UABD_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04CD0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uabd_z_p_zz_invalid_0_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uabd_z_p_zz_invalid_1_0_040d0000() {
    // Encoding: 0x040D0000
    // Test UABD_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x040D0000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UABD_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_uabd_z_p_zz_reg_write_0_040d0000() {
    // Test UABD_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x040D0000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040D0000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LASTA_V.P.Z__ Tests
// ============================================================================

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lasta_v_p_z_field_size_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field size = 0 (Min)
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lasta_v_p_z_field_size_1_poweroftwo_8000_05628000() {
    // Encoding: 0x05628000
    // Test LASTA_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, size=1, Zn=0, Vd=0
    let encoding: u32 = 0x05628000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lasta_v_p_z_field_size_2_poweroftwo_8000_05a28000() {
    // Encoding: 0x05A28000
    // Test LASTA_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vd=0, size=2, Zn=0, Pg=0
    let encoding: u32 = 0x05A28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lasta_v_p_z_field_size_3_max_8000_05e28000() {
    // Encoding: 0x05E28000
    // Test LASTA_V.P.Z__ field size = 3 (Max)
    // Fields: size=3, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x05E28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lasta_v_p_z_field_pg_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field Pg = 0 (Min)
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lasta_v_p_z_field_pg_1_poweroftwo_8000_05228400() {
    // Encoding: 0x05228400
    // Test LASTA_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Vd=0, Zn=0, Pg=1
    let encoding: u32 = 0x05228400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lasta_v_p_z_field_zn_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field Zn = 0 (Min)
    // Fields: Pg=0, Zn=0, size=0, Vd=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lasta_v_p_z_field_zn_1_poweroftwo_8000_05228020() {
    // Encoding: 0x05228020
    // Test LASTA_V.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Vd=0, Pg=0, size=0, Zn=1
    let encoding: u32 = 0x05228020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lasta_v_p_z_field_zn_30_poweroftwominusone_8000_052283c0() {
    // Encoding: 0x052283C0
    // Test LASTA_V.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=0, size=0, Pg=0, Zn=30
    let encoding: u32 = 0x052283C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lasta_v_p_z_field_zn_31_max_8000_052283e0() {
    // Encoding: 0x052283E0
    // Test LASTA_V.P.Z__ field Zn = 31 (Max)
    // Fields: size=0, Zn=31, Pg=0, Vd=0
    let encoding: u32 = 0x052283E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lasta_v_p_z_field_vd_0_min_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field Vd = 0 (Min)
    // Fields: Pg=0, size=0, Zn=0, Vd=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lasta_v_p_z_field_vd_1_poweroftwo_8000_05228001() {
    // Encoding: 0x05228001
    // Test LASTA_V.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Pg=0, Vd=1
    let encoding: u32 = 0x05228001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lasta_v_p_z_field_vd_30_poweroftwominusone_8000_0522801e() {
    // Encoding: 0x0522801E
    // Test LASTA_V.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=30, size=0, Zn=0, Pg=0
    let encoding: u32 = 0x0522801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lasta_v_p_z_field_vd_31_max_8000_0522801f() {
    // Encoding: 0x0522801F
    // Test LASTA_V.P.Z__ field Vd = 31 (Max)
    // Fields: size=0, Pg=0, Zn=0, Vd=31
    let encoding: u32 = 0x0522801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lasta_v_p_z_combo_0_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, size=0, Pg=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lasta_v_p_z_special_size_0_size_variant_0_32768_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lasta_v_p_z_special_size_1_size_variant_1_32768_05628000() {
    // Encoding: 0x05628000
    // Test LASTA_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Pg=0, Zn=0, Vd=0, size=1
    let encoding: u32 = 0x05628000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lasta_v_p_z_special_size_2_size_variant_2_32768_05a28000() {
    // Encoding: 0x05A28000
    // Test LASTA_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Vd=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x05A28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lasta_v_p_z_special_size_3_size_variant_3_32768_05e28000() {
    // Encoding: 0x05E28000
    // Test LASTA_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: size=3, Pg=0, Zn=0, Vd=0
    let encoding: u32 = 0x05E28000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lasta_v_p_z_invalid_0_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Vd=0, Pg=0, Zn=0, size=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lasta_v_p_z_invalid_1_8000_05228000() {
    // Encoding: 0x05228000
    // Test LASTA_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zn=0, Vd=0, size=0
    let encoding: u32 = 0x05228000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTA_V.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_lasta_v_p_z_reg_write_0_05228000() {
    // Test LASTA_V.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x05228000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05228000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LASTB_R.P.Z__ Tests
// ============================================================================

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lastb_r_p_z_field_size_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field size = 0 (Min)
    // Fields: size=0, Pg=0, Rd=0, Zn=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lastb_r_p_z_field_size_1_poweroftwo_a000_0561a000() {
    // Encoding: 0x0561A000
    // Test LASTB_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, size=1, Rd=0, Pg=0
    let encoding: u32 = 0x0561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lastb_r_p_z_field_size_2_poweroftwo_a000_05a1a000() {
    // Encoding: 0x05A1A000
    // Test LASTB_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Zn=0, Pg=0, size=2, Rd=0
    let encoding: u32 = 0x05A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lastb_r_p_z_field_size_3_max_a000_05e1a000() {
    // Encoding: 0x05E1A000
    // Test LASTB_R.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, Rd=0, size=3, Zn=0
    let encoding: u32 = 0x05E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lastb_r_p_z_field_pg_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field Pg = 0 (Min)
    // Fields: Zn=0, Rd=0, size=0, Pg=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lastb_r_p_z_field_pg_1_poweroftwo_a000_0521a400() {
    // Encoding: 0x0521A400
    // Test LASTB_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, size=0, Zn=0, Rd=0
    let encoding: u32 = 0x0521A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lastb_r_p_z_field_zn_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field Zn = 0 (Min)
    // Fields: Rd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lastb_r_p_z_field_zn_1_poweroftwo_a000_0521a020() {
    // Encoding: 0x0521A020
    // Test LASTB_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, Pg=0, size=0, Rd=0
    let encoding: u32 = 0x0521A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lastb_r_p_z_field_zn_30_poweroftwominusone_a000_0521a3c0() {
    // Encoding: 0x0521A3C0
    // Test LASTB_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=30, Rd=0, Pg=0
    let encoding: u32 = 0x0521A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lastb_r_p_z_field_zn_31_max_a000_0521a3e0() {
    // Encoding: 0x0521A3E0
    // Test LASTB_R.P.Z__ field Zn = 31 (Max)
    // Fields: Pg=0, size=0, Zn=31, Rd=0
    let encoding: u32 = 0x0521A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lastb_r_p_z_field_rd_0_min_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field Rd = 0 (Min)
    // Fields: Rd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lastb_r_p_z_field_rd_1_poweroftwo_a000_0521a001() {
    // Encoding: 0x0521A001
    // Test LASTB_R.P.Z__ field Rd = 1 (PowerOfTwo)
    // Fields: size=0, Zn=0, Rd=1, Pg=0
    let encoding: u32 = 0x0521A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_lastb_r_p_z_field_rd_30_poweroftwominusone_a000_0521a01e() {
    // Encoding: 0x0521A01E
    // Test LASTB_R.P.Z__ field Rd = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zn=0, size=0, Rd=30
    let encoding: u32 = 0x0521A01E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd 0 +: 5`
/// Requirement: FieldBoundary { field: "Rd", value: 31, boundary: Max }
/// register index 31 (ZR - zero register)
#[test]
fn test_lastb_r_p_z_field_rd_31_max_a000_0521a01f() {
    // Encoding: 0x0521A01F
    // Test LASTB_R.P.Z__ field Rd = 31 (Max)
    // Fields: Zn=0, Pg=0, Rd=31, size=0
    let encoding: u32 = 0x0521A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lastb_r_p_z_combo_0_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Rd=0
    // Fields: Zn=0, Pg=0, Rd=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lastb_r_p_z_special_size_0_size_variant_0_40960_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zn=0, Rd=0, size=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lastb_r_p_z_special_size_1_size_variant_1_40960_0561a000() {
    // Encoding: 0x0561A000
    // Test LASTB_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Rd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x0561A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lastb_r_p_z_special_size_2_size_variant_2_40960_05a1a000() {
    // Encoding: 0x05A1A000
    // Test LASTB_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Zn=0, size=2, Pg=0, Rd=0
    let encoding: u32 = 0x05A1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lastb_r_p_z_special_size_3_size_variant_3_40960_05e1a000() {
    // Encoding: 0x05E1A000
    // Test LASTB_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Rd=0, Zn=0, Pg=0, size=3
    let encoding: u32 = 0x05E1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `field Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)`
/// Requirement: FieldSpecial { field: "Rd", value: 31, meaning: "Zero register (XZR/WZR) - reads as 0, writes discarded" }
/// Zero register (XZR/WZR) - reads as 0, writes discarded
#[test]
fn test_lastb_r_p_z_special_rd_31_zero_register_xzr_wzr_reads_as_0_writes_discarded_40960_0521a01f()
{
    // Encoding: 0x0521A01F
    // Test LASTB_R.P.Z__ special value Rd = 31 (Zero register (XZR/WZR) - reads as 0, writes discarded)
    // Fields: Zn=0, Rd=31, size=0, Pg=0
    let encoding: u32 = 0x0521A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lastb_r_p_z_invalid_0_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, Zn=0, size=0, Rd=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lastb_r_p_z_invalid_1_a000_0521a000() {
    // Encoding: 0x0521A000
    // Test LASTB_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Rd=0, size=0, Zn=0
    let encoding: u32 = 0x0521A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `GpFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "d" }
/// verify register write to GpFromField("d")
#[test]
fn test_lastb_r_p_z_reg_write_0_0521a000() {
    // Test LASTB_R.P.Z__ register write: GpFromField("d")
    // Encoding: 0x0521A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0521A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

/// Provenance: LASTB_R.P.Z__
/// ASL: `Rd = 31 (ZR)`
/// Requirement: RegisterSpecial { reg: Zr, behavior: "reads as 0, writes discarded" }
/// zero register (Rd = 31)
#[test]
fn test_lastb_r_p_z_zr_rd_0521a01f() {
    // Test LASTB_R.P.Z__ with Rd = ZR (31)
    // Encoding: 0x0521A01F
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0521A01F;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
    assert_eq!(get_x(&cpu, 31), 0, "XZR should always be 0");
}

// ============================================================================
// UMINV_R.P.Z__ Tests
// ============================================================================

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_uminv_r_p_z_field_size_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field size = 0 (Min)
    // Fields: size=0, Vd=0, Pg=0, Zn=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_uminv_r_p_z_field_size_1_poweroftwo_2000_044b2000() {
    // Encoding: 0x044B2000
    // Test UMINV_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zn=0, size=1, Vd=0, Pg=0
    let encoding: u32 = 0x044B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_uminv_r_p_z_field_size_2_poweroftwo_2000_048b2000() {
    // Encoding: 0x048B2000
    // Test UMINV_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: Vd=0, Pg=0, Zn=0, size=2
    let encoding: u32 = 0x048B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_uminv_r_p_z_field_size_3_max_2000_04cb2000() {
    // Encoding: 0x04CB2000
    // Test UMINV_R.P.Z__ field size = 3 (Max)
    // Fields: Vd=0, size=3, Pg=0, Zn=0
    let encoding: u32 = 0x04CB2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_uminv_r_p_z_field_pg_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field Pg = 0 (Min)
    // Fields: Vd=0, size=0, Pg=0, Zn=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_uminv_r_p_z_field_pg_1_poweroftwo_2000_040b2400() {
    // Encoding: 0x040B2400
    // Test UMINV_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Vd=0, Zn=0, Pg=1, size=0
    let encoding: u32 = 0x040B2400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uminv_r_p_z_field_zn_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field Zn = 0 (Min)
    // Fields: Vd=0, Zn=0, Pg=0, size=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uminv_r_p_z_field_zn_1_poweroftwo_2000_040b2020() {
    // Encoding: 0x040B2020
    // Test UMINV_R.P.Z__ field Zn = 1 (PowerOfTwo)
    // Fields: Zn=1, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x040B2020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uminv_r_p_z_field_zn_30_poweroftwominusone_2000_040b23c0() {
    // Encoding: 0x040B23C0
    // Test UMINV_R.P.Z__ field Zn = 30 (PowerOfTwoMinusOne)
    // Fields: Vd=0, Pg=0, size=0, Zn=30
    let encoding: u32 = 0x040B23C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Zn 5 +: 5`
/// Requirement: FieldBoundary { field: "Zn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uminv_r_p_z_field_zn_31_max_2000_040b23e0() {
    // Encoding: 0x040B23E0
    // Test UMINV_R.P.Z__ field Zn = 31 (Max)
    // Fields: Vd=0, size=0, Zn=31, Pg=0
    let encoding: u32 = 0x040B23E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_uminv_r_p_z_field_vd_0_min_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field Vd = 0 (Min)
    // Fields: size=0, Vd=0, Zn=0, Pg=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_uminv_r_p_z_field_vd_1_poweroftwo_2000_040b2001() {
    // Encoding: 0x040B2001
    // Test UMINV_R.P.Z__ field Vd = 1 (PowerOfTwo)
    // Fields: Zn=0, Vd=1, size=0, Pg=0
    let encoding: u32 = 0x040B2001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_uminv_r_p_z_field_vd_30_poweroftwominusone_2000_040b201e() {
    // Encoding: 0x040B201E
    // Test UMINV_R.P.Z__ field Vd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zn=0, Vd=30, Pg=0
    let encoding: u32 = 0x040B201E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field Vd 0 +: 5`
/// Requirement: FieldBoundary { field: "Vd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_uminv_r_p_z_field_vd_31_max_2000_040b201f() {
    // Encoding: 0x040B201F
    // Test UMINV_R.P.Z__ field Vd = 31 (Max)
    // Fields: Vd=31, Pg=0, size=0, Zn=0
    let encoding: u32 = 0x040B201F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_uminv_r_p_z_combo_0_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ field combination: size=0, Pg=0, Zn=0, Vd=0
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_uminv_r_p_z_special_size_0_size_variant_0_8192_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Zn=0, Vd=0, Pg=0, size=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_uminv_r_p_z_special_size_1_size_variant_1_8192_044b2000() {
    // Encoding: 0x044B2000
    // Test UMINV_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Vd=0, Zn=0, size=1, Pg=0
    let encoding: u32 = 0x044B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_uminv_r_p_z_special_size_2_size_variant_2_8192_048b2000() {
    // Encoding: 0x048B2000
    // Test UMINV_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zn=0, Vd=0, Pg=0
    let encoding: u32 = 0x048B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_uminv_r_p_z_special_size_3_size_variant_3_8192_04cb2000() {
    // Encoding: 0x04CB2000
    // Test UMINV_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Zn=0, size=3, Vd=0
    let encoding: u32 = 0x04CB2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_uminv_r_p_z_invalid_0_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zn=0, size=0, Pg=0, Vd=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_uminv_r_p_z_invalid_1_2000_040b2000() {
    // Encoding: 0x040B2000
    // Test UMINV_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vd=0, Zn=0, size=0, Pg=0
    let encoding: u32 = 0x040B2000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMINV_R.P.Z__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_uminv_r_p_z_reg_write_0_040b2000() {
    // Test UMINV_R.P.Z__ register write: SimdFromField("d")
    // Encoding: 0x040B2000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x040B2000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// MSB_Z.P.ZZZ__ Tests
// ============================================================================

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_msb_z_p_zzz_field_size_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field size = 0 (Min)
    // Fields: Zm=0, Za=0, Pg=0, size=0, Zdn=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_msb_z_p_zzz_field_size_1_poweroftwo_e000_0440e000() {
    // Encoding: 0x0440E000
    // Test MSB_Z.P.ZZZ__ field size = 1 (PowerOfTwo)
    // Fields: Za=0, size=1, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x0440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_msb_z_p_zzz_field_size_2_poweroftwo_e000_0480e000() {
    // Encoding: 0x0480E000
    // Test MSB_Z.P.ZZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Za=0, Pg=0, Zm=0
    let encoding: u32 = 0x0480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_msb_z_p_zzz_field_size_3_max_e000_04c0e000() {
    // Encoding: 0x04C0E000
    // Test MSB_Z.P.ZZZ__ field size = 3 (Max)
    // Fields: Pg=0, Za=0, Zm=0, size=3, Zdn=0
    let encoding: u32 = 0x04C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_msb_z_p_zzz_field_zm_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, Pg=0, size=0, Zm=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_msb_z_p_zzz_field_zm_1_poweroftwo_e000_0401e000() {
    // Encoding: 0x0401E000
    // Test MSB_Z.P.ZZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, Zdn=0, size=0, Za=0, Pg=0
    let encoding: u32 = 0x0401E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_msb_z_p_zzz_field_zm_30_poweroftwominusone_e000_041ee000() {
    // Encoding: 0x041EE000
    // Test MSB_Z.P.ZZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zdn=0, Za=0, Zm=30
    let encoding: u32 = 0x041EE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zm 16 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_msb_z_p_zzz_field_zm_31_max_e000_041fe000() {
    // Encoding: 0x041FE000
    // Test MSB_Z.P.ZZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, size=0, Za=0, Zdn=0
    let encoding: u32 = 0x041FE000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_msb_z_p_zzz_field_pg_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Pg = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_msb_z_p_zzz_field_pg_1_poweroftwo_e000_0400e400() {
    // Encoding: 0x0400E400
    // Test MSB_Z.P.ZZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: size=0, Pg=1, Zdn=0, Za=0, Zm=0
    let encoding: u32 = 0x0400E400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_msb_z_p_zzz_field_za_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Za = 0 (Min)
    // Fields: Zm=0, size=0, Zdn=0, Pg=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_msb_z_p_zzz_field_za_1_poweroftwo_e000_0400e020() {
    // Encoding: 0x0400E020
    // Test MSB_Z.P.ZZZ__ field Za = 1 (PowerOfTwo)
    // Fields: Zdn=0, size=0, Zm=0, Za=1, Pg=0
    let encoding: u32 = 0x0400E020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_msb_z_p_zzz_field_za_15_poweroftwominusone_e000_0400e1e0() {
    // Encoding: 0x0400E1E0
    // Test MSB_Z.P.ZZZ__ field Za = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, Zm=0, Pg=0, Za=15
    let encoding: u32 = 0x0400E1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Za 5 +: 5`
/// Requirement: FieldBoundary { field: "Za", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_msb_z_p_zzz_field_za_31_max_e000_0400e3e0() {
    // Encoding: 0x0400E3E0
    // Test MSB_Z.P.ZZZ__ field Za = 31 (Max)
    // Fields: Pg=0, size=0, Zm=0, Za=31, Zdn=0
    let encoding: u32 = 0x0400E3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_msb_z_p_zzz_field_zdn_0_min_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field Zdn = 0 (Min)
    // Fields: Zdn=0, Pg=0, Zm=0, size=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_msb_z_p_zzz_field_zdn_1_poweroftwo_e000_0400e001() {
    // Encoding: 0x0400E001
    // Test MSB_Z.P.ZZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Za=0, Zdn=1, Zm=0
    let encoding: u32 = 0x0400E001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_msb_z_p_zzz_field_zdn_15_poweroftwominusone_e000_0400e00f() {
    // Encoding: 0x0400E00F
    // Test MSB_Z.P.ZZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Za=0, Zdn=15, Pg=0, Zm=0, size=0
    let encoding: u32 = 0x0400E00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_msb_z_p_zzz_field_zdn_31_max_e000_0400e01f() {
    // Encoding: 0x0400E01F
    // Test MSB_Z.P.ZZZ__ field Zdn = 31 (Max)
    // Fields: Zm=0, Pg=0, Zdn=31, size=0, Za=0
    let encoding: u32 = 0x0400E01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_msb_z_p_zzz_combo_0_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ field combination: size=0, Zm=0, Pg=0, Za=0, Zdn=0
    // Fields: size=0, Zdn=0, Zm=0, Za=0, Pg=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_msb_z_p_zzz_special_size_0_size_variant_0_57344_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, Za=0, Zdn=0, size=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_msb_z_p_zzz_special_size_1_size_variant_1_57344_0440e000() {
    // Encoding: 0x0440E000
    // Test MSB_Z.P.ZZZ__ special value size = 1 (Size variant 1)
    // Fields: size=1, Zm=0, Za=0, Pg=0, Zdn=0
    let encoding: u32 = 0x0440E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_msb_z_p_zzz_special_size_2_size_variant_2_57344_0480e000() {
    // Encoding: 0x0480E000
    // Test MSB_Z.P.ZZZ__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Za=0, Zdn=0, Zm=0, size=2
    let encoding: u32 = 0x0480E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_msb_z_p_zzz_special_size_3_size_variant_3_57344_04c0e000() {
    // Encoding: 0x04C0E000
    // Test MSB_Z.P.ZZZ__ special value size = 3 (Size variant 3)
    // Fields: Zm=0, Pg=0, Zdn=0, size=3, Za=0
    let encoding: u32 = 0x04C0E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_msb_z_p_zzz_invalid_0_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zdn=0, Za=0, Zm=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_msb_z_p_zzz_invalid_1_e000_0400e000() {
    // Encoding: 0x0400E000
    // Test MSB_Z.P.ZZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, Zm=0, Pg=0, size=0, Za=0
    let encoding: u32 = 0x0400E000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: MSB_Z.P.ZZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_msb_z_p_zzz_reg_write_0_0400e000() {
    // Test MSB_Z.P.ZZZ__ register write: SimdFromField("dn")
    // Encoding: 0x0400E000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0400E000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTB_R.P.Z__ Tests
// ============================================================================

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clastb_r_p_z_field_size_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field size = 0 (Min)
    // Fields: Rdn=0, size=0, Zm=0, Pg=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clastb_r_p_z_field_size_1_poweroftwo_a000_0571a000() {
    // Encoding: 0x0571A000
    // Test CLASTB_R.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Pg=0, Rdn=0, Zm=0
    let encoding: u32 = 0x0571A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clastb_r_p_z_field_size_2_poweroftwo_a000_05b1a000() {
    // Encoding: 0x05B1A000
    // Test CLASTB_R.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Pg=0, Rdn=0, Zm=0
    let encoding: u32 = 0x05B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clastb_r_p_z_field_size_3_max_a000_05f1a000() {
    // Encoding: 0x05F1A000
    // Test CLASTB_R.P.Z__ field size = 3 (Max)
    // Fields: Rdn=0, Pg=0, Zm=0, size=3
    let encoding: u32 = 0x05F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clastb_r_p_z_field_pg_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field Pg = 0 (Min)
    // Fields: Pg=0, Zm=0, Rdn=0, size=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clastb_r_p_z_field_pg_1_poweroftwo_a000_0531a400() {
    // Encoding: 0x0531A400
    // Test CLASTB_R.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Zm=0, Rdn=0, size=0
    let encoding: u32 = 0x0531A400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clastb_r_p_z_field_zm_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field Zm = 0 (Min)
    // Fields: size=0, Zm=0, Pg=0, Rdn=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clastb_r_p_z_field_zm_1_poweroftwo_a000_0531a020() {
    // Encoding: 0x0531A020
    // Test CLASTB_R.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: Rdn=0, size=0, Zm=1, Pg=0
    let encoding: u32 = 0x0531A020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clastb_r_p_z_field_zm_30_poweroftwominusone_a000_0531a3c0() {
    // Encoding: 0x0531A3C0
    // Test CLASTB_R.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: Pg=0, Zm=30, size=0, Rdn=0
    let encoding: u32 = 0x0531A3C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clastb_r_p_z_field_zm_31_max_a000_0531a3e0() {
    // Encoding: 0x0531A3E0
    // Test CLASTB_R.P.Z__ field Zm = 31 (Max)
    // Fields: size=0, Zm=31, Rdn=0, Pg=0
    let encoding: u32 = 0x0531A3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clastb_r_p_z_field_rdn_0_min_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field Rdn = 0 (Min)
    // Fields: Pg=0, Rdn=0, size=0, Zm=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clastb_r_p_z_field_rdn_1_poweroftwo_a000_0531a001() {
    // Encoding: 0x0531A001
    // Test CLASTB_R.P.Z__ field Rdn = 1 (PowerOfTwo)
    // Fields: Zm=0, Pg=0, size=0, Rdn=1
    let encoding: u32 = 0x0531A001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clastb_r_p_z_field_rdn_15_poweroftwominusone_a000_0531a00f() {
    // Encoding: 0x0531A00F
    // Test CLASTB_R.P.Z__ field Rdn = 15 (PowerOfTwoMinusOne)
    // Fields: Rdn=15, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x0531A00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field Rdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Rdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clastb_r_p_z_field_rdn_31_max_a000_0531a01f() {
    // Encoding: 0x0531A01F
    // Test CLASTB_R.P.Z__ field Rdn = 31 (Max)
    // Fields: size=0, Zm=0, Rdn=31, Pg=0
    let encoding: u32 = 0x0531A01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clastb_r_p_z_combo_0_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ field combination: size=0, Pg=0, Zm=0, Rdn=0
    // Fields: Rdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clastb_r_p_z_special_size_0_size_variant_0_40960_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, Zm=0, size=0, Rdn=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clastb_r_p_z_special_size_1_size_variant_1_40960_0571a000() {
    // Encoding: 0x0571A000
    // Test CLASTB_R.P.Z__ special value size = 1 (Size variant 1)
    // Fields: Zm=0, size=1, Rdn=0, Pg=0
    let encoding: u32 = 0x0571A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clastb_r_p_z_special_size_2_size_variant_2_40960_05b1a000() {
    // Encoding: 0x05B1A000
    // Test CLASTB_R.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, size=2, Zm=0, Rdn=0
    let encoding: u32 = 0x05B1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clastb_r_p_z_special_size_3_size_variant_3_40960_05f1a000() {
    // Encoding: 0x05F1A000
    // Test CLASTB_R.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Rdn=0, Zm=0, Pg=0, size=3
    let encoding: u32 = 0x05F1A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clastb_r_p_z_invalid_0_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zm=0, Rdn=0, size=0, Pg=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clastb_r_p_z_invalid_1_a000_0531a000() {
    // Encoding: 0x0531A000
    // Test CLASTB_R.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, Zm=0, Rdn=0, size=0
    let encoding: u32 = 0x0531A000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTB_R.P.Z__
/// ASL: `GpFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "dn" }
/// verify register write to GpFromField("dn")
#[test]
fn test_clastb_r_p_z_reg_write_0_0531a000() {
    // Test CLASTB_R.P.Z__ register write: GpFromField("dn")
    // Encoding: 0x0531A000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x0531A000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSR_Z.P.ZI__ Tests
// ============================================================================

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zi_field_tszh_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field tszh = 0 (Min)
    // Fields: imm3=0, tszh=0, Pg=0, Zdn=0, tszl=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zi_field_tszh_1_poweroftwo_8000_04418000() {
    // Encoding: 0x04418000
    // Test LSR_Z.P.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: Zdn=0, tszl=0, tszh=1, Pg=0, imm3=0
    let encoding: u32 = 0x04418000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsr_z_p_zi_field_tszh_3_max_8000_04c18000() {
    // Encoding: 0x04C18000
    // Test LSR_Z.P.ZI__ field tszh = 3 (Max)
    // Fields: tszl=0, Pg=0, tszh=3, imm3=0, Zdn=0
    let encoding: u32 = 0x04C18000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsr_z_p_zi_field_pg_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field Pg = 0 (Min)
    // Fields: imm3=0, Pg=0, Zdn=0, tszh=0, tszl=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsr_z_p_zi_field_pg_1_poweroftwo_8000_04018400() {
    // Encoding: 0x04018400
    // Test LSR_Z.P.ZI__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, tszl=0, tszh=0, Pg=1, imm3=0
    let encoding: u32 = 0x04018400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zi_field_tszl_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field tszl = 0 (Min)
    // Fields: Zdn=0, Pg=0, tszh=0, imm3=0, tszl=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zi_field_tszl_1_poweroftwo_8000_04018100() {
    // Encoding: 0x04018100
    // Test LSR_Z.P.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: tszh=0, imm3=0, Pg=0, Zdn=0, tszl=1
    let encoding: u32 = 0x04018100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsr_z_p_zi_field_tszl_3_max_8000_04018300() {
    // Encoding: 0x04018300
    // Test LSR_Z.P.ZI__ field tszl = 3 (Max)
    // Fields: tszh=0, tszl=3, Zdn=0, Pg=0, imm3=0
    let encoding: u32 = 0x04018300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsr_z_p_zi_field_imm3_0_zero_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field imm3 = 0 (Zero)
    // Fields: Pg=0, imm3=0, Zdn=0, tszl=0, tszh=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsr_z_p_zi_field_imm3_1_poweroftwo_8000_04018020() {
    // Encoding: 0x04018020
    // Test LSR_Z.P.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszh=0, Zdn=0, Pg=0, tszl=0, imm3=1
    let encoding: u32 = 0x04018020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsr_z_p_zi_field_imm3_3_poweroftwominusone_8000_04018060() {
    // Encoding: 0x04018060
    // Test LSR_Z.P.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: tszl=0, Pg=0, imm3=3, tszh=0, Zdn=0
    let encoding: u32 = 0x04018060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsr_z_p_zi_field_imm3_7_max_8000_040180e0() {
    // Encoding: 0x040180E0
    // Test LSR_Z.P.ZI__ field imm3 = 7 (Max)
    // Fields: tszh=0, tszl=0, Zdn=0, Pg=0, imm3=7
    let encoding: u32 = 0x040180E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsr_z_p_zi_field_zdn_0_min_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field Zdn = 0 (Min)
    // Fields: Zdn=0, imm3=0, tszl=0, tszh=0, Pg=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsr_z_p_zi_field_zdn_1_poweroftwo_8000_04018001() {
    // Encoding: 0x04018001
    // Test LSR_Z.P.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: Pg=0, tszl=0, tszh=0, imm3=0, Zdn=1
    let encoding: u32 = 0x04018001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsr_z_p_zi_field_zdn_15_poweroftwominusone_8000_0401800f() {
    // Encoding: 0x0401800F
    // Test LSR_Z.P.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Zdn=15, tszl=0, tszh=0, Pg=0, imm3=0
    let encoding: u32 = 0x0401800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsr_z_p_zi_field_zdn_31_max_8000_0401801f() {
    // Encoding: 0x0401801F
    // Test LSR_Z.P.ZI__ field Zdn = 31 (Max)
    // Fields: Pg=0, imm3=0, Zdn=31, tszl=0, tszh=0
    let encoding: u32 = 0x0401801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsr_z_p_zi_combo_0_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: tszl=0, Pg=0, imm3=0, Zdn=0, tszh=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zi_invalid_0_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszl=0, Pg=0, imm3=0, Zdn=0, tszh=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zi_invalid_1_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zdn=0, tszl=0, tszh=0, Pg=0, imm3=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsr_z_p_zi_invalid_2_8000_04018000() {
    // Encoding: 0x04018000
    // Test LSR_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: imm3=0, Pg=0, tszl=0, Zdn=0, tszh=0
    let encoding: u32 = 0x04018000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSR_Z.P.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsr_z_p_zi_reg_write_0_04018000() {
    // Test LSR_Z.P.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x04018000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04018000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSLR_Z.P.ZZ__ Tests
// ============================================================================

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_lslr_z_p_zz_field_size_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field size = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_lslr_z_p_zz_field_size_1_poweroftwo_8000_04578000() {
    // Encoding: 0x04578000
    // Test LSLR_Z.P.ZZ__ field size = 1 (PowerOfTwo)
    // Fields: size=1, Zdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x04578000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_lslr_z_p_zz_field_size_2_poweroftwo_8000_04978000() {
    // Encoding: 0x04978000
    // Test LSLR_Z.P.ZZ__ field size = 2 (PowerOfTwo)
    // Fields: Zdn=0, size=2, Zm=0, Pg=0
    let encoding: u32 = 0x04978000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_lslr_z_p_zz_field_size_3_max_8000_04d78000() {
    // Encoding: 0x04D78000
    // Test LSLR_Z.P.ZZ__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04D78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lslr_z_p_zz_field_pg_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field Pg = 0 (Min)
    // Fields: size=0, Pg=0, Zm=0, Zdn=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lslr_z_p_zz_field_pg_1_poweroftwo_8000_04178400() {
    // Encoding: 0x04178400
    // Test LSLR_Z.P.ZZ__ field Pg = 1 (PowerOfTwo)
    // Fields: Zdn=0, Zm=0, size=0, Pg=1
    let encoding: u32 = 0x04178400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_lslr_z_p_zz_field_zm_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field Zm = 0 (Min)
    // Fields: Zdn=0, size=0, Pg=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_lslr_z_p_zz_field_zm_1_poweroftwo_8000_04178020() {
    // Encoding: 0x04178020
    // Test LSLR_Z.P.ZZ__ field Zm = 1 (PowerOfTwo)
    // Fields: Zm=1, size=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04178020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_lslr_z_p_zz_field_zm_30_poweroftwominusone_8000_041783c0() {
    // Encoding: 0x041783C0
    // Test LSLR_Z.P.ZZ__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Zm=30, Zdn=0, Pg=0
    let encoding: u32 = 0x041783C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_lslr_z_p_zz_field_zm_31_max_8000_041783e0() {
    // Encoding: 0x041783E0
    // Test LSLR_Z.P.ZZ__ field Zm = 31 (Max)
    // Fields: Pg=0, Zm=31, Zdn=0, size=0
    let encoding: u32 = 0x041783E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lslr_z_p_zz_field_zdn_0_min_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field Zdn = 0 (Min)
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lslr_z_p_zz_field_zdn_1_poweroftwo_8000_04178001() {
    // Encoding: 0x04178001
    // Test LSLR_Z.P.ZZ__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zm=0, size=0, Pg=0, Zdn=1
    let encoding: u32 = 0x04178001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lslr_z_p_zz_field_zdn_15_poweroftwominusone_8000_0417800f() {
    // Encoding: 0x0417800F
    // Test LSLR_Z.P.ZZ__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: Pg=0, size=0, Zm=0, Zdn=15
    let encoding: u32 = 0x0417800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lslr_z_p_zz_field_zdn_31_max_8000_0417801f() {
    // Encoding: 0x0417801F
    // Test LSLR_Z.P.ZZ__ field Zdn = 31 (Max)
    // Fields: Pg=0, Zdn=31, Zm=0, size=0
    let encoding: u32 = 0x0417801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_lslr_z_p_zz_combo_0_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ field combination: size=0, Pg=0, Zm=0, Zdn=0
    // Fields: Zdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_lslr_z_p_zz_special_size_0_size_variant_0_32768_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, Zm=0, size=0, Pg=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_lslr_z_p_zz_special_size_1_size_variant_1_32768_04578000() {
    // Encoding: 0x04578000
    // Test LSLR_Z.P.ZZ__ special value size = 1 (Size variant 1)
    // Fields: Zdn=0, Pg=0, Zm=0, size=1
    let encoding: u32 = 0x04578000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_lslr_z_p_zz_special_size_2_size_variant_2_32768_04978000() {
    // Encoding: 0x04978000
    // Test LSLR_Z.P.ZZ__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zm=0, Pg=0, Zdn=0
    let encoding: u32 = 0x04978000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_lslr_z_p_zz_special_size_3_size_variant_3_32768_04d78000() {
    // Encoding: 0x04D78000
    // Test LSLR_Z.P.ZZ__ special value size = 3 (Size variant 3)
    // Fields: Zdn=0, Zm=0, size=3, Pg=0
    let encoding: u32 = 0x04D78000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lslr_z_p_zz_invalid_0_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zdn=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lslr_z_p_zz_invalid_1_8000_04178000() {
    // Encoding: 0x04178000
    // Test LSLR_Z.P.ZZ__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, Pg=0, Zm=0
    let encoding: u32 = 0x04178000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSLR_Z.P.ZZ__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lslr_z_p_zz_reg_write_0_04178000() {
    // Test LSLR_Z.P.ZZ__ register write: SimdFromField("dn")
    // Encoding: 0x04178000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04178000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CLASTA_V.P.Z__ Tests
// ============================================================================

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_clasta_v_p_z_field_size_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field size = 0 (Min)
    // Fields: Zm=0, Pg=0, Vdn=0, size=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_clasta_v_p_z_field_size_1_poweroftwo_8000_056a8000() {
    // Encoding: 0x056A8000
    // Test CLASTA_V.P.Z__ field size = 1 (PowerOfTwo)
    // Fields: Zm=0, size=1, Vdn=0, Pg=0
    let encoding: u32 = 0x056A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_clasta_v_p_z_field_size_2_poweroftwo_8000_05aa8000() {
    // Encoding: 0x05AA8000
    // Test CLASTA_V.P.Z__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zm=0, Vdn=0, Pg=0
    let encoding: u32 = 0x05AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_clasta_v_p_z_field_size_3_max_8000_05ea8000() {
    // Encoding: 0x05EA8000
    // Test CLASTA_V.P.Z__ field size = 3 (Max)
    // Fields: Pg=0, size=3, Vdn=0, Zm=0
    let encoding: u32 = 0x05EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_clasta_v_p_z_field_pg_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field Pg = 0 (Min)
    // Fields: Vdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_clasta_v_p_z_field_pg_1_poweroftwo_8000_052a8400() {
    // Encoding: 0x052A8400
    // Test CLASTA_V.P.Z__ field Pg = 1 (PowerOfTwo)
    // Fields: Vdn=0, Pg=1, size=0, Zm=0
    let encoding: u32 = 0x052A8400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_clasta_v_p_z_field_zm_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field Zm = 0 (Min)
    // Fields: Pg=0, Vdn=0, size=0, Zm=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_clasta_v_p_z_field_zm_1_poweroftwo_8000_052a8020() {
    // Encoding: 0x052A8020
    // Test CLASTA_V.P.Z__ field Zm = 1 (PowerOfTwo)
    // Fields: Vdn=0, size=0, Pg=0, Zm=1
    let encoding: u32 = 0x052A8020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_clasta_v_p_z_field_zm_30_poweroftwominusone_8000_052a83c0() {
    // Encoding: 0x052A83C0
    // Test CLASTA_V.P.Z__ field Zm = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Vdn=0, Zm=30
    let encoding: u32 = 0x052A83C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Zm 5 +: 5`
/// Requirement: FieldBoundary { field: "Zm", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_clasta_v_p_z_field_zm_31_max_8000_052a83e0() {
    // Encoding: 0x052A83E0
    // Test CLASTA_V.P.Z__ field Zm = 31 (Max)
    // Fields: size=0, Pg=0, Zm=31, Vdn=0
    let encoding: u32 = 0x052A83E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_clasta_v_p_z_field_vdn_0_min_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field Vdn = 0 (Min)
    // Fields: size=0, Vdn=0, Zm=0, Pg=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_clasta_v_p_z_field_vdn_1_poweroftwo_8000_052a8001() {
    // Encoding: 0x052A8001
    // Test CLASTA_V.P.Z__ field Vdn = 1 (PowerOfTwo)
    // Fields: size=0, Pg=0, Vdn=1, Zm=0
    let encoding: u32 = 0x052A8001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_clasta_v_p_z_field_vdn_15_poweroftwominusone_8000_052a800f() {
    // Encoding: 0x052A800F
    // Test CLASTA_V.P.Z__ field Vdn = 15 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Zm=0, Vdn=15
    let encoding: u32 = 0x052A800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field Vdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Vdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_clasta_v_p_z_field_vdn_31_max_8000_052a801f() {
    // Encoding: 0x052A801F
    // Test CLASTA_V.P.Z__ field Vdn = 31 (Max)
    // Fields: Pg=0, Zm=0, Vdn=31, size=0
    let encoding: u32 = 0x052A801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_clasta_v_p_z_combo_0_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ field combination: size=0, Pg=0, Zm=0, Vdn=0
    // Fields: Pg=0, Vdn=0, Zm=0, size=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_clasta_v_p_z_special_size_0_size_variant_0_32768_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ special value size = 0 (Size variant 0)
    // Fields: Vdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_clasta_v_p_z_special_size_1_size_variant_1_32768_056a8000() {
    // Encoding: 0x056A8000
    // Test CLASTA_V.P.Z__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Vdn=0, Zm=0
    let encoding: u32 = 0x056A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_clasta_v_p_z_special_size_2_size_variant_2_32768_05aa8000() {
    // Encoding: 0x05AA8000
    // Test CLASTA_V.P.Z__ special value size = 2 (Size variant 2)
    // Fields: Pg=0, Vdn=0, size=2, Zm=0
    let encoding: u32 = 0x05AA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_clasta_v_p_z_special_size_3_size_variant_3_32768_05ea8000() {
    // Encoding: 0x05EA8000
    // Test CLASTA_V.P.Z__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Vdn=0, size=3, Zm=0
    let encoding: u32 = 0x05EA8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_clasta_v_p_z_invalid_0_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Pg=0, size=0, Zm=0, Vdn=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_clasta_v_p_z_invalid_1_8000_052a8000() {
    // Encoding: 0x052A8000
    // Test CLASTA_V.P.Z__ invalid encoding: Unconditional UNDEFINED
    // Fields: Vdn=0, Zm=0, Pg=0, size=0
    let encoding: u32 = 0x052A8000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CLASTA_V.P.Z__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Simd128, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_clasta_v_p_z_reg_write_0_052a8000() {
    // Test CLASTA_V.P.Z__ register write: SimdFromField("dn")
    // Encoding: 0x052A8000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x052A8000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// UMIN_Z.ZI__ Tests
// ============================================================================

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_umin_z_zi_field_size_0_min_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field size = 0 (Min)
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_umin_z_zi_field_size_1_poweroftwo_c000_256bc000() {
    // Encoding: 0x256BC000
    // Test UMIN_Z.ZI__ field size = 1 (PowerOfTwo)
    // Fields: imm8=0, Zdn=0, size=1
    let encoding: u32 = 0x256BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_umin_z_zi_field_size_2_poweroftwo_c000_25abc000() {
    // Encoding: 0x25ABC000
    // Test UMIN_Z.ZI__ field size = 2 (PowerOfTwo)
    // Fields: size=2, Zdn=0, imm8=0
    let encoding: u32 = 0x25ABC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_umin_z_zi_field_size_3_max_c000_25ebc000() {
    // Encoding: 0x25EBC000
    // Test UMIN_Z.ZI__ field size = 3 (Max)
    // Fields: size=3, imm8=0, Zdn=0
    let encoding: u32 = 0x25EBC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_umin_z_zi_field_imm8_0_zero_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field imm8 = 0 (Zero)
    // Fields: size=0, imm8=0, Zdn=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_umin_z_zi_field_imm8_1_poweroftwo_c000_252bc020() {
    // Encoding: 0x252BC020
    // Test UMIN_Z.ZI__ field imm8 = 1 (PowerOfTwo)
    // Fields: imm8=1, Zdn=0, size=0
    let encoding: u32 = 0x252BC020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_umin_z_zi_field_imm8_3_poweroftwominusone_c000_252bc060() {
    // Encoding: 0x252BC060
    // Test UMIN_Z.ZI__ field imm8 = 3 (PowerOfTwoMinusOne)
    // Fields: imm8=3, size=0, Zdn=0
    let encoding: u32 = 0x252BC060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_umin_z_zi_field_imm8_4_poweroftwo_c000_252bc080() {
    // Encoding: 0x252BC080
    // Test UMIN_Z.ZI__ field imm8 = 4 (PowerOfTwo)
    // Fields: size=0, imm8=4, Zdn=0
    let encoding: u32 = 0x252BC080;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_umin_z_zi_field_imm8_7_poweroftwominusone_c000_252bc0e0() {
    // Encoding: 0x252BC0E0
    // Test UMIN_Z.ZI__ field imm8 = 7 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, imm8=7
    let encoding: u32 = 0x252BC0E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_umin_z_zi_field_imm8_8_poweroftwo_c000_252bc100() {
    // Encoding: 0x252BC100
    // Test UMIN_Z.ZI__ field imm8 = 8 (PowerOfTwo)
    // Fields: Zdn=0, imm8=8, size=0
    let encoding: u32 = 0x252BC100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 15, boundary: PowerOfTwoMinusOne }
/// 2^4 - 1 = 15
#[test]
fn test_umin_z_zi_field_imm8_15_poweroftwominusone_c000_252bc1e0() {
    // Encoding: 0x252BC1E0
    // Test UMIN_Z.ZI__ field imm8 = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=15, size=0, Zdn=0
    let encoding: u32 = 0x252BC1E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_umin_z_zi_field_imm8_16_poweroftwo_c000_252bc200() {
    // Encoding: 0x252BC200
    // Test UMIN_Z.ZI__ field imm8 = 16 (PowerOfTwo)
    // Fields: imm8=16, Zdn=0, size=0
    let encoding: u32 = 0x252BC200;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 31, boundary: PowerOfTwoMinusOne }
/// 2^5 - 1 = 31
#[test]
fn test_umin_z_zi_field_imm8_31_poweroftwominusone_c000_252bc3e0() {
    // Encoding: 0x252BC3E0
    // Test UMIN_Z.ZI__ field imm8 = 31 (PowerOfTwoMinusOne)
    // Fields: size=0, imm8=31, Zdn=0
    let encoding: u32 = 0x252BC3E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 32, boundary: PowerOfTwo }
/// power of 2 (2^5 = 32)
#[test]
fn test_umin_z_zi_field_imm8_32_poweroftwo_c000_252bc400() {
    // Encoding: 0x252BC400
    // Test UMIN_Z.ZI__ field imm8 = 32 (PowerOfTwo)
    // Fields: size=0, imm8=32, Zdn=0
    let encoding: u32 = 0x252BC400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 63, boundary: PowerOfTwoMinusOne }
/// 2^6 - 1 = 63
#[test]
fn test_umin_z_zi_field_imm8_63_poweroftwominusone_c000_252bc7e0() {
    // Encoding: 0x252BC7E0
    // Test UMIN_Z.ZI__ field imm8 = 63 (PowerOfTwoMinusOne)
    // Fields: Zdn=0, size=0, imm8=63
    let encoding: u32 = 0x252BC7E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 64, boundary: PowerOfTwo }
/// power of 2 (2^6 = 64)
#[test]
fn test_umin_z_zi_field_imm8_64_poweroftwo_c000_252bc800() {
    // Encoding: 0x252BC800
    // Test UMIN_Z.ZI__ field imm8 = 64 (PowerOfTwo)
    // Fields: Zdn=0, size=0, imm8=64
    let encoding: u32 = 0x252BC800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 127, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (127)
#[test]
fn test_umin_z_zi_field_imm8_127_poweroftwominusone_c000_252bcfe0() {
    // Encoding: 0x252BCFE0
    // Test UMIN_Z.ZI__ field imm8 = 127 (PowerOfTwoMinusOne)
    // Fields: imm8=127, Zdn=0, size=0
    let encoding: u32 = 0x252BCFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 128, boundary: PowerOfTwo }
/// power of 2 (2^7 = 128)
#[test]
fn test_umin_z_zi_field_imm8_128_poweroftwo_c000_252bd000() {
    // Encoding: 0x252BD000
    // Test UMIN_Z.ZI__ field imm8 = 128 (PowerOfTwo)
    // Fields: size=0, imm8=128, Zdn=0
    let encoding: u32 = 0x252BD000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field imm8 5 +: 8`
/// Requirement: FieldBoundary { field: "imm8", value: 255, boundary: Max }
/// maximum immediate (255)
#[test]
fn test_umin_z_zi_field_imm8_255_max_c000_252bdfe0() {
    // Encoding: 0x252BDFE0
    // Test UMIN_Z.ZI__ field imm8 = 255 (Max)
    // Fields: Zdn=0, imm8=255, size=0
    let encoding: u32 = 0x252BDFE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_umin_z_zi_field_zdn_0_min_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field Zdn = 0 (Min)
    // Fields: imm8=0, Zdn=0, size=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_umin_z_zi_field_zdn_1_poweroftwo_c000_252bc001() {
    // Encoding: 0x252BC001
    // Test UMIN_Z.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: Zdn=1, size=0, imm8=0
    let encoding: u32 = 0x252BC001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_umin_z_zi_field_zdn_15_poweroftwominusone_c000_252bc00f() {
    // Encoding: 0x252BC00F
    // Test UMIN_Z.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: imm8=0, Zdn=15, size=0
    let encoding: u32 = 0x252BC00F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_umin_z_zi_field_zdn_31_max_c000_252bc01f() {
    // Encoding: 0x252BC01F
    // Test UMIN_Z.ZI__ field Zdn = 31 (Max)
    // Fields: imm8=0, size=0, Zdn=31
    let encoding: u32 = 0x252BC01F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_umin_z_zi_combo_0_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ field combination: size=0, imm8=0, Zdn=0
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_umin_z_zi_special_size_0_size_variant_0_49152_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ special value size = 0 (Size variant 0)
    // Fields: Zdn=0, imm8=0, size=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_umin_z_zi_special_size_1_size_variant_1_49152_256bc000() {
    // Encoding: 0x256BC000
    // Test UMIN_Z.ZI__ special value size = 1 (Size variant 1)
    // Fields: imm8=0, size=1, Zdn=0
    let encoding: u32 = 0x256BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_umin_z_zi_special_size_2_size_variant_2_49152_25abc000() {
    // Encoding: 0x25ABC000
    // Test UMIN_Z.ZI__ special value size = 2 (Size variant 2)
    // Fields: Zdn=0, imm8=0, size=2
    let encoding: u32 = 0x25ABC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_umin_z_zi_special_size_3_size_variant_3_49152_25ebc000() {
    // Encoding: 0x25EBC000
    // Test UMIN_Z.ZI__ special value size = 3 (Size variant 3)
    // Fields: size=3, imm8=0, Zdn=0
    let encoding: u32 = 0x25EBC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_umin_z_zi_invalid_0_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zdn=0, size=0, imm8=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_umin_z_zi_invalid_1_c000_252bc000() {
    // Encoding: 0x252BC000
    // Test UMIN_Z.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: size=0, Zdn=0, imm8=0
    let encoding: u32 = 0x252BC000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: UMIN_Z.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_umin_z_zi_reg_write_0_252bc000() {
    // Test UMIN_Z.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x252BC000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x252BC000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// CPY_Z.P.V__ Tests
// ============================================================================

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_cpy_z_p_v_field_size_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field size = 0 (Min)
    // Fields: size=0, Vn=0, Zd=0, Pg=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_cpy_z_p_v_field_size_1_poweroftwo_8000_05608000() {
    // Encoding: 0x05608000
    // Test CPY_Z.P.V__ field size = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=0, Vn=0, size=1
    let encoding: u32 = 0x05608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_cpy_z_p_v_field_size_2_poweroftwo_8000_05a08000() {
    // Encoding: 0x05A08000
    // Test CPY_Z.P.V__ field size = 2 (PowerOfTwo)
    // Fields: Pg=0, size=2, Zd=0, Vn=0
    let encoding: u32 = 0x05A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_cpy_z_p_v_field_size_3_max_8000_05e08000() {
    // Encoding: 0x05E08000
    // Test CPY_Z.P.V__ field size = 3 (Max)
    // Fields: size=3, Pg=0, Vn=0, Zd=0
    let encoding: u32 = 0x05E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_cpy_z_p_v_field_pg_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field Pg = 0 (Min)
    // Fields: Zd=0, size=0, Vn=0, Pg=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_cpy_z_p_v_field_pg_1_poweroftwo_8000_05208400() {
    // Encoding: 0x05208400
    // Test CPY_Z.P.V__ field Pg = 1 (PowerOfTwo)
    // Fields: Pg=1, Vn=0, Zd=0, size=0
    let encoding: u32 = 0x05208400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cpy_z_p_v_field_vn_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field Vn = 0 (Min)
    // Fields: Vn=0, Pg=0, size=0, Zd=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cpy_z_p_v_field_vn_1_poweroftwo_8000_05208020() {
    // Encoding: 0x05208020
    // Test CPY_Z.P.V__ field Vn = 1 (PowerOfTwo)
    // Fields: Zd=0, size=0, Pg=0, Vn=1
    let encoding: u32 = 0x05208020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cpy_z_p_v_field_vn_30_poweroftwominusone_8000_052083c0() {
    // Encoding: 0x052083C0
    // Test CPY_Z.P.V__ field Vn = 30 (PowerOfTwoMinusOne)
    // Fields: Vn=30, Zd=0, size=0, Pg=0
    let encoding: u32 = 0x052083C0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Vn 5 +: 5`
/// Requirement: FieldBoundary { field: "Vn", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cpy_z_p_v_field_vn_31_max_8000_052083e0() {
    // Encoding: 0x052083E0
    // Test CPY_Z.P.V__ field Vn = 31 (Max)
    // Fields: size=0, Vn=31, Zd=0, Pg=0
    let encoding: u32 = 0x052083E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_cpy_z_p_v_field_zd_0_min_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field Zd = 0 (Min)
    // Fields: Pg=0, Zd=0, size=0, Vn=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_cpy_z_p_v_field_zd_1_poweroftwo_8000_05208001() {
    // Encoding: 0x05208001
    // Test CPY_Z.P.V__ field Zd = 1 (PowerOfTwo)
    // Fields: Pg=0, Zd=1, Vn=0, size=0
    let encoding: u32 = 0x05208001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_cpy_z_p_v_field_zd_30_poweroftwominusone_8000_0520801e() {
    // Encoding: 0x0520801E
    // Test CPY_Z.P.V__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Pg=0, Vn=0, Zd=30
    let encoding: u32 = 0x0520801E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_cpy_z_p_v_field_zd_31_max_8000_0520801f() {
    // Encoding: 0x0520801F
    // Test CPY_Z.P.V__ field Zd = 31 (Max)
    // Fields: size=0, Vn=0, Zd=31, Pg=0
    let encoding: u32 = 0x0520801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_cpy_z_p_v_combo_0_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ field combination: size=0, Pg=0, Vn=0, Zd=0
    // Fields: Pg=0, size=0, Vn=0, Zd=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_cpy_z_p_v_special_size_0_size_variant_0_32768_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ special value size = 0 (Size variant 0)
    // Fields: Pg=0, size=0, Zd=0, Vn=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_cpy_z_p_v_special_size_1_size_variant_1_32768_05608000() {
    // Encoding: 0x05608000
    // Test CPY_Z.P.V__ special value size = 1 (Size variant 1)
    // Fields: size=1, Pg=0, Zd=0, Vn=0
    let encoding: u32 = 0x05608000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_cpy_z_p_v_special_size_2_size_variant_2_32768_05a08000() {
    // Encoding: 0x05A08000
    // Test CPY_Z.P.V__ special value size = 2 (Size variant 2)
    // Fields: size=2, Zd=0, Pg=0, Vn=0
    let encoding: u32 = 0x05A08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_cpy_z_p_v_special_size_3_size_variant_3_32768_05e08000() {
    // Encoding: 0x05E08000
    // Test CPY_Z.P.V__ special value size = 3 (Size variant 3)
    // Fields: Pg=0, Vn=0, size=3, Zd=0
    let encoding: u32 = 0x05E08000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_v_invalid_0_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Vn=0, size=0, Pg=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_cpy_z_p_v_invalid_1_8000_05208000() {
    // Encoding: 0x05208000
    // Test CPY_Z.P.V__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Pg=0, Vn=0, size=0
    let encoding: u32 = 0x05208000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: CPY_Z.P.V__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_cpy_z_p_v_reg_write_0_05208000() {
    // Test CPY_Z.P.V__ register write: SimdFromField("d")
    // Encoding: 0x05208000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x05208000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// LSL_Z.P.ZI__ Tests
// ============================================================================

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zi_field_tszh_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field tszh = 0 (Min)
    // Fields: tszh=0, tszl=0, imm3=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zi_field_tszh_1_poweroftwo_8000_04438000() {
    // Encoding: 0x04438000
    // Test LSL_Z.P.ZI__ field tszh = 1 (PowerOfTwo)
    // Fields: Zdn=0, Pg=0, tszh=1, imm3=0, tszl=0
    let encoding: u32 = 0x04438000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszh 22 +: 2`
/// Requirement: FieldBoundary { field: "tszh", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_p_zi_field_tszh_3_max_8000_04c38000() {
    // Encoding: 0x04C38000
    // Test LSL_Z.P.ZI__ field tszh = 3 (Max)
    // Fields: tszh=3, Zdn=0, Pg=0, tszl=0, imm3=0
    let encoding: u32 = 0x04C38000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_lsl_z_p_zi_field_pg_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field Pg = 0 (Min)
    // Fields: Zdn=0, tszl=0, Pg=0, tszh=0, imm3=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Pg 10 +: 3`
/// Requirement: FieldBoundary { field: "Pg", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_lsl_z_p_zi_field_pg_1_poweroftwo_8000_04038400() {
    // Encoding: 0x04038400
    // Test LSL_Z.P.ZI__ field Pg = 1 (PowerOfTwo)
    // Fields: imm3=0, Zdn=0, Pg=1, tszh=0, tszl=0
    let encoding: u32 = 0x04038400;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zi_field_tszl_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field tszl = 0 (Min)
    // Fields: tszh=0, Zdn=0, tszl=0, imm3=0, Pg=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zi_field_tszl_1_poweroftwo_8000_04038100() {
    // Encoding: 0x04038100
    // Test LSL_Z.P.ZI__ field tszl = 1 (PowerOfTwo)
    // Fields: tszh=0, Pg=0, imm3=0, Zdn=0, tszl=1
    let encoding: u32 = 0x04038100;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field tszl 8 +: 2`
/// Requirement: FieldBoundary { field: "tszl", value: 3, boundary: Max }
/// maximum value (3)
#[test]
fn test_lsl_z_p_zi_field_tszl_3_max_8000_04038300() {
    // Encoding: 0x04038300
    // Test LSL_Z.P.ZI__ field tszl = 3 (Max)
    // Fields: tszh=0, Pg=0, imm3=0, Zdn=0, tszl=3
    let encoding: u32 = 0x04038300;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_lsl_z_p_zi_field_imm3_0_zero_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field imm3 = 0 (Zero)
    // Fields: tszl=0, Pg=0, Zdn=0, tszh=0, imm3=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_lsl_z_p_zi_field_imm3_1_poweroftwo_8000_04038020() {
    // Encoding: 0x04038020
    // Test LSL_Z.P.ZI__ field imm3 = 1 (PowerOfTwo)
    // Fields: tszh=0, Pg=0, tszl=0, imm3=1, Zdn=0
    let encoding: u32 = 0x04038020;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 3, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (3)
#[test]
fn test_lsl_z_p_zi_field_imm3_3_poweroftwominusone_8000_04038060() {
    // Encoding: 0x04038060
    // Test LSL_Z.P.ZI__ field imm3 = 3 (PowerOfTwoMinusOne)
    // Fields: imm3=3, tszl=0, tszh=0, Zdn=0, Pg=0
    let encoding: u32 = 0x04038060;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field imm3 5 +: 3`
/// Requirement: FieldBoundary { field: "imm3", value: 7, boundary: Max }
/// maximum immediate (7)
#[test]
fn test_lsl_z_p_zi_field_imm3_7_max_8000_040380e0() {
    // Encoding: 0x040380E0
    // Test LSL_Z.P.ZI__ field imm3 = 7 (Max)
    // Fields: Zdn=0, Pg=0, imm3=7, tszl=0, tszh=0
    let encoding: u32 = 0x040380E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 0, boundary: Min }
/// minimum value
#[test]
fn test_lsl_z_p_zi_field_zdn_0_min_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field Zdn = 0 (Min)
    // Fields: tszl=0, Pg=0, Zdn=0, imm3=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 1, boundary: PowerOfTwo }
/// value 1
#[test]
fn test_lsl_z_p_zi_field_zdn_1_poweroftwo_8000_04038001() {
    // Encoding: 0x04038001
    // Test LSL_Z.P.ZI__ field Zdn = 1 (PowerOfTwo)
    // Fields: tszh=0, tszl=0, Pg=0, imm3=0, Zdn=1
    let encoding: u32 = 0x04038001;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 15, boundary: PowerOfTwoMinusOne }
/// midpoint (15)
#[test]
fn test_lsl_z_p_zi_field_zdn_15_poweroftwominusone_8000_0403800f() {
    // Encoding: 0x0403800F
    // Test LSL_Z.P.ZI__ field Zdn = 15 (PowerOfTwoMinusOne)
    // Fields: tszh=0, Pg=0, Zdn=15, imm3=0, tszl=0
    let encoding: u32 = 0x0403800F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field Zdn 0 +: 5`
/// Requirement: FieldBoundary { field: "Zdn", value: 31, boundary: Max }
/// maximum value (31)
#[test]
fn test_lsl_z_p_zi_field_zdn_31_max_8000_0403801f() {
    // Encoding: 0x0403801F
    // Test LSL_Z.P.ZI__ field Zdn = 31 (Max)
    // Fields: imm3=0, Zdn=31, tszh=0, Pg=0, tszl=0
    let encoding: u32 = 0x0403801F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// tszh=0 (minimum value)
#[test]
fn test_lsl_z_p_zi_combo_0_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ field combination: tszh=0, Pg=0, tszl=0, imm3=0, Zdn=0
    // Fields: Pg=0, imm3=0, tszh=0, tszl=0, Zdn=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zi_invalid_0_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: tszl=0, Pg=0, Zdn=0, tszh=0, imm3=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zi_invalid_1_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, tszl=0, imm3=0, tszh=0, Zdn=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_lsl_z_p_zi_invalid_2_8000_04038000() {
    // Encoding: 0x04038000
    // Test LSL_Z.P.ZI__ invalid encoding: Unconditional UNDEFINED
    // Fields: Pg=0, tszl=0, Zdn=0, imm3=0, tszh=0
    let encoding: u32 = 0x04038000;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: LSL_Z.P.ZI__
/// ASL: `SimdFromField("dn") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("dn")
#[test]
fn test_lsl_z_p_zi_reg_write_0_04038000() {
    // Test LSL_Z.P.ZI__ register write: SimdFromField("dn")
    // Encoding: 0x04038000
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04038000;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}

// ============================================================================
// INDEX_Z.IR__ Tests
// ============================================================================

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 0, boundary: Min }
/// 8-bit / byte size
#[test]
fn test_index_z_ir_field_size_0_min_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field size = 0 (Min)
    // Fields: Rm=0, size=0, Zd=0, imm5=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 1, boundary: PowerOfTwo }
/// 16-bit / halfword size
#[test]
fn test_index_z_ir_field_size_1_poweroftwo_4800_04604800() {
    // Encoding: 0x04604800
    // Test INDEX_Z.IR__ field size = 1 (PowerOfTwo)
    // Fields: Zd=0, imm5=0, size=1, Rm=0
    let encoding: u32 = 0x04604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 2, boundary: PowerOfTwo }
/// 32-bit / word size
#[test]
fn test_index_z_ir_field_size_2_poweroftwo_4800_04a04800() {
    // Encoding: 0x04A04800
    // Test INDEX_Z.IR__ field size = 2 (PowerOfTwo)
    // Fields: Rm=0, imm5=0, Zd=0, size=2
    let encoding: u32 = 0x04A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size 22 +: 2`
/// Requirement: FieldBoundary { field: "size", value: 3, boundary: Max }
/// 64-bit / doubleword size
#[test]
fn test_index_z_ir_field_size_3_max_4800_04e04800() {
    // Encoding: 0x04E04800
    // Test INDEX_Z.IR__ field size = 3 (Max)
    // Fields: Zd=0, size=3, imm5=0, Rm=0
    let encoding: u32 = 0x04E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 0, boundary: Min }
/// register index 0 (first register)
#[test]
fn test_index_z_ir_field_rm_0_min_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field Rm = 0 (Min)
    // Fields: imm5=0, Zd=0, size=0, Rm=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 1, boundary: PowerOfTwo }
/// register index 1 (second register)
#[test]
fn test_index_z_ir_field_rm_1_poweroftwo_4800_04214800() {
    // Encoding: 0x04214800
    // Test INDEX_Z.IR__ field Rm = 1 (PowerOfTwo)
    // Fields: size=0, Zd=0, Rm=1, imm5=0
    let encoding: u32 = 0x04214800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 30, boundary: PowerOfTwoMinusOne }
/// register index 30 (LR in some contexts)
#[test]
fn test_index_z_ir_field_rm_30_poweroftwominusone_4800_043e4800() {
    // Encoding: 0x043E4800
    // Test INDEX_Z.IR__ field Rm = 30 (PowerOfTwoMinusOne)
    // Fields: imm5=0, size=0, Zd=0, Rm=30
    let encoding: u32 = 0x043E4800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Rm 16 +: 5`
/// Requirement: FieldBoundary { field: "Rm", value: 31, boundary: Max }
/// register index 31 (special)
#[test]
fn test_index_z_ir_field_rm_31_max_4800_043f4800() {
    // Encoding: 0x043F4800
    // Test INDEX_Z.IR__ field Rm = 31 (Max)
    // Fields: size=0, imm5=0, Rm=31, Zd=0
    let encoding: u32 = 0x043F4800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 0, boundary: Zero }
/// immediate value 0
#[test]
fn test_index_z_ir_field_imm5_0_zero_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field imm5 = 0 (Zero)
    // Fields: imm5=0, size=0, Rm=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 1, boundary: PowerOfTwo }
/// immediate value 1
#[test]
fn test_index_z_ir_field_imm5_1_poweroftwo_4800_04204820() {
    // Encoding: 0x04204820
    // Test INDEX_Z.IR__ field imm5 = 1 (PowerOfTwo)
    // Fields: Zd=0, Rm=0, size=0, imm5=1
    let encoding: u32 = 0x04204820;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 3, boundary: PowerOfTwoMinusOne }
/// 2^2 - 1 = 3
#[test]
fn test_index_z_ir_field_imm5_3_poweroftwominusone_4800_04204860() {
    // Encoding: 0x04204860
    // Test INDEX_Z.IR__ field imm5 = 3 (PowerOfTwoMinusOne)
    // Fields: size=0, Rm=0, imm5=3, Zd=0
    let encoding: u32 = 0x04204860;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 4, boundary: PowerOfTwo }
/// power of 2 (2^2 = 4)
#[test]
fn test_index_z_ir_field_imm5_4_poweroftwo_4800_04204880() {
    // Encoding: 0x04204880
    // Test INDEX_Z.IR__ field imm5 = 4 (PowerOfTwo)
    // Fields: size=0, imm5=4, Rm=0, Zd=0
    let encoding: u32 = 0x04204880;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 7, boundary: PowerOfTwoMinusOne }
/// 2^3 - 1 = 7
#[test]
fn test_index_z_ir_field_imm5_7_poweroftwominusone_4800_042048e0() {
    // Encoding: 0x042048E0
    // Test INDEX_Z.IR__ field imm5 = 7 (PowerOfTwoMinusOne)
    // Fields: size=0, Rm=0, imm5=7, Zd=0
    let encoding: u32 = 0x042048E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 8, boundary: PowerOfTwo }
/// power of 2 (2^3 = 8)
#[test]
fn test_index_z_ir_field_imm5_8_poweroftwo_4800_04204900() {
    // Encoding: 0x04204900
    // Test INDEX_Z.IR__ field imm5 = 8 (PowerOfTwo)
    // Fields: size=0, imm5=8, Zd=0, Rm=0
    let encoding: u32 = 0x04204900;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 15, boundary: PowerOfTwoMinusOne }
/// immediate midpoint (15)
#[test]
fn test_index_z_ir_field_imm5_15_poweroftwominusone_4800_042049e0() {
    // Encoding: 0x042049E0
    // Test INDEX_Z.IR__ field imm5 = 15 (PowerOfTwoMinusOne)
    // Fields: Zd=0, size=0, imm5=15, Rm=0
    let encoding: u32 = 0x042049E0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 16, boundary: PowerOfTwo }
/// power of 2 (2^4 = 16)
#[test]
fn test_index_z_ir_field_imm5_16_poweroftwo_4800_04204a00() {
    // Encoding: 0x04204A00
    // Test INDEX_Z.IR__ field imm5 = 16 (PowerOfTwo)
    // Fields: size=0, Rm=0, imm5=16, Zd=0
    let encoding: u32 = 0x04204A00;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field imm5 5 +: 5`
/// Requirement: FieldBoundary { field: "imm5", value: 31, boundary: Max }
/// maximum immediate (31)
#[test]
fn test_index_z_ir_field_imm5_31_max_4800_04204be0() {
    // Encoding: 0x04204BE0
    // Test INDEX_Z.IR__ field imm5 = 31 (Max)
    // Fields: imm5=31, Zd=0, Rm=0, size=0
    let encoding: u32 = 0x04204BE0;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 0, boundary: Min }
/// SIMD register V0
#[test]
fn test_index_z_ir_field_zd_0_min_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field Zd = 0 (Min)
    // Fields: size=0, imm5=0, Zd=0, Rm=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 1, boundary: PowerOfTwo }
/// SIMD register V1
#[test]
fn test_index_z_ir_field_zd_1_poweroftwo_4800_04204801() {
    // Encoding: 0x04204801
    // Test INDEX_Z.IR__ field Zd = 1 (PowerOfTwo)
    // Fields: size=0, imm5=0, Zd=1, Rm=0
    let encoding: u32 = 0x04204801;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 30, boundary: PowerOfTwoMinusOne }
/// SIMD register V30
#[test]
fn test_index_z_ir_field_zd_30_poweroftwominusone_4800_0420481e() {
    // Encoding: 0x0420481E
    // Test INDEX_Z.IR__ field Zd = 30 (PowerOfTwoMinusOne)
    // Fields: size=0, Rm=0, Zd=30, imm5=0
    let encoding: u32 = 0x0420481E;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field Zd 0 +: 5`
/// Requirement: FieldBoundary { field: "Zd", value: 31, boundary: Max }
/// SIMD register V31
#[test]
fn test_index_z_ir_field_zd_31_max_4800_0420481f() {
    // Encoding: 0x0420481F
    // Test INDEX_Z.IR__ field Zd = 31 (Max)
    // Fields: Zd=31, Rm=0, imm5=0, size=0
    let encoding: u32 = 0x0420481F;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field combination 0`
/// Requirement: FieldExtraction { field: "combination", bit_start: 0, bit_width: 32 }
/// size=0 (8-bit / byte size)
#[test]
fn test_index_z_ir_combo_0_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ field combination: size=0, Rm=0, imm5=0, Zd=0
    // Fields: Zd=0, size=0, imm5=0, Rm=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 0 (Size variant 0)`
/// Requirement: FieldSpecial { field: "size", value: 0, meaning: "Size variant 0" }
/// Size variant 0
#[test]
fn test_index_z_ir_special_size_0_size_variant_0_18432_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ special value size = 0 (Size variant 0)
    // Fields: imm5=0, Rm=0, size=0, Zd=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 1 (Size variant 1)`
/// Requirement: FieldSpecial { field: "size", value: 1, meaning: "Size variant 1" }
/// Size variant 1
#[test]
fn test_index_z_ir_special_size_1_size_variant_1_18432_04604800() {
    // Encoding: 0x04604800
    // Test INDEX_Z.IR__ special value size = 1 (Size variant 1)
    // Fields: imm5=0, Zd=0, size=1, Rm=0
    let encoding: u32 = 0x04604800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 2 (Size variant 2)`
/// Requirement: FieldSpecial { field: "size", value: 2, meaning: "Size variant 2" }
/// Size variant 2
#[test]
fn test_index_z_ir_special_size_2_size_variant_2_18432_04a04800() {
    // Encoding: 0x04A04800
    // Test INDEX_Z.IR__ special value size = 2 (Size variant 2)
    // Fields: Zd=0, imm5=0, Rm=0, size=2
    let encoding: u32 = 0x04A04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `field size = 3 (Size variant 3)`
/// Requirement: FieldSpecial { field: "size", value: 3, meaning: "Size variant 3" }
/// Size variant 3
#[test]
fn test_index_z_ir_special_size_3_size_variant_3_18432_04e04800() {
    // Encoding: 0x04E04800
    // Test INDEX_Z.IR__ special value size = 3 (Size variant 3)
    // Fields: imm5=0, size=3, Zd=0, Rm=0
    let encoding: u32 = 0x04E04800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(
        exit,
        CpuExit::Continue,
        "instruction 0x{:08X} should execute successfully",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }`
/// Requirement: UndefinedEncoding { condition: "Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: \"HaveSVE\" }, args: [] } }" }
/// triggers Undefined
#[test]
fn test_index_z_ir_invalid_0_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ invalid encoding: Unary { op: Not, operand: Call { name: QualifiedIdentifier { qualifier: Any, name: "HaveSVE" }, args: [] } }
    // Fields: Zd=0, Rm=0, imm5=0, size=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `Unconditional UNDEFINED`
/// Requirement: UndefinedEncoding { condition: "Unconditional UNDEFINED" }
/// triggers Undefined
#[test]
fn test_index_z_ir_invalid_1_4800_04204800() {
    // Encoding: 0x04204800
    // Test INDEX_Z.IR__ invalid encoding: Unconditional UNDEFINED
    // Fields: Zd=0, Rm=0, imm5=0, size=0
    let encoding: u32 = 0x04204800;
    let mut cpu = create_test_cpu();
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step();
    assert!(
        exit.is_err() || !matches!(exit.unwrap(), CpuExit::Continue),
        "expected UNDEFINED for encoding 0x{:08X}",
        encoding
    );
}

/// Provenance: INDEX_Z.IR__
/// ASL: `SimdFromField("d") write`
/// Requirement: RegisterWrite { reg_type: Gp64, dest_field: "unknown" }
/// verify register write to SimdFromField("d")
#[test]
fn test_index_z_ir_reg_write_0_04204800() {
    // Test INDEX_Z.IR__ register write: SimdFromField("d")
    // Encoding: 0x04204800
    let mut cpu = create_test_cpu();
    let encoding: u32 = 0x04204800;
    write_insn(&mut cpu, 0, encoding);
    let exit = cpu.step().unwrap();
    assert_eq!(exit, CpuExit::Continue, "instruction should execute");
}
